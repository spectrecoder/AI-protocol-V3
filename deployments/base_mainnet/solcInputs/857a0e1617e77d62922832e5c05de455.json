{
  "language": "Solidity",
  "sources": {
    "@layerzerolabs/lz-evm-sdk-v1-0.7/contracts/interfaces/ILayerZeroEndpoint.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.5.0;\n\nimport \"./ILayerZeroUserApplicationConfig.sol\";\n\ninterface ILayerZeroEndpoint is ILayerZeroUserApplicationConfig {\n    // @notice send a LayerZero message to the specified address at a LayerZero endpoint.\n    // @param _dstChainId - the destination chain identifier\n    // @param _destination - the address on destination chain (in bytes). address length/format may vary by chains\n    // @param _payload - a custom bytes payload to send to the destination contract\n    // @param _refundAddress - if the source transaction is cheaper than the amount of value passed, refund the additional amount to this address\n    // @param _zroPaymentAddress - the address of the ZRO token holder who would pay for the transaction\n    // @param _adapterParams - parameters for custom functionality. e.g. receive airdropped native gas from the relayer on destination\n    function send(\n        uint16 _dstChainId,\n        bytes calldata _destination,\n        bytes calldata _payload,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes calldata _adapterParams\n    ) external payable;\n\n    // @notice used by the messaging library to publish verified payload\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source contract (as bytes) at the source chain\n    // @param _dstAddress - the address on destination chain\n    // @param _nonce - the unbound message ordering nonce\n    // @param _gasLimit - the gas limit for external contract execution\n    // @param _payload - verified payload to send to the destination contract\n    function receivePayload(\n        uint16 _srcChainId,\n        bytes calldata _srcAddress,\n        address _dstAddress,\n        uint64 _nonce,\n        uint _gasLimit,\n        bytes calldata _payload\n    ) external;\n\n    // @notice get the inboundNonce of a receiver from a source chain which could be EVM or non-EVM chain\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    function getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (uint64);\n\n    // @notice get the outboundNonce from this source chain which, consequently, is always an EVM\n    // @param _srcAddress - the source chain contract address\n    function getOutboundNonce(uint16 _dstChainId, address _srcAddress) external view returns (uint64);\n\n    // @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\n    // @param _dstChainId - the destination chain identifier\n    // @param _userApplication - the user app address on this EVM chain\n    // @param _payload - the custom message to send over LayerZero\n    // @param _payInZRO - if false, user app pays the protocol fee in native token\n    // @param _adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain\n    function estimateFees(\n        uint16 _dstChainId,\n        address _userApplication,\n        bytes calldata _payload,\n        bool _payInZRO,\n        bytes calldata _adapterParam\n    ) external view returns (uint nativeFee, uint zroFee);\n\n    // @notice get this Endpoint's immutable source identifier\n    function getChainId() external view returns (uint16);\n\n    // @notice the interface to retry failed message on this Endpoint destination\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    // @param _payload - the payload to be retried\n    function retryPayload(uint16 _srcChainId, bytes calldata _srcAddress, bytes calldata _payload) external;\n\n    // @notice query if any STORED payload (message blocking) at the endpoint.\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool);\n\n    // @notice query if the _libraryAddress is valid for sending msgs.\n    // @param _userApplication - the user app address on this EVM chain\n    function getSendLibraryAddress(address _userApplication) external view returns (address);\n\n    // @notice query if the _libraryAddress is valid for receiving msgs.\n    // @param _userApplication - the user app address on this EVM chain\n    function getReceiveLibraryAddress(address _userApplication) external view returns (address);\n\n    // @notice query if the non-reentrancy guard for send() is on\n    // @return true if the guard is on. false otherwise\n    function isSendingPayload() external view returns (bool);\n\n    // @notice query if the non-reentrancy guard for receive() is on\n    // @return true if the guard is on. false otherwise\n    function isReceivingPayload() external view returns (bool);\n\n    // @notice get the configuration of the LayerZero messaging library of the specified version\n    // @param _version - messaging library version\n    // @param _chainId - the chainId for the pending config change\n    // @param _userApplication - the contract address of the user application\n    // @param _configType - type of configuration. every messaging library has its own convention.\n    function getConfig(\n        uint16 _version,\n        uint16 _chainId,\n        address _userApplication,\n        uint _configType\n    ) external view returns (bytes memory);\n\n    // @notice get the send() LayerZero messaging library version\n    // @param _userApplication - the contract address of the user application\n    function getSendVersion(address _userApplication) external view returns (uint16);\n\n    // @notice get the lzReceive() LayerZero messaging library version\n    // @param _userApplication - the contract address of the user application\n    function getReceiveVersion(address _userApplication) external view returns (uint16);\n}\n"
    },
    "@layerzerolabs/lz-evm-sdk-v1-0.7/contracts/interfaces/ILayerZeroMessagingLibrary.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.7.0;\n\nimport \"./ILayerZeroUserApplicationConfig.sol\";\n\ninterface ILayerZeroMessagingLibrary {\n    // send(), messages will be inflight.\n    function send(\n        address _userApplication,\n        uint64 _lastNonce,\n        uint16 _chainId,\n        bytes calldata _destination,\n        bytes calldata _payload,\n        address payable refundAddress,\n        address _zroPaymentAddress,\n        bytes calldata _adapterParams\n    ) external payable;\n\n    // estimate native fee at the send side\n    function estimateFees(\n        uint16 _chainId,\n        address _userApplication,\n        bytes calldata _payload,\n        bool _payInZRO,\n        bytes calldata _adapterParam\n    ) external view returns (uint nativeFee, uint zroFee);\n\n    //---------------------------------------------------------------------------\n    // setConfig / getConfig are User Application (UA) functions to specify Oracle, Relayer, blockConfirmations, libraryVersion\n    function setConfig(uint16 _chainId, address _userApplication, uint _configType, bytes calldata _config) external;\n\n    function getConfig(\n        uint16 _chainId,\n        address _userApplication,\n        uint _configType\n    ) external view returns (bytes memory);\n}\n"
    },
    "@layerzerolabs/lz-evm-sdk-v1-0.7/contracts/interfaces/ILayerZeroUserApplicationConfig.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.5.0;\n\ninterface ILayerZeroUserApplicationConfig {\n    // @notice set the configuration of the LayerZero messaging library of the specified version\n    // @param _version - messaging library version\n    // @param _chainId - the chainId for the pending config change\n    // @param _configType - type of configuration. every messaging library has its own convention.\n    // @param _config - configuration in the bytes. can encode arbitrary content.\n    function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external;\n\n    // @notice set the send() LayerZero messaging library version to _version\n    // @param _version - new messaging library version\n    function setSendVersion(uint16 _version) external;\n\n    // @notice set the lzReceive() LayerZero messaging library version to _version\n    // @param _version - new messaging library version\n    function setReceiveVersion(uint16 _version) external;\n\n    // @notice Only when the UA needs to resume the message flow in blocking mode and clear the stored payload\n    // @param _srcChainId - the chainId of the source chain\n    // @param _srcAddress - the contract address of the source contract at the source chain\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external;\n}\n"
    },
    "@layerzerolabs/solidity-examples/contracts/contracts-upgradable/interfaces/ILayerZeroEndpointUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.2;\n\nimport \"./ILayerZeroUserApplicationConfigUpgradeable.sol\";\n\ninterface ILayerZeroEndpointUpgradeable is ILayerZeroUserApplicationConfigUpgradeable {\n    // @notice send a LayerZero message to the specified address at a LayerZero endpoint.\n    // @param _dstChainId - the destination chain identifier\n    // @param _destination - the address on destination chain (in bytes). address length/format may vary by chains\n    // @param _payload - a custom bytes payload to send to the destination contract\n    // @param _refundAddress - if the source transaction is cheaper than the amount of value passed, refund the additional amount to this address\n    // @param _zroPaymentAddress - the address of the ZRO token holder who would pay for the transaction\n    // @param _adapterParams - parameters for custom functionality. e.g. receive airdropped native gas from the relayer on destination\n    function send(uint16 _dstChainId, bytes calldata _destination, bytes calldata _payload, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) external payable;\n\n    // @notice used by the messaging library to publish verified payload\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source contract (as bytes) at the source chain\n    // @param _dstAddress - the address on destination chain\n    // @param _nonce - the unbound message ordering nonce\n    // @param _gasLimit - the gas limit for external contract execution\n    // @param _payload - verified payload to send to the destination contract\n    function receivePayload(uint16 _srcChainId, bytes calldata _srcAddress, address _dstAddress, uint64 _nonce, uint _gasLimit, bytes calldata _payload) external;\n\n    // @notice get the inboundNonce of a lzApp from a source chain which could be EVM or non-EVM chain\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    function getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (uint64);\n\n    // @notice get the outboundNonce from this source chain which, consequently, is always an EVM\n    // @param _srcAddress - the source chain contract address\n    function getOutboundNonce(uint16 _dstChainId, address _srcAddress) external view returns (uint64);\n\n    // @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\n    // @param _dstChainId - the destination chain identifier\n    // @param _userApplication - the user app address on this EVM chain\n    // @param _payload - the custom message to send over LayerZero\n    // @param _payInZRO - if false, user app pays the protocol fee in native token\n    // @param _adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain\n    function estimateFees(uint16 _dstChainId, address _userApplication, bytes calldata _payload, bool _payInZRO, bytes calldata _adapterParam) external view returns (uint nativeFee, uint zroFee);\n\n    // @notice get this Endpoint's immutable source identifier\n    function getChainId() external view returns (uint16);\n\n    // @notice the interface to retry failed message on this Endpoint destination\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    // @param _payload - the payload to be retried\n    function retryPayload(uint16 _srcChainId, bytes calldata _srcAddress, bytes calldata _payload) external;\n\n    // @notice query if any STORED payload (message blocking) at the endpoint.\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool);\n\n    // @notice query if the _libraryAddress is valid for sending msgs.\n    // @param _userApplication - the user app address on this EVM chain\n    function getSendLibraryAddress(address _userApplication) external view returns (address);\n\n    // @notice query if the _libraryAddress is valid for receiving msgs.\n    // @param _userApplication - the user app address on this EVM chain\n    function getReceiveLibraryAddress(address _userApplication) external view returns (address);\n\n    // @notice query if the non-reentrancy guard for send() is on\n    // @return true if the guard is on. false otherwise\n    function isSendingPayload() external view returns (bool);\n\n    // @notice query if the non-reentrancy guard for receive() is on\n    // @return true if the guard is on. false otherwise\n    function isReceivingPayload() external view returns (bool);\n\n    // @notice get the configuration of the LayerZero messaging library of the specified version\n    // @param _version - messaging library version\n    // @param _chainId - the chainId for the pending config change\n    // @param _userApplication - the contract address of the user application\n    // @param _configType - type of configuration. every messaging library has its own convention.\n    function getConfig(uint16 _version, uint16 _chainId, address _userApplication, uint _configType) external view returns (bytes memory);\n\n    // @notice get the send() LayerZero messaging library version\n    // @param _userApplication - the contract address of the user application\n    function getSendVersion(address _userApplication) external view returns (uint16);\n\n    // @notice get the lzReceive() LayerZero messaging library version\n    // @param _userApplication - the contract address of the user application\n    function getReceiveVersion(address _userApplication) external view returns (uint16);\n}\n"
    },
    "@layerzerolabs/solidity-examples/contracts/contracts-upgradable/interfaces/ILayerZeroReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.2;\n\ninterface ILayerZeroReceiverUpgradeable {\n    // @notice LayerZero endpoint will invoke this function to deliver the message on the destination\n    // @param _srcChainId - the source endpoint identifier\n    // @param _srcAddress - the source sending contract address from the source chain\n    // @param _nonce - the ordered message nonce\n    // @param _payload - the signed payload is the UA bytes has encoded to be sent\n    function lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) external;\n}\n"
    },
    "@layerzerolabs/solidity-examples/contracts/contracts-upgradable/interfaces/ILayerZeroUserApplicationConfigUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.2;\n\ninterface ILayerZeroUserApplicationConfigUpgradeable {\n    // @notice set the configuration of the LayerZero messaging library of the specified version\n    // @param _version - messaging library version\n    // @param _chainId - the chainId for the pending config change\n    // @param _configType - type of configuration. every messaging library has its own convention.\n    // @param _config - configuration in the bytes. can encode arbitrary content.\n    function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external;\n\n    // @notice set the send() LayerZero messaging library version to _version\n    // @param _version - new messaging library version\n    function setSendVersion(uint16 _version) external;\n\n    // @notice set the lzReceive() LayerZero messaging library version to _version\n    // @param _version - new messaging library version\n    function setReceiveVersion(uint16 _version) external;\n\n    // @notice Only when the UA needs to resume the message flow in blocking mode and clear the stored payload\n    // @param _srcChainId - the chainId of the source chain\n    // @param _srcAddress - the contract address of the source contract at the source chain\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external;\n}\n"
    },
    "@layerzerolabs/solidity-examples/contracts/contracts-upgradable/lzApp/LzAppUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.2;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport \"../interfaces/ILayerZeroReceiverUpgradeable.sol\";\nimport \"../interfaces/ILayerZeroUserApplicationConfigUpgradeable.sol\";\nimport \"../interfaces/ILayerZeroEndpointUpgradeable.sol\";\nimport \"../../util/BytesLib.sol\";\n\n/*\n * a generic LzReceiver implementation\n */\nabstract contract LzAppUpgradeable is Initializable, ContextUpgradeable, ILayerZeroReceiverUpgradeable, ILayerZeroUserApplicationConfigUpgradeable {\n    using BytesLib for bytes;\n\n    // ua can not send payload larger than this by default, but it can be changed by the ua owner\n    uint constant public DEFAULT_PAYLOAD_SIZE_LIMIT = 10000;\n\n    ILayerZeroEndpointUpgradeable public lzEndpoint;\n    mapping(uint16 => bytes) public trustedRemoteLookup;\n    mapping(uint16 => mapping(uint16 => uint)) public minDstGasLookup;\n    mapping(uint16 => uint) public payloadSizeLimitLookup;\n    address public precrime;\n\n    event SetPrecrime(address precrime);\n    event SetTrustedRemote(uint16 _remoteChainId, bytes _path);\n    event SetTrustedRemoteAddress(uint16 _remoteChainId, bytes _remoteAddress);\n    event SetMinDstGas(uint16 _dstChainId, uint16 _type, uint _minDstGas);\n    event PayloadSizeLimitSet(uint16 _dstChainId, uint _size);\n\n    function __LzAppUpgradeable_init(address _endpoint) internal onlyInitializing {\n        __Context_init_unchained();\n        __LzAppUpgradeable_init_unchained(_endpoint);\n    }\n\n    function __LzAppUpgradeable_init_unchained(address _endpoint) internal onlyInitializing {\n        lzEndpoint = ILayerZeroEndpointUpgradeable(_endpoint);\n    }\n\n    function lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) public virtual override {\n        // lzReceive must be called by the endpoint for security\n        require(_msgSender() == address(lzEndpoint), \"LzApp: invalid endpoint caller\");\n\n        bytes memory trustedRemote = trustedRemoteLookup[_srcChainId];\n        // if will still block the message pathway from (srcChainId, srcAddress). should not receive message from untrusted remote.\n        require(_srcAddress.length == trustedRemote.length && trustedRemote.length > 0 && keccak256(_srcAddress) == keccak256(trustedRemote), \"LzApp: invalid source sending contract\");\n\n        _blockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n    }\n\n    // abstract function - the default behaviour of LayerZero is blocking. See: NonblockingLzApp if you dont need to enforce ordered messaging\n    function _blockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual;\n\n    function _lzSend(uint16 _dstChainId, bytes memory _payload, address payable _refundAddress, address _zroPaymentAddress, bytes memory _adapterParams, uint _nativeFee) internal virtual {\n        bytes memory trustedRemote = trustedRemoteLookup[_dstChainId];\n        require(trustedRemote.length != 0, \"LzApp: destination chain is not a trusted source\");\n        _checkPayloadSize(_dstChainId, _payload.length);\n        lzEndpoint.send{value: _nativeFee}(_dstChainId, trustedRemote, _payload, _refundAddress, _zroPaymentAddress, _adapterParams);\n    }\n\n    function _checkGasLimit(uint16 _dstChainId, uint16 _type, bytes memory _adapterParams, uint _extraGas) internal view virtual {\n        uint providedGasLimit = _getGasLimit(_adapterParams);\n        uint minGasLimit = minDstGasLookup[_dstChainId][_type] + _extraGas;\n        require(minGasLimit > 0, \"LzApp: minGasLimit not set\");\n        require(providedGasLimit >= minGasLimit, \"LzApp: gas limit is too low\");\n    }\n\n    function _getGasLimit(bytes memory _adapterParams) internal pure virtual returns (uint gasLimit) {\n        require(_adapterParams.length >= 34, \"LzApp: invalid adapterParams\");\n        assembly {\n            gasLimit := mload(add(_adapterParams, 34))\n        }\n    }\n\n    function _checkPayloadSize(uint16 _dstChainId, uint _payloadSize) internal view virtual {\n        uint payloadSizeLimit = payloadSizeLimitLookup[_dstChainId];\n        if (payloadSizeLimit == 0) { // use default if not set\n            payloadSizeLimit = DEFAULT_PAYLOAD_SIZE_LIMIT;\n        }\n        require(_payloadSize <= payloadSizeLimit, \"LzApp: payload size is too large\");\n    }\n\n    //---------------------------UserApplication config----------------------------------------\n    function getConfig(uint16 _version, uint16 _chainId, address, uint _configType) external view returns (bytes memory) {\n        return lzEndpoint.getConfig(_version, _chainId, address(this), _configType);\n    }\n\n    // generic config for LayerZero user Application\n    function _setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes memory _config) internal virtual {\n        lzEndpoint.setConfig(_version, _chainId, _configType, _config);\n    }\n\n    function _setSendVersion(uint16 _version) internal virtual {\n        lzEndpoint.setSendVersion(_version);\n    }\n\n    function _setReceiveVersion(uint16 _version) internal virtual {\n        lzEndpoint.setReceiveVersion(_version);\n    }\n\n    function _forceResumeReceive(uint16 _srcChainId, bytes memory _srcAddress) internal virtual {\n        lzEndpoint.forceResumeReceive(_srcChainId, _srcAddress);\n    }\n\n    // _path = abi.encodePacked(remoteAddress, localAddress)\n    // this function set the trusted path for the cross-chain communication\n    function _setTrustedRemote(uint16 _srcChainId, bytes memory _path) internal virtual {\n        trustedRemoteLookup[_srcChainId] = _path;\n        emit SetTrustedRemote(_srcChainId, _path);\n    }\n\n    function _setTrustedRemoteAddress(uint16 _remoteChainId, bytes memory _remoteAddress) internal virtual {\n        trustedRemoteLookup[_remoteChainId] = abi.encodePacked(_remoteAddress, address(this));\n        emit SetTrustedRemoteAddress(_remoteChainId, _remoteAddress);\n    }\n\n    function getTrustedRemoteAddress(uint16 _remoteChainId) external view returns (bytes memory) {\n        bytes memory path = trustedRemoteLookup[_remoteChainId];\n        require(path.length != 0, \"LzApp: no trusted path record\");\n        return path.slice(0, path.length - 20); // the last 20 bytes should be address(this)\n    }\n\n    function _setPrecrime(address _precrime) internal virtual {\n        precrime = _precrime;\n        emit SetPrecrime(_precrime);\n    }\n\n    function _setMinDstGas(uint16 _dstChainId, uint16 _packetType, uint _minGas) internal virtual {\n        require(_minGas > 0, \"LzApp: invalid minGas\");\n        minDstGasLookup[_dstChainId][_packetType] = _minGas;\n        emit SetMinDstGas(_dstChainId, _packetType, _minGas);\n    }\n\n    // if the size is 0, it means default size limit\n    function _setPayloadSizeLimit(uint16 _dstChainId, uint _size) internal virtual {\n        payloadSizeLimitLookup[_dstChainId] = _size;\n        emit PayloadSizeLimitSet(_dstChainId, _size);\n    }\n\n    //--------------------------- VIEW FUNCTION ----------------------------------------\n    function isTrustedRemote(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool) {\n        bytes memory trustedSource = trustedRemoteLookup[_srcChainId];\n        return keccak256(trustedSource) == keccak256(_srcAddress);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint[45] private __gap;\n}\n"
    },
    "@layerzerolabs/solidity-examples/contracts/contracts-upgradable/lzApp/NonblockingLzAppUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.2;\n\nimport \"./LzAppUpgradeable.sol\";\nimport \"../../util/ExcessivelySafeCall.sol\";\n\n/*\n * the default LayerZero messaging behaviour is blocking, i.e. any failed message will block the channel\n * this abstract class try-catch all fail messages and store locally for future retry. hence, non-blocking\n * NOTE: if the srcAddress is not configured properly, it will still block the message pathway from (srcChainId, srcAddress)\n */\nabstract contract NonblockingLzAppUpgradeable is Initializable, LzAppUpgradeable {\n    using ExcessivelySafeCall for address;\n\n    function __NonblockingLzAppUpgradeable_init(address _endpoint) internal onlyInitializing {\n        __Context_init_unchained();\n        __LzAppUpgradeable_init_unchained(_endpoint);\n    }\n\n    function __NonblockingLzAppUpgradeable_init_unchained(address _endpoint) internal onlyInitializing {}\n\n    mapping(uint16 => mapping(bytes => mapping(uint64 => bytes32))) public failedMessages;\n\n    event MessageFailed(uint16 _srcChainId, bytes _srcAddress, uint64 _nonce, bytes _payload, bytes _reason);\n    event RetryMessageSuccess(uint16 _srcChainId, bytes _srcAddress, uint64 _nonce, bytes32 _payloadHash);\n\n    // overriding the virtual function in LzReceiver\n    function _blockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual override {\n        (bool success, bytes memory reason) = address(this).excessivelySafeCall(gasleft(), 150, abi.encodeWithSelector(this.nonblockingLzReceive.selector, _srcChainId, _srcAddress, _nonce, _payload));\n        // try-catch all errors/exceptions\n        if (!success) {\n            _storeFailedMessage(_srcChainId, _srcAddress, _nonce, _payload, reason);\n        }\n    }\n\n    function _storeFailedMessage(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload, bytes memory _reason) internal virtual {\n        failedMessages[_srcChainId][_srcAddress][_nonce] = keccak256(_payload);\n        emit MessageFailed(_srcChainId, _srcAddress, _nonce, _payload, _reason);\n    }\n\n    function nonblockingLzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) public virtual {\n        // only internal transaction\n        require(_msgSender() == address(this), \"NonblockingLzApp: caller must be LzApp\");\n        _nonblockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n    }\n\n    //@notice override this function\n    function _nonblockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual;\n\n    function retryMessage(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) public payable virtual {\n        // assert there is message to retry\n        bytes32 payloadHash = failedMessages[_srcChainId][_srcAddress][_nonce];\n        require(payloadHash != bytes32(0), \"NonblockingLzApp: no stored message\");\n        require(keccak256(_payload) == payloadHash, \"NonblockingLzApp: invalid payload\");\n        // clear the stored message\n        failedMessages[_srcChainId][_srcAddress][_nonce] = bytes32(0);\n        // execute the message. revert if it fails again\n        _nonblockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n        emit RetryMessageSuccess(_srcChainId, _srcAddress, _nonce, payloadHash);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint[49] private __gap;\n}\n"
    },
    "@layerzerolabs/solidity-examples/contracts/util/BytesLib.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\n/*\n * @title Solidity Bytes Arrays Utils\n * @author Gonçalo Sá <goncalo.sa@consensys.net>\n *\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\n */\npragma solidity >=0.8.0 <0.9.0;\n\n\nlibrary BytesLib {\n    function concat(\n        bytes memory _preBytes,\n        bytes memory _postBytes\n    )\n    internal\n    pure\n    returns (bytes memory)\n    {\n        bytes memory tempBytes;\n\n        assembly {\n        // Get a location of some free memory and store it in tempBytes as\n        // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n        // Store the length of the first bytes array at the beginning of\n        // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n        // Maintain a memory counter for the current write location in the\n        // temp bytes array by adding the 32 bytes for the array length to\n        // the starting location.\n            let mc := add(tempBytes, 0x20)\n        // Stop copying when the memory counter reaches the length of the\n        // first bytes array.\n            let end := add(mc, length)\n\n            for {\n            // Initialize a copy counter to the start of the _preBytes data,\n            // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n            // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n            // Write the _preBytes data into the tempBytes memory 32 bytes\n            // at a time.\n                mstore(mc, mload(cc))\n            }\n\n        // Add the length of _postBytes to the current length of tempBytes\n        // and store it as the new length in the first 32 bytes of the\n        // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n        // Move the memory counter back from a multiple of 0x20 to the\n        // actual end of the _preBytes data.\n            mc := end\n        // Stop copying when the memory counter reaches the new combined\n        // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n        // Update the free-memory pointer by padding our last write location\n        // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n        // next 32 byte block, then round down to the nearest multiple of\n        // 32. If the sum of the length of the two arrays is zero then add\n        // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(0x40, and(\n            add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n            not(31) // Round down to the nearest 32 bytes.\n            ))\n        }\n\n        return tempBytes;\n    }\n\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n        assembly {\n        // Read the first 32 bytes of _preBytes storage, which is the length\n        // of the array. (We don't need to use the offset into the slot\n        // because arrays use the entire slot.)\n            let fslot := sload(_preBytes.slot)\n        // Arrays of 31 bytes or less have an even value in their slot,\n        // while longer arrays have an odd value. The actual length is\n        // the slot divided by two for odd values, and the lowest order\n        // byte divided by two for even values.\n        // If the slot is even, bitwise and the slot with 255 and divide by\n        // two to get the length. If the slot is odd, bitwise and the slot\n        // with -1 and divide by two.\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n            let newlength := add(slength, mlength)\n        // slength can contain both the length and contents of the array\n        // if length < 32 bytes so let's prepare for that\n        // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n            switch add(lt(slength, 32), lt(newlength, 32))\n            case 2 {\n            // Since the new array still fits in the slot, we just need to\n            // update the contents of the slot.\n            // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n                sstore(\n                _preBytes.slot,\n                // all the modifications to the slot are inside this\n                // next block\n                add(\n                // we can just add to the slot contents because the\n                // bytes we want to change are the LSBs\n                fslot,\n                add(\n                mul(\n                div(\n                // load the bytes from memory\n                mload(add(_postBytes, 0x20)),\n                // zero all bytes to the right\n                exp(0x100, sub(32, mlength))\n                ),\n                // and now shift left the number of bytes to\n                // leave space for the length in the slot\n                exp(0x100, sub(32, newlength))\n                ),\n                // increase length by the double of the memory\n                // bytes length\n                mul(mlength, 2)\n                )\n                )\n                )\n            }\n            case 1 {\n            // The stored value fits in the slot, but the combined value\n            // will exceed it.\n            // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n            // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n            // The contents of the _postBytes array start 32 bytes into\n            // the structure. Our first read should obtain the `submod`\n            // bytes that can fit into the unused space in the last word\n            // of the stored array. To get this, we read 32 bytes starting\n            // from `submod`, so the data we read overlaps with the array\n            // contents by `submod` bytes. Masking the lowest-order\n            // `submod` bytes allows us to add that value directly to the\n            // stored value.\n\n                let submod := sub(32, slength)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(\n                sc,\n                add(\n                and(\n                fslot,\n                0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\n                ),\n                and(mload(mc), mask)\n                )\n                )\n\n                for {\n                    mc := add(mc, 0x20)\n                    sc := add(sc, 1)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n            default {\n            // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n            // Start copying to the last used word of the stored array.\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n            // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n            // Copy over the first `submod` bytes of the new data as in\n            // case 1 above.\n                let slengthmod := mod(slength, 32)\n                let mlengthmod := mod(mlength, 32)\n                let submod := sub(32, slengthmod)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\n\n                for {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n        }\n    }\n\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    )\n    internal\n    pure\n    returns (bytes memory)\n    {\n        require(_length + 31 >= _length, \"slice_overflow\");\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n            // The first word of the slice result is potentially a partial\n            // word read from the original array. To read it, we calculate\n            // the length of that partial word and start copying that many\n            // bytes into the array. The first word we copy will start with\n            // data we don't care about, but the last `lengthmod` bytes will\n            // land at the beginning of the contents of the new array. When\n            // we're done copying, we overwrite the full first word with\n            // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n            // The multiplication in the next line is necessary\n            // because when slicing multiples of 32 bytes (lengthmod == 0)\n            // the following copy loop was copying the origin's length\n            // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                // The multiplication in the next line has the same exact purpose\n                // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n            //update free-memory pointer\n            //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n            //zero out the 32 bytes slice we are about to return\n            //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_bytes.length >= _start + 20, \"toAddress_outOfBounds\");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\n        require(_bytes.length >= _start + 1 , \"toUint8_outOfBounds\");\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\n        require(_bytes.length >= _start + 2, \"toUint16_outOfBounds\");\n        uint16 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x2), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\n        require(_bytes.length >= _start + 4, \"toUint32_outOfBounds\");\n        uint32 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x4), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\n        require(_bytes.length >= _start + 8, \"toUint64_outOfBounds\");\n        uint64 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x8), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\n        require(_bytes.length >= _start + 12, \"toUint96_outOfBounds\");\n        uint96 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0xc), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\n        require(_bytes.length >= _start + 16, \"toUint128_outOfBounds\");\n        uint128 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x10), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\n        require(_bytes.length >= _start + 32, \"toUint256_outOfBounds\");\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\n        require(_bytes.length >= _start + 32, \"toBytes32_outOfBounds\");\n        bytes32 tempBytes32;\n\n        assembly {\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes32;\n    }\n\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n        // if lengths don't match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n            case 1 {\n            // cb is a circuit breaker in the for loop since there's\n            //  no said feature for inline assembly loops\n            // cb = 1 - don't breaker\n            // cb = 0 - break\n                let cb := 1\n\n                let mc := add(_preBytes, 0x20)\n                let end := add(mc, length)\n\n                for {\n                    let cc := add(_postBytes, 0x20)\n                // the next line is the loop condition:\n                // while(uint256(mc < end) + cb == 2)\n                } eq(add(lt(mc, end), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                // if any of these checks fails then arrays are not equal\n                    if iszero(eq(mload(mc), mload(cc))) {\n                    // unsuccess:\n                        success := 0\n                        cb := 0\n                    }\n                }\n            }\n            default {\n            // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function equalStorage(\n        bytes storage _preBytes,\n        bytes memory _postBytes\n    )\n    internal\n    view\n    returns (bool)\n    {\n        bool success = true;\n\n        assembly {\n        // we know _preBytes_offset is 0\n            let fslot := sload(_preBytes.slot)\n        // Decode the length of the stored array like in concatStorage().\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n\n        // if lengths don't match the arrays are not equal\n            switch eq(slength, mlength)\n            case 1 {\n            // slength can contain both the length and contents of the array\n            // if length < 32 bytes so let's prepare for that\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n                if iszero(iszero(slength)) {\n                    switch lt(slength, 32)\n                    case 1 {\n                    // blank the last byte which is the length\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n                        // unsuccess:\n                            success := 0\n                        }\n                    }\n                    default {\n                    // cb is a circuit breaker in the for loop since there's\n                    //  no said feature for inline assembly loops\n                    // cb = 1 - don't breaker\n                    // cb = 0 - break\n                        let cb := 1\n\n                    // get the keccak hash to get the contents of the array\n                        mstore(0x0, _preBytes.slot)\n                        let sc := keccak256(0x0, 0x20)\n\n                        let mc := add(_postBytes, 0x20)\n                        let end := add(mc, mlength)\n\n                    // the next line is the loop condition:\n                    // while(uint256(mc < end) + cb == 2)\n                        for {} eq(add(lt(mc, end), cb), 2) {\n                            sc := add(sc, 1)\n                            mc := add(mc, 0x20)\n                        } {\n                            if iszero(eq(sload(sc), mload(mc))) {\n                            // unsuccess:\n                                success := 0\n                                cb := 0\n                            }\n                        }\n                    }\n                }\n            }\n            default {\n            // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n}\n"
    },
    "@layerzerolabs/solidity-examples/contracts/util/ExcessivelySafeCall.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.7.6;\n\nlibrary ExcessivelySafeCall {\n    uint256 constant LOW_28_MASK =\n    0x00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    /// @notice Use when you _really_ really _really_ don't trust the called\n    /// contract. This prevents the called contract from causing reversion of\n    /// the caller in as many ways as we can.\n    /// @dev The main difference between this and a solidity low-level call is\n    /// that we limit the number of bytes that the callee can cause to be\n    /// copied to caller memory. This prevents stupid things like malicious\n    /// contracts returning 10,000,000 bytes causing a local OOG when copying\n    /// to memory.\n    /// @param _target The address to call\n    /// @param _gas The amount of gas to forward to the remote contract\n    /// @param _maxCopy The maximum number of bytes of returndata to copy\n    /// to memory.\n    /// @param _calldata The data to send to the remote contract\n    /// @return success and returndata, as `.call()`. Returndata is capped to\n    /// `_maxCopy` bytes.\n    function excessivelySafeCall(\n        address _target,\n        uint256 _gas,\n        uint16 _maxCopy,\n        bytes memory _calldata\n    ) internal returns (bool, bytes memory) {\n        // set up for assembly call\n        uint256 _toCopy;\n        bool _success;\n        bytes memory _returnData = new bytes(_maxCopy);\n        // dispatch message to recipient\n        // by assembly calling \"handle\" function\n        // we call via assembly to avoid memcopying a very large returndata\n        // returned by a malicious contract\n        assembly {\n            _success := call(\n            _gas, // gas\n            _target, // recipient\n            0, // ether value\n            add(_calldata, 0x20), // inloc\n            mload(_calldata), // inlen\n            0, // outloc\n            0 // outlen\n            )\n        // limit our copy to 256 bytes\n            _toCopy := returndatasize()\n            if gt(_toCopy, _maxCopy) {\n                _toCopy := _maxCopy\n            }\n        // Store the length of the copied bytes\n            mstore(_returnData, _toCopy)\n        // copy the bytes from returndata[0:_toCopy]\n            returndatacopy(add(_returnData, 0x20), 0, _toCopy)\n        }\n        return (_success, _returnData);\n    }\n\n    /// @notice Use when you _really_ really _really_ don't trust the called\n    /// contract. This prevents the called contract from causing reversion of\n    /// the caller in as many ways as we can.\n    /// @dev The main difference between this and a solidity low-level call is\n    /// that we limit the number of bytes that the callee can cause to be\n    /// copied to caller memory. This prevents stupid things like malicious\n    /// contracts returning 10,000,000 bytes causing a local OOG when copying\n    /// to memory.\n    /// @param _target The address to call\n    /// @param _gas The amount of gas to forward to the remote contract\n    /// @param _maxCopy The maximum number of bytes of returndata to copy\n    /// to memory.\n    /// @param _calldata The data to send to the remote contract\n    /// @return success and returndata, as `.call()`. Returndata is capped to\n    /// `_maxCopy` bytes.\n    function excessivelySafeStaticCall(\n        address _target,\n        uint256 _gas,\n        uint16 _maxCopy,\n        bytes memory _calldata\n    ) internal view returns (bool, bytes memory) {\n        // set up for assembly call\n        uint256 _toCopy;\n        bool _success;\n        bytes memory _returnData = new bytes(_maxCopy);\n        // dispatch message to recipient\n        // by assembly calling \"handle\" function\n        // we call via assembly to avoid memcopying a very large returndata\n        // returned by a malicious contract\n        assembly {\n            _success := staticcall(\n            _gas, // gas\n            _target, // recipient\n            add(_calldata, 0x20), // inloc\n            mload(_calldata), // inlen\n            0, // outloc\n            0 // outlen\n            )\n        // limit our copy to 256 bytes\n            _toCopy := returndatasize()\n            if gt(_toCopy, _maxCopy) {\n                _toCopy := _maxCopy\n            }\n        // Store the length of the copied bytes\n            mstore(_returnData, _toCopy)\n        // copy the bytes from returndata[0:_toCopy]\n            returndatacopy(add(_returnData, 0x20), 0, _toCopy)\n        }\n        return (_success, _returnData);\n    }\n\n    /**\n     * @notice Swaps function selectors in encoded contract calls\n     * @dev Allows reuse of encoded calldata for functions with identical\n     * argument types but different names. It simply swaps out the first 4 bytes\n     * for the new selector. This function modifies memory in place, and should\n     * only be used with caution.\n     * @param _newSelector The new 4-byte selector\n     * @param _buf The encoded contract args\n     */\n    function swapSelector(bytes4 _newSelector, bytes memory _buf)\n    internal\n    pure\n    {\n        require(_buf.length >= 4);\n        uint256 _mask = LOW_28_MASK;\n        assembly {\n        // load the first word of\n            let _word := mload(add(_buf, 0x20))\n        // mask out the top 4 bytes\n        // /x\n            _word := and(_word, _mask)\n            _word := or(_newSelector, _word)\n            mstore(add(_buf, 0x20), _word)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/beacon/IBeaconUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeaconUpgradeable {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeaconUpgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/StorageSlotUpgradeable.sol\";\nimport \"../utils/Initializable.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967UpgradeUpgradeable is Initializable {\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n        __ERC1967Upgrade_init_unchained();\n    }\n\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            _functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallSecure(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        address oldImplementation = _getImplementation();\n\n        // Initial upgrade and setup call\n        _setImplementation(newImplementation);\n        if (data.length > 0 || forceCall) {\n            _functionDelegateCall(newImplementation, data);\n        }\n\n        // Perform rollback test if not already in progress\n        StorageSlotUpgradeable.BooleanSlot storage rollbackTesting = StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT);\n        if (!rollbackTesting.value) {\n            // Trigger rollback using upgradeTo from the new implementation\n            rollbackTesting.value = true;\n            _functionDelegateCall(\n                newImplementation,\n                abi.encodeWithSignature(\"upgradeTo(address)\", oldImplementation)\n            );\n            rollbackTesting.value = false;\n            // Check rollback was effective\n            require(oldImplementation == _getImplementation(), \"ERC1967Upgrade: upgrade breaks further upgrades\");\n            // Finally reset to the new implementation and log the upgrade\n            _upgradeTo(newImplementation);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            _functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function _functionDelegateCall(address target, bytes memory data) private returns (bytes memory) {\n        require(AddressUpgradeable.isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return AddressUpgradeable.verifyCallResult(success, returndata, \"Address: low-level delegate call failed\");\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() initializer {}\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\n        // contract may have been reentered.\n        require(_initializing ? _isConstructor() : !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} modifier, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/utils/UUPSUpgradeable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1967/ERC1967UpgradeUpgradeable.sol\";\nimport \"./Initializable.sol\";\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n *\n * _Available since v4.1._\n */\nabstract contract UUPSUpgradeable is Initializable, ERC1967UpgradeUpgradeable {\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n        __ERC1967Upgrade_init_unchained();\n        __UUPSUpgradeable_init_unchained();\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n    address private immutable __self = address(this);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        require(address(this) != __self, \"Function must be called through delegatecall\");\n        require(_getImplementation() == __self, \"Function must be called through active proxy\");\n        _;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeTo(address newImplementation) external virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallSecure(newImplementation, new bytes(0), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallSecure(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeTo} and {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/cryptography/draft-EIP712Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/draft-EIP712.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSAUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712Upgradeable is Initializable {\n    /* solhint-disable var-name-mixedcase */\n    bytes32 private _HASHED_NAME;\n    bytes32 private _HASHED_VERSION;\n    bytes32 private constant _TYPE_HASH = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator(_TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash());\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSAUpgradeable.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev The hash of the name parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712NameHash() internal virtual view returns (bytes32) {\n        return _HASHED_NAME;\n    }\n\n    /**\n     * @dev The hash of the version parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712VersionHash() internal virtual view returns (bytes32) {\n        return _HASHED_VERSION;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../StringsUpgradeable.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSAUpgradeable {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s;\n        uint8 v;\n        assembly {\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            v := add(shr(255, vs), 27)\n        }\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", StringsUpgradeable.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlotUpgradeable {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/Clones.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Proxy.sol\";\nimport \"./ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializating the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallSecure(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        address oldImplementation = _getImplementation();\n\n        // Initial upgrade and setup call\n        _setImplementation(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n\n        // Perform rollback test if not already in progress\n        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);\n        if (!rollbackTesting.value) {\n            // Trigger rollback using upgradeTo from the new implementation\n            rollbackTesting.value = true;\n            Address.functionDelegateCall(\n                newImplementation,\n                abi.encodeWithSignature(\"upgradeTo(address)\", oldImplementation)\n            );\n            rollbackTesting.value = false;\n            // Check rollback was effective\n            require(oldImplementation == _getImplementation(), \"ERC1967Upgrade: upgrade breaks further upgrades\");\n            // Finally reset to the new implementation and log the upgrade\n            _upgradeTo(newImplementation);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overriden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overriden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits a {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/ERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\nimport \"./IERC721Enumerable.sol\";\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n */\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721Enumerable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/ERC721URIStorage.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\n\n/**\n * @dev ERC721 token with storage based token URI management.\n */\nabstract contract ERC721URIStorage is ERC721 {\n    using Strings for uint256;\n\n    // Optional mapping for token URIs\n    mapping(uint256 => string) private _tokenURIs;\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721URIStorage: URI query for nonexistent token\");\n\n        string memory _tokenURI = _tokenURIs[tokenId];\n        string memory base = _baseURI();\n\n        // If there is no base URI, return the token URI.\n        if (bytes(base).length == 0) {\n            return _tokenURI;\n        }\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\n        if (bytes(_tokenURI).length > 0) {\n            return string(abi.encodePacked(base, _tokenURI));\n        }\n\n        return super.tokenURI(tokenId);\n    }\n\n    /**\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n        require(_exists(tokenId), \"ERC721URIStorage: URI set of nonexistent token\");\n        _tokenURIs[tokenId] = _tokenURI;\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual override {\n        super._burn(tokenId);\n\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle Trees proofs.\n *\n * The proofs can be generated using the JavaScript library\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\n *\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merklee tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     *\n     * _Available since v4.4._\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n            if (computedHash <= proofElement) {\n                // Hash(current computed hash + current element of the proof)\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\n            } else {\n                // Hash(current element of the proof + current computed hash)\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\n            }\n        }\n        return computedHash;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/bonding_curves/AbstractShares.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../utils/InitializableAccessControl.sol\";\nimport \"./TradeableShares.sol\";\nimport \"./SharesFactory.sol\";\nimport \"./SharesSubjectLib.sol\";\nimport \"./FriendTechBondingCurve.sol\";\n\n/**\n * @title Abstract Shares\n *\n * @notice Contains the logic which is currently common for the ETHShares\n *      and ERC20Shares TradeableShares implementations.\n *      Once these contracts diverge enough in their logic, this abstract contract\n *      may cease to exist.\n *\n * @dev Based on the friend.tech FriendtechSharesV1.sol\n */\nabstract contract AbstractShares is TradeableShares, FriendTechBondingCurve, InitializableAccessControl {\n\t/// @dev Shares subject is an NFT; NFT owner receives the subject fee\n\tSharesSubject private sharesSubject;\n\t/// @dev Protocol fee destination is an address collecting the protocol fee\n\taddress private protocolFeeDestination;\n\t/// @dev Protocol fee percent, immutable; maximum value: 10^18 (< 2^60)\n\tuint64 private /*immutable*/ protocolFeePercent;\n\t/// @dev Holders rewards fee destination is a contract collecting the holders fee, immutable\n\tHoldersRewardsDistributor private /*immutable*/ holdersFeeDestination;\n\t/// @dev Holders rewards fee percent, immutable\n\tuint64 private /*immutable*/ holdersFeePercent;\n\t/// @dev Subject fee percent, immutable\n\tuint64 private /*immutable*/ subjectFeePercent;\n\n\t/// @dev Total shares supply, sum of all the individual balances in `sharesBalances`\n\tuint256 internal sharesSupply;\n\t/// @dev Individual shares balances: Holder => Balance\n\tmapping(address => uint256) internal sharesBalances;\n\n\t/// @dev Cumulative value of all trades, allows to derive cumulative fees paid\n\tuint256 private tradeVolume;\n\n\t/**\n\t * @dev Fired in `updateSharesSubject`\n\t *\n\t * @param oldSubject old shares subject\n\t * @param newSubject new shares subject\n\t * @param factory the factory contract notified about the update\n\t */\n\tevent SharesSubjectUpdated(SharesSubject oldSubject, SharesSubject newSubject, SharesFactory factory);\n\n\t/**\n\t * @dev Fired in `updateProtocolFeeDestination`\n\t *\n\t * @param oldProtocolFeeDestination old protocol fee destination\n\t * @param newProtocolFeeDestination new protocol fee destination\n\t */\n\tevent ProtocolFeeDestinationUpdated(address oldProtocolFeeDestination, address newProtocolFeeDestination);\n\n\t/**\n\t * @dev Fire in `disableHoldersFee` no more than once\n\t *      for the entire lifespan of the contract\n\t *\n\t * @param oldProtocolFeePercent old protocol fee percent\n\t * @param newProtocolFeePercent new protocol fee percent, new >= old\n\t */\n\tevent HoldersFeeDisabled(uint256 oldProtocolFeePercent, uint256 newProtocolFeePercent);\n\n\t/**\n\t * @notice Protocol fee destination manager is responsible for updating the address collecting the\n\t *      protocol fee destination, that is `protocolFeeDestination`; the manager cannot update the fee percent\n\t *\n\t * @dev This role should be granted to the MultiSig, not to EOA and not to\n\t *      RBAC managed smart contract, so that this functionality is not scalable;\n\t *      this reduces the risk of misuse, and/or malicious use\n\t *\n\t * @dev Role ROLE_PROTOCOL_FEE_MANAGER is required to execute `updateProtocolFeeDestination` function\n\t */\n\tuint32 public constant ROLE_PROTOCOL_FEE_MANAGER = 0x0001_0000;\n\n\t/**\n\t * @notice Holders fee [disable] manager can disable the shares holders fee functionality;\n\t *      the manager cannot enable it back\n\t *\n\t * @dev This role should be granted to the MultiSig, not to EOA and not to\n\t *      RBAC managed smart contract, so that this functionality is not scalable;\n\t *      this reduces the risk of misuse, and/or malicious use\n\t *\n\t * @dev Role ROLE_HOLDERS_FEE_MANAGER is required to execute `disableHoldersFee` function\n\t */\n\tuint32 public constant ROLE_HOLDERS_FEE_MANAGER = 0x0002_0000;\n\n\t/**\n\t * @notice Shares subject manager is responsible for updating the \"shares subject\"\n\t *      in case of emergency, for example if underlying NFT was stolen\n\t *\n\t * @dev This role should be granted to the MultiSig, not to EOA and not to\n\t *      RBAC managed smart contract, so that this functionality is not scalable;\n\t *      this reduces the risk of misuse, and/or malicious use\n\t *\n\t * @dev Role ROLE_SHARES_SUBJECT_MANAGER is required to execute `updateSharesSubject` function\n\t */\n\tuint32 public constant ROLE_SHARES_SUBJECT_MANAGER = 0x0008_0000;\n\n\t/**\n\t * @dev \"Constructor replacement\" for initializable, must be execute during or immediately after deployment\n\t *      see https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#initializers\n\t *\n\t * @param _owner the address receiving all the RBAC permissions on the contract\n\t * @param _sharesSubject shares subject, usually defined as NFT (ERC721 contract address + NFT ID)\n\t * @param _protocolFeeDestination protocol fee destination, the address protocol fee is sent to\n\t * @param _protocolFeePercent protocol fee percent, applied to all the buy and sell operations;\n\t *      the fee percent is defined with the 18 decimals, 10^18 corresponds to 100%\n\t * @param _holdersFeeDestination shares holders fee destination, the HoldersRewardsDistributor contract\n\t *      the shares holders fee is sent to\n\t * @param _holdersFeePercent shares holders fee percent, applied to all the buy and sell operations,\n\t *      the fee percent is defined with the 18 decimals, 10^18 corresponds to 100%\n\t * @param _subjectFeePercent subject fee percent, applied to all the buy and sell operations,\n\t *      the fee percent is defined with the 18 decimals, 10^18 corresponds to 100%\n\t */\n\tfunction _postConstruct(\n\t\taddress _owner,\n\t\tSharesSubject memory _sharesSubject,\n\t\taddress _protocolFeeDestination,\n\t\tuint64 _protocolFeePercent,\n\t\tHoldersRewardsDistributor _holdersFeeDestination,\n\t\tuint64 _holdersFeePercent,\n\t\tuint64 _subjectFeePercent\n\t) internal onlyInitializing {\n\t\t// execute parent initializer\n\t\t_postConstruct(_owner);\n\t\t// this initializer is called only from the factory, we do not verify the\n\t\t// validity of the inputs generated by the factory itself\n\t\t// if the factory goes buggy/malicious after the upgrade, all the\n\t\t// shares contracts deployed after should be considered invalid\n\t\tsharesSubject = _sharesSubject;\n\t\tprotocolFeeDestination = _protocolFeeDestination;\n\t\tprotocolFeePercent = _protocolFeePercent;\n\t\tholdersFeeDestination = _holdersFeeDestination;\n\t\tholdersFeePercent = _holdersFeePercent;\n\t\tsubjectFeePercent = _subjectFeePercent;\n\t}\n\n\t/**\n\t * @inheritdoc TradeableShares\n\t */\n\tfunction getSharesSubject() public view returns(SharesSubject memory) {\n\t\t// read value from the storage\n\t\treturn sharesSubject;\n\t}\n\n\t/**\n\t * @notice Updates the shares subject\n\t *\n\t * @dev This is a restricted access function which should be accessible only from the\n\t *      MultiSig wallet controlling the protocol, so that its usage is not scalable\n\t *\n\t * @param _sharesSubject new subject to set\n\t */\n\tfunction updateSharesSubject(SharesSubject calldata _sharesSubject) public {\n\t\t// delegate to `updateSharesSubject` with the zero factory\n\t\tupdateSharesSubject(_sharesSubject, SharesFactory(address(0)));\n\t}\n\n\t/**\n\t * @notice Updates the shares subject and optionally notifies the factory about the update;\n\t *      update fails if the factory notification fails\n\t *\n\t * @dev This is a restricted access function which should be accessible only from the\n\t *      MultiSig wallet controlling the protocol, so that its usage is not scalable\n\t *\n\t * @param _sharesSubject new subject to set\n\t * @param _factory shares factory contract to notify about the update, optional\n\t *      if set to zero, the notification is not done\n\t */\n\tfunction updateSharesSubject(SharesSubject calldata _sharesSubject, SharesFactory _factory) public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_SHARES_SUBJECT_MANAGER), \"access denied\");\n\n\t\t// emit an event first - to log both old and new values\n\t\temit SharesSubjectUpdated(sharesSubject, _sharesSubject, _factory);\n\n\t\t// update contract's state\n\t\tsharesSubject = _sharesSubject;\n\n\t\t// if factory is set (factory notification requested)\n\t\tif(address(_factory) != address(0)) {\n\t\t\t// notify factory contract\n\t\t\t_factory.notifySubjectUpdated();\n\t\t}\n\t}\n\n\t/**\n\t * @inheritdoc TradeableShares\n\t */\n\tfunction getProtocolFeeDestination() public view returns(address) {\n\t\t// read the value from storage\n\t\treturn protocolFeeDestination;\n\t}\n\n\t/**\n\t * @notice Updates the protocol fee destination address `protocolFeeDestination`\n\t *\n\t * @dev This is a restricted access function which should be accessible only from the\n\t *      MultiSig wallet controlling the protocol, so that its usage is not scalable\n\t *\n\t * @param _protocolFeeDestination new protocol fee destination address to set\n\t */\n\tfunction updateProtocolFeeDestination(address _protocolFeeDestination) public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_PROTOCOL_FEE_MANAGER), \"access denied\");\n\n\t\t// emit an event first - to log both old and new values\n\t\temit ProtocolFeeDestinationUpdated(protocolFeeDestination, _protocolFeeDestination);\n\n\t\t// update contract's state\n\t\tprotocolFeeDestination = _protocolFeeDestination;\n\t}\n\n\t/**\n\t * @inheritdoc TradeableShares\n\t */\n\tfunction getProtocolFeePercent() public view returns(uint256) {\n\t\t// read the value from storage (immutable)\n\t\treturn protocolFeePercent;\n\t}\n\n\t/**\n\t * @inheritdoc TradeableShares\n\t */\n\tfunction getProtocolFeeInfo() public view returns(address feeDestination, uint256 feePercent) {\n\t\t// read fee destination first\n\t\tfeeDestination = getProtocolFeeDestination();\n\t\t// if it's zero, zero down the fee as well\n\t\tfeePercent = feeDestination == address(0)? 0: getProtocolFeePercent();\n\t}\n\n\t/**\n\t * @inheritdoc TradeableShares\n\t */\n\tfunction getHoldersFeeDestination() public view returns(HoldersRewardsDistributor) {\n\t\t// read the value from storage (immutable)\n\t\treturn holdersFeeDestination;\n\t}\n\n\t/**\n\t * @notice Disables shares holders fee functionality; detaches shares contract from\n\t *      the HoldersRewardsDistributor, stops sending fees, stops sending syncs\n\t *\n\t * @notice Increases the protocol fee by the value of the disabled shares holders fee,\n\t *      so that the sum of all the fees remains the same\n\t *\n\t * @notice Once disabled, the holders fee functionality cannot be enabled back\n\t */\n\tfunction disableHoldersFee() public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_HOLDERS_FEE_MANAGER), \"access denied\");\n\n\t\t// verify the holders functionality is enabled\n\t\trequire(address(holdersFeeDestination) != address(0) || holdersFeePercent != 0, \"not enabled\");\n\n\t\t// emit an event first - to log both old and new values\n\t\temit HoldersFeeDisabled(protocolFeePercent, protocolFeePercent + holdersFeePercent);\n\n\t\t// shares holders fee goes to the protocol from now on\n\t\tprotocolFeePercent += holdersFeePercent;\n\n\t\t// zero the shares holders fee\n\t\tholdersFeeDestination = HoldersRewardsDistributor(address(0));\n\t\tholdersFeePercent = 0;\n\t}\n\n\t/**\n\t * @inheritdoc TradeableShares\n\t */\n\tfunction getHoldersFeePercent() public view returns(uint256) {\n\t\t// read the value from storage (immutable)\n\t\treturn holdersFeePercent;\n\t}\n\n\t/**\n\t * @inheritdoc TradeableShares\n\t */\n\tfunction getHoldersFeeInfo() public view returns(HoldersRewardsDistributor feeDestination, uint256 feePercent) {\n\t\t// read fee destination first\n\t\tfeeDestination = getHoldersFeeDestination();\n\t\t// if it's zero, zero down the fee as well\n\t\tfeePercent = address(feeDestination) == address(0)? 0: getHoldersFeePercent();\n\t}\n\n\t/**\n\t * @inheritdoc TradeableShares\n\t */\n\tfunction getSubjectFeeInfo() public view returns(address feeDestination, uint256 feePercent) {\n\t\t// read fee destination first\n\t\tfeeDestination = getSharesIssuer();\n\t\t// if it's zero, zero down the fee as well\n\t\tfeePercent = feeDestination == address(0)? 0: getSubjectFeePercent();\n\t}\n\n\t/**\n\t * @inheritdoc TradeableShares\n\t */\n\tfunction getSubjectFeePercent() public view returns(uint256) {\n\t\t// read the value from storage (immutable)\n\t\treturn subjectFeePercent;\n\t}\n\n\t/**\n\t * @inheritdoc TradeableShares\n\t */\n\tfunction getSharesIssuer() public view returns(address nftOwner) {\n\t\t// derive the NFT owner defined by the subject\n\t\treturn SharesSubjectLib.getSharesIssuer(sharesSubject);\n\t}\n\n\t/**\n\t * @inheritdoc TradeableShares\n\t */\n\tfunction getSharesBalance(address _holder) public view returns(uint256 balance) {\n\t\t// read the value from storage\n\t\treturn sharesBalances[_holder];\n\t}\n\n\t/**\n\t * @inheritdoc TradeableShares\n\t */\n\tfunction getSharesSupply() public view returns(uint256 supply) {\n\t\t// read the value from storage\n\t\treturn sharesSupply;\n\t}\n\n\t/**\n\t * @inheritdoc TradeableShares\n\t */\n\tfunction getBuyPrice(uint256 _supply, uint256 _amount) public pure returns(uint256) {\n\t\t// this is the original friend tech formula\n\t\treturn getPrice(_supply, _amount);\n\t}\n\n\t/**\n\t * @inheritdoc TradeableShares\n\t */\n\tfunction getSellPrice(uint256 _supply, uint256 _amount) public pure returns(uint256) {\n\t\t// this is the original friend tech formula\n\t\treturn getPrice(_supply - _amount, _amount);\n\t}\n\n\t/**\n\t * @inheritdoc TradeableShares\n\t */\n\tfunction getBuyPriceAfterFee(\n\t\tuint256 _supply,\n\t\tuint256 _amount,\n\t\tuint256 _protocolFeePercent,\n\t\tuint256 _holdersFeePercent,\n\t\tuint256 _subjectFeePercent\n\t) public pure returns(uint256) {\n\t\t// this is the original friend tech formula\n\t\tuint256 price = getBuyPrice(_supply, _amount);\n\t\tuint256 protocolFee = price * _protocolFeePercent / 1 ether;\n\t\tuint256 holdersFee = price * _holdersFeePercent / 1 ether;\n\t\tuint256 subjectFee = price * _subjectFeePercent / 1 ether;\n\t\treturn price + protocolFee + holdersFee + subjectFee;\n\t}\n\n\t/**\n\t * @inheritdoc TradeableShares\n\t */\n\tfunction getSellPriceAfterFee(\n\t\tuint256 _supply,\n\t\tuint256 _amount,\n\t\tuint256 _protocolFeePercent,\n\t\tuint256 _holdersFeePercent,\n\t\tuint256 _subjectFeePercent\n\t) public pure returns(uint256) {\n\t\t// this is the original friend tech formula\n\t\tuint256 price = getSellPrice(_supply, _amount);\n\t\tuint256 protocolFee = price * _protocolFeePercent / 1 ether;\n\t\tuint256 holdersFee = price * _holdersFeePercent / 1 ether;\n\t\tuint256 subjectFee = price * _subjectFeePercent / 1 ether;\n\t\treturn price - protocolFee - holdersFee - subjectFee;\n\t}\n\n\t/**\n\t * @inheritdoc TradeableShares\n\t */\n\tfunction getBuyPrice(uint256 _amount) public view returns(uint256) {\n\t\t// delegate to `getBuyPrice`\n\t\treturn getBuyPrice(getSharesSupply(), _amount);\n\t}\n\n\t/**\n\t * @inheritdoc TradeableShares\n\t */\n\tfunction getSellPrice(uint256 _amount) public view returns(uint256) {\n\t\t// delegate to `getSellPrice`\n\t\treturn getSellPrice(getSharesSupply(), _amount);\n\t}\n\n\t/**\n\t * @inheritdoc TradeableShares\n\t */\n\tfunction getBuyPriceAfterFee(uint256 _amount) public view returns(uint256) {\n\t\t// read the effective fees values\n\t\t(, uint256 _protocolFeePercent) = getProtocolFeeInfo();\n\t\t(, uint256 _holdersFeePercent) = getHoldersFeeInfo();\n\t\t(, uint256 _subjectFeePercent) = getSubjectFeeInfo();\n\n\t\t// delegate to `getBuyPriceAfterFee`\n\t\treturn getBuyPriceAfterFee(getSharesSupply(), _amount, _protocolFeePercent, _holdersFeePercent, _subjectFeePercent);\n\t}\n\n\t/**\n\t * @inheritdoc TradeableShares\n\t */\n\tfunction getSellPriceAfterFee(uint256 _amount) public view returns(uint256) {\n\t\t// read the effective fees values\n\t\t(, uint256 _protocolFeePercent) = getProtocolFeeInfo();\n\t\t(, uint256 _holdersFeePercent) = getHoldersFeeInfo();\n\t\t(, uint256 _subjectFeePercent) = getSubjectFeeInfo();\n\n\t\t// delegate to `getSellPriceAfterFee`\n\t\treturn getSellPriceAfterFee(getSharesSupply(), _amount, _protocolFeePercent, _holdersFeePercent, _subjectFeePercent);\n\t}\n\n\t/**\n\t * @dev Executed internally on every trade (buy/sell) to track the trading volume\n\t *\n\t * @param value trading operation value, the price of the buy/sell operation without the fees\n\t */\n\tfunction __increaseTradeVolume(uint256 value) internal {\n\t\t// update the value in the storage\n\t\ttradeVolume += value;\n\t}\n\n\t/**\n\t * @inheritdoc TradeableShares\n\t */\n\tfunction getTradeVolume() public view returns(uint256) {\n\t\t// read the value from the storage\n\t\treturn tradeVolume;\n\t}\n}\n"
    },
    "contracts/bonding_curves/Aliases.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./ERC20Shares.sol\";\nimport \"./ETHShares.sol\";\nimport \"./TradeableShares.sol\";\n\n/**\n * @title Tradeable Keys Alias\n *\n * @notice Displays the function names using the \"keys\" word instead of \"shares\"\n *      in MetaMask, Etherscan, etc.\n */\ninterface TradeableKeys is TradeableShares {\n\t/**\n\t * @notice buyShares alias\n\t */\n\tfunction buyKeys(uint256 amount) external payable;\n\n\t/**\n\t * @notice sellShares alias\n\t */\n\tfunction sellKeys(uint256 amount) external;\n}\n\n/**\n * @title ERC20 Keys Alias\n *\n * @notice Displays the function names using the \"keys\" word instead of \"shares\"\n *      in MetaMask, Etherscan, etc.\n */\ncontract ERC20Keys is ERC20Shares, TradeableKeys {\n\tconstructor(address _owner, SharesSubject memory _sharesSubject, address _protocolFeeDestination, uint64 _protocolFeePercent, HoldersRewardsDistributor _holdersFeeDestination, uint64 _holdersFeePercent, uint64 _subjectFeePercent, uint256 _amount, address _beneficiary, ERC1363 _paymentToken\n\t) ERC20Shares(      _owner,                      _sharesSubject,         _protocolFeeDestination,        _protocolFeePercent,                           _holdersFeeDestination,        _holdersFeePercent,        _subjectFeePercent,         _amount,         _beneficiary,         _paymentToken){}\n\n\t/**\n\t * @inheritdoc TradeableKeys\n\t */\n\tfunction buyKeys(uint256 amount) public payable {\n\t\tbuyShares(amount);\n\t}\n\n\t/**\n\t * @inheritdoc TradeableKeys\n\t */\n\tfunction sellKeys(uint256 amount) public {\n\t\tsellShares(amount);\n\t}\n}\n\n/**\n * @title ETH Keys Alias\n *\n * @notice Displays the function names using the \"keys\" word instead of \"shares\"\n *      in MetaMask, Etherscan, etc.\n */\ncontract ETHKeys is ETHShares, TradeableKeys {\n\tconstructor(address _owner, SharesSubject memory _sharesSubject, address _protocolFeeDestination, uint64 _protocolFeePercent, HoldersRewardsDistributor _holdersFeeDestination, uint64 _holdersFeePercent, uint64 _subjectFeePercent, uint256 _amount, address _beneficiary\n\t) ETHShares(        _owner,                      _sharesSubject,         _protocolFeeDestination,        _protocolFeePercent,                           _holdersFeeDestination,        _holdersFeePercent,        _subjectFeePercent,         _amount,         _beneficiary){}\n\n\t/**\n\t * @inheritdoc TradeableKeys\n\t */\n\tfunction buyKeys(uint256 amount) public payable {\n\t\tbuyShares(amount);\n\t}\n\n\t/**\n\t * @inheritdoc TradeableKeys\n\t */\n\tfunction sellKeys(uint256 amount) public {\n\t\tsellShares(amount);\n\t}\n}\n"
    },
    "contracts/bonding_curves/BondingCurve.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title Bonding Curve\n *\n * @notice A friend.tech-like bonding curve definition\n *\n * @notice Bonding curve defines the price of the smallest unit of the asset as a function\n *      of the asset supply\n */\ninterface BondingCurve {\n\t/**\n\t * @notice Bonding curve function definition. The function calculating the price\n\t *      of the `amount` of shares given the current total supply `supply`\n\t *\n\t * @param supply total shares supply\n\t * @param amount number of shares to buy/sell\n\t * @return the price of the shares (all `amount` amount)\n\t */\n\tfunction getPrice(uint256 supply, uint256 amount) external pure returns(uint256);\n}\n"
    },
    "contracts/bonding_curves/ERC20Shares.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ERC1363Spec.sol\";\nimport \"./AbstractShares.sol\";\n\n/**\n * @title ERC20 Shares\n *\n * @notice TradeableShares implementation using ERC20 token as a payment token\n *\n * @dev Doesn't have \"payable\" functions, that is the functions accepting ETH\n *\n * @dev Based on the friend.tech FriendtechSharesV1.sol\n */\ncontract ERC20Shares is AbstractShares {\n\t/// @dev ERC1363 payment token used for payments\n\tERC1363 private /*immutable*/ paymentToken;\n\n\t/**\n\t * @dev Deploys the ERC20Shares instance and initializes it\n\t *\n\t * @param _owner the address receiving all the RBAC permissions on the contract\n\t * @param _sharesSubject shares subject, usually defined as NFT (ERC721 contract address + NFT ID)\n\t * @param _protocolFeeDestination protocol fee destination, the address protocol fee is sent to\n\t * @param _protocolFeePercent protocol fee percent, applied to all the buy and sell operations;\n\t *      the fee percent is defined with the 18 decimals, 10^18 corresponds to 100%\n\t * @param _holdersFeeDestination shares holders fee destination, the HoldersRewardsDistributor contract\n\t *      the shares holders fee is sent to\n\t * @param _holdersFeePercent shares holders fee percent, applied to all the buy and sell operations,\n\t *      the fee percent is defined with the 18 decimals, 10^18 corresponds to 100%\n\t * @param _subjectFeePercent subject fee percent, applied to all the buy and sell operations,\n\t *      the fee percent is defined with the 18 decimals, 10^18 corresponds to 100%\n\t * @param _amount how many shares to buy immediately upon \"post-construction\", can be zero\n\t * @param _beneficiary the address receiving the shares bought immediately (must be set\n\t *      if `_amount` is not zero)\n\t * @param _paymentToken ERC1363 token used as a payment token instead of ETH\n\t */\n\tconstructor(\n\t\taddress _owner,\n\t\tSharesSubject memory _sharesSubject,\n\t\taddress _protocolFeeDestination,\n\t\tuint64 _protocolFeePercent,\n\t\tHoldersRewardsDistributor _holdersFeeDestination,\n\t\tuint64 _holdersFeePercent,\n\t\tuint64 _subjectFeePercent,\n\t\tuint256 _amount,\n\t\taddress _beneficiary,\n\t\tERC1363 _paymentToken\n\t) initializer {\n\t\t// initialize the deployed instance\n\t\tpostConstruct(\n\t\t\t_owner,\n\t\t\t_sharesSubject,\n\t\t\t_protocolFeeDestination,\n\t\t\t_protocolFeePercent,\n\t\t\t_holdersFeeDestination,\n\t\t\t_holdersFeePercent,\n\t\t\t_subjectFeePercent,\n\t\t\t_amount,\n\t\t\t_beneficiary,\n\t\t\t_paymentToken\n\t\t);\n\t}\n\n\t/**\n\t * @dev \"Constructor replacement\" for initializable, must be execute during or immediately after deployment\n\t *      see https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#initializers\n\t *\n\t * @param _owner the address receiving all the RBAC permissions on the contract\n\t * @param _sharesSubject shares subject, usually defined as NFT (ERC721 contract address + NFT ID)\n\t * @param _protocolFeeDestination protocol fee destination, the address protocol fee is sent to\n\t * @param _protocolFeePercent protocol fee percent, applied to all the buy and sell operations;\n\t *      the fee percent is defined with the 18 decimals, 10^18 corresponds to 100%\n\t * @param _holdersFeeDestination shares holders fee destination, the HoldersRewardsDistributor contract\n\t *      the shares holders fee is sent to\n\t * @param _holdersFeePercent shares holders fee percent, applied to all the buy and sell operations,\n\t *      the fee percent is defined with the 18 decimals, 10^18 corresponds to 100%\n\t * @param _subjectFeePercent subject fee percent, applied to all the buy and sell operations,\n\t *      the fee percent is defined with the 18 decimals, 10^18 corresponds to 100%\n\t * @param _amount how many shares to buy immediately upon \"post-construction\", can be zero\n\t * @param _beneficiary the address receiving the shares bought immediately (must be set\n\t *      if `_amount` is not zero)\n\t * @param _paymentToken ERC20 token used as a payment token instead of ETH\n\t */\n\tfunction postConstruct(\n\t\taddress _owner,\n\t\tSharesSubject memory _sharesSubject,\n\t\taddress _protocolFeeDestination,\n\t\tuint64 _protocolFeePercent,\n\t\tHoldersRewardsDistributor _holdersFeeDestination,\n\t\tuint64 _holdersFeePercent,\n\t\tuint64 _subjectFeePercent,\n\t\tuint256 _amount,\n\t\taddress _beneficiary,\n\t\tERC1363 _paymentToken\n\t) public initializer {\n\t\t// execute parent initializer\n\t\t_postConstruct(\n\t\t\t_owner,\n\t\t\t_sharesSubject,\n\t\t\t_protocolFeeDestination,\n\t\t\t_protocolFeePercent,\n\t\t\t_holdersFeeDestination,\n\t\t\t_holdersFeePercent,\n\t\t\t_subjectFeePercent\n\t\t);\n\t\t// no need to check if payment token is zero since this is designed to be\n\t\t// deployed only from the factory where the ERC20 address in non-modifiable\n\t\t// and is defined on the deployment of the factory\n\t\tpaymentToken = _paymentToken;\n\n\t\t// buy shares if requested\n\t\tif(_amount != 0) {\n\t\t\t__buySharesTo(_amount, _beneficiary);\n\t\t}\n\t}\n\n\t/**\n\t * @notice ERC1363 payment token getter\n\t *\n\t * @return ERC1363 payment token, immutable\n\t */\n\tfunction getPaymentToken() public view returns(ERC1363) {\n\t\t// read from the storage and return\n\t\treturn paymentToken;\n\t}\n\n\t/**\n\t * @inheritdoc BondingCurve\n\t *\n\t * @notice Shifts the curve by multiplying the result by 50,000\n\t */\n\tfunction getPrice(uint256 supply, uint256 amount) public pure override(BondingCurve, FriendTechBondingCurve) returns(uint256) {\n\t\t// shift the curve by 50,000\n\t\treturn (10**5 / 2) * super.getPrice(supply, amount);\n\t}\n\n\t/**\n\t * @inheritdoc TradeableShares\n\t */\n\tfunction buyShares(uint256 amount) public payable {\n\t\t// delegate to `buySharesTo`\n\t\tbuySharesTo(amount, msg.sender);\n\t}\n\n\t/**\n\t * @inheritdoc TradeableShares\n\t */\n\tfunction sellShares(uint256 amount) public {\n\t\t// delegate to `sellSharesTo`\n\t\tsellSharesTo(amount, payable(msg.sender));\n\t}\n\n\t/**\n\t * @inheritdoc TradeableShares\n\t */\n\tfunction buySharesTo(uint256 amount, address beneficiary) public payable {\n\t\t// verify the first share is not bought\n\t\trequire(getSharesSupply() > 0 || getSharesIssuer() == msg.sender, \"only the issuer can buy the first share\");\n\n\t\t// delegate to unsafe `__buySharesTo`\n\t\t__buySharesTo(amount, beneficiary);\n\t}\n\n\t/**\n\t * @dev Buys amount of shares for the beneficiary, without checking if the first share was bought\n\t *\n\t * @param amount amount of the shares to buy\n\t * @param beneficiary an address receiving the shares\n\t */\n\tfunction __buySharesTo(uint256 amount, address beneficiary) private {\n\t\t// ERC20 implementation doesn't expect Ether to be sent\n\t\trequire(msg.value == 0, \"only payment in ERC20 token is expected\");\n\n\t\t// cache the supply value\n\t\tuint256 supply = getSharesSupply();\n\n\t\t// update the balances (note: security checks are below)\n\t\tsharesBalances[beneficiary] += amount;\n\t\tsharesSupply = supply + amount;\n\n\t\t// determine the price and process the fees\n\t\tuint256 price = getPrice(supply, amount);\n\t\t(, , uint256 protocolFee) = __processProtocolFee(msg.sender, price);\n\t\t(, , uint256 holdersFee) = __processHoldersFeeAndNotify(msg.sender, price, true, amount, beneficiary);\n\t\t(address issuer, , uint256 subjectFee) = __processSubjectFee(msg.sender, price);\n\n\t\t// do the required ERC20 payment token price transfer\n\t\trequire(\n\t\t\t// do not try to transfer zero price\n\t\t\tprice == 0 || paymentToken.transferFrom(msg.sender, address(this), price),\n\t\t\t\"payment failed\"\n\t\t);\n\n\t\t// update the cumulative trade volume\n\t\t__increaseTradeVolume(price);\n\n\t\t// emit an event\n\t\temit Trade(beneficiary, issuer, true, amount, price, protocolFee, holdersFee, subjectFee, sharesSupply);\n\t}\n\n\t/**\n\t * @inheritdoc TradeableShares\n\t */\n\tfunction sellSharesTo(uint256 amount, address payable beneficiary) public {\n\t\t// verify the amount vs total supply\n\t\tuint256 supply = getSharesSupply();\n\t\trequire(supply > amount, \"cannot sell the last share\");\n\n\t\t// verify the amount vs seller's balance\n\t\tuint256 balance = getSharesBalance(msg.sender);\n\t\trequire(balance >= amount, \"insufficient shares\");\n\n\t\t// update the balances\n\t\tsharesBalances[msg.sender] = balance - amount;\n\t\tsharesSupply = supply - amount;\n\n\t\t// determine the price and process the fees\n\t\tuint256 price = getPrice(sharesSupply, amount);\n\t\t(, , uint256 protocolFee) = __processProtocolFee(address(this), price);\n\t\t(, , uint256 holdersFee) = __processHoldersFeeAndNotify(address(this), price, false, amount, msg.sender);\n\t\t(address issuer, , uint256 subjectFee) = __processSubjectFee(address(this), price);\n\n\t\t// price cannot be zero since the last share cannot be sold\n\t\t// if the price transfer fails, we do fail\n\t\t// note: if any of the fees failed to transfer, they are sent to the seller\n\t\trequire(\n\t\t\tpaymentToken.transfer(beneficiary, price - protocolFee - holdersFee - subjectFee),\n\t\t\t\"payment failed\"\n\t\t);\n\n\t\t// update the cumulative trade volume\n\t\t__increaseTradeVolume(price);\n\n\t\t// emit an event\n\t\temit Trade(beneficiary, issuer, false, amount, price, protocolFee, holdersFee, subjectFee, sharesSupply);\n\t}\n\n\t/**\n\t * @dev Calculates the protocol fee and sends it to the protocol fee destination\n\t *\n\t * @param from the address where the tokens are being sent from, this can be either\n\t *      the the shares buyer, or the contract itself (when selling)\n\t * @param price already calculated price of the trade\n\t */\n\tfunction __processProtocolFee(address from, uint256 price) private returns(\n\t\taddress protocolFeeDestination,\n\t\tuint256 protocolFeePercent,\n\t\tuint256 protocolFee\n\t) {\n\t\t// read fee information in a consistent way\n\t\t(protocolFeeDestination, protocolFeePercent) = getProtocolFeeInfo();\n\n\t\t// calculate the fee\n\t\tprotocolFee = price * protocolFeePercent / 1 ether;\n\n\t\t// do the required ERC20 payment token transfer\n\t\trequire(\n\t\t\t// do not try to transfer zero protocol fee\n\t\t\tprotocolFee == 0 || paymentToken.transferFrom(from, protocolFeeDestination, protocolFee),\n\t\t\t\"protocol fee payment failed\"\n\t\t);\n\t}\n\n\t/**\n\t * @dev Calculates the shares holders fee and sends it to the holders fee destination;\n\t *      notifies the destination (which is a HoldersRewardsDistributor contract) about\n\t *      the trade, submits trader address, and trade amount\n\t *\n\t * @dev isBuy is true if the shares are bought\n\t *      isBuy is false if the shares are sold\n\t *\n\t * @param from the address where the tokens are being sent from, this can be either\n\t *      the the shares buyer, or the contract itself (when selling)\n\t * @param price already calculated price of the trade\n\t * @param isBuy operation type, [true] buying, [false] selling\n\t * @param amount trade amount\n\t * @param trader an account which makes a trade, whose shares balance changes by the `amount`\n\t */\n\tfunction __processHoldersFeeAndNotify(address from, uint256 price, bool isBuy, uint256 amount, address trader) private returns(\n\t\tHoldersRewardsDistributor holdersFeeDestination,\n\t\tuint256 holdersFeePercent,\n\t\tuint256 holdersFee\n\t) {\n\t\t// read fee information in a consistent way\n\t\t(holdersFeeDestination, holdersFeePercent) = getHoldersFeeInfo();\n\n\t\t// calculate the fee\n\t\tholdersFee = price * holdersFeePercent / 1 ether;\n\n\t\t// do the required ERC1363 payment token transfer and HoldersRewardsDistributor sync\n\t\tif(address(holdersFeeDestination) != address(0) && amount != 0) {\n\t\t\t// construct the HoldersRewardsDistributor sync message\n\t\t\tbytes memory syncMessage = abi.encode(trader, isBuy, amount);\n\n\t\t\t// send the fee together with the sync message\n\t\t\tbool success = paymentToken.transferFromAndCall(from, address(holdersFeeDestination), holdersFee, syncMessage);\n\n\t\t\t// we require synchronization to succeed, otherwise we can't guarantee data consistency\n\t\t\t// on the HoldersRewardsDistributor contract's side\n\t\t\trequire(success, \"sync failed\");\n\t\t}\n\t}\n\n\t/**\n\t * @dev Calculates the subject fee and sends it to the issuer\n\t *\n\t * @param from the address where the tokens are being sent from, this can be either\n\t *      the the shares buyer, or the contract itself (when selling)\n\t * @param price already calculated price of the trade\n\t */\n\tfunction __processSubjectFee(address from, uint256 price) private returns(\n\t\taddress subjectFeeDestination,\n\t\tuint256 subjectFeePercent,\n\t\tuint256 subjectFee\n\t) {\n\t\t// read fee information in a consistent way\n\t\t(subjectFeeDestination, subjectFeePercent) = getSubjectFeeInfo();\n\n\t\t// calculate the fee\n\t\tsubjectFee = price * subjectFeePercent / 1 ether;\n\n\t\t// do the required ERC20 payment token transfer\n\t\trequire(\n\t\t\t// do not try to transfer zero subject fee\n\t\t\tsubjectFee == 0 || paymentToken.transferFrom(from, subjectFeeDestination, subjectFee),\n\t\t\t\"subject fee payment failed\"\n\t\t);\n\t}\n}\n"
    },
    "contracts/bonding_curves/ETHShares.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../utils/Transfers.sol\";\nimport \"./AbstractShares.sol\";\n\n/**\n * @title ETH Shares\n *\n * @notice TradeableShares implementation using native ETH for payments\n *\n * @dev Based on the friend.tech FriendtechSharesV1.sol\n */\ncontract ETHShares is AbstractShares {\n\t/// @dev Overrides standard send and transfer Solidity functions\n\tusing Transfers for address payable;\n\n\t/**\n\t * @dev Deploys the ETHShares instance and initializes it\n\t *\n\t * @param _owner the address receiving all the RBAC permissions on the contract\n\t * @param _sharesSubject shares subject, usually defined as NFT (ERC721 contract address + NFT ID)\n\t * @param _protocolFeeDestination protocol fee destination, the address protocol fee is sent to\n\t * @param _protocolFeePercent protocol fee percent, applied to all the buy and sell operations;\n\t *      the fee percent is defined with the 18 decimals, 10^18 corresponds to 100%\n\t * @param _holdersFeeDestination shares holders fee destination, the HoldersRewardsDistributor contract\n\t *      the shares holders fee is sent to\n\t * @param _holdersFeePercent shares holders fee percent, applied to all the buy and sell operations,\n\t *      the fee percent is defined with the 18 decimals, 10^18 corresponds to 100%\n\t * @param _subjectFeePercent subject fee percent, applied to all the buy and sell operations,\n\t *      the fee percent is defined with the 18 decimals, 10^18 corresponds to 100%\n\t * @param _amount how many shares to buy immediately upon \"post-construction\", can be zero\n\t * @param _beneficiary the address receiving the shares bought immediately (must be set\n\t *      if `_amount` is not zero)\n\t */\n\tconstructor(\n\t\taddress _owner,\n\t\tSharesSubject memory _sharesSubject,\n\t\taddress _protocolFeeDestination,\n\t\tuint64 _protocolFeePercent,\n\t\tHoldersRewardsDistributor _holdersFeeDestination,\n\t\tuint64 _holdersFeePercent,\n\t\tuint64 _subjectFeePercent,\n\t\tuint256 _amount,\n\t\taddress _beneficiary\n\t) payable initializer {\n\t\t// initialize the deployed instance\n\t\tpostConstruct(\n\t\t\t_owner,\n\t\t\t_sharesSubject,\n\t\t\t_protocolFeeDestination,\n\t\t\t_protocolFeePercent,\n\t\t\t_holdersFeeDestination,\n\t\t\t_holdersFeePercent,\n\t\t\t_subjectFeePercent,\n\t\t\t_amount,\n\t\t\t_beneficiary\n\t\t);\n\t}\n\n\t/**\n\t * @dev \"Constructor replacement\" for initializable, must be execute during or immediately after deployment\n\t *      see https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#initializers\n\t *\n\t * @param _owner the address receiving all the RBAC permissions on the contract\n\t * @param _sharesSubject shares subject, usually defined as NFT (ERC721 contract address + NFT ID)\n\t * @param _protocolFeeDestination protocol fee destination, the address protocol fee is sent to\n\t * @param _protocolFeePercent protocol fee percent, applied to all the buy and sell operations;\n\t *      the fee percent is defined with the 18 decimals, 10^18 corresponds to 100%\n\t * @param _holdersFeeDestination shares holders fee destination, the HoldersRewardsDistributor contract\n\t *      the shares holders fee is sent to\n\t * @param _holdersFeePercent shares holders fee percent, applied to all the buy and sell operations,\n\t *      the fee percent is defined with the 18 decimals, 10^18 corresponds to 100%\n\t * @param _subjectFeePercent subject fee percent, applied to all the buy and sell operations,\n\t *      the fee percent is defined with the 18 decimals, 10^18 corresponds to 100%\n\t * @param _amount how many shares to buy immediately upon \"post-construction\", can be zero\n\t * @param _beneficiary the address receiving the shares bought immediately (must be set\n\t *      if `_amount` is not zero)\n\t */\n\tfunction postConstruct(\n\t\taddress _owner,\n\t\tSharesSubject memory _sharesSubject,\n\t\taddress _protocolFeeDestination,\n\t\tuint64 _protocolFeePercent,\n\t\tHoldersRewardsDistributor _holdersFeeDestination,\n\t\tuint64 _holdersFeePercent,\n\t\tuint64 _subjectFeePercent,\n\t\tuint256 _amount,\n\t\taddress _beneficiary\n\t) public payable initializer {\n\t\t// execute parent initializer\n\t\t_postConstruct(\n\t\t\t_owner,\n\t\t\t_sharesSubject,\n\t\t\t_protocolFeeDestination,\n\t\t\t_protocolFeePercent,\n\t\t\t_holdersFeeDestination,\n\t\t\t_holdersFeePercent,\n\t\t\t_subjectFeePercent\n\t\t);\n\n\t\t// buy shares if requested\n\t\tif(_amount != 0) {\n\t\t\t__buySharesTo(_amount, _beneficiary);\n\t\t}\n\t\t// otherwise if transaction contains a payment\n\t\telse if(msg.value > 0) {\n\t\t\t//  don't forget to return it back\n\t\t\tpayable(msg.sender).transfer1(msg.value);\n\t\t}\n\t}\n\n\t/**\n\t * @inheritdoc TradeableShares\n\t */\n\tfunction buyShares(uint256 amount) public payable {\n\t\t// delegate to `buySharesTo`\n\t\tbuySharesTo(amount, msg.sender);\n\t}\n\n\t/**\n\t * @inheritdoc TradeableShares\n\t */\n\tfunction sellShares(uint256 amount) public {\n\t\t// delegate to `sellSharesTo`\n\t\tsellSharesTo(amount, payable(msg.sender));\n\t}\n\n\t/**\n\t * @inheritdoc TradeableShares\n\t */\n\tfunction buySharesTo(uint256 amount, address beneficiary) public payable {\n\t\t// verify the first share is not bought\n\t\trequire(getSharesSupply() > 0 || getSharesIssuer() == msg.sender, \"only the issuer can buy the first share\");\n\n\t\t// delegate to unsafe `__buySharesTo`\n\t\t__buySharesTo(amount, beneficiary);\n\t}\n\n\t/**\n\t * @dev Buys amount of shares for the beneficiary, without checking if the first share was bought\n\t *\n\t * @param amount amount of the shares to buy\n\t * @param beneficiary an address receiving the shares\n\t */\n\tfunction __buySharesTo(uint256 amount, address beneficiary) private {\n\t\t// cache the supply value\n\t\tuint256 supply = getSharesSupply();\n\n\t\t// update the balances (note: security checks are below)\n\t\tsharesBalances[beneficiary] += amount;\n\t\tsharesSupply = supply + amount;\n\n\t\t// determine the price and process the fees\n\t\tuint256 price = getPrice(supply, amount);\n\t\t(, , uint256 protocolFee) = __processProtocolFee(price);\n\t\t(, , uint256 holdersFee) = __processHoldersFeeAndNotify(price, true, amount, beneficiary);\n\t\t(address issuer, , uint256 subjectFee) = __processSubjectFee(price);\n\n\t\t// verify the transaction has enough Ether supplied\n\t\tuint256 value = price + protocolFee + holdersFee + subjectFee;\n\t\trequire(msg.value >= value, \"insufficient value supplied\");\n\n\t\t// return the change back to the buyer; here we do fail on error\n\t\t// note: if any of the fees failed to transfer, they are sent to the buyer\n\t\tif(msg.value > value) {\n\t\t\tpayable(msg.sender).transfer1(msg.value - value);\n\t\t}\n\n\t\t// update the cumulative trade volume\n\t\t__increaseTradeVolume(price);\n\n\t\t// emit an event\n\t\temit Trade(beneficiary, issuer, true, amount, price, protocolFee, holdersFee, subjectFee, sharesSupply);\n\t}\n\n\t/**\n\t * @inheritdoc TradeableShares\n\t */\n\tfunction sellSharesTo(uint256 amount, address payable beneficiary) public {\n\t\t// verify the amount vs total supply\n\t\tuint256 supply = getSharesSupply();\n\t\trequire(supply > amount, \"cannot sell the last share\");\n\n\t\t// verify the amount vs seller's balance\n\t\tuint256 balance = getSharesBalance(msg.sender);\n\t\trequire(balance >= amount, \"insufficient shares\");\n\n\t\t// update the balances\n\t\tsharesBalances[msg.sender] = balance - amount;\n\t\tsharesSupply = supply - amount;\n\n\t\t// determine the price and process the fees\n\t\tuint256 price = getPrice(sharesSupply, amount);\n\t\t(, , uint256 protocolFee) = __processProtocolFee(price);\n\t\t(, , uint256 holdersFee) = __processHoldersFeeAndNotify(price, false, amount, msg.sender);\n\t\t(address issuer, , uint256 subjectFee) = __processSubjectFee(price);\n\n\t\t// price cannot be zero since the last share cannot be sold\n\t\t// if the price transfer fails, we do fail\n\t\t// note: if any of the fees failed to transfer, they are sent to the seller\n\t\tbeneficiary.transfer1(price - protocolFee - holdersFee - subjectFee);\n\n\t\t// update the cumulative trade volume\n\t\t__increaseTradeVolume(price);\n\n\t\t// emit an event\n\t\temit Trade(beneficiary, issuer, false, amount, price, protocolFee, holdersFee, subjectFee, sharesSupply);\n\t}\n\n\t/**\n\t * @dev Calculates the protocol fee and sends it to the protocol fee destination\n\t *\n\t * @param price already calculated price of the trade\n\t */\n\tfunction __processProtocolFee(uint256 price) private returns(\n\t\taddress protocolFeeDestination,\n\t\tuint256 protocolFeePercent,\n\t\tuint256 protocolFee\n\t) {\n\t\t// read fee information in a consistent way\n\t\t(protocolFeeDestination, protocolFeePercent) = getProtocolFeeInfo();\n\n\t\t// calculate the fee\n\t\tprotocolFee = price * protocolFeePercent / 1 ether;\n\n\t\t// do the required ETH payment transfer\n\t\t// if the fee payment fails - do not throw and update the fee to zero\n\t\tif(protocolFee != 0 && !payable(protocolFeeDestination).send1(protocolFee)) {\n\t\t\t// protocol fee couldn't be sent or is zero\n\t\t\tprotocolFee = 0;\n\t\t}\n\t}\n\n\t/**\n\t * @dev Calculates the shares holders fee and sends it to the holders fee destination;\n\t *      notifies the destination (which is a HoldersRewardsDistributor contract) about\n\t *      the trade, submits trader address, and trade amount\n\t *\n\t * @dev isBuy is true if the shares are bought\n\t *      isBuy is false if the shares are sold\n\t *\n\t * @param price already calculated price of the trade\n\t * @param isBuy operation type, [true] buying, [false] selling\n\t * @param amount trade amount\n\t * @param trader an account which makes a trade, whose shares balance changes by the `amount`\n\t */\n\tfunction __processHoldersFeeAndNotify(uint256 price, bool isBuy, uint256 amount, address trader) private returns(\n\t\tHoldersRewardsDistributor holdersFeeDestination,\n\t\tuint256 holdersFeePercent,\n\t\tuint256 holdersFee\n\t) {\n\t\t// read fee information in a consistent way\n\t\t(holdersFeeDestination, holdersFeePercent) = getHoldersFeeInfo();\n\n\t\t// calculate the fee\n\t\tholdersFee = price * holdersFeePercent / 1 ether;\n\n\t\t// do the required ETH payment transfer and HoldersRewardsDistributor sync\n\t\tif(address(holdersFeeDestination) != address(0) && amount != 0) {\n\t\t\t// construct the HoldersRewardsDistributor sync message\n\t\t\tbytes memory syncMessage = abi.encode(trader, isBuy, amount);\n\n\t\t\t// send the fee together with the sync message\n\t\t\t// we pass all the gas available since the fee destination address is trusted,\n\t\t\t// and since if the call fails we also fail the entire transaction\n\t\t\t(bool success, ) = address(holdersFeeDestination).call{value: holdersFee}(syncMessage);\n\n\t\t\t// we require synchronization to succeed, otherwise we can't guarantee data consistency\n\t\t\t// on the HoldersRewardsDistributor contract's side\n\t\t\trequire(success, \"sync failed\");\n\t\t}\n\t}\n\n\t/**\n\t * @dev Calculates the subject fee and sends it to the issuer\n\t *\n\t * @param price already calculated price of the trade\n\t */\n\tfunction __processSubjectFee(uint256 price) private returns(\n\t\taddress subjectFeeDestination,\n\t\tuint256 subjectFeePercent,\n\t\tuint256 subjectFee\n\t) {\n\t\t// read fee information in a consistent way\n\t\t(subjectFeeDestination, subjectFeePercent) = getSubjectFeeInfo();\n\n\t\t// calculate the fee\n\t\tsubjectFee = price * subjectFeePercent / 1 ether;\n\n\t\t// do the required ETH payment transfer\n\t\t// if the fee payment fails - do not throw and update the fee to zero\n\t\tif(subjectFee != 0 && !payable(subjectFeeDestination).send1(subjectFee)) {\n\t\t\t// protocol fee couldn't be sent or is zero\n\t\t\tsubjectFee = 0;\n\t\t}\n\t}\n}\n"
    },
    "contracts/bonding_curves/FriendTechBondingCurve.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./BondingCurve.sol\";\n\n/**\n * @title FriendTech Bonding Curve\n *\n * @notice friend.tech definition of the bonding curve function\n */\ncontract FriendTechBondingCurve is BondingCurve {\n\t/**\n\t * @inheritdoc BondingCurve\n\t *\n\t * @param s supply, total shares supply\n\t * @param a amount, number of shares to buy/sell\n\t */\n\tfunction getPrice(uint256 s, uint256 a) public pure virtual returns(uint256) {\n\t\t// this is the original friend tech formula with the underflow fix\n\t\t// the fix allows both supply and amount be zero, as well as\n\t\t// it allows supply be zero when the amount is bigger than one\n\t\tuint256 sum1 = s == 0 ? 0 : (s - 1) * s * (2 * (s - 1) + 1) / 6;\n\t\tuint256 sum2 = s == 0 && a <= 1 ? 0 : (s + a - 1) * (s + a) * (2 * (s + a - 1) + 1) / 6;\n\t\tuint256 summation = sum2 - sum1;\n\t\treturn summation * 1 ether / 16000;\n\t}\n}\n"
    },
    "contracts/bonding_curves/HoldersRewardsDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ERC1363Spec.sol\";\n\n/**\n * @title Bonding Curve Holder Reward Distributor\n *\n * @notice Holder reward distributor keeps track of every trade event happening in the curve,\n *      and based on the amount of shares the holder has, alters the holders' reward weight,\n *      which directly affects the amount of the distributed rewards between the holders\n *\n * @notice Holder reward distributor accepts the fees from the curve and distributes these fees\n *      across shares holders proportionally to their weights\n *\n * @dev Apart from the `accept(uint256,address)` function designed to accept the fees from the\n *      curve contract, the implementation must implement receive(), fallback(), and onTransferReceived()\n *      functions to accept direct payments in both ETH and/or ERC20 payment token\n *\n * @dev receive() and onTransferReceived() with an empty data field must accept the fee in the same way\n *      as an accept() function would do, but in a passive way (without ERC20 transfer)\n *\n * @dev The fallback() and onTransferReceived() with non-empty data field must accept the fee and the trading event;\n *      trading event encoded in the bytes data field contains the information\n *      on the trade which resulted in the fee being sent:\n *\n *      - address trader - shares holder/trader\n *      - bool isBuy - true if shares were bought, false if shares were sold\n *      - uint256 sharesAmount - amount of shares bought or sold\n *\n *      the values above are packed as data = abi.encode(trader, isBuy, sharesAmount)\n *      and can be unpacked as (trader, isBuy, sharesAmount) = abi.decode(data, (address, bool, uint256))\n *\n *      if specified, the data field must be parsed by the implementation and its containing data applied;\n *      standard logic applies, if the data is malformed implementation should throw\n *\n */\ninterface HoldersRewardsDistributor is ERC1363Receiver {\n\t/**\n\t * @dev Fired in `sharesBought` and `sharesSold`\n\t *\n\t * @param trader is a buyer or a seller, depending on the operation type\n\t * @param isBuy true if the event comes from the `sharesBought` and represents the buy operation,\n\t *      false if the event comes from the `sharesSold` and represents the sell operation\n\t * @param sharesAmount amount of the shares bought or sold (see `isBuy`)\n\t */\n\tevent SharesTraded(address indexed trader, bool indexed isBuy, uint256 sharesAmount);\n\n\t/**\n\t * @dev Fired when the fee for the distribution is received\n\t *\n\t * @param feeAmount amount of the fee to distribute between the holders\n\t */\n\tevent FeeReceived(uint256 feeAmount);\n\n\t/**\n\t * @dev Fired in `claimReward`\n\t *\n\t * @param holder address of the trader (and shares holder) who received the reward\n\t * @param rewardAmount amount of the reward sent\n\t */\n\tevent RewardClaimed(address indexed holder, uint256 rewardAmount);\n\n\t/**\n\t * @notice ERC20 payment token distributor is bound to\n\t *\n\t * @return paymentToken ERC20 payment token address the contract is bound to,\n\t *      or zero zero address if it operates with the plain ETH\n\t */\n\tfunction getPaymentToken() external view returns(address paymentToken);\n\n/*\n\t*/\n/**\n\t * @notice Notifies the distributor about the trade event\n\t *\n\t * @dev Trade amount specified affects holder's (buyer's) weight when calculating the reward\n\t *\n\t * @param buyer shares buyer (becomes shares holder if not yet), a.k.a trader\n\t * @param amountBought amount of the shares bought\n\t *//*\n\n\tfunction sharesBought(address buyer, uint256 amountBought) external;\n\n\t*/\n/**\n\t * @notice Notifies the distributor about the trade event\n\t *\n\t * @dev Trade amount specified affects holder's (seller's) weight when calculating the reward\n\t *\n\t * @param seller shares seller (shares holder), a.k.a trader\n\t * @param amountSold amount of the shares sold\n\t *//*\n\n\tfunction sharesSold(address seller, uint256 amountSold) external;\n\n\t*/\n/**\n\t * @notice Executed by the fee sender to send the fee; in case of the ERC20 payment,\n\t *      this is the ask to take the specified amount of the ERC20 token of the specified type;\n\t *      in case of the ETH payment, the amount must be supplied with the transaction itself\n\t *\n\t * @dev When paying with an ERC20 payment token, sender must approve the contract for\n\t *      at least the amount specified before executing this function\n\t *\n\t * @dev Updates the accumulated reward per share\n\t *\n\t * @param feeAmount amount of the fee sent,\n\t *      in the case of ETH payment must be equal to msg.value\n\t *//*\n\n\tfunction accept(uint256 feeAmount) external payable;\n*/\n\n\t/**\n\t * @notice Executed by the holder to claim entire pending reward\n\t *\n\t * @dev Holder can verify pending reward amount with the `pendingReward` function\n\t */\n\tfunction claimTheReward() external;\n\n\t/**\n\t * @notice Pending (claimable) reward. This is the amount which can be claimed using `claimTheReward`\n\t *\n\t * @param holder the holder address to query the reward for\n\t * @return rewardAmount pending reward amount\\\n\t */\n\tfunction pendingReward(address holder) external view returns(uint256 rewardAmount);\n}\n"
    },
    "contracts/bonding_curves/HoldersRewardsDistributorV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./HoldersRewardsDistributor.sol\";\nimport \"../utils/Transfers.sol\";\nimport \"../utils/InitializableAccessControl.sol\";\n\n/**\n * @title Bonding Curve Holder Reward Distributor\n *\n * @notice Holder reward distributor keeps track of every trade event happening in the curve,\n *      and based on the amount of shares the holder has, alters the holders' reward weight,\n *      which directly affects the amount of the distributed rewards between the holders\n *\n * @notice Holder reward distributor accepts the fees from the curve and distributes these fees\n *      across shares holders proportionally to their weights\n *\n * @dev Apart from the `accept(uint256,address)` function designed to accept the fees from the\n *      curve contract, the implementation must implement receive(), fallback(), and onTransferReceived()\n *      functions to accept direct payments in both ETH and/or ERC20 payment token\n *\n * @dev receive() and onTransferReceived() with an empty data field must accept the fee in the same way\n *      as an accept() function would do, but in a passive way (without ERC20 transfer)\n *\n * @dev The fallback() and onTransferReceived() with non-empty data field must accept the fee and the trading event;\n *      trading event encoded in the bytes data field contains the information\n *      on the trade which resulted in the fee being sent:\n *\n *      - address trader - shares holder/trader\n *      - bool isBuy - true if shares were bought, false if shares were sold\n *      - uint256 sharesAmount - amount of shares bought or sold\n *\n *      the values above are packed as data = abi.encode(trader, isBuy, sharesAmount)\n *      and can be unpacked as (trader, isBuy, sharesAmount) = abi.decode(data, (address, bool, uint256))\n *\n *      if specified, the data field must be parsed by the implementation and its containing data applied;\n *      standard logic applies, if the data is malformed implementation should throw\n *\n */\ncontract HoldersRewardsDistributorV1 is HoldersRewardsDistributor, InitializableAccessControl {\n\t// Info of each user.\n\tstruct UserInfo {\n\t\tuint256 shares;\n\t\tuint256 rewardDebt;\n\t\tuint256 claimedAmount;\n\t\tuint256 unclaimedAmount;\n\t}\n\n\t// ERC20 payment token address\n\taddress private /*immutable*/ paymentToken;\n\t/// bonding curve contract address\n\taddress public sharesContractAddress;\n\t/// accumulated reward per share, times 1e18 (with 18 decimal precision)\n\tuint256 public accRewardPerShare;\n\t/// total number of share registered\n\tuint256 public totalShares;\n\t// Info of each user that stakes LP tokens.\n\tmapping(address => UserInfo) public userInfo;\n\n\t/**\n\t * @dev Deploys the distributor contract\n\t *\n\t * @param _owner contract, optional (can be zero address), since there are no admin functions\n\t * @param _sharesContractAddress TradeableShares contract to bind the distributor to,\n\t *      optional (can be zero address), this can be set up later with the\n\t *      `initializeSharesContractAddressIfRequired` function\n\t * @param _paymentToken ERC1363 payment token to bind to, optional (can be zero address),\n\t *      zero address means distributor works with the plain ETH\n\t */\n\tconstructor(address _owner, address _sharesContractAddress, address _paymentToken) initializer {\n\t\t// initialize the deployed instance\n\t\tpostConstruct(_owner, _sharesContractAddress, _paymentToken);\n\t}\n\n\t/**\n\t * @dev \"Constructor replacement\" for initializable, must be execute during or immediately after deployment\n\t *      see https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#initializers\n\t *\n\t * @param _owner contract, optional (can be zero address), since there are no admin functions\n\t * @param _sharesContractAddress TradeableShares contract to bind the distributor to,\n\t *      optional (can be zero address), this can be set up later with the\n\t *      `initializeSharesContractAddressIfRequired` function\n\t * @param _paymentToken ERC1363 payment token to bind to, optional (can be zero address),\n\t *      zero address means distributor works with the plain ETH\n\t */\n\tfunction postConstruct(address _owner, address _sharesContractAddress, address _paymentToken) public initializer {\n\t\t// execute parent initializer(s)\n\t\t_postConstruct(_owner);\n\n\t\tsharesContractAddress = _sharesContractAddress;\n\t\tpaymentToken = _paymentToken;\n\t}\n\n\t/**\n\t * @notice Sets the TradeableShares contract to bind the distributor to\n\t *\n\t * @dev TradeableShares contract can be set only once; fails if it is already set\n\t * @param _sharesContractAddress TradeableShares contract to bind the distributor to\n\t */\n\tfunction initializeSharesContractAddressIfRequired(address _sharesContractAddress) public {\n\t\t// check the address is not yet set\n\t\trequire(sharesContractAddress == address(0) && _sharesContractAddress != address(0), \"already initialized\");\n\n\t\t// set the TradeableShares contract address\n\t\tsharesContractAddress = _sharesContractAddress;\n\t}\n\n\t/**\n\t * @inheritdoc HoldersRewardsDistributor\n\t */\n\tfunction getPaymentToken() public view returns (address) {\n\t\treturn paymentToken;\n\t}\n\n\t/**\n\t * @dev Executed when TradeableShares contract notifies about shares bought event\n\t */\n\tfunction __sharesBought(address _buyer, uint256 _amountBought) private {\n\t\tUserInfo storage userDetail = userInfo[_buyer];\n\t\tif(userDetail.shares > 0) {\n\t\t\t// calculated pending reward if any\n\t\t\tuint256 pending = ((userDetail.shares * accRewardPerShare) / 1e18) - userDetail.rewardDebt;\n\t\t\tif(pending > 0) {\n\t\t\t\t// update unclaimed amount\n\t\t\t\tuserDetail.unclaimedAmount += pending;\n\t\t\t}\n\t\t}\n\n\t\t// update state variables\n\t\tuserDetail.shares += _amountBought;\n\t\ttotalShares += _amountBought;\n\t\tuserDetail.rewardDebt = (userDetail.shares * accRewardPerShare) / 1e18;\n\t}\n\n\t/**\n\t * @dev Executed when TradeableShares contract notifies about shares sold event\n\t */\n\tfunction __sharesSold(address _seller, uint256 _amountSold) private {\n\t\trequire(_amountSold <= userInfo[_seller].shares, \"amount must be <= registered amount\");\n\n\t\tUserInfo storage userDetail = userInfo[_seller];\n\t\t// calculated pending reward if any\n\t\tuint256 pending = ((userDetail.shares * accRewardPerShare) / 1e18) - userDetail.rewardDebt;\n\t\tif(pending > 0) {\n\t\t\t// update unclaimed amount\n\t\t\tuserDetail.unclaimedAmount += pending;\n\t\t}\n\n\t\t// update state variables\n\t\tuserDetail.shares = userDetail.shares - _amountSold;\n\t\ttotalShares = totalShares - _amountSold;\n\t\tuserDetail.rewardDebt = (userDetail.shares * accRewardPerShare) / 1e18;\n\t}\n\n\t/**\n\t * @dev Executed when TradeableShares contract send the fees;\n\t * @dev The very first tranche of the fees might be ignored if it is done by the issuer\n\t */\n\tfunction __accept(uint256 _feeAmount) private {\n\t\t// check the state can accept the changes\n\t\tif(_feeAmount == 0 || totalShares == 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t// update state variables\n\t\taccRewardPerShare += (_feeAmount * 1e18) / totalShares;\n\n\t\t// emit an event\n\t\temit FeeReceived(_feeAmount);\n\t}\n\n\n\t/**\n\t * @dev Processes the fee, and the sync message\n\t *\n\t * @dev Takes care about the encoded bytes data containing trader address, trade operation type,\n\t *      and amount of the shares bought\n\t *\n\t * @dev Format: address | bool | uint256\n\t */\n\tfunction __parseTrade(uint256 _feeAmount, bytes memory data) private {\n\t\tif(totalShares == 0) {\n\t\t\t__parseFirstTrade(_feeAmount, data);\n\t\t}\n\t\telse {\n\t\t\t__parseNextTrade(_feeAmount, data);\n\t\t}\n\t}\n\n\t/**\n\t * @dev Processes the very first fee, and the sync message\n\t */\n\tfunction __parseFirstTrade(uint256 _feeAmount, bytes memory data) private {\n\t\t// the very first sync message must not be empty\n\t\trequire(data.length != 0, \"sync message expected\");\n\n\t\t// verify message length\n\t\trequire(data.length == 96, \"malformed sync message\");\n\n\t\t// decode the sync message\n\t\t(address trader, bool isBuy, uint256 sharesAmount) = abi.decode(data, (address, bool, uint256));\n\t\t// the very first operation can be buy only, and cannot be zero\n\t\trequire(isBuy && sharesAmount >= 1, \"invalid state\");\n\n\t\t// init: notify about the first share\n\t\t__sharesBought(trader, 1);\n\t\t// to save the gas execute the rest of the functions only if there is a need\n\t\tif(sharesAmount > 1) {\n\t\t\t// process the fee\n\t\t\t__accept(_feeAmount);\n\t\t\t// notify about the remaining shares\n\t\t\t__sharesBought(trader, sharesAmount - 1);\n\t\t}\n\n\t\t// emit an event\n\t\temit SharesTraded(trader, true, sharesAmount);\n\t}\n\n\t/**\n\t * @dev Processes not the very first fee, and the sync message\n\t */\n\tfunction __parseNextTrade(uint256 _feeAmount, bytes memory data) private {\n\t\t// process the fee\n\t\t__accept(_feeAmount);\n\n\t\t// if the sync message is empty, we're done\n\t\tif(data.length == 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t// verify message length\n\t\trequire(data.length == 96, \"malformed sync message\");\n\n\t\t// decode the sync message\n\t\t(address trader, bool isBuy, uint256 sharesAmount) = abi.decode(data, (address, bool, uint256));\n\t\tif(isBuy) {\n\t\t\t// notify buy\n\t\t\t__sharesBought(trader, sharesAmount);\n\t\t}\n\t\telse {\n\t\t\t// notify sell\n\t\t\t__sharesSold(trader, sharesAmount);\n\t\t}\n\n\t\t// emit an event\n\t\temit SharesTraded(trader, isBuy, sharesAmount);\n\t}\n\n\t/**\n\t * @inheritdoc HoldersRewardsDistributor\n\t */\n\tfunction claimTheReward() public {\n\t\tuint256 claimableAmount = pendingReward(msg.sender);\n\t\trequire(claimableAmount > 0, \"Nothing to claim\");\n\n\t\tUserInfo storage userDetail = userInfo[msg.sender];\n\t\t// update state variable\n\t\tuserDetail.unclaimedAmount = 0;\n\t\tuserDetail.claimedAmount += claimableAmount;\n\t\tuserDetail.rewardDebt = (userDetail.shares * accRewardPerShare) / 1e18;\n\n\t\t// transfer reward\n\t\tif(paymentToken == address(0)) {\n\t\t\tTransfers.transfer(payable(msg.sender), claimableAmount);\n\t\t}\n\t\telse {\n\t\t\trequire(ERC20(paymentToken).transfer(msg.sender, claimableAmount));\n\t\t}\n\n\t\t// emit an event\n\t\temit RewardClaimed(msg.sender, claimableAmount);\n\t}\n\n\t/**\n\t * @inheritdoc HoldersRewardsDistributor\n\t */\n\tfunction pendingReward(address holder) public view returns (uint256) {\n\t\t// read user details and calculate how much we own\n\t\tUserInfo memory userDetail = userInfo[holder];\n\t\tuint256 pending = userDetail.unclaimedAmount + userDetail.shares * accRewardPerShare / 1e18 - userDetail.rewardDebt;\n\n\t\t// get an idea of how much we have on the balance\n\t\tuint256 available = paymentToken == address(0)? address(this).balance: ERC20(paymentToken).balanceOf(address(this));\n\n\t\t// we allow up to 1 gwei cumulative discrepancy due to rounding errors\n\t\trequire(pending < 1_000_000_000 + available, \"discrepancy error\");\n\n\t\t// return the amount we're actually able to return in `claimTheReward`\n\t\treturn pending > available? available: pending;\n\t}\n\n\t/**\n\t * @inheritdoc ERC1363Receiver\n\t *\n\t * @notice Anyone can send some additional rewards – just use empty `data` for a callback\n\t *\n\t * @dev Non-empty `data` executes trade updates and therefore is restricted to be sent only\n\t *      by `sharesContractAddress`\n\t */\n\tfunction onTransferReceived(address operator, address, uint256 value, bytes memory data) public returns (bytes4) {\n\t\trequire(msg.sender == paymentToken, \"received event from wrong token\");\n\t\trequire(operator == sharesContractAddress, \"not allowed\");\n\n\t\t__parseTrade(value, data);\n\t\treturn ERC1363Receiver(this).onTransferReceived.selector;\n\t}\n\n\t/**\n\t * @notice Receive is public. Anyone can send some additional rewards ;)\n\t */\n\treceive() external payable {\n\t\trequire(paymentToken == address(0), \"not allowed\");\n\t\t__parseTrade(msg.value, bytes(\"\"));\n\t}\n\n\t/**\n\t * @dev Fallback executes trade updates and therefore is restricted to be executed only by `sharesContractAddress`\n\t *\n\t * @notice If you want do donate some rewards - use `receive()`\n\t */\n\tfallback() external payable {\n\t\trequire(paymentToken == address(0), \"not an ETH reward distributor\");\n\n\t\trequire(msg.sender == sharesContractAddress, \"not allowed\");\n\t\t__parseTrade(msg.value, msg.data);\n\t}\n}\n"
    },
    "contracts/bonding_curves/ProtocolFeeDistributorV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ERC20Spec.sol\";\nimport \"../utils/UpgradeableAccessControl.sol\";\nimport \"../utils/Transfers.sol\";\n\n/**\n * @title Protocol Fee Distributor V1\n *\n * @notice Accepts protocol fees from the bonding curve contracts and distributes them\n *      later to the list of recipients via the admin-push mechanism\n *\n * @notice The factory manages protocol fees of the deployed TradeableShares contract:\n *      deployed contracts usually follow the protocol fees set on the factory\n */\ncontract ProtocolFeeDistributorV1 is UpgradeableAccessControl {\n\t// recipient details\n\tstruct RecipientDetails {\n\t\taddress payable recipient;\n\t\tuint32 allocationPercent;\n\t}\n\n\t// list of recipients\n\tRecipientDetails[] private recipients;\n\n\t// ERC20 payment token address\n\tERC20 private /*immutable*/ paymentToken;\n\n\t// max number of recipients allowed\n\tuint8 public MAX_RECIPIENTS_ALLOWED;\n\n\t/**\n\t * @notice Recipient list manager having role can add/update recipient details\n\t *\n\t * @dev Role ROLE_RECIPIENT_LIST_MANAGER manager to add/update recipient details\n\t */\n\tuint32 public constant ROLE_RECIPIENT_LIST_MANAGER = 0x0001_0000;\n\n\t/**\n\t * @notice Distribution manager having role can distributor protocol fees\n\t *      to registered recipients\n\t *\n\t * @dev Role ROLE_DISTRIBUTION_MANAGER manager to distribute ETH/ERC20 to recipients\n\t */\n\tuint32 public constant ROLE_DISTRIBUTION_MANAGER = 0x0002_0000;\n\n\t/**\n\t * @dev Fired in receive()\n\t *\n\t * @param from address of user/contract who has sent Ether\n\t * @param amount amount of ETH received\n\t */\n\tevent ETHReceived(address indexed from, uint256 amount);\n\n\t/**\n\t * @dev Fired in distributeETH()\n\t *\n\t * @param recipient recipient address\n\t * @param amount amount of ETH transferred\n\t */\n\tevent ETHSent(address indexed recipient, uint256 amount);\n\n\t/**\n\t * @dev Fired in distributeERC20()\n\t *\n\t * @param paymentToken ERC20 payment token address\n\t * @param recipient recipient address\n\t * @param amount amount of ERC20 payment token transferred\n\t */\n\tevent ERC20Sent(address indexed paymentToken, address indexed recipient, uint256 amount);\n\n\t/**\n\t * @dev Fired in updateRecipientsList()\n\t *\n\t * @param recipient recipient address\n\t * @param allocation allocated in percentage with 4 decimal precision\n\t */\n\tevent RecipientsListUpdated(address indexed recipient, uint32 allocation);\n\n\t/**\n\t * @dev \"Constructor replacement\" for a smart contract with a delayed initialization (post-deployment initialization)\n\t *\n\t * @param _paymentToken ERC20 payment token address\n\t */\n\tfunction postConstruct(address _paymentToken) public virtual initializer {\n\t\t// execute parent initializer\n\t\t_postConstruct(msg.sender);\n\n\t\trequire(_paymentToken != address(0), \"zero address\");\n\n\t\tpaymentToken = ERC20(_paymentToken);\n\t\tMAX_RECIPIENTS_ALLOWED = 5; // max 5 recipients admin can add\n\t}\n\n\t/**\n\t * @notice ERC20 payment token distributor is bound to\n\t *\n\t * @return ERC20 payment token\n\t */\n\tfunction getPaymentToken() public view returns(ERC20) {\n\t\treturn paymentToken;\n\t}\n\n\t// Function to receive Ether. msg.data must be empty\n\treceive() external payable virtual{\n\t\t// emit an event\n\t\temit ETHReceived(msg.sender, msg.value);\n\t}\n\n\t/**\n\t * @notice distribute Ether to all added recipients\n\t *\n\t * @dev distributes Ether to the recipients based on allocation of each recipient.\n\t *\n\t * @dev Restricted access function which can only accessable to address having\n\t *      ROLE_DISTRIBUTION_MANAGER role.\n\t */\n\tfunction distributeETH() public payable {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_DISTRIBUTION_MANAGER), \"access denied\");\n\t\t// verify whether contract has having enough balance to distribute\n\t\trequire(address(this).balance > 0, \"nothing to distribute\");\n\t\t// verify the recipients list is not empty\n\t\trequire(recipients.length > 0, \"recipients list is empty\");\n\n\t\tuint256 amount = address(this).balance;\n\t\tuint256 allocatedAmount;\n\t\tfor(uint8 i = 0; i < recipients.length; i++) {\n\t\t\tallocatedAmount = amount * recipients[i].allocationPercent / 1e6;\n\n\t\t\tif(allocatedAmount > 0) {\n\t\t\t\t// transfer the ETH to the recipient\n\t\t\t\tTransfers.transfer(recipients[i].recipient, allocatedAmount);\n\t\t\t\t// emit an event\n\t\t\t\temit ETHSent(recipients[i].recipient, allocatedAmount);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @notice distribute ERC20 token to all added recipients\n\t *\n\t * @dev distributes ERC20 token to the recipients based on allocation of each recipient.\n\t *\n\t * @dev Restricted access function which can only accessible to address having\n\t *      ROLE_DISTRIBUTION_MANAGER role\n\t */\n\tfunction distributeERC20() public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_DISTRIBUTION_MANAGER), \"access denied\");\n\t\t// verify whether contract has having enough value to distribute\n\t\trequire(paymentToken.balanceOf(address(this)) > 0, \"nothing to distribute\");\n\t\t// verify recipients list is not empty\n\t\trequire(recipients.length > 0, \"recipients list is empty\");\n\n\t\tuint256 amount = paymentToken.balanceOf(address(this));\n\t\tuint256 allocatedAmount;\n\t\tfor(uint8 i = 0; i < recipients.length; i++) {\n\t\t\tallocatedAmount = amount * recipients[i].allocationPercent / 1e6;\n\n\t\t\tif(allocatedAmount > 0) {\n\t\t\t\trequire(paymentToken.transfer(recipients[i].recipient, allocatedAmount));\n\t\t\t\t// emit an event\n\t\t\t\temit ERC20Sent(address(paymentToken), recipients[i].recipient, allocatedAmount);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @notice Add recipient address and allocation for each recipient\n\t *\n\t * @dev Restricted access function which can only accessible to address having\n\t *      ROLE_RECIPIENT_LIST_MANAGER role.\n\t *\n\t * @dev total recipient allocation of all recipients in the list must be 100%,\n\t *      else transaction will be reverted\n\t *\n\t * @param _recipients array of the recipients containing addresses and allocations\n\t */\n\tfunction updateRecipientsList(RecipientDetails[] calldata _recipients) public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_RECIPIENT_LIST_MANAGER), \"access denied\");\n\t\t// input validations\n\t\trequire(_recipients.length > 0, \"recipients list is empty\");\n\t\trequire(_recipients.length <= MAX_RECIPIENTS_ALLOWED, \"recipients list is too big\");\n\n\t\t// delete old recipients list\n\t\tdelete recipients;\n\n\t\tuint256 totalAllocation;\n\t\tfor(uint8 i = 0; i < _recipients.length; i++){\n\t\t\trequire(_recipients[i].recipient != address(0), \"zero recipient\");\n\n\t\t\ttotalAllocation += _recipients[i].allocationPercent;\n\t\t\trecipients.push(_recipients[i]);\n\n\t\t\t// emit an event\n\t\t\temit RecipientsListUpdated(_recipients[i].recipient, _recipients[i].allocationPercent);\n\t\t}\n\n\t\trequire(totalAllocation == 1e6, \"totalAllocation must be 100%\");\n\t}\n\n\t/**\n\t * @notice Number of recipients added to the contract\n\t *      `getRecipient(i)` can be used to iterate the list, 0 <= i < getRecipientsLength()\n\t *\n\t * @return total number of recipients\n\t */\n\tfunction getRecipientsLength() public view returns(uint8) {\n\t\treturn uint8(recipients.length);\n\t}\n\n\t/**\n\t * @notice Reads an element from the list of recipients\n\t *\n\t * @param i zero-based index of the recipient\n\t * @return recipient as RecipientDetails\n\t */\n\tfunction getRecipient(uint256 i) public view returns(RecipientDetails memory) {\n\t\treturn recipients[i];\n\t}\n\n\t/**\n\t * @notice Returns the entire recipients list\n\t *\n\t * @return RecipientDetails[] recipients list array\n\t */\n\tfunction getRecipients() public view returns(RecipientDetails[] memory) {\n\t\treturn recipients;\n\t}\n}\n"
    },
    "contracts/bonding_curves/RewardSystem.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ERC20Spec.sol\";\nimport \"../utils/UpgradeableAccessControl.sol\";\nimport \"../utils/Transfers.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\n\n/**\n * @title Leaderboard Reward System\n *\n * @notice leaderboard reward system designated to release reward for all leaderboard winner\n *\n * @notice reward system uses merkle root to maintain list of winners and reward amounts,\n *      once new winner list is announced, merkle root will be update which include\n *      new winner list and past winners and tier respective won reward amount.\n *\n * @notice leaderboard reward system is proxy upgradeable.\n *\n */\ncontract RewardSystem is UpgradeableAccessControl {\n\t// Use Zeppelin MerkleProof Library to verify Merkle proofs\n\tusing MerkleProof for bytes32[];\n\n\t// Input data root, Merkle tree root for an array of (address, totalReward) pairs,\n\t// Merkle root effectively \"compresses\" the (potentially) huge array of data elements\n\t// and allows to store it in a single 256-bits storage slot on-chain\n\tbytes32 public root;\n\n\t// userAddress => total claimed reward\n\tmapping(address => uint256) public claimedReward;\n\n\t// ERC20 reward token address\n\t// reward system type:\n\t// zero address means contract supports ETH reward\n\t// non-zero address means contract supports ERC20 reward\n\tERC20 public erc20RewardToken;\n\n\t// cumulative reward claimed\n\tuint256 public totalClaimedReward;\n\n\t/**\n\t * @notice Data Root manager is responsible for supplying the valid input data array\n\t *      Merkle root which then can be used to check total reward won by user.\n\t *\n\t * @dev Role ROLE_DATA_ROOT_MANAGER allows setting the Merkle tree root via setInputDataRoot()\n\t */\n\tuint32 public constant ROLE_DATA_ROOT_MANAGER = 0x0001_0000;\n\n\t/**\n\t * @notice Enables the airdrop, redeeming the tokens\n\t *\n\t * @dev Feature FEATURE_CLAIM_ACTIVE must be enabled in order to\n\t *      allow user to claim pending reward\n\t */\n\tuint32 public constant FEATURE_CLAIM_ACTIVE = 0x0000_0001;\n\n\t/**\n\t * @dev Fired in setInputDataRoot()\n\t *\n\t * @param by an address which executed the operation\n\t * @param root new Merkle root value\n\t */\n\tevent RootChanged(address indexed by, bytes32 root);\n\n\t/**\n\t * @dev Fired in claimEthReward()\n\t *\n\t * @param user user address\n\t * @param amount amount of reward transferred\n\t */\n\tevent EthRewardClaimed(address indexed user, uint256 amount);\n\n\t/**\n\t * @dev Fired in claimErc20Reward()\n\t *\n\t * @param rewardToken erc20 reward token address\n\t * @param user user address\n\t * @param amount amount of reward transferred\n\t */\n\tevent ERC20RewardClaimed(address indexed rewardToken, address indexed user, uint256 amount);\n\n\t/**\n\t * @dev Fired in the default receive()\n\t *\n\t * @param value amount received \n\t */\n\tevent PaymentReceived(uint256 value);\n\n\t/**\n\t * @dev \"Constructor replacement\" for a smart contract with a delayed initialization (post-deployment initialization)\n\t *\n\t * @param _erc20RewardToken ERC20 reward token address\n\t *      zero address means contract supports ETH reward\n\t *      non-zero address means contract supports ERC20 reward\n\t */\n\tfunction postConstruct(address _erc20RewardToken) public virtual initializer {\n\t\t// execute parent initializer\n\t\t_postConstruct(msg.sender);\n\n\t\t// zero address is OK meaning we use ETH reward mode\n\t\terc20RewardToken = ERC20(_erc20RewardToken);\n\t}\n\n\t// Function to receive Ether. msg.data must be empty\n\treceive() external payable {\n\t\trequire(rewardSystemType(), \"ETH payments not supported\");\n\t\temit PaymentReceived(msg.value);\n\t}\n\n\t/**\n\t * @notice total amount of token `_totalReward` to an address `_to`, verifying the validity\n\t *      of a `(_to, _totalReward)` pair via the Merkle proof `_proof`\n\t *\n\t * @dev Merkle tree and proof can be constructed using the `web3-utils`, `merkletreejs`,\n\t *      and `keccak256` npm packages:\n\t *      1. Hash the original array data elements (_to, _totalReward) via `web3.utils.soliditySha3`,\n\t *         making sure the packing order.\n\t *      2. Create a sorted MerkleTree (`merkletreejs`) from the hashed array, use `keccak256`\n\t *         from the `keccak256` npm package as a hashing function, do not hash leaves\n\t *         (already hashed in step 1); Ex. MerkleTree options: {hashLeaves: false, sortPairs: true}\n\t *      3. For any given data element (_to, _totalReward) the proof is constructed by hashing it\n\t *         (as in step 1) and querying the MerkleTree for a proof, providing the hashed element\n\t *         as a leaf\n\t *\n\t * @dev Throws is the data or merkle proof supplied is not valid\n\t *\n\t * @param _to an address to whom reward to be sent\n\t * @param _totalReward total reward accumulated by a user across all competitions\n\t * @param _proof Merkle proof for the (_to, _totalReward) pair supplied\n\t */\n\tfunction claimReward(address payable _to, uint256 _totalReward, bytes32[] memory _proof) external {\n\t\t// verify airdrop is in active state\n\t\trequire(isFeatureEnabled(FEATURE_CLAIM_ACTIVE), \"redeems are disabled\");\n\n\t\t// verify the `(_to, _totalReward)` pair is valid\n\t\trequire(isClaimValid(_to, _totalReward, _proof), \"invalid request\");\n\n\t\t// check user has reward to claim\n\t\trequire(claimedReward[_to] < _totalReward, \"nothing to claim\");\n\t\tuint256 claimableAmount = _totalReward - claimedReward[_to];\n\n\t\t// update reward details\n\t\tclaimedReward[_to] += claimableAmount;\n\t\ttotalClaimedReward += claimableAmount;\n\n\t\tif (rewardSystemType()) {\n\t\t\t// transfer ether to user\n\t\t\tTransfers.transfer(_to, claimableAmount);\n\n\t\t\t// emit an event\n\t\t\temit EthRewardClaimed(_to, claimableAmount);\n\t\t}\n\t\telse {\n\t\t\t// transfer erc20 reward token to user\n\t\t\terc20RewardToken.transfer(_to, claimableAmount);\n\n\t\t\t// emit an event\n\t\t\temit ERC20RewardClaimed(address(erc20RewardToken), _to, claimableAmount);\n\t\t}\n\t}\n\n\t/**\n\t * @notice Restricted access function to update input data root (Merkle tree root),\n\t *      and to define, effectively, the tokens to be created by this smart contract\n\t *\n\t * @dev Requires executor to have `ROLE_DATA_MANAGER` permission\n\t *\n\t * @param _root Merkle tree root for the input data array\n\t */\n\tfunction setInputDataRoot(bytes32 _root) public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_DATA_ROOT_MANAGER), \"access denied\");\n\n\t\t// update input data Merkle tree root\n\t\troot = _root;\n\n\t\t// emit an event\n\t\temit RootChanged(msg.sender, _root);\n\t}\n\n\t/**\n\t * @notice Verifies the validity of a `(_to, _totalReward)` pair supplied based on the Merkle root\n\t *      of the entire `(_to, _totalReward)` data array (pre-stored in the contract), and the Merkle\n\t *      proof `_proof` for the particular `(_to, _totalReward)` pair supplied\n\t *\n\t * @dev Merkle tree and proof can be constructed using the `web3-utils`, `merkletreejs`,\n\t *      and `keccak256` npm packages:\n\t *      1. Hash the original array data elements (_to, _totalReward) via `web3.utils.soliditySha3`,\n\t *         making sure the packing order.\n\t *      2. Create a sorted MerkleTree (`merkletreejs`) from the hashed array, use `keccak256`\n\t *         from the `keccak256` npm package as a hashing function, do not hash leaves\n\t *         (already hashed in step 1); Ex. MerkleTree options: {hashLeaves: false, sortPairs: true}\n\t *      3. For any given data element (_to, _totalReward) the proof is constructed by hashing it\n\t *         (as in step 1) and querying the MerkleTree for a proof, providing the hashed element\n\t *         as a leaf\n\t *\n\t * @param _to an address to whom reward to be sent\n\t * @param _totalReward total reward accumulated by a user across all competitions\n\t * @param _proof Merkle proof for the (_to, _totalReward) pair supplied\n\t * @return true if Merkle proof is valid (data belongs to the original array), false otherwise\n\t */\n\tfunction isClaimValid(address _to, uint256 _totalReward, bytes32[] memory _proof) public view returns(bool) {\n\t\t// construct Merkle tree leaf from the inputs supplied\n\t\tbytes32 leaf = keccak256(abi.encodePacked(_to, _totalReward));\n\n\t\t// verify the proof supplied, and return the verification result\n\t\treturn _proof.verify(root, leaf);\n\t}\n\n\t/**\n\t * @notice Reward system type\n\t *\n\t * @return true if contract supports ETH reward\n\t *         false if contract supports ERC20 reward\n\t */\n\tfunction rewardSystemType() public view returns(bool) {\n\t\t// derive from the token address\n\t\treturn address(erc20RewardToken) == address(0);\n\t}\n}\n"
    },
    "contracts/bonding_curves/SharesFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./TradeableShares.sol\";\n\n/**\n * @title Shares Factory\n *\n * @notice Creates/deploys TradeableShares contracts\n *\n * @notice The factory manages protocol fees of the deployed TradeableShares contract:\n *      deployed contracts usually follow the protocol fees set on the factory\n *\n * @dev Based on the friend.tech FriendtechSharesV1.sol\n */\ninterface SharesFactory {\n\t/**\n\t * @dev Enum of all possible TradeableShares implementations the factory can deploy\n\t */\n\tenum ImplementationType {\n\t\t/// @dev ETHShares implementation\n\t\tETH,\n\t\t/// @dev ERC20Shares implementation bound to the ERC20 payment token\n\t\tERC20\n\t}\n\n\t/**\n\t * @dev Shares deployment request is used to enable the TradeableShares\n\t *      deployment with meta-transactions\n\t * @dev See `executeDeploymentRequest()`\n\t */\n\tstruct SharesDeploymentRequest {\n\t\t/// @dev TradeableShares implementation type\n\t\tImplementationType implementationType;\n\t\t/// @dev shares subject, owner of the curve\n\t\tTradeableShares.SharesSubject sharesSubject;\n\t\t/// @dev an address to mint the NFT defined by the subject if it doesn't exist\n\t\taddress issuer;\n\t\t/// @dev how many shares to buy immediately after the deployment\n\t\tuint256 amount;\n\t\t/// @dev unix timestamp when the request becomes valid\n\t\tuint256 validFromTimestamp;\n\t\t/// @dev unix timestamp when the request expires (becomes invalid)\n\t\tuint256 expiresAtTimestamp;\n\t\t/// @dev nonce of the request (sequential number, increased by one)\n\t\tuint256 nonce;\n\t}\n\n\t/**\n\t * @dev Fired in\n\t *      `setProtocolFeeDestination`\n\t *      `setProtocolFeePercent`\n\t *      `setHoldersFeePercent`\n\t *      `setSubjectFeePercent`\n\t *      `setProtocolFee`\n\t *\n\t * @param protocolFeeDestination address where the protocol fee is sent\n\t * @param protocolFeePercent protocol fee percent, value 10^18 corresponds to 100%\n\t * @param holdersFeePercent shares holders fee percent, value 10^18 corresponds to 100%\n\t * @param subjectFeePercent subject fee percent, value 10^18 corresponds to 100%\n\t */\n\tevent ProtocolFeeUpdated(\n\t\taddress protocolFeeDestination,\n\t\tuint64 protocolFeePercent,\n\t\tuint64 holdersFeePercent,\n\t\tuint64 subjectFeePercent\n\t);\n\n\t/**\n\t * @dev Fired in `deploySharesContract` and `registerSharesContract`\n\t *\n\t * @param creator shares creator, a.k.a. shares issuer, or current owner\n\t * @param implementationContract newly deployed or registered TradeableShares contract\n\t * @param holdersRewardsDistributor the shares holders fee destination, HoldersRewardsDistributor contract,\n\t *      this can be zero if shares contract is deployed without the shares holders fee distribution\n\t * @param implementationType type of the TradeableShares, see ImplementationType\n\t * @param sharesSubject current shares subject\n\t * @param newDeployment true if the factory deployed this TradeableShares contract,\n\t *      false if TradeableShares contract was already deployed and factory just registered it\n\t */\n\tevent SharesContractRegistered(\n\t\taddress indexed creator,\n\t\tTradeableShares indexed implementationContract,\n\t\tHoldersRewardsDistributor indexed holdersRewardsDistributor,\n\t\tImplementationType implementationType,\n\t\tTradeableShares.SharesSubject sharesSubject,\n\t\tbool newDeployment\n\t);\n\n\t/**\n\t * @dev Fired in `executeDeploymentRequest` and in `rewind`\n\t */\n\tevent NonceUsed(address indexed issuer, uint256 nonce);\n\n\t/**\n\t * @notice Address of the already deployed TradeableShares implementation\n\t *      to be used by the factory to deploy the TradeableShares contracts EIP-1167 clones\n\t *\n\t * @param _implementationType TradeableShares implementation type\n\t * @return the address of the already deployed TradeableShares implementation corresponding\n\t *      to the given implementation type\n\t */\n\tfunction getSharesImplAddress(ImplementationType _implementationType) external view returns(address);\n\n\t/**\n\t * @notice Address of the already deployed HoldersRewardsDistributor implementation\n\t *      to be used by the factory to deploy the HoldersRewardsDistributor contracts EIP-1167 clones\n\t *\n\t * @dev If the HoldersRewardsDistributor implementation is missing, the TradeableShares contract\n\t *      can still be deployed, not being attached to the HoldersRewardsDistributor\n\t *\n\t * @param _implementationType TradeableShares implementation type\n\t * @return the address of the already deployed HoldersRewardsDistributor implementation corresponding\n\t *      to the given implementation type\n\t */\n\tfunction getDistributorImplAddress(ImplementationType _implementationType) external view returns(address);\n\n\t/**\n\t * @notice Protocol fee destination is the address receiving the protocol fee\n\t *\n\t * @return feeDestination protocol fee destination, address\n\t */\n\tfunction getProtocolFeeDestination() external view returns(address feeDestination);\n\n\t/**\n\t * @notice Protocol fee percent is the percentage of the buy/sell transaction volume\n\t *      sent to the protocol fee destination\n\t *\n\t * @dev The value has 18 decimals, 100% is represented as 10^18\n\t *\n\t * @return feePercent protocol fee percent\n\t */\n\tfunction getProtocolFeePercent() external view returns(uint256 feePercent);\n\n\t/**\n\t * @notice Shares holders fee percent is the percentage of the buy/sell transaction volume\n\t *      sent to the shares holders rewards distributor contract\n\t *\n\t * @dev The value has 18 decimals, 100% is represented as 10^18\n\t *\n\t * @return feePercent shares holders fee percent\n\t */\n\tfunction getHoldersFeePercent() external view returns(uint256 feePercent);\n\n\t/**\n\t * @notice Subject fee percent is the percentage of the buy/sell transaction volume\n\t *      sent to the subject issuer\n\t *\n\t * @dev The value has 18 decimals, 100% is represented as 10^18\n\t *\n\t * @dev Implementation may return different values for different callers,\n\t *      for example it can read SharesSubject from the caller TradeableShares contract\n\t *      and dynamically determine the subject fee\n\t *\n\t * @return feePercent subject fee percent\n\t */\n\tfunction getSubjectFeePercent() external view returns(uint256 feePercent);\n\n\t/**\n\t * @notice Sets the protocol fee destination\n\t *\n\t * @dev Implementation must check the consistency of the protocol fee destination and percent\n\t *      set by this and `setProtocolFeePercent` functions\n\t *\n\t * @param feeDestination protocol fee destination to set\n\t */\n\tfunction setProtocolFeeDestination(address feeDestination) external;\n\n\t/**\n\t * @notice Sets the protocol fee percent\n\t *\n\t * @dev Implementation must check the consistency of the protocol fee destination and percent\n\t *      set by this and `setProtocolFeeDestination` functions\n\t *\n\t * @param feePercent protocol fee percent to set, examples: 10^18 is 100%, 10^17 is 10%\n\t */\n\tfunction setProtocolFeePercent(uint64 feePercent) external;\n\n\t/**\n\t * @notice Sets the shares holders fee percent\n\t *\n\t * @param feePercent shares holders fee percent to set, examples: 10^18 is 100%, 10^17 is 10%\n\t */\n\tfunction setHoldersFeePercent(uint64 feePercent) external;\n\n\t/**\n\t * @notice Sets the subject fee percent\n\t *\n\t * @param feePercent subject fee percent to set, examples: 10^18 is 100%, 10^17 is 10%\n\t */\n\tfunction setSubjectFeePercent(uint64 feePercent) external;\n\n\t/**\n\t * @notice Sets all the fees at once:\n\t *      protocolFeeDestination\n\t *      protocolFeePercent\n\t *      holdersFeePercent\n\t *      subjectFeePercent\n\t *\n\t * @param protocolFeeDestination protocol fee destination to set\n\t * @param protocolFeePercent protocol fee percent to set, examples: 10^18 is 100%, 10^17 is 10%\n\t * @param holdersFeePercent shares holders fee percent to set, examples: 10^18 is 100%, 10^17 is 10%\n\t * @param subjectFeePercent subject fee percent to set, examples: 10^18 is 100%, 10^17 is 10%\n\t */\n\tfunction setProtocolFee(\n\t\taddress protocolFeeDestination,\n\t\tuint64 protocolFeePercent,\n\t\tuint64 holdersFeePercent,\n\t\tuint64 subjectFeePercent\n\t) external;\n\n\t/**\n\t * @notice Deploys the TradeableShares implementation for the specified subject;\n\t *      the curve remains paused, no shares are being bought immediately\n\t *\n\t * @notice Tries minting the NFT defined by the subject if it doesn't exist\n\t *\n\t * @dev Implementation must guarantee only one TradeableShares contract per subject\n\t *\n\t * @param implementationType TradeableShares implementation type\n\t * @param sharesSubject shares subject, owner of the curve\n\t * @return deployed TradeableShares contract\n\t */\n\tfunction deploySharesContractPaused(\n\t\tImplementationType implementationType,\n\t\tTradeableShares.SharesSubject calldata sharesSubject\n\t) external returns(TradeableShares);\n\n\t/**\n\t * @notice Deploys the TradeableShares implementation for the specified subject;\n\t *      the curve launches immediately, the first share is issued to the subject issuer (NFT owner)\n\t *\n\t * @notice Tries minting the NFT defined by the subject if it doesn't exist\n\t *\n\t * @dev Implementation must guarantee only one TradeableShares contract per subject\n\t *\n\t * @param implementationType TradeableShares implementation type\n\t * @param sharesSubject shares subject, owner of the curve\n\t * @return deployed TradeableShares contract\n\t */\n\tfunction deploySharesContract(\n\t\tImplementationType implementationType,\n\t\tTradeableShares.SharesSubject calldata sharesSubject\n\t) external returns(TradeableShares);\n\n\t/**\n\t * @notice Deploys the TradeableShares implementation for the specified subject;\n\t *      allows to immediately buy any amount of shares (including zero)\n\t *\n\t * @notice Tries minting the NFT defined by the subject if it doesn't exist\n\t *\n\t * @dev Implementation must guarantee only one TradeableShares contract per subject\n\t *\n\t * @param implementationType TradeableShares implementation type\n\t * @param sharesSubject shares subject, owner of the curve\n\t * @param amount how many shares to buy immediately after the deployment\n\t * @return deployed TradeableShares contract\n\t */\n\tfunction deploySharesContractAndBuy(\n\t\tImplementationType implementationType,\n\t\tTradeableShares.SharesSubject calldata sharesSubject,\n\t\tuint256 amount\n\t) external payable returns(TradeableShares);\n\n\t/**\n\t * @notice Deploys the TradeableShares implementation for the specified subject;\n\t *      allows to immediately buy any amount of shares (including zero)\n\t *\n\t * @notice Tries minting the NFT defined by the subject if it doesn't exist\n\t *\n\t * @dev Implementation must guarantee only one TradeableShares contract per subject\n\t *\n\t * @param implementationType TradeableShares implementation type\n\t * @param sharesSubject shares subject, owner of the curve\n\t * @param issuer an address to mint the NFT defined by the subject if it doesn't exist\n\t * @param amount how many shares to buy immediately after the deployment\n\t * @return deployed TradeableShares contract\n\t */\n\tfunction mintSubjectAndDeployShares(\n\t\tImplementationType implementationType,\n\t\tTradeableShares.SharesSubject calldata sharesSubject,\n\t\taddress issuer,\n\t\tuint256 amount\n\t) external payable returns(TradeableShares);\n\n\t/**\n\t * @notice Executes signed SharesDeploymentRequest; this is identical to executing `mintSubjectAndDeployShares`\n\t *      on behalf of the signer and allows the transaction to be relayed so that the gas is payed by the\n\t *      relayer\n\t *\n\t * @param req the deployment request to fulfill, containing same data as in `mintSubjectAndDeployShares`\n\t * @param signature the deployment request EIP712 signature issued by the address allowed to execute\n\t *      the request\n\t * @return deployed TradeableShares contract\n\t */\n\tfunction executeDeploymentRequest(\n\t\tSharesDeploymentRequest calldata req,\n\t\tbytes calldata signature\n\t) external payable returns(TradeableShares);\n\n\t/**\n\t * @notice Gets current (unused) nonce for the given issuer address;\n\t *      unused nonce is required to build the SharesDeploymentRequest and sign it\n\t *      nonces increment by one after each use\n\t *\n\t * @param issuer the issuer address to get the nonce for\n\t * @return current (unused) nonce; incremented by one after\n\t *      each successful execution of the `executeDeploymentRequest` function\n\t */\n\tfunction getNonce(address issuer) external view returns(uint256);\n\n\t/**\n\t * @notice Rewinds forward the nonce for the issuer specified, used to\n\t *      discard one or more signed requests to `executeDeploymentRequest`\n\t *\n\t * @dev Implementation must not allow to decrease the nonce, only increasing (rewinding)\n\t *      must be possible\n\t *\n\t * @param issuer the issuer address to rewind the nonce for\n\t * @param nonce the nonce value to rewind to\n\t */\n\tfunction rewindNonce(address issuer, uint256 nonce) external;\n\n\t/**\n\t * @notice Gets the already deployed TradeableShares contract\n\t *\n\t * @param sharesSubject shares subject, owner of the curve\n\t * @return deployed TradeableShares contract\n\t */\n\tfunction lookupSharesContract(\n\t\tTradeableShares.SharesSubject calldata sharesSubject\n\t) external view returns(TradeableShares);\n\n\t/**\n\t * @notice Registers or re-registers the already deployed TradeableShares contract\n\t *\n\t * @dev Initial registration is usually done manually by authorized address,\n\t *      Re-registration is usually done by the shares contract itself\n\t *      and implementations must keep the access to this function open for\n\t *      the already registered contracts\n\t *\n\t * @param shares already deployed TradeableShares contract\n\t */\n\tfunction registerSharesContract(TradeableShares shares) external;\n\n\t/**\n\t * @notice Executed only by the previously registered TradeableShares contracts\n\t *      to notify the factory about the subject change.\n\t *\n\t * @dev The factory may throw if the subject is already taken by another contract\n\t */\n\tfunction notifySubjectUpdated() external;\n}\n\n"
    },
    "contracts/bonding_curves/SharesFactoryV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ERC721SpecExt.sol\";\nimport \"../utils/UpgradeableAccessControl.sol\";\nimport \"./TypedStructLib.sol\";\nimport \"./SharesFactory.sol\";\nimport \"./ETHShares.sol\";\nimport \"./ERC20Shares.sol\";\nimport \"./HoldersRewardsDistributorV1.sol\";\n\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/cryptography/draft-EIP712Upgradeable.sol\";\n\n/**\n * @title Shares Factory V1\n *\n * @notice Role-based access control (RBAC) based implementation of the SharesFactory\n *\n * @dev Based on the friend.tech FriendtechSharesV1.sol\n */\ncontract SharesFactoryV1 is SharesFactory, UpgradeableAccessControl, EIP712Upgradeable {\n\t// libraries in use\n\tusing ECDSAUpgradeable for bytes32;\n\tusing SharesSubjectLib for TradeableShares.SharesSubject;\n\tusing TypedStructLib for SharesDeploymentRequest;\n\n\t/**\n\t * @dev ERC20 payment token address, effectively immutable (cannot be updated)\n\t */\n\tERC1363 private /* immutable */ paymentToken;\n\n\t/**\n\t * @dev Protocol fee destination is the address receiving the protocol fee\n\t */\n\taddress private protocolFeeDestination;\n\n\t/**\n\t * @dev Protocol fee percent with 18 decimals (10^18 = 100%)\n\t */\n\tuint64 private protocolFeePercent;\n\n\t/**\n\t * @dev Shares holders fee percent with 18 decimals (10^18 = 100%)\n\t */\n\tuint64 private holdersFeePercent;\n\n\t/**\n\t * @dev Subject fee percent with 18 decimals (10^18 = 100%)\n\t */\n\tuint64 private subjectFeePercent;\n\n\t/**\n\t * @dev An address receiving the ownership of the deployed TradeableShares contracts\n\t *\n\t * @dev This should be the MultiSig address, not to EOA and not the\n\t *      RBAC managed smart contract, so that this address cannot act in a scalable way;\n\t *      this reduces the risk of misuse, and/or malicious use\n\t */\n\taddress private sharesOwnerAddress;\n\n\t/**\n\t * @dev Deployed shares contracts mapping, keeps track of the deployed contracts subjects\n\t *      Maps SharesSubject => TradeableShares\n\t */\n\tmapping(bytes32 => TradeableShares) private shares;\n\n\t/**\n\t * @dev Reverse deployed shares contracts mapping, keeps track of the deployed contracts\n\t *      Maps TradeableShares address => SharesSubject\n\t */\n\tmapping(address => TradeableShares.SharesSubject) private subjects;\n\n\t/**\n\t * @dev TradeableShares implementations mapping storing deployed TradeableShares\n\t *      address for every supported implementation type, used by the factory to\n\t *      deploy the TradeableShares contracts EIP-1167 clones\n\t *\n\t * @dev Maps TradeableShares ImplementationType => TradeableShares deployed implementation address\n\t */\n\tmapping(ImplementationType => address) private sharesImplementations;\n\n\t/**\n\t * @dev HoldersRewardsDistributor implementations mapping storing deployed HoldersRewardsDistributor\n\t *      address for every supported implementation type, used by the factory to\n\t *      deploy the HoldersRewardsDistributor contracts EIP-1167 clones\n\t *\n\t * @dev If available, HoldersRewardsDistributor implementation is attached to the shares contract\n\t *      during the deployment, allowing it to send shares holders fees to the distributor\n\t *\n\t * @dev Maps TradeableShares ImplementationType => HoldersRewardsDistributor deployed implementation address\n\t */\n\tmapping(ImplementationType => address) private distributorsImplementations;\n\n\t/**\n\t * @dev Keeps track of the used nonces for every possible issuer\n\t *      Maps address => number of used nonces\n\t */\n\tmapping(address => uint256) private nonces;\n\n\t/**\n\t * @notice Enables [TradeableShares] curve deployment functionality\n\t * @dev Feature FEATURE_SHARES_DEPLOYMENT_ENABLED enables `deploySharesContractPaused`,\n\t *      `deploySharesContract`, and `deploySharesContractAndBuy` functions\n\t */\n\tuint32 public constant FEATURE_SHARES_DEPLOYMENT_ENABLED = 0x0000_0001;\n\n\t/**\n\t * @notice Allows the [TradeableShares] curve deployer not to buy any shares on deployment;\n\t *      if disabled the deployer always gets at least one share,\n\t *      effectively launching the curve and allowing anyone to buy\n\t *\n\t * @dev Feature FEATURE_ALLOW_PAUSED_DEPLOYMENTS enables `deploySharesContractPaused` function\n\t */\n\tuint32 public constant FEATURE_ALLOW_PAUSED_DEPLOYMENTS = 0x0000_0002;\n\n\t/**\n\t * @notice Allows the [TradeableShares] curve deployer to exclusively buy\n\t *      any amount of the initial shares; if disabled the deployer always gets\n\t *      no more than only one share\n\t *\n\t * @dev Feature FEATURE_ALLOW_EXCLUSIVE_BUY enables `deploySharesContractAndBuy` function\n\t */\n\tuint32 public constant FEATURE_ALLOW_EXCLUSIVE_BUY = 0x0000_0004;\n\n\t/**\n\t * @notice Protocol fee manager sets protocol fee destination address (protocolFeeDestination)\n\t *      and protocol fee percent (protocolFeePercent)\n\t *\n\t * @dev Role ROLE_PROTOCOL_FEE_MANAGER is required to execute\n\t *      `setProtocolFeeDestination` and `setProtocolFeePercent` functions\n\t */\n\tuint32 public constant ROLE_PROTOCOL_FEE_MANAGER = 0x0001_0000;\n\n\t/**\n\t * @notice Shares holders fee manager sets shares holders fee percent (holdersFeePercent)\n\t *\n\t * @dev Role ROLE_HOLDERS_FEE_MANAGER is required to execute `setHoldersFeePercent` function\n\t */\n\tuint32 public constant ROLE_HOLDERS_FEE_MANAGER = 0x0002_0000;\n\n\t/**\n\t * @notice Subject fee manager sets subject fee percent (subjectFeePercent)\n\t *\n\t * @dev Role ROLE_SUBJECT_FEE_MANAGER is required to execute `setSubjectFeePercent` function\n\t */\n\tuint32 public constant ROLE_SUBJECT_FEE_MANAGER = 0x0004_0000;\n\n\t/**\n\t * @notice Shares registrar deploys new and registers already deployed TradeableShares instances\n\t *\n\t * @dev Role ROLE_SHARES_REGISTRAR is required to execute `deploySharesContract`\n\t *      and `registerSharesContract` functions\n\t */\n\tuint32 public constant ROLE_SHARES_REGISTRAR = 0x0008_0000;\n\n\t/**\n\t * @notice Factory deployment manager\n\t *      - registers already deployed TradeableShares implementations to be used by the factory\n\t *        to deploy the TradeableShares contracts EIP-1167 clones\n\t *      - sets/unsets/updates the shares owner address `sharesOwnerAddress`\n\t *\n\t * @dev Role ROLE_SHARES_IMPLEMENTATION_REGISTRAR is required to execute functions:\n\t *      - `setImplementationAddress`\n\t *      - `setSharesOwnerAddress`\n\t */\n\tuint32 public constant ROLE_FACTORY_DEPLOYMENT_MANAGER = 0x0010_0000;\n\n\t/**\n\t * @dev Fired in setSharesOwnerAddress\n\t *\n\t * @param sharesOwnerAddress new shares owner address, or zero\n\t */\n\tevent SharesOwnerAddressUpdated(address indexed sharesOwnerAddress);\n\n\t/**\n\t * @dev Fired in `setSharesImplAddress`\n\t *\n\t * @param implementationType TradeableShares implementation type\n\t * @param implementationAddress the address of the already deployed TradeableShares implementation\n\t *      corresponding to the given implementation type, or zero address\n\t */\n\tevent SharesImplAddressUpdated(ImplementationType implementationType, address implementationAddress);\n\n\t/**\n\t * @dev Fired in `setDistributorImplAddress`\n\t *\n\t * @param implementationType HoldersRewardsDistributor implementation type\n\t * @param implementationAddress the address of the already deployed HoldersRewardsDistributor implementation\n\t *      corresponding to the given implementation type, or zero address\n\t */\n\tevent DistributorImplAddressUpdated(ImplementationType implementationType, address implementationAddress);\n\n\t/**\n\t * @dev \"Constructor replacement\" for upgradeable, must be execute immediately after proxy deployment\n\t *      see https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#initializers\n\t *\n\t * @param _paymentToken ERC20 payment token address to bind to, immutable\n\t */\n\tfunction postConstruct(ERC1363 _paymentToken) public initializer {\n\t\t// execute parent initializer(s)\n\t\t__EIP712_init_unchained(\"SharesFactory\", \"1\");\n\t\t_postConstruct(msg.sender);\n\n\t\t// verify token address is set\n\t\trequire(address(_paymentToken) != address(0), \"zero address\");\n\n\t\t// set up the immutable ERC20 payment token contract\n\t\tpaymentToken = _paymentToken;\n\t}\n\n\t/**\n\t * @notice ERC1363 payment token contract which the factory uses to deploy the `ERC20` curve type\n\t *\n\t * @dev Immutable, client applications may cache this value\n\t *\n\t * @return ERC1363 payment token contract\n\t */\n\tfunction getPaymentToken() public view returns(ERC1363) {\n\t\t// return the (effectively) immutable value from the storage\n\t\treturn paymentToken;\n\t}\n\n\t/**\n\t * @notice An address receiving the ownership of the deployed TradeableShares contracts\n\t *\n\t * @dev This should be the MultiSig address, not to EOA and not the\n\t *      RBAC managed smart contract, so that this address cannot act in a scalable way;\n\t *      this reduces the risk of misuse, and/or malicious use\n\t *\n\t * @return currently active shares owner address, or zero if not set\n\t */\n\tfunction getSharesOwnerAddress() public view returns(address) {\n\t\t// read it from the storage\n\t\treturn sharesOwnerAddress;\n\t}\n\n\t/**\n\t * @notice Sets/unsets/updates the shares owner address `sharesOwnerAddress`, which is\n\t *      an address receiving the ownership of the deployed TradeableShares contracts\n\t *\n\t * @dev This should be the MultiSig address, not to EOA and not the\n\t *      RBAC managed smart contract, so that this address cannot act in a scalable way;\n\t *      this reduces the risk of misuse, and/or malicious use\n\t *\n\t * @dev Once changed/set, the address affects only new TradeableShares deployments\n\t *\n\t * @param _sharesOwnerAddress new shares owner address to set, or zero to unset\n\t */\n\tfunction setSharesOwnerAddress(address _sharesOwnerAddress) public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_FACTORY_DEPLOYMENT_MANAGER), \"access denied\");\n\n\t\t// update the storage (note: this address is allowed to be zero)\n\t\tsharesOwnerAddress = _sharesOwnerAddress;\n\n\t\t// emit an event\n\t\temit SharesOwnerAddressUpdated(_sharesOwnerAddress);\n\t}\n\n\t/**\n\t * @inheritdoc SharesFactory\n\t */\n\tfunction getSharesImplAddress(ImplementationType _implementationType) public view returns(address) {\n\t\t// read the result from storage\n\t\treturn sharesImplementations[_implementationType];\n\t}\n\n\t/**\n\t * @notice Sets the address of the already deployed TradeableShares implementation\n\t *      to be used by the factory to deploy the TradeableShares contracts EIP-1167 clones\n\t *\n\t * @param _implementationType TradeableShares implementation type\n\t * @param _implementationAddress address of the already deployed TradeableShares implementation\n\t *      corresponding to the given implementation type\n\t */\n\tfunction setSharesImplAddress(ImplementationType _implementationType, address _implementationAddress) public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_FACTORY_DEPLOYMENT_MANAGER), \"access denied\");\n\n\t\t// register/update/deregister implementation\n\t\tsharesImplementations[_implementationType] = _implementationAddress;\n\n\t\t// emit an event\n\t\temit SharesImplAddressUpdated(_implementationType, _implementationAddress);\n\t}\n\n\t/**\n\t * @inheritdoc SharesFactory\n\t */\n\tfunction getDistributorImplAddress(ImplementationType _implementationType) public view returns(address) {\n\t\t// read the result from storage\n\t\treturn distributorsImplementations[_implementationType];\n\t}\n\n\t/**\n\t * @notice Sets the address of the already deployed HoldersRewardsDistributor implementation\n\t *      to be used by the factory to deploy the HoldersRewardsDistributor contracts EIP-1167 clones\n\t *\n\t * @param _implementationType HoldersRewardsDistributor implementation type\n\t * @param _implementationAddress address of the already deployed HoldersRewardsDistributor implementation\n\t *      corresponding to the given implementation type\n\t */\n\tfunction setDistributorImplAddress(ImplementationType _implementationType, address _implementationAddress) public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_FACTORY_DEPLOYMENT_MANAGER), \"access denied\");\n\n\t\t// register/update/deregister implementation\n\t\tdistributorsImplementations[_implementationType] = _implementationAddress;\n\n\t\t// emit an event\n\t\temit DistributorImplAddressUpdated(_implementationType, _implementationAddress);\n\t}\n\n\t/**\n\t * @inheritdoc SharesFactory\n\t */\n\tfunction getProtocolFeeDestination() public view returns(address feeDestination) {\n\t\t// read the result from storage\n\t\treturn protocolFeeDestination;\n\t}\n\n\t/**\n\t * @inheritdoc SharesFactory\n\t */\n\tfunction getProtocolFeePercent() public view returns(uint256 feePercent) {\n\t\t// read the result from storage\n\t\treturn protocolFeePercent;\n\t}\n\n\t/**\n\t * @inheritdoc SharesFactory\n\t */\n\tfunction getHoldersFeePercent() public view returns(uint256 feePercent) {\n\t\t// read the result from storage\n\t\treturn holdersFeePercent;\n\t}\n\n\t/**\n\t * @inheritdoc SharesFactory\n\t */\n\tfunction getSubjectFeePercent() public view returns(uint256 feePercent) {\n\t\t// read the result from storage\n\t\treturn subjectFeePercent;\n\t}\n\n\t/**\n\t * @inheritdoc SharesFactory\n\t */\n\tfunction setProtocolFeeDestination(address _feeDestination) public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_PROTOCOL_FEE_MANAGER), \"access denied\");\n\t\t// verify state change doesn't result into the discrepancy\n\t\trequire(_feeDestination != address(0) || protocolFeePercent == 0, \"protocolFeePercent must be set to zero first\");\n\n\t\t// update contract's state\n\t\tprotocolFeeDestination = _feeDestination;\n\n\t\t// emit an event\n\t\temit ProtocolFeeUpdated(_feeDestination, protocolFeePercent, holdersFeePercent, subjectFeePercent);\n\t}\n\n\t/**\n\t * @inheritdoc SharesFactory\n\t */\n\tfunction setProtocolFeePercent(uint64 _feePercent) public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_PROTOCOL_FEE_MANAGER), \"access denied\");\n\t\t// verify state change doesn't result into the discrepancy\n\t\trequire(_feePercent == 0 || protocolFeeDestination != address(0), \"protocolFeeDestination must be set first\");\n\t\t// verify the fee is not mistakenly too small or big (0.00000001%, 30%)\n\t\trequire(_feePercent == 0 || _feePercent > 1000000 && _feePercent < 300000000000000000, \"malformed fee percent\");\n\n\t\t// update contract's state\n\t\tprotocolFeePercent = _feePercent;\n\n\t\t// emit an event\n\t\temit ProtocolFeeUpdated(protocolFeeDestination, _feePercent, holdersFeePercent, subjectFeePercent);\n\t}\n\n\t/**\n\t * @inheritdoc SharesFactory\n\t */\n\tfunction setHoldersFeePercent(uint64 _feePercent) public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_HOLDERS_FEE_MANAGER), \"access denied\");\n\t\t// verify the fee is not mistakenly too small or big (0.00000001%, 30%)\n\t\trequire(_feePercent == 0 || _feePercent > 1000000 && _feePercent < 300000000000000000, \"malformed fee percent\");\n\n\t\t// update contract's state\n\t\tholdersFeePercent = _feePercent;\n\n\t\t// emit an event\n\t\temit ProtocolFeeUpdated(protocolFeeDestination, protocolFeePercent, _feePercent, subjectFeePercent);\n\t}\n\n\t/**\n\t * @inheritdoc SharesFactory\n\t */\n\tfunction setSubjectFeePercent(uint64 _feePercent) public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_SUBJECT_FEE_MANAGER), \"access denied\");\n\t\t// verify the fee is not mistakenly too small or big (0.00000001%, 30%)\n\t\trequire(_feePercent == 0 || _feePercent > 1000000 && _feePercent < 300000000000000000, \"malformed fee percent\");\n\n\t\t// update contract's state\n\t\tsubjectFeePercent = _feePercent;\n\n\t\t// emit an event\n\t\temit ProtocolFeeUpdated(protocolFeeDestination, protocolFeePercent, holdersFeePercent, _feePercent);\n\t}\n\n\t/**\n\t * @inheritdoc SharesFactory\n\t */\n\tfunction setProtocolFee(\n\t\taddress _protocolFeeDestination,\n\t\tuint64 _protocolFeePercent,\n\t\tuint64 _holdersFeePercent,\n\t\tuint64 _subjectFeePercent\n\t) public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_PROTOCOL_FEE_MANAGER | ROLE_HOLDERS_FEE_MANAGER | ROLE_SUBJECT_FEE_MANAGER), \"access denied\");\n\n\t\t// verify state change doesn't result into the discrepancy\n\t\trequire(_protocolFeePercent == 0 || _protocolFeeDestination != address(0), \"zero address\");\n\t\t// verify the fee is not mistakenly too small or big (0.00000001%, 30%)\n\t\trequire(\n\t\t\t(_protocolFeePercent == 0 || _protocolFeePercent > 1000000 && _protocolFeePercent < 300000000000000000)\n\t\t\t&& (_holdersFeePercent == 0 || _holdersFeePercent > 1000000 && _holdersFeePercent < 300000000000000000)\n\t\t\t&& (_subjectFeePercent == 0 || _subjectFeePercent > 1000000 && _subjectFeePercent < 300000000000000000),\n\t\t\t\"malformed fee percent\"\n\t\t);\n\n\t\t// update contract's state\n\t\tprotocolFeeDestination = _protocolFeeDestination;\n\t\tprotocolFeePercent = _protocolFeePercent;\n\t\tholdersFeePercent = _holdersFeePercent;\n\t\tsubjectFeePercent = _subjectFeePercent;\n\n\t\t// emit an event\n\t\temit ProtocolFeeUpdated(_protocolFeeDestination, _protocolFeePercent, _holdersFeePercent, _subjectFeePercent);\n\t}\n\n\t/**\n\t * @inheritdoc SharesFactory\n\t */\n\tfunction deploySharesContractPaused(\n\t\tImplementationType _implementationType,\n\t\tTradeableShares.SharesSubject calldata _sharesSubject\n\t) public returns(TradeableShares) {\n\t\t// delegate to `deploySharesContractAndBuy`\n\t\treturn deploySharesContractAndBuy(_implementationType, _sharesSubject, 0);\n\t}\n\n\t/**\n\t * @inheritdoc SharesFactory\n\t */\n\tfunction deploySharesContract(\n\t\tImplementationType _implementationType,\n\t\tTradeableShares.SharesSubject calldata _sharesSubject\n\t) public returns(TradeableShares) {\n\t\t// delegate to `deploySharesContractAndBuy`\n\t\treturn deploySharesContractAndBuy(_implementationType, _sharesSubject, 1);\n\t}\n\n\t/**\n\t * @inheritdoc SharesFactory\n\t */\n\tfunction deploySharesContractAndBuy(\n\t\tImplementationType _implementationType,\n\t\tTradeableShares.SharesSubject calldata _sharesSubject,\n\t\tuint256 _amount\n\t) public payable returns(TradeableShares) {\n\t\t// delegate to `mintSubjectAndDeployShares`\n\t\treturn mintSubjectAndDeployShares(_implementationType, _sharesSubject, msg.sender, _amount);\n\t}\n\n\t/**\n\t * @inheritdoc SharesFactory\n\t */\n\tfunction mintSubjectAndDeployShares(\n\t\tImplementationType _implementationType,\n\t\tTradeableShares.SharesSubject calldata _sharesSubject,\n\t\taddress _issuer,\n\t\tuint256 _amount\n\t) public payable returns(TradeableShares) {\n\t\t// delegate to unsafe `__mintSubjectAndDeployShares`\n\t\treturn __mintSubjectAndDeployShares(_implementationType, _sharesSubject, _issuer, _amount, msg.sender);\n\t}\n\n\t/**\n\t * @dev Deploys the TradeableShares implementation for the specified subject;\n\t *      allows to immediately buy any amount of shares (including zero)\n\t *\n\t * @dev Tries minting the NFT defined by the subject if it doesn't exist\n\t *\n\t * @dev Unsafe, uses the specified `_authorizedBy` to check the access permission, which\n\t *      is either msg.sender, or the derived signer (if used in EIP712 meta tx mode)\n\t *\n\t * @param _implementationType TradeableShares implementation type\n\t * @param _sharesSubject shares subject, owner of the curve\n\t * @param _issuer an address to mint the NFT defined by the subject if it doesn't exist\n\t * @param _amount how many shares to buy immediately after the deployment\n\t * @param _authorizedBy must be either msg.sender or EIP712 signer if executed by the relayer\n\t * @return deployed TradeableShares contract\n\t */\n\tfunction __mintSubjectAndDeployShares(\n\t\tImplementationType _implementationType,\n\t\tTradeableShares.SharesSubject calldata _sharesSubject,\n\t\taddress _issuer,\n\t\tuint256 _amount,\n\t\taddress _authorizedBy\n\t) private returns(TradeableShares) {\n\t\t// verify deployments are enabled\n\t\trequire(isFeatureEnabled(FEATURE_SHARES_DEPLOYMENT_ENABLED), \"shares deployments disabled\");\n\n\t\t// verify paused deployments are enabled\n\t\trequire(\n\t\t\t// zero amount means paused deployment\n\t\t\t_amount != 0 || isFeatureEnabled(FEATURE_ALLOW_PAUSED_DEPLOYMENTS)\n\t\t\t\t// we do not allow to bypass the feature with meta-tx\n\t\t\t\t|| isSenderInRole(ROLE_SHARES_REGISTRAR),\n\t\t\t\"paused deployments disabled\"\n\t\t);\n\n\t\t// verify exclusive buys are enabled (if exclusive buy is requested)\n\t\trequire(\n\t\t\t_amount <= 1 || isFeatureEnabled(FEATURE_ALLOW_EXCLUSIVE_BUY)\n\t\t\t\t// we do not allow to bypass the feature with meta-tx\n\t\t\t\t|| isSenderInRole(ROLE_SHARES_REGISTRAR),\n\t\t\t\"exclusive buys disabled\"\n\t\t);\n\n\t\t// determine the issuer\n\t\taddress issuer = _sharesSubject.getSharesIssuer();\n\n\t\t// verify the access permission:\n\t\t// contract can be deployed either by the shares subject owner, or by the shares registrar\n\t\trequire(\n\t\t\t// contract can be deployed either by the shares subject owner\n\t\t\tmsg.sender == issuer\n\t\t\t// or by the shares registrar (role)\n\t\t\t|| isOperatorInRole(_authorizedBy, ROLE_SHARES_REGISTRAR)\n\t\t\t// or by the ERC721 contract owner\n\t\t\t|| _authorizedBy == _sharesSubject.getCollectionOwner(),\n\t\t\t\"access denied\"\n\t\t);\n\n\t\t// if issuer couldn't determined, we might need to mint the corresponding NFT\n\t\tif(issuer == address(0)) {\n\t\t\t// ensure the address to mint to is defined\n\t\t\t// if not - we cannot mint, but the error is in the shares subject in the first place\n\t\t\trequire(_issuer != address(0), \"invalid subject\");\n\t\t\t// try to mint, we expect this function to fail in case of an error\n\t\t\tMintableERC721(_sharesSubject.tokenAddress).mint(_issuer, _sharesSubject.tokenId);\n\t\t\t// set the issuer to the address NFT was minted to\n\t\t\tissuer = _issuer;\n\t\t}\n\n\t\t// at this point issuer cannot be zero, but it can be different from msg.sender\n\t\t// assert(issuer != address(0));\n\n\t\t// get shares implementation address for the implementation type specified\n\t\taddress sharesImplAddress = getSharesImplAddress(_implementationType);\n\n\t\t// verify the implementation address is registered for the implementation type specified\n\t\trequire(sharesImplAddress != address(0), \"implementation not registered\");\n\n\t\t// \"clone\" the impl (deploy a minimalistic EIP-1167 proxy)\n\t\tTradeableShares sharesContract = TradeableShares(Clones.clone(sharesImplAddress));\n\n\t\t// get holders rewards distributor implementation address for the implementation type specified\n\t\taddress distributorImplAddress = getDistributorImplAddress(_implementationType);\n\n\t\t// distributorImplAddress can be zero, in this case we will deploy the shares\n\t\t// without the HoldersRewardsDistributor attached to the contract\n\t\tHoldersRewardsDistributor distributorContract = HoldersRewardsDistributor(address(0));\n\n\t\t// if distributorImplAddress is defined, clone and initialize the HoldersRewardsDistributor\n\t\tif(distributorImplAddress != address(0)) {\n\t\t\t// \"clone\" the impl (deploy a minimalistic EIP-1167 proxy)\n\t\t\tdistributorContract = HoldersRewardsDistributor(Clones.clone(distributorImplAddress));\n\n\t\t\t// proxy initialization logic is implementation dependent\n\t\t\tHoldersRewardsDistributorV1(payable(address(distributorContract))).postConstruct(\n\t\t\t\tsharesOwnerAddress,\n\t\t\t\taddress(sharesContract),\n\t\t\t\t_implementationType == ImplementationType.ETH? address(0): address(paymentToken)\n\t\t\t);\n\t\t}\n\n\t\t// initialize TradeableShares EIP-1167 proxy\n\t\t__initSharesContract(sharesContract, distributorContract, _implementationType, _sharesSubject, _amount, issuer);\n\n\t\t// verify the shares subject is not yet mapped (not in use)\n\t\tbytes32 sharesKey = _sharesSubject.getSharesKey();\n\t\trequire(address(shares[sharesKey]) == address(0), \"subject in use\");\n\n\t\t// register the deployed implementation into the mappings\n\t\tshares[sharesKey] = sharesContract;\n\t\tsubjects[address(sharesContract)] = _sharesSubject;\n\n\t\t// emit an event\n\t\temit SharesContractRegistered(issuer, sharesContract, distributorContract, _implementationType, _sharesSubject, true);\n\n\t\t// return the result - deployed address\n\t\treturn sharesContract;\n\t}\n\n\t/**\n\t * @dev Part of the `__mintSubjectAndDeployShares` routine moved into\n\t *      a separate routine to fix the \"Stack too deep\" issue\n\t */\n\tfunction __initSharesContract(\n\t\tTradeableShares _sharesContract,\n\t\tHoldersRewardsDistributor _distributorContract,\n\t\tImplementationType _implementationType,\n\t\tTradeableShares.SharesSubject calldata _sharesSubject,\n\t\tuint256 _amount,\n\t\taddress _beneficiary\n\t) private {\n\t\t// determine the effective shares holders fee percent\n\t\t// this also caches the fee on stack and saves a bit of gas\n\t\tuint64 _holdersFeePercent = address(_distributorContract) == address(0)? 0: holdersFeePercent;\n\n\t\t// proxy initialization logic is implementation dependent\n\t\t// switch(_implementationType)\n\t\tif(_implementationType == ImplementationType.ETH) {\n\t\t\t// initialize the Ethereum version by invoking the postConstruct on the proxy\n\t\t\tETHShares(address(_sharesContract)).postConstruct{value: msg.value}(\n\t\t\t\tsharesOwnerAddress,\n\t\t\t\t_sharesSubject,\n\t\t\t\tprotocolFeeDestination,\n\t\t\t\tprotocolFeePercent,\n\t\t\t\t_distributorContract,\n\t\t\t\t_holdersFeePercent,\n\t\t\t\tsubjectFeePercent,\n\t\t\t\t_amount,\n\t\t\t\t_beneficiary\n\t\t\t);\n\t\t}\n\t\telse if(_implementationType == ImplementationType.ERC20) {\n\t\t\t// factory doesn't support sending the change back\n\t\t\trequire(msg.value == 0, \"non-zero value\");\n\n\t\t\t// if there is a request of the immediate shares buy\n\t\t\tif(_amount > 1) {\n\t\t\t\t// determine how much tokens we need\n\t\t\t\tuint256 toPay = _sharesContract.getBuyPriceAfterFee(0, _amount, protocolFeePercent, _holdersFeePercent, subjectFeePercent);\n\t\t\t\t// get the tokens required to buy\n\t\t\t\trequire(paymentToken.transferFrom(msg.sender, address(this), toPay));\n\t\t\t\t// approve the tokens to be spent\n\t\t\t\trequire(paymentToken.approve(address(_sharesContract), toPay));\n\t\t\t}\n\n\t\t\t// initialize the ERC20 version with the ERC20 as a payment token by invoking the postConstruct on the proxy\n\t\t\tERC20Shares(address(_sharesContract)).postConstruct(\n\t\t\t\tsharesOwnerAddress,\n\t\t\t\t_sharesSubject,\n\t\t\t\tprotocolFeeDestination,\n\t\t\t\tprotocolFeePercent,\n\t\t\t\t_distributorContract,\n\t\t\t\t_holdersFeePercent,\n\t\t\t\tsubjectFeePercent,\n\t\t\t\t_amount,\n\t\t\t\t_beneficiary,\n\t\t\t\tpaymentToken\n\t\t\t);\n\n\t\t\t// if there was a request of the immediate shares buy\n\t\t\tif(_amount > 1) {\n\t\t\t\t// transfer the remaining tokens (if any) back to the sender\n\t\t\t\trequire(paymentToken.transfer(msg.sender, paymentToken.balanceOf(address(this))));\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// throw if the implementation type is unknown\n\t\t\t// this must be an unreachable else block because the if-else blocks above\n\t\t\t// should have been taken care about all possible implementation types\n\t\t\trevert(\"unknown implementation type\");\n\t\t}\n\t}\n\n\t/**\n\t * @inheritdoc SharesFactory\n\t */\n\tfunction executeDeploymentRequest(\n\t\tSharesDeploymentRequest calldata req,\n\t\tbytes calldata signature\n\t) public payable returns(TradeableShares) {\n\t\t// verify the request validity\n\t\trequire(req.validFromTimestamp <= block.timestamp, \"not yet valid\");\n\t\trequire(req.expiresAtTimestamp > block.timestamp, \"expired\");\n\n\t\t// verify and use nonce\n\t\t__useNonce(req.issuer, req.nonce);\n\n\t\t// derive the request signer\n\t\t// this also verifies that the signature is valid\n\t\taddress signer = _hashTypedDataV4(req.hashStruct()).recover(signature);\n\n\t\t// delegate to unsafe `__mintSubjectAndDeployShares`\n\t\treturn __mintSubjectAndDeployShares(req.implementationType, req.sharesSubject, req.issuer, req.amount, signer);\n\t}\n\n\t/**\n\t * @dev Verifies the nonce is valid and marks it as used\n\t *      Throws if nonce is already used or if it is invalid\n\t *\n\t * @param _issuer the owner of the nonce\n\t * @param _nonce the nonce to be used\n\t */\n\tfunction __useNonce(address _issuer, uint256 _nonce) private {\n\t\t// verify the nonce wasn't yet used and use it\n\t\trequire(nonces[_issuer]++ == _nonce, \"invalid nonce\");\n\n\t\t// emit an event\n\t\temit NonceUsed(_issuer, _nonce);\n\t}\n\n\t/**\n\t * @inheritdoc SharesFactory\n\t */\n\tfunction getNonce(address _issuer) external view returns(uint256) {\n\t\t// read the nonce from the storage\n\t\treturn nonces[_issuer];\n\t}\n\n\t/**\n\t * @inheritdoc SharesFactory\n\t */\n\tfunction rewindNonce(address _issuer, uint256 _nonce) external {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_SHARES_REGISTRAR), \"access denied\");\n\n\t\t// make sure nonce is not decreasing\n\t\trequire(nonces[_issuer] < _nonce, \"new nonce must be bigger than the current one\");\n\n\t\t// rewind the nonce to the value requested\n\t\tnonces[_issuer] = _nonce;\n\n\t\t// emit an event\n\t\temit NonceUsed(_issuer, _nonce - 1);\n\t}\n\n\t/**\n\t * @inheritdoc SharesFactory\n\t */\n\tfunction lookupSharesContract(\n\t\tTradeableShares.SharesSubject calldata _sharesSubject\n\t) public view returns(TradeableShares) {\n\t\treturn shares[_sharesSubject.getSharesKey()];\n\t}\n\n\t/**\n\t * @inheritdoc SharesFactory\n\t *\n\t * @dev Note: this restricted function allows the authorized address to register\n\t *      the shares contract with the invalid subject\n\t */\n\tfunction registerSharesContract(TradeableShares _sharesContract) external {\n\t\t// verify the access permission: contract can be registered only by the shares registrar\n\t\trequire(isSenderInRole(ROLE_SHARES_REGISTRAR), \"access denied\");\n\n\t\t// delegate to unsafe `__registerSharesContract`\n\t\t__registerSharesContract(_sharesContract);\n\t}\n\n\t/**\n\t * @inheritdoc SharesFactory\n\t */\n\tfunction notifySubjectUpdated() external {\n\t\t// read the registered subject (this can be zero if not registered)\n\t\tTradeableShares.SharesSubject memory registeredSubject = subjects[msg.sender];\n\n\t\t// ensure the subject is registered (we know the caller, we already registered it)\n\t\trequire(!registeredSubject.isZero(), \"not registered\");\n\t\t// we do not allow binding to non-existent NFTs (consistency with `__mintSubjectAndDeployShares`)\n\t\trequire(TradeableShares(msg.sender).getSharesSubject().getSharesIssuer() != address(0), \"invalid subject\");\n\n\t\t// delegate to unsafe `__registerSharesContract`\n\t\t__registerSharesContract(TradeableShares(msg.sender));\n\t}\n\n\t/**\n\t * @dev Registers the TradeableShares contract;\n\t *      unsafe, doesn't verify the access permissions, must be kept private at all times\n\t *\n\t * @param _sharesContract TradeableShares contract to register\n\t */\n\tfunction __registerSharesContract(TradeableShares _sharesContract) private {\n\t\t// determine current shares subject\n\t\tTradeableShares.SharesSubject memory sharesSubject = _sharesContract.getSharesSubject();\n\t\t// this contract may had already been registered under the different subject\n\t\tTradeableShares.SharesSubject memory registeredSubject = subjects[address(_sharesContract)];\n\n\t\t// if it was already registered and subject didn't change there is nothing to do\n\t\tif(sharesSubject.equals(registeredSubject)) {\n\t\t\t// exit from the function silently\n\t\t\treturn;\n\t\t}\n\n\t\t// verify the shares subject is not yet mapped (not in use)\n\t\tbytes32 sharesKey = sharesSubject.getSharesKey();\n\t\trequire(address(shares[sharesKey]) == address(0), \"subject in use\");\n\n\t\t// cleanup previously registered subject mapping if any\n\t\tdelete shares[registeredSubject.getSharesKey()];\n\n\t\t// register the deployed implementation into the mappings\n\t\tshares[sharesKey] = _sharesContract;\n\t\tsubjects[address(_sharesContract)] = sharesSubject;\n\n\t\t// emit an event\n\t\temit SharesContractRegistered(\n\t\t\t_sharesContract.getSharesIssuer(),\n\t\t\t_sharesContract,\n\t\t\t_sharesContract.getHoldersFeeDestination(),\n\t\t\tdetermineImplementationType(_sharesContract),\n\t\t\t_sharesContract.getSharesSubject(),\n\t\t\tfalse\n\t\t);\n\t}\n\n\t/**\n\t * @notice Tries to determine the implementation type of the already deployed TradeableShares contract;\n\t *      the result should not be considered reliable and can be used only as a hint\n\t *\n\t * @param _sharesContract deployed TradeableShares instance\n\t * @return implementation type of the instance specified\n\t */\n\tfunction determineImplementationType(TradeableShares _sharesContract) public view returns(ImplementationType) {\n\t\t// determine the implementation type\n\t\tImplementationType implementationType;\n\n\t\t// try to treat the implementation as ERC20\n\t\ttry ERC20Shares(address(_sharesContract)).getPaymentToken() returns (ERC1363 token) {\n\t\t\t// for the ERC20Shares impl we support only ERC20 token known to factory\n\t\t\trequire(token == paymentToken, \"unknown ERC20 implementation type\");\n\n\t\t\t// implementation type is successfully determined as ERC20\n\t\t\timplementationType = ImplementationType.ERC20;\n\t\t}\n\t\tcatch {\n\t\t\t// fallback to ETH\n\t\t\timplementationType = ImplementationType.ETH;\n\t\t}\n\n\t\t// return the result\n\t\treturn implementationType;\n\t}\n}\n"
    },
    "contracts/bonding_curves/SharesSubjectLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ERC721Spec.sol\";\nimport \"../interfaces/ERC721SpecExt.sol\";\nimport \"./TradeableShares.sol\";\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title Shares Subject Library\n *\n * @notice Auxiliary functions to work with SharesSubject struct\n */\nlibrary SharesSubjectLib {\n\t/**\n\t * @notice Determines current owner of the shares subject, which is a corresponding NFT owner\n\t *\n\t * @dev This function returns zero address if NFT doesn't exist, or even if NFT contract doesn't exist\n\t *\n\t * @param sharesSubject shares subject, owner of the curve\n\t * @return address of the issuer, underlying NFT owner; or zero address\n\t */\n\tfunction getSharesIssuer(TradeableShares.SharesSubject memory sharesSubject) internal view returns(address) {\n\t\t// we have to check if the address is callable, otherwise staticall would throw\n\t\tif(isCallable(sharesSubject.tokenAddress)) {\n\t\t\t// try to avoid an exception / failed call in the ownerOf function by checking NFT existence first\n\t\t\t// this is required *only* to avoid \"partially failed\" transaction display on etherscan\n\t\t\t{\n\t\t\t\t// we use staticcall instead of ABI function call to guaranty immutable call\n\t\t\t\t(bool success, bytes memory data) = sharesSubject.tokenAddress.staticcall{gas: 4900}(\n\t\t\t\t\t// MintableERC721 interface: function exists(uint256) external view returns(bool)\n\t\t\t\t\tabi.encodeWithSelector(MintableERC721.exists.selector, sharesSubject.tokenId)\n\t\t\t\t);\n\t\t\t\t// only if the call was successful\n\t\t\t\tif(success) {\n\t\t\t\t\t// try to decode the result as a bool,\n\t\t\t\t\t// and if we know for sure token doesn't exist,\n\t\t\t\t\tif(!abi.decode(data, (bool))) {\n\t\t\t\t\t\t// just return zero address as a default result in case of any error\n\t\t\t\t\t\treturn address(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// try to get the ERC721 owner of the underlying NFT\n\t\t\t{\n\t\t\t\t// we use staticcall instead of ABI function call to guaranty immutable call\n\t\t\t\t(bool success, bytes memory data) = sharesSubject.tokenAddress.staticcall{gas: 4900}(\n\t\t\t\t\t// ERC721 interface: function ownerOf(uint256) external view returns(address)\n\t\t\t\t\tabi.encodeWithSelector(ERC721.ownerOf.selector, sharesSubject.tokenId)\n\t\t\t\t);\n\t\t\t\t// only if the call was successful\n\t\t\t\tif(success) {\n\t\t\t\t\t// try to decode the result as an address and return\n\t\t\t\t\treturn abi.decode(data, (address));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// return the default zero address value in case of any errors\n\t\treturn address(0);\n\t}\n\n\t/**\n\t * @notice Determines the owner of the shares subject's underlying NFT collection\n\t *\n\t * @dev This function returns zero address if the underlying ERC721 contract is not OZ ownable\n\t *      (doesn't have `owner()` function), doesn't exist, or if any other error occurs\n\t *\n\t * @param sharesSubject shares subject, owner of the curve\n\t * @return address of the NFT collection owner (OZ ownable); or zero address\n\t */\n\tfunction getCollectionOwner(TradeableShares.SharesSubject memory sharesSubject) internal view returns(address) {\n\t\t// we have to check if the address is callable, otherwise staticall would throw\n\t\tif(isCallable(sharesSubject.tokenAddress)) {\n\t\t\t// try to derive the owner via the OZ Ownable interface owner()\n\t\t\t// we use staticcall instead of ABI function call to guaranty immutable call\n\t\t\t(bool success, bytes memory data) = sharesSubject.tokenAddress.staticcall{gas: 4900}(\n\t\t\t\t// OZ Ownable interface: function owner() external view returns(address)\n\t\t\t\tabi.encodeWithSelector(Ownable.owner.selector)\n\t\t\t);\n\n\t\t\t// only if the call was successful\n\t\t\tif(success) {\n\t\t\t\t// try to decode the result as an address and return\n\t\t\t\treturn abi.decode(data, (address));\n\t\t\t}\n\t\t}\n\n\t\t// return the default zero address value in case of any errors\n\t\treturn address(0);\n\t}\n\n\t/**\n\t * @notice Calculates the keccak256 bytes32 key for the shares subject to be used in the mappings\n\t *\n\t * @param sharesSubject shares subject, owner of the curve\n\t * @return keccak256 of the shares subject\n\t */\n\tfunction getSharesKey(TradeableShares.SharesSubject memory sharesSubject) internal pure returns(bytes32) {\n\t\t// calculate the keccak256 from the concatenated internals of the SharesSubject struct\n\t\treturn keccak256(abi.encode(sharesSubject.tokenAddress, sharesSubject.tokenId));\n\t}\n\n\t/**\n\t * @notice Checks if two subjects - subject 1 and subject 2 - are equal\n\t *      Returns false if any of the subjects is not initialized (have zero ERC721 address)\n\t *\n\t * @param sharesSubject1 subject 1\n\t * @param sharesSubject2 subject 2\n\t * @return true if subject 1 and subject 2 are equal\n\t */\n\tfunction equals(\n\t\tTradeableShares.SharesSubject memory sharesSubject1,\n\t\tTradeableShares.SharesSubject memory sharesSubject2\n\t) internal pure returns(bool) {\n\t\treturn sharesSubject1.tokenAddress != address(0)\n\t\t\t&& sharesSubject1.tokenAddress == sharesSubject2.tokenAddress\n\t\t\t&& sharesSubject1.tokenId == sharesSubject2.tokenId;\n\t}\n\n\t/**\n\t * @notice Verifies if the shares subject contains a value; this function is useful\n\t *      to check if the value in storage (mapping) was initialized\n\t *\n\t * @param sharesSubject the shares subject to check\n\t * @return true if the subject has a value, false otherwise (zero value)\n\t */\n\tfunction isZero(TradeableShares.SharesSubject memory sharesSubject) internal pure returns(bool) {\n\t\treturn sharesSubject.tokenAddress == address(0) && sharesSubject.tokenId == 0;\n\t}\n\n\t/**\n\t * @notice Checks if account can be called (is callable, already deployed contract)\n\t *\n\t * @dev Verifies if the bytecode on the specified address is present\n\t *\n\t * @param account an address to check\n\t * @return true if address denotes already deployed callable contract\n\t */\n\tfunction isCallable(address account) internal view returns(bool) {\n\t\t// This method relies on extcodesize, which returns 0 for contracts in\n\t\t// construction, since the code is only stored at the end of the\n\t\t// constructor execution.\n\n\t\tuint256 size;\n\t\tassembly {\n\t\t\tsize := extcodesize(account)\n\t\t}\n\t\treturn size > 0;\n\t}\n}\n"
    },
    "contracts/bonding_curves/TradeableShares.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./BondingCurve.sol\";\nimport \"./HoldersRewardsDistributor.sol\";\n\n/**\n * @title Tradeable Shares\n *\n * @notice Tradeable shares is a non-transferable, but buyable/sellable fungible token-like asset,\n *      which is sold/bought solely by the shares contract at the predefined by\n *      the bonding curve function price\n *\n * @notice The shares is bound to its \"subject\" – an NFT; the NFT owner gets the subject fee\n *      emerging in every buy/sell operation\n *\n * @dev Based on the friend.tech FriendtechSharesV1.sol\n */\ninterface TradeableShares is BondingCurve {\n\t/**\n\t * @notice Shares subject is an NFT defined by its ERC721 contract address and NFT ID\n\t *       Note: this is different from the original FriendTech implementation where\n\t *       shares subject is always equal to the issuer address\n\t */\n\tstruct SharesSubject {\n\t\t/// @dev ERC721 contract address\n\t\taddress tokenAddress;\n\n\t\t/// @dev NFT ID\n\t\tuint256 tokenId;\n\t}\n\n\t/**\n\t * @dev Fired in `buyShares` and `sellShares` functions, this event logs\n\t *      the entire trading activity happening on the curve\n\t *\n\t * @dev Trader, that is the buyer or seller, depending on the operation type is the transaction sender\n\t *\n\t * @param beneficiary the address which receives shares or funds, usually this is the trader itself\n\t * @param issuer subject issuer, usually an owner of the NFT defined by the subject\n\t * @param isBuy true if the event comes from the `buyShares` and represents the buy operation,\n\t *      false if the event comes from the `sellShares` and represents the sell operation\n\t * @param sharesAmount amount of the shares bought or sold (see `isBuy`)\n\t * @param paidAmount amount of ETH spent or gained by the buyer or seller;\n\t *      this is implementation dependent and can represent an amount of ERC20 payment token\n\t * @param protocolFeeAmount amount of fees paid to the protocol\n\t * @param holdersFeeAmount amount of fees paid to the shares holders\n\t * @param subjectFeeAmount amount of fees paid to the subject (issuer)\n\t * @param supply total shares supply after the operation\n\t */\n\tevent Trade(\n\t\taddress indexed beneficiary,\n\t\taddress indexed issuer,\n\t\tbool indexed isBuy,\n\t\tuint256 sharesAmount,\n\t\tuint256 paidAmount,\n\t\tuint256 protocolFeeAmount,\n\t\tuint256 holdersFeeAmount,\n\t\tuint256 subjectFeeAmount,\n\t\tuint256 supply\n\t);\n\n\t/**\n\t * @notice Shares subject, usually defined as NFT (ERC721 contract address + NFT ID)\n\t *\n\t * @dev Immutable, client applications may cache this value\n\t *\n\t * @return Shares subject as a SharesSubject struct, this is an NFT if all currently known implementations\n\t */\n\tfunction getSharesSubject() external view returns(SharesSubject calldata);\n\n\t/**\n\t * @notice Protocol fee destination, the address protocol fee is sent to\n\t *\n\t * @dev Mutable, can be changed by the protocol fee manager\n\t *\n\t * @return the address where the protocol fee is sent to\n\t */\n\tfunction getProtocolFeeDestination() external view returns(address);\n\n\t/**\n\t * @notice Protocol fee percent, applied to all the buy and sell operations;\n\t *      the fee percent is defined with the 18 decimals, 10^18 corresponds to 100%\n\t *\n\t * @notice Protocol fee is sent to the protocol fee destination (see `getProtocolFeeDestination`)\n\t *\n\t * @dev Immutable, client applications may cache this value\n\t *\n\t * @return protocol fee percent with the 18 decimals (10^18 is 100%)\n\t */\n\tfunction getProtocolFeePercent() external view returns(uint256);\n\n\t/**\n\t * @notice Protocol fee destination and protocol fee percent as a tuple;\n\t *      the fee percent is defined with the 18 decimals, 10^18 corresponds to 100%\n\t *\n\t * @dev Implementation must always return zero fee percent if fee destination is zero address\n\t *\n\t * @return feeDestination protocol fee destination\n\t * @return feePercent protocol fee percent, zero if protocol fee destination is zero\n\t */\n\tfunction getProtocolFeeInfo() external view returns(address feeDestination, uint256 feePercent);\n\n\t/**\n\t * @notice Shares holders reward distributor contract attached to the shares contract\n\t *      in order to receive its portion of the fees to be distributed among the shares holders\n\t *\n\t * @dev Immutable, client applications may cache this value; holders fee destination is not\n\t *      an arbitrary address capable of receiving ETH or ERC20, but a HoldersRewardsDistributor\n\t *      smart contract, which not only receives the fees but also receives updated on the\n\t *      trading activity in the shares contract\n\t *\n\t * @return the contract where the holders fee is sent to\n\t */\n\tfunction getHoldersFeeDestination() external view returns(HoldersRewardsDistributor);\n\n\t/**\n\t * @notice Shares holders fee percent, applied to all the buy and sell operations;\n\t *      the fee percent is defined with the 18 decimals, 10^18 corresponds to 100%\n\t *\n\t * @notice Shares holders fee is sent to the holders fee destination (see `getHoldersFeeDestination`)\n\t *\n\t * @dev Immutable, client applications may cache this value\n\t *\n\t * @return shares holders fee percent with the 18 decimals (10^18 is 100%)\n\t */\n\tfunction getHoldersFeePercent() external view returns(uint256);\n\n\t/**\n\t * @notice Shares holders fee destination and shares holders fee percent as a tuple;\n\t *      the fee percent is defined with the 18 decimals, 10^18 corresponds to 100%\n\t *\n\t * @dev Implementation must always return zero fee percent if fee destination is zero\n\t *\n\t * @return feeDestination shares holders fee destination\n\t * @return feePercent shares holders fee percent, zero if holders fee destination is zero\n\t */\n\tfunction getHoldersFeeInfo() external view returns(HoldersRewardsDistributor feeDestination, uint256 feePercent);\n\n\t/**\n\t * @notice Subject fee destination and subject fee percent as a tuple;\n\t *      subject fee destination is shares issuer address;\n\t *      the fee percent is defined with the 18 decimals, 10^18 corresponds to 100%;\n\t *\n\t * @dev Implementation must always return zero fee percent if fee destination is zero address\n\t *\n\t * @return feeDestination protocol fee destination\n\t * @return feePercent protocol fee percent, zero if subject fee destination is zero\n\t */\n\tfunction getSubjectFeeInfo() external view returns(address feeDestination, uint256 feePercent);\n\n\t/**\n\t * @notice Subject fee percent, applied to all the buy and sell operations,\n\t *      the fee percent is defined with the 18 decimals, 10^18 corresponds to 100%\n\t *\n\t * @notice Subject fee is sent to the subject fee issuer (see `getSharesIssuer`)\n\t *\n\t * @dev Immutable, client applications may cache this value\n\t *\n\t * @return subject fee percent with the 18 decimals (10^18 is 100%)\n\t */\n\tfunction getSubjectFeePercent() external view returns(uint256);\n\n\t/**\n\t * @notice Shares issuer, the receiver of the shares fees\n\t *\n\t * @dev Mutable, changes (potentially frequently and unpredictably) when the NFT owner changes;\n\t *      subject to the front-run attacks, off-chain client applications must not rely on this address\n\t *      in anyway\n\t *\n\t * @return nftOwner subject issuer, the owner of the NFT\n\t */\n\tfunction getSharesIssuer() external view returns(address nftOwner);\n\n\t/**\n\t * @notice Shares balance of the given holder; this function is similar to ERC20.balanceOf()\n\t *\n\t * @param holder the address to check the balance for\n\t *\n\t * @return balance number of shares the holder has\n\t */\n\tfunction getSharesBalance(address holder) external view returns(uint256 balance);\n\n\t/**\n\t * @notice Total amount of the shares in existence, the sum of all individual shares balances;\n\t *      this function is similar to ERC20.totalSupply()\n\t *\n\t * @return supply total shares supply\n\t */\n\tfunction getSharesSupply() external view returns(uint256 supply);\n\n\t/**\n\t * @notice The price of the `amount` of shares to buy calculated based on\n\t *      the specified total shares supply\n\t *\n\t * @param supply total shares supply\n\t * @param amount number of shares to buy\n\t * @return the price of the shares to buy\n\t */\n\tfunction getBuyPrice(uint256 supply, uint256 amount) external pure returns(uint256);\n\n\t/**\n\t * @notice The price of the `amount` of shares to sell calculated based on\n\t *      the specified total shares supply\n\t *\n\t * @param supply total shares supply\n\t * @param amount number of shares to sell\n\t * @return the price of the shares to sell\n\t */\n\tfunction getSellPrice(uint256 supply, uint256 amount) external pure returns(uint256);\n\n\t/**\n\t * @notice The price of the `amount` of shares to buy, including all fees;\n\t *      calculated based on the specified total shares supply and fees percentages\n\t *\n\t * @param supply total shares supply\n\t * @param amount number of shares to buy\n\t * @param protocolFeePercent protocol fee percent\n\t * @param holdersFeePercent shares holders fee percent\n\t * @param subjectFeePercent protocol fee percent\n\t * @return the price of the shares to buy\n\t */\n\tfunction getBuyPriceAfterFee(\n\t\tuint256 supply,\n\t\tuint256 amount,\n\t\tuint256 protocolFeePercent,\n\t\tuint256 holdersFeePercent,\n\t\tuint256 subjectFeePercent\n\t) external pure returns(uint256);\n\n\t/**\n\t * @notice The price of the `amount` of shares to sell, including all fees;\n\t *      calculated based on the specified total shares supply and fees percentages\n\t *\n\t * @param supply total shares supply\n\t * @param amount number of shares to sell\n\t * @param protocolFeePercent protocol fee percent\n\t * @param holdersFeePercent shares holders fee percent\n\t * @param subjectFeePercent protocol fee percent\n\t * @return the price of the shares to sell\n\t */\n\tfunction getSellPriceAfterFee(\n\t\tuint256 supply,\n\t\tuint256 amount,\n\t\tuint256 protocolFeePercent,\n\t\tuint256 holdersFeePercent,\n\t\tuint256 subjectFeePercent\n\t) external pure returns(uint256);\n\n\t/**\n\t * @notice Current price of the `amount` of shares to buy; calculated based on\n\t *      the current total shares supply\n\t *\n\t * @param amount number of shares to buy\n\t * @return the price of the shares to buy\n\t */\n\tfunction getBuyPrice(uint256 amount) external view returns(uint256);\n\n\t/**\n\t * @notice Current price of the `amount` of shares to sell; calculated based on\n\t *      the current total shares supply\n\t *\n\t * @param amount number of shares to sell\n\t * @return the price of the shares to sell\n\t */\n\tfunction getSellPrice(uint256 amount) external view returns(uint256);\n\n\t/**\n\t * @notice Current price of the `amount` of shares to buy, including all fees;\n\t *      calculated based on the current total shares supply and fees percentages\n\t *\n\t * @param amount number of shares to buy\n\t * @return the price of the shares to buy\n\t */\n\tfunction getBuyPriceAfterFee(uint256 amount) external view returns(uint256);\n\n\t/**\n\t * @notice Current price of the `amount` of shares to sell, including all fees;\n\t *      calculated based on the current total shares supply and fees percentages\n\t *\n\t * @param amount number of shares to sell\n\t * @return the price of the shares to sell\n\t */\n\tfunction getSellPriceAfterFee(uint256 amount) external view returns(uint256);\n\n\t/**\n\t * @notice Buy `amount` of shares. Sender has to supply `getBuyPriceAfterFee(amount)` ETH.\n\t *      First share can be bought only by current subject issuer.\n\t *\n\t * @dev Depending on the implementation, ERC20 token payment may be required instead of ETH.\n\t *      In such a case, implementation must through if ETH is sent, effectively overriding\n\t *      the function definition as non-payable\n\t *\n\t * @param amount amount of the shares to buy\n\t */\n\tfunction buyShares(uint256 amount) external payable;\n\n\t/**\n\t * @notice Buy `amount` of shares in the favor of the address specified (beneficiary).\n\t *      Sender has to supply `getBuyPriceAfterFee(amount)` ETH.\n\t *      First share can be bought only by current subject issuer.\n\t *\n\t * @dev Depending on the implementation, ERC20 token payment may be required instead of ETH.\n\t *      In such a case, implementation must through if ETH is sent, effectively overriding\n\t *      the function definition as non-payable\n\t *\n\t * @param amount amount of the shares to buy\n\t * @param beneficiary an address receiving the shares\n\t */\n\tfunction buySharesTo(uint256 amount, address beneficiary) external payable;\n\n\t/**\n\t * @notice Sell `amount` of shares. Sender gets `getSellPriceAfterFee(amount)` of ETH.\n\t *      Last share cannot be sold.\n\t *\n\t * @dev Depending on the implementation, ERC20 token may be payed instead of ETH.\n\t *\n\t * @param amount amount of the shares to sell\n\t */\n\tfunction sellShares(uint256 amount) external;\n\n\t/**\n\t * @notice Sell `amount` of shares in the favor of the address specified (beneficiary).\n\t *      The beneficiary gets `getSellPriceAfterFee(amount)` of ETH.\n\t *      Last share cannot be sold.\n\t *\n\t * @dev Depending on the implementation, ERC20 token may be payed instead of ETH.\n\t *\n\t * @param amount amount of the shares to sell\n\t * @param beneficiary an address receiving the funds from the sale\n\t */\n\tfunction sellSharesTo(uint256 amount, address payable beneficiary) external;\n\n\t/**\n\t * @notice Cumulative value of all trades; allows to derive cumulative fees paid\n\t *\n\t * @dev This value cannot decrease over time; it can increase or remain constant\n\t *      if no trades are happening\n\t *\n\t * @return Sum of the modulo of all trading operations\n\t */\n\tfunction getTradeVolume() external view returns(uint256);\n}\n"
    },
    "contracts/bonding_curves/TypedStructLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./SharesFactory.sol\";\n\n/**\n * @title EIP712 Typed Struct Library\n *\n * @notice Calculates EIP712 typed structured data typeHash and hashStruct\n */\nlibrary TypedStructLib {\n\t/**\n\t * @notice SharesDeploymentRequest typeHash\n\t */\n\tfunction hashType(SharesFactory.SharesDeploymentRequest calldata) internal pure returns(bytes32) {\n\t\t// hashType(SharesDeploymentRequest) = keccak256(\"SharesDeploymentRequest(ImplementationType implementationType,TradeableShares.SharesSubject sharesSubject,address issuer,uint256 amount,uint256 validFromTimestamp,uint256 expiresAtTimestamp,uint256 nonce)\")\n\t\treturn 0x7acc9d8c19a06f50ae6d92c5e1206302e8aeac9f7f8bf014389ca2a4354650fd;\n\t}\n\n\t/**\n\t * @notice SharesSubject typeHash\n\t */\n\tfunction hashType(TradeableShares.SharesSubject calldata) internal pure returns(bytes32) {\n\t\t// hashType(SharesSubject) = keccak256(\"SharesSubject(address tokenAddress,uint256 tokenId)\")\n\t\treturn 0x685dd8e2693cf377e50b3e95f06b61dff4c1705fa19df1071074d64f4e1469eb;\n\t}\n\n\t/**\n\t * @notice SharesDeploymentRequest hashStruct\n\t */\n\tfunction hashStruct(SharesFactory.SharesDeploymentRequest calldata request) internal pure returns(bytes32) {\n\t\treturn keccak256(abi.encode(\n\t\t\thashType(request),\n\t\t\trequest.implementationType,\n\t\t\thashStruct(request.sharesSubject),\n\t\t\trequest.issuer,\n\t\t\trequest.amount,\n\t\t\trequest.validFromTimestamp,\n\t\t\trequest.expiresAtTimestamp,\n\t\t\trequest.nonce\n\t\t));\n\t}\n\n\t/**\n\t * @notice SharesSubject hashStruct\n\t */\n\tfunction hashStruct(TradeableShares.SharesSubject calldata sharesSubject) internal pure returns(bytes32) {\n\t\treturn keccak256(abi.encode(\n\t\t\thashType(sharesSubject),\n\t\t\tsharesSubject.tokenAddress,\n\t\t\tsharesSubject.tokenId\n\t\t));\n\t}\n\n}\n"
    },
    "contracts/hardhat-dependency-compiler/@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport '@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol';\n"
    },
    "contracts/interfaces/bedrock/IOptimismMintableERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {ERC165} from \"../ERC165Spec.sol\";\n\n/// @title IOptimismMintableERC20\n/// @notice This interface is available on the OptimismMintableERC20 contract.\n///         We declare it as a separate interface so that it can be used in\n///         custom implementations of OptimismMintableERC20.\ninterface IOptimismMintableERC20 is ERC165 {\n\tfunction remoteToken() external view returns (address);\n\n\tfunction bridge() external returns (address);\n\n\tfunction mint(address _to, uint256 _amount) external;\n\n\tfunction burn(address _from, uint256 _amount) external;\n}\n\n/// @custom:legacy\n/// @title ILegacyMintableERC20\n/// @notice This interface was available on the legacy L2StandardERC20 contract.\n///         It remains available on the OptimismMintableERC20 contract for\n///         backwards compatibility.\ninterface ILegacyMintableERC20 is ERC165 {\n\tfunction l1Token() external view returns (address);\n\n\tfunction mint(address _to, uint256 _amount) external;\n\n\tfunction burn(address _from, uint256 _amount) external;\n}\n"
    },
    "contracts/interfaces/EIP2612.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title EIP-2612: permit - 712-signed approvals\n *\n * @notice A function permit extending ERC-20 which allows for approvals to be made via secp256k1 signatures.\n *      This kind of “account abstraction for ERC-20” brings about two main benefits:\n *        - transactions involving ERC-20 operations can be paid using the token itself rather than ETH,\n *        - approve and pull operations can happen in a single transaction instead of two consecutive transactions,\n *        - while adding as little as possible over the existing ERC-20 standard.\n *\n * @notice See https://eips.ethereum.org/EIPS/eip-2612#specification\n */\ninterface EIP2612 {\n\t/**\n\t * @notice EIP712 domain separator of the smart contract. It should be unique to the contract\n\t *      and chain to prevent replay attacks from other domains, and satisfy the requirements of EIP-712,\n\t *      but is otherwise unconstrained.\n\t */\n\tfunction DOMAIN_SEPARATOR() external view returns (bytes32);\n\n\t/**\n\t * @notice Counter of the nonces used for the given address; nonce are used sequentially\n\t *\n\t * @dev To prevent from replay attacks nonce is incremented for each address after a successful `permit` execution\n\t *\n\t * @param owner an address to query number of used nonces for\n\t * @return number of used nonce, nonce number to be used next\n\t */\n\tfunction nonces(address owner) external view returns (uint);\n\n\t/**\n\t * @notice For all addresses owner, spender, uint256s value, deadline and nonce, uint8 v, bytes32 r and s,\n\t *      a call to permit(owner, spender, value, deadline, v, r, s) will set approval[owner][spender] to value,\n\t *      increment nonces[owner] by 1, and emit a corresponding Approval event,\n\t *      if and only if the following conditions are met:\n\t *        - The current blocktime is less than or equal to deadline.\n\t *        - owner is not the zero address.\n\t *        - nonces[owner] (before the state update) is equal to nonce.\n\t *        - r, s and v is a valid secp256k1 signature from owner of the message:\n\t *\n\t * @param owner token owner address, granting an approval to spend its tokens\n\t * @param spender an address approved by the owner (token owner)\n\t *      to spend some tokens on its behalf\n\t * @param value an amount of tokens spender `spender` is allowed to\n\t *      transfer on behalf of the token owner\n\t * @param v the recovery byte of the signature\n\t * @param r half of the ECDSA signature pair\n\t * @param s half of the ECDSA signature pair\n\t */\n\tfunction permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n}\n"
    },
    "contracts/interfaces/EIP2981Spec.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./ERC165Spec.sol\";\n\n///\n/// @dev Interface for the NFT Royalty Standard\n///\ninterface EIP2981 is ERC165 {\n\t/// ERC165 bytes to add to interface array - set in parent contract\n\t/// implementing this standard\n\t///\n\t/// bytes4(keccak256(\"royaltyInfo(uint256,uint256)\")) == 0x2a55205a\n\t/// bytes4 private constant _INTERFACE_ID_ERC2981 = 0x2a55205a;\n\t/// _registerInterface(_INTERFACE_ID_ERC2981);\n\n\t/// @notice Called with the sale price to determine how much royalty\n\t//          is owed and to whom.\n\t/// @param _tokenId - the NFT asset queried for royalty information\n\t/// @param _salePrice - the sale price of the NFT asset specified by _tokenId\n\t/// @return receiver - address of who should be sent the royalty payment\n\t/// @return royaltyAmount - the royalty payment amount for _salePrice\n\tfunction royaltyInfo(\n\t\tuint256 _tokenId,\n\t\tuint256 _salePrice\n\t) external view returns (\n\t\taddress receiver,\n\t\tuint256 royaltyAmount\n\t);\n}\n"
    },
    "contracts/interfaces/EIP3009.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title EIP-3009: Transfer With Authorization\n *\n * @notice A contract interface that enables transferring of fungible assets via a signed authorization.\n *      See https://eips.ethereum.org/EIPS/eip-3009\n *      See https://eips.ethereum.org/EIPS/eip-3009#specification\n */\ninterface EIP3009 {\n\t/**\n\t * @dev Fired whenever the nonce gets used (ex.: `transferWithAuthorization`, `receiveWithAuthorization`)\n\t *\n\t * @param authorizer an address which has used the nonce\n\t * @param nonce the nonce used\n\t */\n\tevent AuthorizationUsed(address indexed authorizer, bytes32 indexed nonce);\n\n\t/**\n\t * @dev Fired whenever the nonce gets cancelled (ex.: `cancelAuthorization`)\n\t *\n\t * @dev Both `AuthorizationUsed` and `AuthorizationCanceled` imply the nonce\n\t *      cannot be longer used, the only difference is that `AuthorizationCanceled`\n\t *      implies no smart contract state change made (except the nonce marked as cancelled)\n\t *\n\t * @param authorizer an address which has cancelled the nonce\n\t * @param nonce the nonce cancelled\n\t */\n\tevent AuthorizationCanceled(address indexed authorizer, bytes32 indexed nonce);\n\n\t/**\n\t * @notice Returns the state of an authorization, more specifically\n\t *      if the specified nonce was already used by the address specified\n\t *\n\t * @dev Nonces are expected to be client-side randomly generated 32-byte data\n\t *      unique to the authorizer's address\n\t *\n\t * @param authorizer    Authorizer's address\n\t * @param nonce         Nonce of the authorization\n\t * @return true if the nonce is used\n\t */\n\tfunction authorizationState(\n\t\taddress authorizer,\n\t\tbytes32 nonce\n\t) external view returns (bool);\n\n\t/**\n\t * @notice Execute a transfer with a signed authorization\n\t *\n\t * @param from          Payer's address (Authorizer)\n\t * @param to            Payee's address\n\t * @param value         Amount to be transferred\n\t * @param validAfter    The time after which this is valid (unix time)\n\t * @param validBefore   The time before which this is valid (unix time)\n\t * @param nonce         Unique nonce\n\t * @param v             v of the signature\n\t * @param r             r of the signature\n\t * @param s             s of the signature\n\t */\n\tfunction transferWithAuthorization(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 value,\n\t\tuint256 validAfter,\n\t\tuint256 validBefore,\n\t\tbytes32 nonce,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) external;\n\n\t/**\n\t * @notice Receive a transfer with a signed authorization from the payer\n\t *\n\t * @dev This has an additional check to ensure that the payee's address matches\n\t *      the caller of this function to prevent front-running attacks.\n\t * @dev See https://eips.ethereum.org/EIPS/eip-3009#security-considerations\n\t *\n\t * @param from          Payer's address (Authorizer)\n\t * @param to            Payee's address\n\t * @param value         Amount to be transferred\n\t * @param validAfter    The time after which this is valid (unix time)\n\t * @param validBefore   The time before which this is valid (unix time)\n\t * @param nonce         Unique nonce\n\t * @param v             v of the signature\n\t * @param r             r of the signature\n\t * @param s             s of the signature\n\t */\n\tfunction receiveWithAuthorization(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 value,\n\t\tuint256 validAfter,\n\t\tuint256 validBefore,\n\t\tbytes32 nonce,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) external;\n\n\t/**\n\t * @notice Attempt to cancel an authorization\n\t *\n\t * @param authorizer    Authorizer's address\n\t * @param nonce         Nonce of the authorization\n\t * @param v             v of the signature\n\t * @param r             r of the signature\n\t * @param s             s of the signature\n\t */\n\tfunction cancelAuthorization(\n\t\taddress authorizer,\n\t\tbytes32 nonce,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) external;\n}\n"
    },
    "contracts/interfaces/ERC1363Spec.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./ERC20Spec.sol\";\nimport \"./ERC165Spec.sol\";\n\n/**\n * @title ERC1363 Interface\n *\n * @dev Interface defining a ERC1363 Payable Token contract.\n *      Implementing contracts MUST implement the ERC1363 interface as well as the ERC20 and ERC165 interfaces.\n */\ninterface ERC1363 is ERC20, ERC165  {\n\t/*\n\t * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n\t * 0xb0202a11 ===\n\t *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n\t *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n\t *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n\t *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n\t *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n\t *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n\t */\n\n\t/**\n\t * @notice Transfer tokens from `msg.sender` to another address and then call `onTransferReceived` on receiver\n\t * @param to address The address which you want to transfer to\n\t * @param value uint256 The amount of tokens to be transferred\n\t * @return true unless throwing\n\t */\n\tfunction transferAndCall(address to, uint256 value) external returns (bool);\n\n\t/**\n\t * @notice Transfer tokens from `msg.sender` to another address and then call `onTransferReceived` on receiver\n\t * @param to address The address which you want to transfer to\n\t * @param value uint256 The amount of tokens to be transferred\n\t * @param data bytes Additional data with no specified format, sent in call to `to`\n\t * @return true unless throwing\n\t */\n\tfunction transferAndCall(address to, uint256 value, bytes memory data) external returns (bool);\n\n\t/**\n\t * @notice Transfer tokens from one address to another and then call `onTransferReceived` on receiver\n\t * @param from address The address which you want to send tokens from\n\t * @param to address The address which you want to transfer to\n\t * @param value uint256 The amount of tokens to be transferred\n\t * @return true unless throwing\n\t */\n\tfunction transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n\n\t/**\n\t * @notice Transfer tokens from one address to another and then call `onTransferReceived` on receiver\n\t * @param from address The address which you want to send tokens from\n\t * @param to address The address which you want to transfer to\n\t * @param value uint256 The amount of tokens to be transferred\n\t * @param data bytes Additional data with no specified format, sent in call to `to`\n\t * @return true unless throwing\n\t */\n\tfunction transferFromAndCall(address from, address to, uint256 value, bytes memory data) external returns (bool);\n\n\t/**\n\t * @notice Approve the passed address to spend the specified amount of tokens on behalf of msg.sender\n\t * and then call `onApprovalReceived` on spender.\n\t * @param spender address The address which will spend the funds\n\t * @param value uint256 The amount of tokens to be spent\n\t */\n\tfunction approveAndCall(address spender, uint256 value) external returns (bool);\n\n\t/**\n\t * @notice Approve the passed address to spend the specified amount of tokens on behalf of msg.sender\n\t * and then call `onApprovalReceived` on spender.\n\t * @param spender address The address which will spend the funds\n\t * @param value uint256 The amount of tokens to be spent\n\t * @param data bytes Additional data with no specified format, sent in call to `spender`\n\t */\n\tfunction approveAndCall(address spender, uint256 value, bytes memory data) external returns (bool);\n}\n\n/**\n * @title ERC1363Receiver Interface\n *\n * @dev Interface for any contract that wants to support `transferAndCall` or `transferFromAndCall`\n *      from ERC1363 token contracts.\n */\ninterface ERC1363Receiver {\n\t/*\n\t * Note: the ERC-165 identifier for this interface is 0x88a7ca5c.\n\t * 0x88a7ca5c === bytes4(keccak256(\"onTransferReceived(address,address,uint256,bytes)\"))\n\t */\n\n\t/**\n\t * @notice Handle the receipt of ERC1363 tokens\n\t *\n\t * @dev Any ERC1363 smart contract calls this function on the recipient\n\t *      after a `transfer` or a `transferFrom`. This function MAY throw to revert and reject the\n\t *      transfer. Return of other than the magic value MUST result in the\n\t *      transaction being reverted.\n\t *      Note: the token contract address is always the message sender.\n\t *\n\t * @param operator address The address which called `transferAndCall` or `transferFromAndCall` function\n\t * @param from address The address which are token transferred from\n\t * @param value uint256 The amount of tokens transferred\n\t * @param data bytes Additional data with no specified format\n\t * @return `bytes4(keccak256(\"onTransferReceived(address,address,uint256,bytes)\"))`\n\t *      unless throwing\n\t */\n\tfunction onTransferReceived(address operator, address from, uint256 value, bytes memory data) external returns (bytes4);\n}\n\n/**\n * @title ERC1363Spender Interface\n *\n * @dev Interface for any contract that wants to support `approveAndCall`\n *      from ERC1363 token contracts.\n */\ninterface ERC1363Spender {\n\t/*\n\t * Note: the ERC-165 identifier for this interface is 0x7b04a2d0.\n\t * 0x7b04a2d0 === bytes4(keccak256(\"onApprovalReceived(address,uint256,bytes)\"))\n\t */\n\n\t/**\n\t * @notice Handle the approval of ERC1363 tokens\n\t *\n\t * @dev Any ERC1363 smart contract calls this function on the recipient\n\t *      after an `approve`. This function MAY throw to revert and reject the\n\t *      approval. Return of other than the magic value MUST result in the\n\t *      transaction being reverted.\n\t *      Note: the token contract address is always the message sender.\n\t *\n\t * @param owner address The address which called `approveAndCall` function\n\t * @param value uint256 The amount of tokens to be spent\n\t * @param data bytes Additional data with no specified format\n\t * @return `bytes4(keccak256(\"onApprovalReceived(address,uint256,bytes)\"))`\n\t *      unless throwing\n\t */\n\tfunction onApprovalReceived(address owner, uint256 value, bytes memory data) external returns (bytes4);\n}\n"
    },
    "contracts/interfaces/ERC165Spec.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title ERC-165 Standard Interface Detection\n *\n * @dev Interface of the ERC165 standard, as defined in the\n *       https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * @dev Implementers can declare support of contract interfaces,\n *      which can then be queried by others.\n *\n * @author Christian Reitwießner, Nick Johnson, Fabian Vogelsteller, Jordi Baylina, Konrad Feldmeier, William Entriken\n */\ninterface ERC165 {\n\t/**\n\t * @notice Query if a contract implements an interface\n\t *\n\t * @dev Interface identification is specified in ERC-165.\n\t *      This function uses less than 30,000 gas.\n\t *\n\t * @param interfaceID The interface identifier, as specified in ERC-165\n\t * @return `true` if the contract implements `interfaceID` and\n\t *      `interfaceID` is not 0xffffffff, `false` otherwise\n\t */\n\tfunction supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/ERC20Spec.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title EIP-20: ERC-20 Token Standard\n *\n * @notice The ERC-20 (Ethereum Request for Comments 20), proposed by Fabian Vogelsteller in November 2015,\n *      is a Token Standard that implements an API for tokens within Smart Contracts.\n *\n * @notice It provides functionalities like to transfer tokens from one account to another,\n *      to get the current token balance of an account and also the total supply of the token available on the network.\n *      Besides these it also has some other functionalities like to approve that an amount of\n *      token from an account can be spent by a third party account.\n *\n * @notice If a Smart Contract implements the following methods and events it can be called an ERC-20 Token\n *      Contract and, once deployed, it will be responsible to keep track of the created tokens on Ethereum.\n *\n * @notice See https://ethereum.org/en/developers/docs/standards/tokens/erc-20/\n * @notice See https://eips.ethereum.org/EIPS/eip-20\n */\ninterface ERC20 {\n\t/**\n\t * @dev Fired in transfer(), transferFrom() to indicate that token transfer happened\n\t *\n\t * @param from an address tokens were consumed from\n\t * @param to an address tokens were sent to\n\t * @param value number of tokens transferred\n\t */\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n\n\t/**\n\t * @dev Fired in approve() to indicate an approval event happened\n\t *\n\t * @param owner an address which granted a permission to transfer\n\t *      tokens on its behalf\n\t * @param spender an address which received a permission to transfer\n\t *      tokens on behalf of the owner `_owner`\n\t * @param value amount of tokens granted to transfer on behalf\n\t */\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\n\n\t/**\n\t * @return name of the token (ex.: USD Coin)\n\t */\n\t// OPTIONAL - This method can be used to improve usability,\n\t// but interfaces and other contracts MUST NOT expect these values to be present.\n\t// function name() external view returns (string memory);\n\n\t/**\n\t * @return symbol of the token (ex.: USDC)\n\t */\n\t// OPTIONAL - This method can be used to improve usability,\n\t// but interfaces and other contracts MUST NOT expect these values to be present.\n\t// function symbol() external view returns (string memory);\n\n\t/**\n\t * @dev Returns the number of decimals used to get its user representation.\n\t *      For example, if `decimals` equals `2`, a balance of `505` tokens should\n\t *      be displayed to a user as `5,05` (`505 / 10 ** 2`).\n\t *\n\t * @dev Tokens usually opt for a value of 18, imitating the relationship between\n\t *      Ether and Wei. This is the value {ERC20} uses, unless this function is\n\t *      overridden;\n\t *\n\t * @dev NOTE: This information is only used for _display_ purposes: it in\n\t *      no way affects any of the arithmetic of the contract, including\n\t *      {IERC20-balanceOf} and {IERC20-transfer}.\n\t *\n\t * @return token decimals\n\t */\n\t// OPTIONAL - This method can be used to improve usability,\n\t// but interfaces and other contracts MUST NOT expect these values to be present.\n\t// function decimals() external view returns (uint8);\n\n\t/**\n\t * @return the amount of tokens in existence\n\t */\n\tfunction totalSupply() external view returns (uint256);\n\n\t/**\n\t * @notice Gets the balance of a particular address\n\t *\n\t * @param _owner the address to query the the balance for\n\t * @return balance an amount of tokens owned by the address specified\n\t */\n\tfunction balanceOf(address _owner) external view returns (uint256 balance);\n\n\t/**\n\t * @notice Transfers some tokens to an external address or a smart contract\n\t *\n\t * @dev Called by token owner (an address which has a\n\t *      positive token balance tracked by this smart contract)\n\t * @dev Throws on any error like\n\t *      * insufficient token balance or\n\t *      * incorrect `_to` address:\n\t *          * zero address or\n\t *          * self address or\n\t *          * smart contract which doesn't support ERC20\n\t *\n\t * @param _to an address to transfer tokens to,\n\t *      must be either an external address or a smart contract,\n\t *      compliant with the ERC20 standard\n\t * @param _value amount of tokens to be transferred,, zero\n\t *      value is allowed\n\t * @return success true on success, throws otherwise\n\t */\n\tfunction transfer(address _to, uint256 _value) external returns (bool success);\n\n\t/**\n\t * @notice Transfers some tokens on behalf of address `_from' (token owner)\n\t *      to some other address `_to`\n\t *\n\t * @dev Called by token owner on his own or approved address,\n\t *      an address approved earlier by token owner to\n\t *      transfer some amount of tokens on its behalf\n\t * @dev Throws on any error like\n\t *      * insufficient token balance or\n\t *      * incorrect `_to` address:\n\t *          * zero address or\n\t *          * same as `_from` address (self transfer)\n\t *          * smart contract which doesn't support ERC20\n\t *\n\t * @param _from token owner which approved caller (transaction sender)\n\t *      to transfer `_value` of tokens on its behalf\n\t * @param _to an address to transfer tokens to,\n\t *      must be either an external address or a smart contract,\n\t *      compliant with the ERC20 standard\n\t * @param _value amount of tokens to be transferred,, zero\n\t *      value is allowed\n\t * @return success true on success, throws otherwise\n\t */\n\tfunction transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n\n\t/**\n\t * @notice Approves address called `_spender` to transfer some amount\n\t *      of tokens on behalf of the owner (transaction sender)\n\t *\n\t * @dev Transaction sender must not necessarily own any tokens to grant the permission\n\t *\n\t * @param _spender an address approved by the caller (token owner)\n\t *      to spend some tokens on its behalf\n\t * @param _value an amount of tokens spender `_spender` is allowed to\n\t *      transfer on behalf of the token owner\n\t * @return success true on success, throws otherwise\n\t */\n\tfunction approve(address _spender, uint256 _value) external returns (bool success);\n\n\t/**\n\t * @notice Returns the amount which _spender is still allowed to withdraw from _owner.\n\t *\n\t * @dev A function to check an amount of tokens owner approved\n\t *      to transfer on its behalf by some other address called \"spender\"\n\t *\n\t * @param _owner an address which approves transferring some tokens on its behalf\n\t * @param _spender an address approved to transfer some tokens on behalf\n\t * @return remaining an amount of tokens approved address `_spender` can transfer on behalf\n\t *      of token owner `_owner`\n\t */\n\tfunction allowance(address _owner, address _spender) external view returns (uint256 remaining);\n}\n\n/**\n * @title Mintable/burnable ERC20 Extension\n *\n * @notice Adds mint/burn functions to ERC20 interface, these functions\n *      are usually present in ERC20 implementations, but these become\n *      a must for the bridged tokens in L2 since the bridge on L2\n *      needs to have a way to mint tokens deposited from L1 to L2\n *      and to burn tokens to be withdrawn from L2 to L1\n */\ninterface MintableBurnableERC20 is ERC20 {\n\t/**\n\t * @dev Mints (creates) some tokens to address specified\n\t * @dev The value specified is treated as is without taking\n\t *      into account what `decimals` value is\n\t *\n\t * @param _to an address to mint tokens to\n\t * @param _value an amount of tokens to mint (create)\n\t */\n\tfunction mint(address _to, uint256 _value) external;\n\n\t/**\n\t * @dev Burns (destroys) some tokens from the address specified\n\t *\n\t * @dev The value specified is treated as is without taking\n\t *      into account what `decimals` value is\n\t *\n\t * @param _from an address to burn some tokens from\n\t * @param _value an amount of tokens to burn (destroy)\n\t */\n\tfunction burn(address _from, uint256 _value) external;\n}\n"
    },
    "contracts/interfaces/ERC721Spec.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./ERC165Spec.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard\n *\n * @notice See https://eips.ethereum.org/EIPS/eip-721\n *\n * @dev Solidity issue #3412: The ERC721 interfaces include explicit mutability guarantees for each function.\n *      Mutability guarantees are, in order weak to strong: payable, implicit nonpayable, view, and pure.\n *      Implementation MUST meet the mutability guarantee in this interface and MAY meet a stronger guarantee.\n *      For example, a payable function in this interface may be implemented as nonpayable\n *      (no state mutability specified) in implementing contract.\n *      It is expected a later Solidity release will allow stricter contract to inherit from this interface,\n *      but current workaround is that we edit this interface to add stricter mutability before inheriting:\n *      we have removed all \"payable\" modifiers.\n *\n * @dev The ERC-165 identifier for this interface is 0x80ac58cd.\n *\n * @author William Entriken, Dieter Shirley, Jacob Evans, Nastassia Sachs\n */\ninterface ERC721 is ERC165 {\n\t/// @dev This emits when ownership of any NFT changes by any mechanism.\n\t///  This event emits when NFTs are created (`from` == 0) and destroyed\n\t///  (`to` == 0). Exception: during contract creation, any number of NFTs\n\t///  may be created and assigned without emitting Transfer. At the time of\n\t///  any transfer, the approved address for that NFT (if any) is reset to none.\n\tevent Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\n\n\t/// @dev This emits when the approved address for an NFT is changed or\n\t///  reaffirmed. The zero address indicates there is no approved address.\n\t///  When a Transfer event emits, this also indicates that the approved\n\t///  address for that NFT (if any) is reset to none.\n\tevent Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\n\n\t/// @dev This emits when an operator is enabled or disabled for an owner.\n\t///  The operator can manage all NFTs of the owner.\n\tevent ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n\n\t/// @notice Count all NFTs assigned to an owner\n\t/// @dev NFTs assigned to the zero address are considered invalid, and this\n\t///  function throws for queries about the zero address.\n\t/// @param _owner An address for whom to query the balance\n\t/// @return The number of NFTs owned by `_owner`, possibly zero\n\tfunction balanceOf(address _owner) external view returns (uint256);\n\n\t/// @notice Find the owner of an NFT\n\t/// @dev NFTs assigned to zero address are considered invalid, and queries\n\t///  about them do throw.\n\t/// @param _tokenId The identifier for an NFT\n\t/// @return The address of the owner of the NFT\n\tfunction ownerOf(uint256 _tokenId) external view returns (address);\n\n\t/// @notice Transfers the ownership of an NFT from one address to another address\n\t/// @dev Throws unless `msg.sender` is the current owner, an authorized\n\t///  operator, or the approved address for this NFT. Throws if `_from` is\n\t///  not the current owner. Throws if `_to` is the zero address. Throws if\n\t///  `_tokenId` is not a valid NFT. When transfer is complete, this function\n\t///  checks if `_to` is a smart contract (code size > 0). If so, it calls\n\t///  `onERC721Received` on `_to` and throws if the return value is not\n\t///  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n\t/// @param _from The current owner of the NFT\n\t/// @param _to The new owner\n\t/// @param _tokenId The NFT to transfer\n\t/// @param _data Additional data with no specified format, sent in call to `_to`\n\tfunction safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external /*payable*/;\n\n\t/// @notice Transfers the ownership of an NFT from one address to another address\n\t/// @dev This works identically to the other function with an extra data parameter,\n\t///  except this function just sets data to \"\".\n\t/// @param _from The current owner of the NFT\n\t/// @param _to The new owner\n\t/// @param _tokenId The NFT to transfer\n\tfunction safeTransferFrom(address _from, address _to, uint256 _tokenId) external /*payable*/;\n\n\t/// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\n\t///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\n\t///  THEY MAY BE PERMANENTLY LOST\n\t/// @dev Throws unless `msg.sender` is the current owner, an authorized\n\t///  operator, or the approved address for this NFT. Throws if `_from` is\n\t///  not the current owner. Throws if `_to` is the zero address. Throws if\n\t///  `_tokenId` is not a valid NFT.\n\t/// @param _from The current owner of the NFT\n\t/// @param _to The new owner\n\t/// @param _tokenId The NFT to transfer\n\tfunction transferFrom(address _from, address _to, uint256 _tokenId) external /*payable*/;\n\n\t/// @notice Change or reaffirm the approved address for an NFT\n\t/// @dev The zero address indicates there is no approved address.\n\t///  Throws unless `msg.sender` is the current NFT owner, or an authorized\n\t///  operator of the current owner.\n\t/// @param _approved The new approved NFT controller\n\t/// @param _tokenId The NFT to approve\n\tfunction approve(address _approved, uint256 _tokenId) external /*payable*/;\n\n\t/// @notice Enable or disable approval for a third party (\"operator\") to manage\n\t///  all of `msg.sender`'s assets\n\t/// @dev Emits the ApprovalForAll event. The contract MUST allow\n\t///  multiple operators per owner.\n\t/// @param _operator Address to add to the set of authorized operators\n\t/// @param _approved True if the operator is approved, false to revoke approval\n\tfunction setApprovalForAll(address _operator, bool _approved) external;\n\n\t/// @notice Get the approved address for a single NFT\n\t/// @dev Throws if `_tokenId` is not a valid NFT.\n\t/// @param _tokenId The NFT to find the approved address for\n\t/// @return The approved address for this NFT, or the zero address if there is none\n\tfunction getApproved(uint256 _tokenId) external view returns (address);\n\n\t/// @notice Query if an address is an authorized operator for another address\n\t/// @param _owner The address that owns the NFTs\n\t/// @param _operator The address that acts on behalf of the owner\n\t/// @return True if `_operator` is an approved operator for `_owner`, false otherwise\n\tfunction isApprovedForAll(address _owner, address _operator) external view returns (bool);\n}\n\n/// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.\ninterface ERC721TokenReceiver {\n\t/// @notice Handle the receipt of an NFT\n\t/// @dev The ERC721 smart contract calls this function on the recipient\n\t///  after a `transfer`. This function MAY throw to revert and reject the\n\t///  transfer. Return of other than the magic value MUST result in the\n\t///  transaction being reverted.\n\t///  Note: the contract address is always the message sender.\n\t/// @param _operator The address which called `safeTransferFrom` function\n\t/// @param _from The address which previously owned the token\n\t/// @param _tokenId The NFT identifier which is being transferred\n\t/// @param _data Additional data with no specified format\n\t/// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n\t///  unless throwing\n\tfunction onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4);\n}\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n *\n * @notice See https://eips.ethereum.org/EIPS/eip-721\n *\n * @dev The ERC-165 identifier for this interface is 0x5b5e139f.\n *\n * @author William Entriken, Dieter Shirley, Jacob Evans, Nastassia Sachs\n */\ninterface ERC721Metadata is ERC721 {\n\t/// @notice A descriptive name for a collection of NFTs in this contract\n\tfunction name() external view returns (string memory _name);\n\n\t/// @notice An abbreviated name for NFTs in this contract\n\tfunction symbol() external view returns (string memory _symbol);\n\n\t/// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\n\t/// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\n\t///  3986. The URI may point to a JSON file that conforms to the \"ERC721\n\t///  Metadata JSON Schema\".\n\tfunction tokenURI(uint256 _tokenId) external view returns (string memory);\n}\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n *\n * @notice See https://eips.ethereum.org/EIPS/eip-721\n *\n * @dev The ERC-165 identifier for this interface is 0x780e9d63.\n *\n * @author William Entriken, Dieter Shirley, Jacob Evans, Nastassia Sachs\n */\ninterface ERC721Enumerable is ERC721 {\n\t/// @notice Count NFTs tracked by this contract\n\t/// @return A count of valid NFTs tracked by this contract, where each one of\n\t///  them has an assigned and queryable owner not equal to the zero address\n\tfunction totalSupply() external view returns (uint256);\n\n\t/// @notice Enumerate valid NFTs\n\t/// @dev Throws if `_index` >= `totalSupply()`.\n\t/// @param _index A counter less than `totalSupply()`\n\t/// @return The token identifier for the `_index`th NFT,\n\t///  (sort order not specified)\n\tfunction tokenByIndex(uint256 _index) external view returns (uint256);\n\n\t/// @notice Enumerate NFTs assigned to an owner\n\t/// @dev Throws if `_index` >= `balanceOf(_owner)` or if\n\t///  `_owner` is the zero address, representing invalid NFTs.\n\t/// @param _owner An address where we are interested in NFTs owned by them\n\t/// @param _index A counter less than `balanceOf(_owner)`\n\t/// @return The token identifier for the `_index`th NFT assigned to `_owner`,\n\t///   (sort order not specified)\n\tfunction tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/ERC721SpecExt.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title Mintable ERC721\n *\n * @notice Defines mint capabilities for Alethea ERC721 tokens.\n *      This interface should be treated as a definition of what mintable means for ERC721\n */\ninterface MintableERC721 {\n\t/**\n\t * @notice Checks if specified token exists\n\t *\n\t * @dev Returns whether the specified token ID has an ownership\n\t *      information associated with it\n\t *\n\t * @param _tokenId ID of the token to query existence for\n\t * @return whether the token exists (true - exists, false - doesn't exist)\n\t */\n\tfunction exists(uint256 _tokenId) external view returns(bool);\n\n\t/**\n\t * @dev Creates new token with token ID specified\n\t *      and assigns an ownership `_to` for this token\n\t *\n\t * @dev Unsafe: doesn't execute `onERC721Received` on the receiver.\n\t *      Prefer the use of `safeMint` instead of `mint`.\n\t *\n\t * @dev Should have a restricted access handled by the implementation\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId ID of the token to mint\n\t */\n\tfunction mint(address _to, uint256 _tokenId) external;\n\n\t/**\n\t * @dev Creates new tokens starting with token ID specified\n\t *      and assigns an ownership `_to` for these tokens\n\t *\n\t * @dev Token IDs to be minted: [_tokenId, _tokenId + n)\n\t *\n\t * @dev n must be greater or equal 2: `n > 1`\n\t *\n\t * @dev Unsafe: doesn't execute `onERC721Received` on the receiver.\n\t *      Prefer the use of `safeMintBatch` instead of `mintBatch`.\n\t *\n\t * @dev Should have a restricted access handled by the implementation\n\t *\n\t * @param _to an address to mint tokens to\n\t * @param _tokenId ID of the first token to mint\n\t * @param n how many tokens to mint, sequentially increasing the _tokenId\n\t */\n\tfunction mintBatch(address _to, uint256 _tokenId, uint256 n) external;\n\n\t/**\n\t * @dev Creates new token with token ID specified\n\t *      and assigns an ownership `_to` for this token\n\t *\n\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\n\t *      `onERC721Received` on `_to` and throws if the return value is not\n\t *      `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n\t *\n\t * @dev Should have a restricted access handled by the implementation\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId ID of the token to mint\n\t */\n\tfunction safeMint(address _to, uint256 _tokenId) external;\n\n\t/**\n\t * @dev Creates new token with token ID specified\n\t *      and assigns an ownership `_to` for this token\n\t *\n\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\n\t *      `onERC721Received` on `_to` and throws if the return value is not\n\t *      `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n\t *\n\t * @dev Should have a restricted access handled by the implementation\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId ID of the token to mint\n\t * @param _data additional data with no specified format, sent in call to `_to`\n\t */\n\tfunction safeMint(address _to, uint256 _tokenId, bytes memory _data) external;\n\n\t/**\n\t * @dev Creates new tokens starting with token ID specified\n\t *      and assigns an ownership `_to` for these tokens\n\t *\n\t * @dev Token IDs to be minted: [_tokenId, _tokenId + n)\n\t *\n\t * @dev n must be greater or equal 2: `n > 1`\n\t *\n\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\n\t *      `onERC721Received` on `_to` and throws if the return value is not\n\t *      `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n\t *\n\t * @dev Should have a restricted access handled by the implementation\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId ID of the token to mint\n\t * @param n how many tokens to mint, sequentially increasing the _tokenId\n\t */\n\tfunction safeMintBatch(address _to, uint256 _tokenId, uint256 n) external;\n\n\t/**\n\t * @dev Creates new tokens starting with token ID specified\n\t *      and assigns an ownership `_to` for these tokens\n\t *\n\t * @dev Token IDs to be minted: [_tokenId, _tokenId + n)\n\t *\n\t * @dev n must be greater or equal 2: `n > 1`\n\t *\n\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\n\t *      `onERC721Received` on `_to` and throws if the return value is not\n\t *      `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n\t *\n\t * @dev Should have a restricted access handled by the implementation\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId ID of the token to mint\n\t * @param n how many tokens to mint, sequentially increasing the _tokenId\n\t * @param _data additional data with no specified format, sent in call to `_to`\n\t */\n\tfunction safeMintBatch(address _to, uint256 _tokenId, uint256 n, bytes memory _data) external;\n}\n\n/**\n * @title Alethea Burnable ERC721\n *\n * @notice Defines burn capabilities for Alethea ERC721 tokens.\n *      This interface should be treated as a definition of what burnable means for ERC721\n */\ninterface BurnableERC721 {\n\t/**\n\t * @notice Destroys the token with token ID specified\n\t *\n\t * @dev Should be accessible publicly by token owners.\n\t *      May have a restricted access handled by the implementation\n\t *\n\t * @param _tokenId ID of the token to burn\n\t */\n\tfunction burn(uint256 _tokenId) external;\n}\n\n/**\n * @title With Base URI\n *\n * @notice A marker interface for the contracts having the baseURI() function\n *      or public string variable named baseURI\n *      NFT implementations like TinyERC721, or ShortERC721 are example of such smart contracts\n */\ninterface WithBaseURI {\n\t/**\n\t * @dev Usually used in NFT implementations to construct ERC721Metadata.tokenURI as\n\t *      `base URI + token ID` if token URI is not set (not present in `_tokenURIs` mapping)\n\t *\n\t * @dev For example, if base URI is https://api.com/token/, then token #1\n\t *      will have an URI https://api.com/token/1\n\t */\n\tfunction baseURI() external view returns(string memory);\n}\n"
    },
    "contracts/interfaces/ImmutableSpec.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title Immutable X Mintable Specification\n *\n * @notice Interfaces supporting IMX integration:\n *      - ImmutableMintableERC20: @imtbl/imx-contracts/contracts/IMintable.sol\n *      - ImmutableMintableERC721: @imtbl/imx-contracts/contracts/IMintable.sol\n *\n * @dev See https://docs.x.immutable.com/docs/minting-assets-1\n * @dev See https://docs.x.immutable.com/docs/partner-nft-minting-setup\n */\n\n/**\n * @dev IMX Mintable interface, enables Layer 2 minting in IMX,\n *      see https://docs.x.immutable.com/docs/minting-assets-1\n *\n * @dev See @imtbl/imx-contracts/contracts/IMintable.sol\n */\ninterface ImmutableMintableERC20 {\n\t/**\n\t * @dev Mints ERC20 tokens\n\t *\n\t * @param to address to mint tokens to\n\t * @param amount amount of tokens to mint\n\t * @param mintingBlob [optional] data structure supplied\n\t */\n\tfunction mintFor(address to, uint256 amount, bytes memory mintingBlob) external;\n}\n\n/**\n * @dev IMX Mintable interface, enables Layer 2 minting in IMX,\n *      see https://docs.x.immutable.com/docs/minting-assets-1\n *\n * @dev See @imtbl/imx-contracts/contracts/IMintable.sol\n */\ninterface ImmutableMintableERC721 {\n\t/**\n\t * @dev Mints an NFT\n\t *\n\t * @param to address to mint NFT to\n\t * @param id ID of the NFT to mint\n\t * @param mintingBlob [optional] data structure stored alongside with NFT\n\t */\n\tfunction mintFor(address to, uint256 id, bytes memory mintingBlob) external;\n}\n"
    },
    "contracts/interfaces/MaticSpec.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {ERC20} from \"./ERC20Spec.sol\";\nimport {ERC721} from \"./ERC721Spec.sol\";\nimport {IERC1155} from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\n\n/**\n * @title Matic Mintable Specification\n *\n * @notice Interfaces supporting Matic integration:\n *      - MaticMintableERC20: https://github.com/maticnetwork/pos-portal/blob/master/contracts/root/RootToken/IMintableERC20.sol\n *      - MaticMintableERC721: https://github.com/maticnetwork/pos-portal/blob/master/contracts/root/RootToken/IMintableERC721.sol\n *      - MaticMintableERC1155: https://github.com/maticnetwork/pos-portal/blob/master/contracts/root/RootToken/IMintableERC1155.sol\n *\n * @dev See https://docs.matic.network/docs/develop/ethereum-matic/mintable-assets\n */\n\n/**\n * @dev Matic Mintable ERC20 interface, enables Layer 2 minting in Matic,\n *      see https://docs.matic.network/docs/develop/ethereum-matic/mintable-assets\n */\ninterface MaticMintableERC20 is ERC20 {\n\t/**\n\t * @notice called by predicate contract to mint tokens while withdrawing\n\t * @dev Should be callable only by MintableERC20Predicate\n\t * Make sure minting is done only by this function\n\t * @param user user address for whom token is being minted\n\t * @param amount amount of token being minted\n\t */\n\tfunction mint(address user, uint256 amount) external;\n}\n\n/**\n * @dev Matic Mintable ERC721 interface, enables Layer 2 minting in Matic,\n *      see https://docs.matic.network/docs/develop/ethereum-matic/mintable-assets\n */\ninterface MaticMintableERC721 is ERC721 {\n\t/**\n\t * @notice called by predicate contract to mint tokens while withdrawing\n\t * @dev Should be callable only by MintableERC721Predicate\n\t * Make sure minting is done only by this function\n\t * @param user user address for whom token is being minted\n\t * @param tokenId tokenId being minted\n\t */\n\tfunction mint(address user, uint256 tokenId) external;\n\n\t/**\n\t * @notice called by predicate contract to mint tokens while withdrawing with metadata from L2\n\t * @dev Should be callable only by MintableERC721Predicate\n\t * Make sure minting is only done either by this function/ 👆\n\t * @param user user address for whom token is being minted\n\t * @param tokenId tokenId being minted\n\t * @param metaData Associated token metadata, to be decoded & set using `setTokenMetadata`\n\t *\n\t * Note : If you're interested in taking token metadata from L2 to L1 during exit, you must\n\t * implement this method\n\t */\n\tfunction mint(address user, uint256 tokenId, bytes calldata metaData) external;\n\n\t/**\n\t * @notice check if token already exists, return true if it does exist\n\t * @dev this check will be used by the predicate to determine if the token needs to be minted or transfered\n\t * @param tokenId tokenId being checked\n\t */\n\tfunction exists(uint256 tokenId) external view returns (bool);\n}\n\n/**\n * @dev Matic Mintable ERC1155 interface, enables Layer 2 minting in Matic,\n *      see https://docs.matic.network/docs/develop/ethereum-matic/mintable-assets\n */\ninterface MaticMintableERC1155 is IERC1155 {\n\t/**\n\t * @notice Creates `amount` tokens of token type `id`, and assigns them to `account`.\n\t * @dev Should be callable only by MintableERC1155Predicate\n\t * Make sure minting is done only by this function\n\t * @param account user address for whom token is being minted\n\t * @param id token which is being minted\n\t * @param amount amount of token being minted\n\t * @param data extra byte data to be accompanied with minted tokens\n\t */\n\tfunction mint(address account, uint256 id, uint256 amount, bytes calldata data) external;\n\n\t/**\n\t * @notice Batched version of singular token minting, where\n\t * for each token in `ids` respective amount to be minted from `amounts`\n\t * array, for address `to`.\n\t * @dev Should be callable only by MintableERC1155Predicate\n\t * Make sure minting is done only by this function\n\t * @param to user address for whom token is being minted\n\t * @param ids tokens which are being minted\n\t * @param amounts amount of each token being minted\n\t * @param data extra byte data to be accompanied with minted tokens\n\t */\n\tfunction mintBatch(address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;\n}\n"
    },
    "contracts/layer_zero/interfaces/ILayerZeroEndpointExtension.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@layerzerolabs/lz-evm-sdk-v1-0.7/contracts/interfaces/ILayerZeroEndpoint.sol\";\nimport \"@layerzerolabs/lz-evm-sdk-v1-0.7/contracts/interfaces/ILayerZeroMessagingLibrary.sol\";\n\n/**\n * @notice Useful function not present in ILayerZeroEndpoint,\n *      but required for proper application deployment and configuration locking\n */\ninterface ILayerZeroEndpointExtension is ILayerZeroEndpoint {\n\tfunction latestVersion() external view returns(uint16);\n\t// version -> ILayerZeroEndpointLibrary\n\tfunction libraryLookup(uint16) external view returns(ILayerZeroMessagingLibrary);\n\n\t// default send/receive libraries\n\tfunction defaultSendVersion() external view returns(uint16);\n\tfunction defaultReceiveVersion() external view returns(uint16);\n\tfunction defaultSendLibrary() external view returns(ILayerZeroMessagingLibrary);\n\tfunction defaultReceiveLibraryAddress() external view returns(address);\n\n\tstruct LibraryConfig {\n\t\tuint16 sendVersion;\n\t\tuint16 receiveVersion;\n\t\taddress receiveLibraryAddress;\n\t\tILayerZeroMessagingLibrary sendLibrary;\n\t}\n\n\t// user app config = [uaAddress]\n\tfunction uaConfigLookup(address) external view returns (LibraryConfig calldata);\n}\n"
    },
    "contracts/layer_zero/interfaces/ILayerZeroMessagingLibraryExtension.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@layerzerolabs/lz-evm-sdk-v1-0.7/contracts/interfaces/ILayerZeroMessagingLibrary.sol\";\n\n/**\n * @notice Useful function not present in ILayerZeroMessagingLibrary,\n *      but required for proper application deployment and configuration locking\n */\ninterface ILayerZeroMessagingLibraryExtension is ILayerZeroMessagingLibrary {\n\t// Application config\n\tstruct ApplicationConfiguration {\n\t\tuint16 inboundProofLibraryVersion;\n\t\tuint64 inboundBlockConfirmations;\n\t\taddress relayer;\n\t\tuint16 outboundProofType;\n\t\tuint64 outboundBlockConfirmations;\n\t\taddress oracle;\n\t}\n\n\t// User Application\n\t// app address => chainId => config\n\tfunction appConfig(address, uint16) external view returns(ApplicationConfiguration calldata);\n\t// default UA settings if no version specified\n\tfunction defaultAppConfig(uint16) external view returns(ApplicationConfiguration calldata);\n\tfunction defaultAdapterParams(uint16, uint16) external view returns (bytes calldata);\n}\n"
    },
    "contracts/layer_zero/LzERC20ChildTunnelV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// use non-strict version pragma to simplify contract imports in other projects\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ERC20Spec.sol\";\nimport \"./NonblockingUpgradeableLzApp.sol\";\n\n/**\n * @title LayerZero ERC20 Child Tunnel\n *\n * @notice Non-Ethereum network (child chain - L2) exit of the ERC20 tunnel,\n *      can be used for Non-Ethereum mainnet and testnet networks (ex. Polygon/Mumbai)\n *\n * @notice The tunnel is used to bridge specific ERC20 token between L1/L2;\n *      we call L1 -> L2 bridging a \"deposit\", L2 -> L1 a \"withdrawal\"\n *\n * @notice The tunnel has two entrances and two exits:\n *       LzERC20RootTunnel contains Root/L1 entrance and exit,\n *       and LzERC20ChildTunnel contains Child/L2 entrance and exit\n *\n * @notice All exits and child entrance are always open, while root entrance\n *      may get paused or even closed permanently\n *\n * @notice Deposit flow:\n *      1. The user initiates a deposit on the L1 entrance by executing the deposit function\n *         `LzERC20RootTunnel.deposit` or `LzERC20RootTunnel.depositTo`\n *      2. LayerZero messaging system picks up the event emitted by the `deposit` call\n *         and delivers it to L2 chain\n *      3. The deposit completes on the L2 exit when LayerZero messaging system executes\n *         the `LzERC20ChildTunnel.lzReceive` function\n *      Note: overall, the user executes only one function and then just waits for the bridge\n *         operation to complete\n *\n * @notice Withdrawal flow:\n *      1. The user initiates a withdrawal on the L2 entrance by executing the withdraw function\n *         `LzERC20ChildTunnel.withdraw` or `LzERC20ChildTunnel.withdrawTo`\n *      2. LayerZero messaging system picks up the event emitted by the `withdraw` call\n *         and delivers it to L1 chain\n *      3. The withdrawal completes on the L1 exit when LayerZero messaging system executes\n *         the `LzERC20RootTunnel.lzReceive` function\n *      Note: overall, the user executes only one function and then just waits for the bridge\n *         operation to complete\n *\n * @dev see https://github.com/LayerZero-Labs/LayerZero\n * @dev see https://github.com/LayerZero-Labs/solidity-examples\n */\ncontract LzERC20ChildTunnelV1 is NonblockingUpgradeableLzApp {\n\t/**\n\t * @notice Child tunnel is strictly bound to the child ERC20 token\n\t */\n\tMintableBurnableERC20 public /*immutable*/ childToken;\n\n\t/**\n\t * @notice LayerZero specific chainId where the LzERC20RootTunnel is deployed\n\t *\n\t * @dev Incoming messages must specify this chainId in order to be accepted\n\t *      see https://layerzero.gitbook.io/docs/technical-reference/mainnet/supported-chain-ids\n\t *      see https://layerzero.gitbook.io/docs/technical-reference/testnet/testnet-addresses\n\t */\n\tuint16 public rootTunnelChainId;\n\n\t/**\n\t * @notice The address of the deployed LzERC20RootTunnel which is bound to this LzERC20ChildTunnel\n\t *\n\t * @dev Incoming messages must specify this LzERC20RootTunnel address in order to be accepted\n\t */\n\taddress public rootTunnelAddress;\n\n\t/**\n\t * @notice People do mistakes and may send tokens by mistake\n\t *\n\t * @notice Rescue manager is responsible for \"rescuing\" ERC20/ERC721 tokens\n\t *      accidentally sent to the smart contract\n\t *\n\t * @dev Role ROLE_RESCUE_MANAGER allows withdrawing non-bridged ERC20/ERC721\n\t *      tokens stored on the smart contract balance via `rescueTokens` function\n\t */\n\tuint32 public constant ROLE_RESCUE_MANAGER = 0x0001_0000;\n\n\t/**\n\t * @dev Fired in `lzReceive` when token deposit completes successfully\n\t *\n\t * @param stateId unique tx identifier submitted from the root chain (L1)\n\t * @param from token sender address in the root chain (L1)\n\t * @param to token receiver address in the child chain (L2)\n\t * @param value amount of tokens deposited\n\t */\n\tevent DepositComplete(uint256 indexed stateId, address indexed from, address indexed to, uint256 value);\n\n\t/**\n\t * @dev Fired in `withdraw` and `withdrawTo`\n\t *\n\t * @param from token sender address in the child chain (L2)\n\t * @param to token receiver address in the root chain (L1)\n\t * @param value amount of tokens withdrawn\n\t */\n\tevent WithdrawalInitiated(address indexed from, address indexed to, uint256 value);\n\n\t/**\n\t * @dev \"Constructor replacement\" for upgradeable, must be execute immediately after deployment\n\t *      see https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#initializers\n\t *\n\t * @dev Initializes an Non-Ethereum network (L2) exit bound to\n\t *      LayerZero Endpoint, and child ERC20 token\n\t * @dev LayerZero Endpoint is a helper contract providing\n\t *      L1/L2 messaging infrastructure, managed by the LayerZero\n\t *\n\t * @param _lzEndpoint LayerZero Endpoint contract address (maintained by LayerZero)\n\t * @param _childToken child ERC20 token address\n\t */\n\tfunction postConstruct(address _lzEndpoint, address _childToken) public initializer {\n\t\t// execute parent initializer\n\t\t_postConstruct(msg.sender);\n\n\t\t// verify the inputs are set\n\t\trequire(_lzEndpoint != address(0), \"LZ endpoint not set\");\n\t\trequire(_childToken != address(0), \"child token not set\");\n\n\t\t// initialize contract internal state\n\t\t__NonblockingUpgradeableLzApp_init(_lzEndpoint);\n\t\tchildToken = MintableBurnableERC20(_childToken);\n\t}\n\n\t/**\n\t * @dev Sets the rootTunnel if it is not yet set\n\t *\n\t * @param _rootTunnelChainId root tunnel chain ID to set\n\t * @param _rootTunnelAddress root tunnel address to set\n\t */\n\tfunction setRootTunnel(uint16 _rootTunnelChainId, address _rootTunnelAddress) public {\n\t\t// `setRootTunnel` must be executed during the deployment process by\n\t\t// the same account which is making a deployment (full admin)\n\t\trequire(isSenderInRole(type(uint256).max), \"access denied\");\n\n\t\t// verify the chain ID is set (not zero)\n\t\trequire(_rootTunnelChainId != 0, \"zero chain ID\");\n\t\t// verify the address is set (not zero)\n\t\trequire(_rootTunnelAddress != address(0), \"zero address\");\n\n\t\t// verify the address is not yet set on the contract\n\t\trequire(rootTunnelChainId == 0 && rootTunnelAddress == address(0), \"root tunnel already set\");\n\n\t\t// set the tunnel\n\t\trootTunnelChainId = _rootTunnelChainId;\n\t\trootTunnelAddress = _rootTunnelAddress;\n\n\t\t// propagate the setup to `LzAppUpgradeable`\n\t\t_setTrustedRemote(_rootTunnelChainId, abi.encodePacked(_rootTunnelAddress, address(this)));\n\t}\n\n\t/**\n\t * @notice L2 Tunnel Exit.\n\t *      L2 Tunnel is always open in both directions.\n\t *\n\t * @dev Auxiliary function which can be executed only within the smart contract itself\n\t *      Effectively private (internal) as it is not callable by other contracts or EOAs\n\t *\n\t * @dev Wrapped by the ILayerZeroReceiver lzReceive catching any error and logging it\n\t *      See `ILayerZeroReceiver.lzReceive`\n\t */\n\tfunction _nonblockingLzReceive(uint16, bytes memory, uint64 _nonce, bytes memory _payload) internal override {\n\t\t// decode the message from the root\n\t\t// format: sender, recipient, amount\n\t\t(address _from, address _to, uint256 _value) = abi.decode(_payload, (address, address, uint256));\n\n\t\t// mint the requested amount of tokens in the child chain\n\t\tchildToken.mint(_to, _value);\n\n\t\t// emit an event\n\t\temit DepositComplete(_nonce, _from, _to, _value);\n\t}\n\n\t/**\n\t * @notice L2 Tunnel Entrance.\n\t *      L2 Tunnel is always open in both directions.\n\t *\n\t * @notice Initiates the withdrawal from the child chain (L2) into the root chain (L1)\n\t *      to the same address which initiated the withdrawal process\n\t *\n\t * @notice The process is finalized in the root chain (L1) via the\n\t *      `LzERC20RootTunnel.lzReceive` without the user/initiator participation\n\t *\n\t * @notice User pays for the withdrawal message delivery in native currency.\n\t *      The amount to be payed can be estimated with `estimateWithdrawalFee`\n\t *\n\t * @notice Specified amount of tokens is burnt from the sender,\n\t *      user may need to make sure this amount is approved for transfer/burning\n\t *\n\t * @param _value amount of tokens to withdraw\n\t */\n\tfunction withdraw(uint256 _value) public payable {\n\t\t// delegate to `withdrawTo`\n\t\twithdrawTo(msg.sender, _value);\n\t}\n\n\t/**\n\t * @notice L2 Tunnel Entrance.\n\t *      L2 Tunnel is always open in both directions.\n\t *\n\t * @notice Initiates the withdrawal from the child chain (L2) into the root chain (L1)\n\t *\n\t * @notice The process is finalized in the root chain (L1) via the\n\t *      `LzERC20RootTunnel.lzReceive` without the user/initiator participation\n\t *\n\t * @notice User pays for the withdrawal message delivery in native currency.\n\t *      The amount to be payed can be estimated with `estimateWithdrawalFee`\n\t *\n\t * @notice Specified amount of tokens is burnt from the sender,\n\t *      user may need to make sure this amount is approved for transfer/burning\n\t *\n\t * @param _to token recipient in the root chain (L1)\n\t * @param _value amount of tokens to withdraw\n\t */\n\tfunction withdrawTo(address _to, uint256 _value) public payable {\n\t\t// burn the requested amount of tokens in the child chain\n\t\tchildToken.burn(msg.sender, _value);\n\n\t\t// notify the L1 about the withdrawal\n\t\t__withdrawalNotify(msg.sender, _to, _value);\n\t}\n\n\t/**\n\t * @dev Notifies the L1 about the initiated withdrawal\n\t *\n\t * @dev Unsafe: doesn't verify the executor (msg.sender) permissions,\n\t *      must be kept private at all times\n\t *\n\t * @param _from token sender in the child chain (in L2)\n\t * @param _to token recipient in the root chain (in L1)\n\t * @param _value amount of tokens withdrawn\n\t */\n\tfunction __withdrawalNotify(address _from, address _to, uint256 _value) private {\n\t\t// send message to the root to unlock equal amount of tokens in the root chain\n\t\t// format: sender, recipient, amount\n\t\t__sendMessageToRoot(abi.encode(_from, _to, _value));\n\n\t\t// emit an event\n\t\temit WithdrawalInitiated(_from, _to, _value);\n\t}\n\n\t/**\n\t * @notice Estimates the token transfer fee from L2 to L1; this should be supplied\n\t *      as a transaction value into withdraw/withdrawTo\n\t *\n\t * @param _from token sender in the child chain (in L2)\n\t * @param _to token recipient in the root chain (in L1)\n\t * @param _value amount of tokens withdrawn\n\t * @return token transfer fee in wei\n\t */\n\tfunction estimateWithdrawalFee(address _from, address _to, uint256 _value) public view returns (uint256) {\n\t\t// delegate to `__estimateMessageFee`\n\t\treturn __estimateMessageFee(abi.encode(_from, _to, _value));\n\t}\n\n\t/**\n\t * @dev Estimates the message transfer fee from L2 to L1; this should be supplied\n\t *      as a transaction value into withdraw/withdrawTo\n\t *\n\t * @param message to deliver from the child chain (L2) into the root chain (L1)\n\t * @return message transfer fee in wei\n\t */\n\tfunction __estimateMessageFee(bytes memory message) private view returns (uint256) {\n\t\t// delegate to `__estimateMessageFee`\n\t\treturn __estimateMessageFee(rootTunnelChainId, message);\n\t}\n\n\t/**\n\t * @dev Auxiliary function to send the token transfer message from\n\t *      the child chain (L2) into the root chain (L1)\n\t *\n\t * @dev Evaluates the message transfer fee and tries to supply this fee\n\t *      Throws if sender didn't supply enough value to cover the fee\n\t *      Returns any excess of the funds sent back to sender\n\t *      (all of the above happens in LZ code, see UltraLightNode)\n\t *\n\t * @param message the message to send\n\t */\n\tfunction __sendMessageToRoot(bytes memory message) private {\n\t\t// delegate to `__sendMessageToRoot`\n\t\t__sendMessageTo(rootTunnelChainId, message);\n\t}\n\n\t/**\n\t * @dev Restricted access function to rescue accidentally sent tokens,\n\t *      the tokens are rescued via `transferFrom` function call on the\n\t *      contract address specified and with the parameters specified:\n\t *      `_contract.transferFrom(this, _to, _value)`\n\t *\n\t * @dev Requires executor to have `ROLE_RESCUE_MANAGER` permission\n\t *\n\t * @param _contract smart contract address to execute `transfer` function on\n\t * @param _to to address in `transferFrom(this, _to, _value)`\n\t * @param _value value to transfer in `transferFrom(this, _to, _value)`;\n\t *      this can also be a tokenId for ERC721 transfer\n\t */\n\tfunction rescueToken(address _contract, address _to, uint256 _value) public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_RESCUE_MANAGER), \"access denied\");\n\n\t\t// perform the transfer as requested, without any checks\n\t\trequire(ERC20(_contract).transferFrom(address(this), _to, _value));\n\t}\n}\n"
    },
    "contracts/layer_zero/LzERC20RootTunnelV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// use non-strict version pragma to simplify contract imports in other projects\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ERC20Spec.sol\";\nimport \"./NonblockingUpgradeableLzApp.sol\";\n\n/**\n * @title LayerZero ERC20 Root Tunnel\n *\n * @notice Ethereum network (root chain - L1) exit of the ERC20 tunnel,\n *      can be used for Ethereum mainnet and Goerli testnet networks\n *\n * @notice The tunnel is used to bridge specific ERC20 token between L1/L2;\n *      we call L1 -> L2 bridging a \"deposit\", L2 -> L1 a \"withdrawal\"\n *\n * @notice The tunnel has two entrances and two exits:\n *       LzERC20RootTunnel contains Root/L1 entrance and exit,\n *       and LzERC20ChildTunnel contains Child/L2 entrance and exit\n *\n * @notice All exits and child entrance are always open, while root entrance\n *      may get paused or even closed permanently\n *\n * @notice Deposit flow:\n *      1. The user initiates a deposit on the L1 entrance by executing the deposit function\n *         `LzERC20RootTunnel.deposit` or `LzERC20RootTunnel.depositTo`\n *      2. LayerZero messaging system picks up the event emitted by the `deposit` call\n *         and delivers it to L2 chain\n *      3. The deposit completes on the L2 exit when LayerZero messaging system executes\n *         the `LzERC20ChildTunnel.lzReceive` function\n *      Note: overall, the user executes only one function and then just waits for the bridge\n *         operation to complete\n *\n * @notice Withdrawal flow:\n *      1. The user initiates a withdrawal on the L2 entrance by executing the withdraw function\n *         `LzERC20ChildTunnel.withdraw` or `LzERC20ChildTunnel.withdrawTo`\n *      2. LayerZero messaging system picks up the event emitted by the `withdraw` call\n *         and delivers it to L1 chain\n *      3. The withdrawal completes on the L1 exit when LayerZero messaging system executes\n *         the `LzERC20RootTunnel.lzReceive` function\n *      Note: overall, the user executes only one function and then just waits for the bridge\n *         operation to complete\n *\n * @dev see https://github.com/LayerZero-Labs/LayerZero\n * @dev see https://github.com/LayerZero-Labs/solidity-examples\n */\ncontract LzERC20RootTunnelV1 is NonblockingUpgradeableLzApp {\n\t/**\n\t * @notice Root tunnel is strictly bound to the root ERC20 token\n\t *\n\t * @dev Root token MUST be an ERC20 implementation throwing on non-successful transfers\n\t */\n\tERC20 public /*immutable*/ rootToken;\n\n\t/**\n\t * @notice LayerZero specific chainId where the LzERC20ChildTunnel is deployed\n\t *\n\t * @dev Incoming messages must specify this chainId in order to be accepted\n\t *      see https://layerzero.gitbook.io/docs/technical-reference/mainnet/supported-chain-ids\n\t *      see https://layerzero.gitbook.io/docs/technical-reference/testnet/testnet-addresses\n\t */\n\tuint16 public childTunnelChainId;\n\n\t/**\n\t * @notice The address of the deployed LzERC20ChildTunnel which is bound to this LzERC20RootTunnel\n\t *\n\t * @dev Incoming messages must specify this LzERC20ChildTunnel address in order to be accepted\n\t */\n\taddress public childTunnelAddress;\n\n\t/**\n\t * @notice Counter of the amount of tokens locked in the tunnel\n\t *\n\t * @dev This is used to locate accidentally sent tokens which weren't bridged\n\t */\n\tuint256 public lockedInTunnel;\n\n\t/**\n\t * @notice Enables deposits on the tunnel (tunnel entrance)\n\t *      note: withdrawals are always enabled and cannot be disabled\n\t *\n\t * @dev Feature FEATURE_ENTRANCE_OPEN must be enabled in order for\n\t *      deposit functions (`deposit` and `depositTo`) to succeed\n\t */\n\tuint32 public constant FEATURE_ENTRANCE_OPEN = 0x0000_0001;\n\n\t/**\n\t * @notice People do mistakes and may send tokens by mistake\n\t *\n\t * @notice Rescue manager is responsible for \"rescuing\" ERC20/ERC721 tokens\n\t *      accidentally sent to the smart contract\n\t *\n\t * @dev Role ROLE_RESCUE_MANAGER allows withdrawing non-bridged ERC20/ERC721\n\t *      tokens stored on the smart contract balance via `rescueTokens` function\n\t */\n\tuint32 public constant ROLE_RESCUE_MANAGER = 0x0001_0000;\n\n\t/**\n\t * @dev Fired in `lzReceive` when token withdrawal completes successfully\n\t *\n\t * @param stateId unique tx identifier submitted from the child chain (L2)\n\t * @param from token sender address in the child chain (L2)\n\t * @param to token receiver address in the root chain (L1)\n\t * @param value amount of tokens withdrawn\n\t */\n\tevent WithdrawalComplete(uint256 indexed stateId, address indexed from, address indexed to, uint256 value);\n\n\t/**\n\t * @dev Fired in `deposit` and `depositTo`\n\t *\n\t * @param from token sender address in the root chain (L1)\n\t * @param to token receiver address in the child chain (L2)\n\t * @param value amount of tokens deposited\n\t */\n\tevent DepositInitiated(address indexed from, address indexed to, uint256 value);\n\n\t/**\n\t * @dev \"Constructor replacement\" for upgradeable, must be execute immediately after deployment\n\t *      see https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#initializers\n\t *\n\t * @dev Initializes an Ethereum network (L1) exit bound to\n\t *      LayerZero Endpoint, and root ERC20 token\n\t * @dev LayerZero Endpoint is a helper contract providing\n\t *      L1/L2 messaging infrastructure, managed by the LayerZero\n\t *\n\t * @param _lzEndpoint LayerZero Endpoint contract address (maintained by LayerZero)\n\t * @param _rootToken root ERC20 token address\n\t */\n\tfunction postConstruct(address _lzEndpoint, address _rootToken) public initializer {\n\t\t// execute parent initializer\n\t\t_postConstruct(msg.sender);\n\n\t\t// verify the inputs are set\n\t\trequire(_lzEndpoint != address(0), \"LZ endpoint not set\");\n\t\trequire(_rootToken != address(0), \"root token not set\");\n\n\t\t// initialize contract internal state\n\t\t__NonblockingUpgradeableLzApp_init(_lzEndpoint);\n\t\trootToken = ERC20(_rootToken);\n\t}\n\n\t/**\n\t * @dev Sets the childTunnel if it is not yet set\n\t *\n\t * @param _childTunnelChainId child tunnel chain ID to set\n\t * @param _childTunnelAddress child tunnel address to set\n\t */\n\tfunction setChildTunnel(uint16 _childTunnelChainId, address _childTunnelAddress) public {\n\t\t// `setChildTunnel` must be executed during the deployment process by\n\t\t// the same account which is making a deployment (full admin)\n\t\trequire(isSenderInRole(type(uint256).max), \"access denied\");\n\n\t\t// verify the chain ID is set (not zero)\n\t\trequire(_childTunnelChainId != 0, \"zero chain ID\");\n\t\t// verify the address is set (not zero)\n\t\trequire(_childTunnelAddress != address(0), \"zero address\");\n\n\t\t// verify the address is not yet set on the contract\n\t\trequire(childTunnelChainId == 0 && childTunnelAddress == address(0), \"child tunnel already set\");\n\n\t\t// set the tunnel\n\t\tchildTunnelChainId = _childTunnelChainId;\n\t\tchildTunnelAddress = _childTunnelAddress;\n\n\t\t// propagate the setup to `LzAppUpgradeable`\n\t\t_setTrustedRemote(childTunnelChainId, abi.encodePacked(_childTunnelAddress, address(this)));\n\t}\n\n\t/**\n\t * @notice L1 Tunnel Exit.\n\t *      Exit is always open.\n\t *\n\t * @dev Auxiliary function which can be executed only within the smart contract itself\n\t *      Effectively private (internal) as it is not callable by other contracts or EOAs\n\t *\n\t * @dev Wrapped by the ILayerZeroReceiver lzReceive catching any error and logging it\n\t *      See `ILayerZeroReceiver.lzReceive`\n\t */\n\tfunction _nonblockingLzReceive(uint16, bytes memory, uint64 _nonce, bytes memory _payload) internal override {\n\t\t// decode the message from the child\n\t\t// format: sender, recipient, amount\n\t\t(address _from, address _to, uint256 _value) = abi.decode(_payload, (address, address, uint256));\n\n\t\t// unlock the tokens from the contract by transferring them to the recipient\n\t\trootToken.transfer(_to, _value);\n\n\t\t// update locked tokens counter\n\t\tlockedInTunnel -= _value;\n\n\t\t// emit an event\n\t\temit WithdrawalComplete(_nonce, _from, _to, _value);\n\t}\n\n\t/**\n\t * @notice L1 Tunnel Entrance.\n\t *      Entrance can be closed/opened by the tunnel manager.\n\t *\n\t * @notice Initiates the deposit from the root chain (L1) to the child chain (L2)\n\t *      to the same address which initiated the deposit process\n\t *\n\t * @notice The process is finalized in the child chain (L2) via the\n\t *      `ERC20ChildTunnel.lzReceive` without the user/initiator participation\n\t *\n\t * @notice User pays for the deposit message delivery in native currency.\n\t *      The amount to be payed can be estimated with `estimateDepositFee`\n\t *\n\t * @notice Specified amount of tokens is transferred into the tunnel and locked,\n\t *      user needs to make sure this amount is approved for transfer\n\t *\n\t * @param _value amount of tokens to deposit\n\t */\n\tfunction deposit(uint256 _value) public payable {\n\t\t// delegate to `depositTo`\n\t\tdepositTo(msg.sender, _value);\n\t}\n\n\t/**\n\t * @notice L1 Tunnel Entrance.\n\t *      Entrance can be closed/opened by the tunnel manager.\n\t *\n\t * @notice Initiates the deposit from L1 to L2\n\t *\n\t * @notice The process is finalized in the child chain (L2) via the\n\t *      `ERC20ChildTunnel.lzReceive` without user/initiator participation\n\t *\n\t * @notice User pays for the deposit message delivery in native currency.\n\t *      The amount to be payed can be estimated with `estimateDepositFee`\n\t *\n\t * @notice Specified amount of tokens is transferred into the tunnel and locked,\n\t *      user needs to make sure this amount is approved for transfer\n\t *\n\t * @param _to token recipient in the child chain (in L2)\n\t * @param _value amount of tokens to deposit\n\t */\n\tfunction depositTo(address _to, uint256 _value) public payable {\n\t\t// verify tunnel entrance is open\n\t\trequire(isFeatureEnabled(FEATURE_ENTRANCE_OPEN), \"entrance closed\");\n\n\t\t// lock the tokens in the contract by transferring them from sender\n\t\t// in general one should check the return value of ERC20 transfer\n\t\t// we work here only with ERC20 implementations throwing on any error\n\t\trootToken.transferFrom(msg.sender, address(this), _value);\n\n\t\t// notify the L2 about the deposit\n\t\t__depositNotify(msg.sender, _to, _value);\n\t}\n\n\t/**\n\t * @dev Notifies the L2 about the initiated deposit\n\t *\n\t * @dev Unsafe: doesn't verify the executor (msg.sender) permissions,\n\t *      must be kept private at all times\n\t *\n\t * @param _from token sender in the root chain (in L1)\n\t * @param _to token recipient in the child chain (in L2)\n\t * @param _value amount of tokens deposited\n\t */\n\tfunction __depositNotify(address _from, address _to, uint256 _value) private {\n\t\t// update locked tokens counter\n\t\tlockedInTunnel += _value;\n\n\t\t// send a message to the child tunnel about the deposit made\n\t\t// format: sender, recipient, amount\n\t\t__sendMessageToChild(abi.encode(_from, _to, _value));\n\n\t\t// emit an event\n\t\temit DepositInitiated(_from, _to, _value);\n\t}\n\n\t/**\n\t * @notice Estimates the token transfer fee from L1 to L2; this should be supplied\n\t *      as a transaction value into deposit/depositTo\n\t *\n\t * @param _from token sender in the root chain (in L1)\n\t * @param _to token recipient in the child chain (in L2)\n\t * @param _value amount of tokens withdrawn\n\t * @return token transfer fee in wei\n\t */\n\tfunction estimateDepositFee(address _from, address _to, uint256 _value) public view returns (uint256) {\n\t\t// delegate to `__estimateMessageFee`\n\t\treturn __estimateMessageFee(abi.encode(_from, _to, _value));\n\t}\n\n\t/**\n\t * @dev Estimates the message transfer fee from L1 to L2; this should be supplied\n\t *      as a transaction value into deposit/depositTo\n\t *\n\t * @param message to deliver from the root chain (L1) into the child chain (L2)\n\t * @return message transfer fee in wei\n\t */\n\tfunction __estimateMessageFee(bytes memory message) private view returns (uint256) {\n\t\t// delegate to `__estimateMessageFee`\n\t\treturn __estimateMessageFee(childTunnelChainId, message);\n\t}\n\n\t/**\n\t * @dev Auxiliary function to send the token transfer message from\n\t *      the root chain (L1) into the child chain (L2)\n\t *\n\t * @dev Evaluates the message transfer fee and tries to supply this fee\n\t *      Throws if sender didn't supply enough value to cover the fee\n\t *      Returns any excess of the funds sent back to sender\n\t *      (all of the above happens in LZ code, see UltraLightNode)\n\t *\n\t * @param message the message to send\n\t */\n\tfunction __sendMessageToChild(bytes memory message) private {\n\t\t// delegate to `__sendMessageToRoot`\n\t\t__sendMessageTo(childTunnelChainId, message);\n\t}\n\n\t/**\n\t * @dev Restricted access function to rescue accidentally sent tokens,\n\t *      the tokens are rescued via `transferFrom` function call on the\n\t *      contract address specified and with the parameters specified:\n\t *      `_contract.transferFrom(this, _to, _value)`\n\t *\n\t * @dev Requires executor to have `ROLE_RESCUE_MANAGER` permission\n\t *\n\t * @param _contract smart contract address to execute `transfer` function on\n\t * @param _to to address in `transferFrom(this, _to, _value)`\n\t * @param _value value to transfer in `transferFrom(this, _to, _value)`;\n\t *      this can also be a tokenId for ERC721 transfer\n\t */\n\tfunction rescueToken(address _contract, address _to, uint256 _value) public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_RESCUE_MANAGER), \"access denied\");\n\n\t\t// verify tokens are not locked in tunnel\n\t\trequire(\n\t\t\t_contract != address(rootToken) || _value + lockedInTunnel <= rootToken.balanceOf(address(this)),\n\t\t\t\"locked in tunnel\"\n\t\t);\n\n\t\t// perform the transfer as requested, without any checks\n\t\trequire(ERC20(_contract).transferFrom(address(this), _to, _value));\n\t}\n}\n"
    },
    "contracts/layer_zero/NonblockingUpgradeableLzApp.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@layerzerolabs/solidity-examples/contracts/contracts-upgradable/lzApp/NonblockingLzAppUpgradeable.sol\";\nimport \"../utils/UpgradeableAccessControl.sol\";\n\n/**\n * @title Nonblocking Upgradeable LayerZero App with Access Control\n */\nabstract contract NonblockingUpgradeableLzApp is NonblockingLzAppUpgradeable, UpgradeableAccessControl {\n\t/**\n\t * @dev The address of the ZRO token holder who would pay for the transaction\n\t *      Zero address value means the native token is used instead of ZRO (default)\n\t */\n\taddress internal zroPaymentAddress;\n\n\t/**\n\t * @dev Parameters for custom functionality encoded as bytes (empty value means no custom params);\n\t *      e.g. gas limit override, receive airdropped native gas from the relayer on destination, etc.\n\t *      see https://layerzero.gitbook.io/docs/evm-guides/advanced/relayer-adapter-parameters\n\t */\n\tbytes internal adapterParams;\n\n\t/**\n\t * @dev An empty reserved space in storage that is put in place in Upgrade Safe contracts\n\t *      see https://docs.openzeppelin.com/contracts/3.x/upgradeable#storage_gaps\n\t */\n\tuint256[48] private __gap;\n\n\t/**\n\t * @notice LZ Config Manager is responsible for tunnel configuration, manager is\n\t *      allowed to access LZ Endpoint configuration functions via the tunnel\n\t *\n\t * @dev Role ROLE_LZ_CONFIG_MANAGER allows accessing LZ Endpoint configuration related\n\t *      functions: `setConfig`, `setSendVersion`, `setReceiveVersion`, and `forceResumeReceive`\n\t */\n\tuint32 public constant ROLE_LZ_CONFIG_MANAGER = 0x0010_0000;\n\n\t/**\n\t * @notice Tunnel Manager is responsible for tunnel setup, manager is\n\t *      allowed to access tunnel setup related functions\n\t *\n\t * @dev Role ROLE_TUNNEL_MANAGER allows accessing Tunnel setup related\n\t *      functions: `setPrecrime`, `setMinDstGas`, and `setPayloadSizeLimit`\n\t */\n\tuint32 public constant ROLE_TUNNEL_MANAGER = 0x0020_0000;\n\n\t/**\n\t * @dev Fired in setZroPaymentAddress()\n\t *\n\t * @param zroPaymentAddress ZRO payment address set, or zero address;\n\t *      zero address means native token is used for payments instead of ZRO token\n\t */\n\tevent ZroPaymentAddressUpdated(address zroPaymentAddress);\n\n\t/**\n\t * @dev Fired in setAdapterParams()\n\t *\n\t * @param adapterParams LZ relayer adapter parameters encoded as bytes\n\t *      see https://layerzero.gitbook.io/docs/evm-guides/advanced/relayer-adapter-parameters\n\t *\n\t * The rest of the params represent the decoded adapterParams bytes\n\t */\n\tevent AdapterParamsUpdated(\n\t\tbytes adapterParams,\n\t\tuint16 version,\n\t\tuint256 gasAmount,\n\t\tuint256 nativeForDst,\n\t\taddress addressOnDst\n\t);\n\n\t/**\n\t * @dev Ensures function is executed only by ROLE_LZ_CONFIG_MANAGER\n\t */\n\tmodifier onlyLzConfigManager {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_LZ_CONFIG_MANAGER), \"access denied\");\n\n\t\t_;\n\t}\n\n\t/**\n\t * @dev Ensures function is executed only by ROLE_TUNNEL_MANAGER\n\t */\n\tmodifier onlyTunnelManager {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_TUNNEL_MANAGER), \"access denied\");\n\n\t\t_;\n\t}\n\n\t/**\n\t * @dev OZ proxy init, initialization routines usually present inside the constructor\n\t */\n\tfunction __NonblockingUpgradeableLzApp_init(address _endpoint) internal onlyInitializing {\n\t\t__Context_init_unchained();\n\t\t__LzAppUpgradeable_init_unchained(_endpoint);\n\t\t__NonblockingLzAppUpgradeable_init_unchained(_endpoint);\n\t}\n\n\t/**\n\t * @dev OZ proxy init, initialization routines usually present outside the constructor\n\t */\n\tfunction __NonblockingUpgradeableLzApp_init_unchained() internal onlyInitializing {}\n\n\t/**\n\t * @dev Set/update/unset ZRO payment address, which is\n\t *      the address of the ZRO token holder who would pay for the transaction\n\t *      Zero address value means the native token is used instead of ZRO (default)\n\t *\n\t * @param _zroPaymentAddress ZRO payment address\n\t */\n\tfunction setZroPaymentAddress(address _zroPaymentAddress) external virtual onlyLzConfigManager {\n\t\t// update the address (note: zero value is OK)\n\t\tzroPaymentAddress = _zroPaymentAddress;\n\n\t\t// emit an event\n\t\temit ZroPaymentAddressUpdated(_zroPaymentAddress);\n\t}\n\n\t/**\n\t * @dev Set/update/unset LZ relayer adapter parameters for custom functionality\n\t *      encoded as bytes (empty value means no custom params)\n\t *\n\t * @param _adapterParams LZ relayer adapter custom params\n\t */\n\tfunction setAdapterParams(bytes memory _adapterParams) external virtual onlyLzConfigManager {\n\t\t// what can be packed inside the adapter params (if it is not empty)\n\t\tuint16 version; // 1 or 2\n\t\tuint256 gasAmount; // present in both 1 and 2\n\t\tuint256 nativeForDst; // present only in 2\n\t\taddress addressOnDst; // present only in 2\n\n\t\t// if custom relayer adapter parameters are set, we validate them:\n\t\tif(_adapterParams.length > 0) {\n\t\t\t// decode the parameters as if they are version 1 (version 2 compatible)\n\t\t\t// since the parameters are tightly packed\n\t\t\t// this cannot be unpacked with abi.decode, but only with assembly\n\t\t\tassembly {\n\t\t\t\t// see https://ethereum.stackexchange.com/questions/143522/how-to-decode-encodepacked-data\n\t\t\t\tversion := mload(add(_adapterParams, 2))\n\t\t\t\tgasAmount := mload(add(_adapterParams, 34))\n\t\t\t}\n\n\t\t\t// supported versions are 1 and 2\n\t\t\trequire(version > 0 && version <= 2, \"unknown version\");\n\n\t\t\t// check that adapter params length is correct\n\t\t\trequire(version == 1 && _adapterParams.length == 34 || version == 2 && _adapterParams.length == 86, \"malformed\");\n\n\t\t\t// verify gas amount value is set\n\t\t\trequire(gasAmount > 0, \"gas amount not set\");\n\n\t\t\t// for the version 2\n\t\t\tif(version > 1) {\n\t\t\t\t// decode the rest of the parameters\n\t\t\t\tassembly {\n\t\t\t\t\t// see https://ethereum.stackexchange.com/questions/143522/how-to-decode-encodepacked-data\n\t\t\t\t\tnativeForDst := mload(add(_adapterParams, 66))\n\t\t\t\t\taddressOnDst := mload(add(_adapterParams, 86))\n\t\t\t\t}\n\n\t\t\t\t// verify the values are set\n\t\t\t\trequire(nativeForDst > 0, \"airdrop value not set\");\n\t\t\t\trequire(addressOnDst != address(0), \"airdrop address not set\");\n\t\t\t}\n\t\t}\n\n\t\t// update the address (note: empty value is OK)\n\t\tadapterParams = _adapterParams;\n\n\t\t// emit an event\n\t\temit AdapterParamsUpdated(_adapterParams, version, gasAmount, nativeForDst, addressOnDst);\n\t}\n\n\t/**\n\t * @inheritdoc ILayerZeroUserApplicationConfigUpgradeable\n\t *\n\t * @notice Restricted access function to execute `setConfig` function on the LZ Endpoint\n\t *      set the configuration of the LayerZero messaging library of the specified version\n\t *\n\t * @dev Requires sender to have ROLE_LZ_CONFIG_MANAGER permission\n\t *\n\t * @param _version - messaging library version\n\t * @param _chainId - the chainId for the pending config change\n\t * @param _configType - type of configuration. every messaging library has its own convention.\n\t * @param _config - configuration in the bytes. can encode arbitrary content.\n\t */\n\tfunction setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external virtual override onlyLzConfigManager {\n\t\t_setConfig(_version, _chainId, _configType, _config);\n\t}\n\n\t/**\n\t * @inheritdoc ILayerZeroUserApplicationConfigUpgradeable\n\t *\n\t * @notice Restricted access function to execute `setSendVersion` function on the LZ Endpoint\n\t *      set the send() LayerZero messaging library version to _version\n\t *\n\t * @dev Requires sender to have ROLE_LZ_CONFIG_MANAGER permission\n\t *\n\t * @param _version - new messaging library version\n\t */\n\tfunction setSendVersion(uint16 _version) external virtual override onlyLzConfigManager {\n\t\t_setSendVersion(_version);\n\t}\n\n\t/**\n\t * @inheritdoc ILayerZeroUserApplicationConfigUpgradeable\n\t *\n\t * @notice Restricted access function to execute `setReceiveVersion` function on the LZ Endpoint\n\t *      set the lzReceive() LayerZero messaging library version to _version\n\t *\n\t * @dev Requires sender to have ROLE_LZ_CONFIG_MANAGER permission\n\t *\n\t * @param _version - new messaging library version\n\t */\n\tfunction setReceiveVersion(uint16 _version) external virtual override onlyLzConfigManager {\n\t\t_setReceiveVersion(_version);\n\t}\n\n\t/**\n\t * @inheritdoc ILayerZeroUserApplicationConfigUpgradeable\n\t *\n\t * @notice Restricted access function to execute `forceResumeReceive` function on the LZ Endpoint\n\t *      Only when the UA needs to resume the message flow in blocking mode and clear the stored payload\n\t *\n\t * @dev Requires sender to have ROLE_LZ_CONFIG_MANAGER permission\n\t *\n\t * @param _srcChainId - the chainId of the source chain\n\t * @param _srcAddress - the contract address of the source contract at the source chain\n\t */\n\tfunction forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external override virtual onlyLzConfigManager {\n\t\t_forceResumeReceive(_srcChainId, _srcAddress);\n\t}\n\n\t/**\n\t * @dev see LzAppUpgradeable\n\t */\n\tfunction setPrecrime(address _precrime) external virtual onlyTunnelManager {\n\t\t_setPrecrime(_precrime);\n\t}\n\n\t/**\n\t * @dev see LzAppUpgradeable\n\t */\n/*\n\tfunction setMinDstGas(uint16 _dstChainId, uint16 _packetType, uint _minGas) external virtual onlyTunnelManager {\n\t\t_setMinDstGas(_dstChainId, _packetType, _minGas);\n\t}\n*/\n\n\t/**\n\t * @dev see LzAppUpgradeable\n\t */\n\tfunction setPayloadSizeLimit(uint16 _dstChainId, uint _size) external virtual onlyTunnelManager {\n\t\t_setPayloadSizeLimit(_dstChainId, _size);\n\t}\n\n\t/**\n\t * @dev Estimates the message transfer fee to the destination chain `chainId`\n\t *\n\t * @param chainId destination chain\n\t * @param message the message to send\n\t * @return message transfer fee in wei\n\t */\n\tfunction __estimateMessageFee(uint16 chainId, bytes memory message) internal view returns (uint256) {\n\t\t// estimate fee based on the message input\n\t\t(uint256 fee,) = lzEndpoint.estimateFees(\n\t\t\tchainId,\n\t\t\taddress(this),\n\t\t\tmessage,\n\t\t\taddress(0) == zroPaymentAddress, // _payInZRO\n\t\t\tadapterParams\n\t\t);\n\t\t// return the result\n\t\treturn fee;\n\t}\n\n\t/**\n\t * @dev Auxiliary function to send the token transfer message to the\n\t *      destination chain `chainId`\n\t *\n\t * @dev Evaluates the message transfer fee and tries to supply this fee\n\t *      Throws if sender didn't supply enough value to cover the fee\n\t *      Returns any excess of the funds sent back to sender\n\t *      (all of the above happens in LZ code, see UltraLightNode)\n\t *\n\t * @param chainId destination chain\n\t * @param message the message to send\n\t */\n\tfunction __sendMessageTo(uint16 chainId, bytes memory message) internal {\n\t\t// send the message\n\t\t_lzSend(\n\t\t\tchainId,\n\t\t\tmessage,\n\t\t\tpayable(msg.sender),\n\t\t\tzroPaymentAddress,\n\t\t\tadapterParams,\n\t\t\tmsg.value\n\t\t);\n\t}\n}\n"
    },
    "contracts/lib/AddressUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title Address Utils\n *\n * @dev Utility library of inline functions on addresses\n *\n * @dev Copy of the Zeppelin's library:\n *      https://github.com/gnosis/openzeppelin-solidity/blob/master/contracts/AddressUtils.sol\n */\nlibrary AddressUtils {\n\n\t/**\n\t * @notice Checks if the target address is a contract\n\t *\n\t * @dev It is unsafe to assume that an address for which this function returns\n\t *      false is an externally-owned account (EOA) and not a contract.\n\t *\n\t * @dev Among others, `isContract` will return false for the following\n\t *      types of addresses:\n\t *        - an externally-owned account\n\t *        - a contract in construction\n\t *        - an address where a contract will be created\n\t *        - an address where a contract lived, but was destroyed\n\t *\n\t * @param addr address to check\n\t * @return whether the target address is a contract\n\t */\n\tfunction isContract(address addr) internal view returns (bool) {\n\t\t// a variable to load `extcodesize` to\n\t\tuint256 size = 0;\n\n\t\t// XXX Currently there is no better way to check if there is a contract in an address\n\t\t// than to check the size of the code at that address.\n\t\t// See https://ethereum.stackexchange.com/a/14016/36603 for more details about how this works.\n\t\t// TODO: Check this again before the Serenity release, because all addresses will be contracts.\n\t\t// solium-disable-next-line security/no-inline-assembly\n\t\tassembly {\n\t\t\t// retrieve the size of the code at address `addr`\n\t\t\tsize := extcodesize(addr)\n\t\t}\n\n\t\t// positive size indicates a smart contract address\n\t\treturn size > 0;\n\t}\n}\n"
    },
    "contracts/lib/ArrayUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title Array Utils\n *\n * @notice Solidity doesn't always work with arrays in an optimal way.\n *      This library collects functions helping to optimize gas usage\n *      when working with arrays in Solidity.\n *\n * @dev One of the most important use cases for arrays is \"tight\" arrays -\n *      arrays which store values significantly less than 256-bits numbers\n */\nlibrary ArrayUtils {\n\t/**\n\t * @dev Pushes `n` 32-bits values sequentially into storage allocated array `data`\n\t *      starting from the 32-bits value `v0`\n\t *\n\t * @dev Optimizations comparing to non-assembly implementation:\n\t *      - reads+writes to array size slot only once (instead of `n` times)\n\t *      - reads from the array data slots only once (instead of `7n/8` times)\n\t *      - writes into array data slots `n/8` times (instead of `n` times)\n\t *\n\t * @dev Maximum gas saving estimate: ~3n sstore, or 15,000 * n\n\t *\n\t * @param data storage array pointer to an array of 32-bits elements\n\t * @param v0 first number to push into the array\n\t * @param n number of values to push, pushes [v0, ..., v0 + n - 1]\n\t */\n\tfunction push32(uint32[] storage data, uint32 v0, uint32 n) internal {\n\t\t// we're going to write 32-bits values into 256-bits storage slots of the array\n\t\t// each 256-slot can store up to 8 32-bits sub-blocks, it can also be partially empty\n\t\tassembly {\n\t\t\t// for dynamic arrays their slot (array.slot) contains the array length\n\t\t\t// array data is stored separately in consequent storage slots starting\n\t\t\t// from the slot with the address keccak256(array.slot)\n\n\t\t\t// read the array length into `len` and increase it by `n`\n\t\t\tlet len := sload(data.slot)\n\t\t\tsstore(data.slot, add(len, n))\n\n\t\t\t// find where to write elements and store this location into `loc`\n\t\t\t// load array storage slot number into memory onto position 0,\n\t\t\t// calculate the keccak256 of the slot number (first 32 bytes at position 0)\n\t\t\t// - this will point to the beginning of the array,\n\t\t\t// so we add array length divided by 8 to point to the last array slot\n\t\t\tmstore(0, data.slot)\n\t\t\tlet loc := add(keccak256(0, 32), div(len, 8))\n\n\t\t\t// if we start writing data into already partially occupied slot (`len % 8 != 0`)\n\t\t\t// we need to modify the contents of that slot: read it and rewrite it\n\t\t\tlet offset := mod(len, 8)\n\t\t\tif not(iszero(offset)) {\n\t\t\t\t// how many 32-bits sub-blocks left in the slot\n\t\t\t\tlet left := sub(8, offset)\n\t\t\t\t// update the `left` value not to exceed `n`\n\t\t\t\tif gt(left, n) { left := n }\n\t\t\t\t// load the contents of the first slot (partially occupied)\n\t\t\t\tlet v256 := sload(loc)\n\t\t\t\t// write the slot in 32-bits sub-blocks\n\t\t\t\tfor { let j := 0 } lt(j, left) { j := add(j, 1) } {\n\t\t\t\t\t// write sub-block `j` at offset: `(j + offset) * 32` bits, length: 32-bits\n\t\t\t\t\t// v256 |= (v0 + j) << (j + offset) * 32\n\t\t\t\t\tv256 := or(v256, shl(mul(add(j, offset), 32), add(v0, j)))\n\t\t\t\t}\n\t\t\t\t// write first slot back, it can be still partially occupied, it can also be full\n\t\t\t\tsstore(loc, v256)\n\t\t\t\t// update `loc`: move to the next slot\n\t\t\t\tloc := add(loc, 1)\n\t\t\t\t// update `v0`: increment by number of values pushed\n\t\t\t\tv0 := add(v0, left)\n\t\t\t\t// update `n`: decrement by number of values pushed\n\t\t\t\tn := sub(n, left)\n\t\t\t}\n\n\t\t\t// rest of the slots (if any) are empty and will be only written to\n\t\t\t// write the array in 256-bits (8x32) slots\n\t\t\t// `i` iterates [0, n) with the 256-bits step, which is 8 taken `n` is 32-bits long\n\t\t\tfor { let i := 0 } lt(i, n) { i := add(i, 8) } {\n\t\t\t\t// how many 32-bits sub-blocks left in the slot\n\t\t\t\tlet left := 8\n\t\t\t\t// update the `left` value not to exceed `n`\n\t\t\t\tif gt(left, n) { left := n }\n\t\t\t\t// init the 256-bits slot value\n\t\t\t\tlet v256 := 0\n\t\t\t\t// write the slot in 32-bits sub-blocks\n\t\t\t\tfor { let j := 0 } lt(j, left) { j := add(j, 1) } {\n\t\t\t\t\t// write sub-block `j` at offset: `j * 32` bits, length: 32-bits\n\t\t\t\t\t// v256 |= (v0 + i + j) << j * 32\n\t\t\t\t\tv256 := or(v256, shl(mul(j, 32), add(v0, add(i, j))))\n\t\t\t\t}\n\t\t\t\t// write slot `i / 8`\n\t\t\t\tsstore(add(loc, div(i, 8)), v256)\n\t\t\t}\n\t\t}\n\t}\n\n}\n"
    },
    "contracts/lib/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n *\n * @dev Copy of the Zeppelin's library:\n *      https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b0cf6fbb7a70f31527f36579ad644e1cf12fdf4e/contracts/utils/cryptography/ECDSA.sol\n */\nlibrary ECDSA {\n\t/**\n\t * @dev Returns the address that signed a hashed message (`hash`) with\n\t * `signature`. This address can then be used for verification purposes.\n\t *\n\t * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n\t * this function rejects them by requiring the `s` value to be in the lower\n\t * half order, and the `v` value to be either 27 or 28.\n\t *\n\t * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n\t * verification to be secure: it is possible to craft signatures that\n\t * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n\t * this is by receiving a hash of the original message (which may otherwise\n\t * be too long), and then calling {toEthSignedMessageHash} on it.\n\t *\n\t * Documentation for signature generation:\n\t * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n\t * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n\t */\n\tfunction recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n\t\t// Divide the signature in r, s and v variables\n\t\tbytes32 r;\n\t\tbytes32 s;\n\t\tuint8 v;\n\n\t\t// Check the signature length\n\t\t// - case 65: r,s,v signature (standard)\n\t\t// - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n\t\tif (signature.length == 65) {\n\t\t\t// ecrecover takes the signature parameters, and the only way to get them\n\t\t\t// currently is to use assembly.\n\t\t\tassembly {\n\t\t\t\tr := mload(add(signature, 0x20))\n\t\t\t\ts := mload(add(signature, 0x40))\n\t\t\t\tv := byte(0, mload(add(signature, 0x60)))\n\t\t\t}\n\t\t}\n\t\telse if (signature.length == 64) {\n\t\t\t// ecrecover takes the signature parameters, and the only way to get them\n\t\t\t// currently is to use assembly.\n\t\t\tassembly {\n\t\t\t\tlet vs := mload(add(signature, 0x40))\n\t\t\t\tr := mload(add(signature, 0x20))\n\t\t\t\ts := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n\t\t\t\tv := add(shr(255, vs), 27)\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\trevert(\"invalid signature length\");\n\t\t}\n\n\t\treturn recover(hash, v, r, s);\n\t}\n\n\t/**\n\t * @dev Overload of {ECDSA-recover} that receives the `v`,\n\t * `r` and `s` signature fields separately.\n\t */\n\tfunction recover(\n\t\tbytes32 hash,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) internal pure returns (address) {\n\t\t// EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n\t\t// unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n\t\t// the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\n\t\t// signatures from current libraries generate a unique signature with an s-value in the lower half order.\n\t\t//\n\t\t// If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n\t\t// with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n\t\t// vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n\t\t// these malleable signatures as well.\n\t\trequire(\n\t\t\tuint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0,\n\t\t\t\"invalid signature 's' value\"\n\t\t);\n\t\trequire(v == 27 || v == 28, \"invalid signature 'v' value\");\n\n\t\t// If the signature is valid (and not malleable), return the signer address\n\t\taddress signer = ecrecover(hash, v, r, s);\n\t\trequire(signer != address(0), \"invalid signature\");\n\n\t\treturn signer;\n\t}\n\n\t/**\n\t * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n\t * produces hash corresponding to the one signed with the\n\t * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n\t * JSON-RPC method as part of EIP-191.\n\t *\n\t * See {recover}.\n\t */\n\tfunction toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n\t\t// 32 is the length in bytes of hash,\n\t\t// enforced by the type signature above\n\t\treturn keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n\t}\n\n\t/**\n\t * @dev Returns an Ethereum Signed Typed Data, created from a\n\t * `domainSeparator` and a `structHash`. This produces hash corresponding\n\t * to the one signed with the\n\t * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n\t * JSON-RPC method as part of EIP-712.\n\t *\n\t * See {recover}.\n\t */\n\tfunction toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n\t\treturn keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n\t}\n}\n"
    },
    "contracts/lib/StringUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title String Utils Library\n *\n * @dev Library for working with strings, primarily converting\n *      between strings and integer types\n */\nlibrary StringUtils {\n\t/**\n\t * @dev Converts a string to unsigned integer using the specified `base`\n\t * @dev Throws on invalid input\n\t *      (wrong characters for a given `base`)\n\t * @dev Throws if given `base` is not supported\n\t * @param a string to convert\n\t * @param base number base, one of 2, 8, 10, 16\n\t * @return i a number representing given string\n\t */\n\tfunction atoi(string memory a, uint8 base) internal pure returns (uint256 i) {\n\t\t// check if the base is valid\n\t\trequire(base == 2 || base == 8 || base == 10 || base == 16);\n\n\t\t// convert string into bytes for convenient iteration\n\t\tbytes memory buf = bytes(a);\n\n\t\t// iterate over the string (bytes buffer)\n\t\tfor(uint256 p = 0; p < buf.length; p++) {\n\t\t\t// extract the digit\n\t\t\tuint8 digit = uint8(buf[p]) - 0x30;\n\n\t\t\t// if digit is greater then 10 - mind the gap\n\t\t\t// see `itoa` function for more details\n\t\t\tif(digit > 10) {\n\t\t\t\t// remove the gap\n\t\t\t\tdigit -= 7;\n\t\t\t}\n\n\t\t\t// check if digit meets the base\n\t\t\trequire(digit < base);\n\n\t\t\t// move to the next digit slot\n\t\t\ti *= base;\n\n\t\t\t// add digit to the result\n\t\t\ti += digit;\n\t\t}\n\n\t\t// return the result\n\t\treturn i;\n\t}\n\n\t/**\n\t * @dev Converts a integer to a string using the specified `base`\n\t * @dev Throws if given `base` is not supported\n\t * @param i integer to convert\n\t * @param base number base, one of 2, 8, 10, 16\n\t * @return a a string representing given integer\n\t */\n\tfunction itoa(uint256 i, uint8 base) internal pure returns (string memory a) {\n\t\t// check if the base is valid\n\t\trequire(base == 2 || base == 8 || base == 10 || base == 16);\n\n\t\t// for zero input the result is \"0\" string for any base\n\t\tif(i == 0) {\n\t\t\treturn \"0\";\n\t\t}\n\n\t\t// bytes buffer to put ASCII characters into\n\t\tbytes memory buf = new bytes(256);\n\n\t\t// position within a buffer to be used in cycle\n\t\tuint256 p = 0;\n\n\t\t// extract digits one by one in a cycle\n\t\twhile(i > 0) {\n\t\t\t// extract current digit\n\t\t\tuint8 digit = uint8(i % base);\n\n\t\t\t// convert it to an ASCII code\n\t\t\t// 0x20 is \" \"\n\t\t\t// 0x30-0x39 is \"0\"-\"9\"\n\t\t\t// 0x41-0x5A is \"A\"-\"Z\"\n\t\t\t// 0x61-0x7A is \"a\"-\"z\" (\"A\"-\"Z\" XOR \" \")\n\t\t\tuint8 ascii = digit + 0x30;\n\n\t\t\t// if digit is greater then 10,\n\t\t\t// fix the 0x3A-0x40 gap of punctuation marks\n\t\t\t// (7 characters in ASCII table)\n\t\t\tif(digit >= 10) {\n\t\t\t\t// jump through the gap\n\t\t\t\tascii += 7;\n\t\t\t}\n\n\t\t\t// write character into the buffer\n\t\t\tbuf[p++] = bytes1(ascii);\n\n\t\t\t// move to the next digit\n\t\t\ti /= base;\n\t\t}\n\n\t\t// `p` contains real length of the buffer now,\n\t\t// allocate the resulting buffer of that size\n\t\tbytes memory result = new bytes(p);\n\n\t\t// copy the buffer in the reversed order\n\t\tfor(p = 0; p < result.length; p++) {\n\t\t\t// copy from the beginning of the original buffer\n\t\t\t// to the end of resulting smaller buffer\n\t\t\tresult[result.length - p - 1] = buf[p];\n\t\t}\n\n\t\t// construct string and return\n\t\treturn string(result);\n\t}\n\n\t/**\n\t * @dev Concatenates two strings `s1` and `s2`, for example, if\n\t *      `s1` == `foo` and `s2` == `bar`, the result `s` == `foobar`\n\t * @param s1 first string\n\t * @param s2 second string\n\t * @return s concatenation result s1 + s2\n\t */\n\tfunction concat(string memory s1, string memory s2) internal pure returns (string memory s) {\n\t\t// an old way of string concatenation (Solidity 0.4) is commented out\n/*\n\t\t// convert s1 into buffer 1\n\t\tbytes memory buf1 = bytes(s1);\n\t\t// convert s2 into buffer 2\n\t\tbytes memory buf2 = bytes(s2);\n\t\t// create a buffer for concatenation result\n\t\tbytes memory buf = new bytes(buf1.length + buf2.length);\n\n\t\t// copy buffer 1 into buffer\n\t\tfor(uint256 i = 0; i < buf1.length; i++) {\n\t\t\tbuf[i] = buf1[i];\n\t\t}\n\n\t\t// copy buffer 2 into buffer\n\t\tfor(uint256 j = buf1.length; j < buf2.length; j++) {\n\t\t\tbuf[j] = buf2[j - buf1.length];\n\t\t}\n\n\t\t// construct string and return\n\t\treturn string(buf);\n*/\n\n\t\t// simply use built in function\n\t\treturn string(abi.encodePacked(s1, s2));\n\t}\n}\n"
    },
    "contracts/mocks/AccessControlMocks.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../utils/AccessControl.sol\";\nimport \"../utils/UpgradeableAccessControl.sol\";\n\n/**\n * @title Access Control Mock\n *\n * @notice Used to test the AccessControl core functionality\n */\n// Used in AccessControl tests to check if `isSenderInRole` works through the `restrictedTo` modifier\ncontract AccessControlMock is AccessControl {\n\tuint32 public constant RESTRICTED_ROLE = 1;\n\tevent Restricted();\n\tconstructor(address _owner) AccessControl(_owner){}\n\tfunction restricted() public restrictedTo(RESTRICTED_ROLE) {\n\t\temit Restricted();\n\t}\n}\n\n/**\n * @title Upgradeable Access Control Mock\n *\n * @notice Used to test the UpgradeableAccessControl core functionality\n */\ncontract UpgradeableAccessControl1 is UpgradeableAccessControl {\n\t// v1 identifier\n\tstring public v1;\n\n\t/**\n\t * @dev UUPS initializer, sets the contract owner to have full privileges\n\t *\n\t * param _owner smart contract owner having full privileges\n\t */\n\tfunction postConstruct() public virtual initializer {\n\t\t// execute parent initializer\n\t\t_postConstruct(msg.sender);\n\n\t\t// self init\n\t\tv1 = \"v1\";\n\t}\n}\n\n/**\n * @title Upgradeable Access Control Mock 2\n *\n * @notice Used to test the UpgradeableAccessControl core functionality\n */\ncontract UpgradeableAccessControl2 is UpgradeableAccessControl {\n\t// v2 identifier\n\tstring public v2;\n\n\t/**\n\t * @dev UUPS initializer, sets the contract owner to have full privileges\n\t *\n\t * param _owner smart contract owner having full privileges\n\t */\n\tfunction postConstruct() public virtual initializer {\n\t\t// execute parent initializer\n\t\t_postConstruct(msg.sender);\n\n\t\t// self init\n\t\tv2 = \"v2\";\n\t}\n}\n"
    },
    "contracts/mocks/AliCompMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../token/AliERC20v2.sol\";\n\n// Token extension to simplify Compound-like voting delegation testing\ncontract AliCompMock is AliERC20v2 {\n\tconstructor(address _initialHolder) AliERC20v2(_initialHolder){}\n\n\t// replaces 3 transactions in CompTest to be put into single block with a single transaction\n\tfunction __delegate_transfer_transfer(address a1, address a2, uint256 val) public {\n\t\tdelegate(a1);      // transaction 1\n\t\ttransfer(a2, val); // transaction 2\n\t\ttransfer(a2, val); // transaction 3\n\t}\n\n\t// taken from CompHarness.sol, used in CompScenarioTest\n\tfunction generateCheckpoints(uint count, uint offset) external {\n\t\tfor (uint i = 1 + offset; i <= count + offset; i++) {\n\t\t\tvotingPowerHistory[msg.sender].push(KV(uint64(i), uint192(i)));\n\t\t}\n\t}\n}\n"
    },
    "contracts/mocks/ArrayBlockMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../lib/ArrayUtils.sol\";\n\n/**\n * @dev Helper contract to measure sequential array writing gas savings\n * @dev Supports seq_rnd_gas.js tess and ArrayUtils library\n */\ncontract ArrayBlockMock {\n\tusing ArrayUtils for uint32[];\n\tuint32[] public array321;\n\tuint32[] public array322;\n\tuint256[] public array2561;\n\tuint256[] public array2562;\n\n\tfunction writeSequential(uint32 m, uint32 n) public {\n\t\tfor(uint32 i = 0; i < n; i++) {\n\t\t\tarray321.push(i + m);\n\t\t}\n\t\tfor(uint32 i = 0; i < n; i++) {\n\t\t\tarray322.push(i + m);\n\t\t}\n\t}\n\n\tfunction writeRandomized(uint32 m, uint32 n) public {\n\t\tfor(uint32 i = 0; i < n; i++) {\n\t\t\tarray321.push(i + m);\n\t\t\tarray322.push(i + m);\n\t\t}\n\t}\n\n\tfunction writePacked(uint32 m, uint32 n) public {\n\t\tfor(uint256 i = 0; i < n; i += 8) {\n\t\t\tuint256 e = 0;\n\t\t\tfor(uint256 j = 0; j < 8; j++) {\n\t\t\t\te |= (i + j + m) << j * 32;\n\t\t\t}\n\t\t\tarray2561.push(e);\n\t\t\tarray2562.push(e);\n\t\t}\n\t}\n\n\tfunction writeWithAssembly(uint32 m, uint32 n) public {\n\t\tarray321.push32(m, n);\n\t\tarray322.push32(m, n);\n\t}\n\n\tfunction getArray321() public view returns(uint32[] memory) {\n\t\treturn array321;\n\t}\n\n\tfunction getArray322() public view returns(uint32[] memory) {\n\t\treturn array322;\n\t}\n\n\tfunction getArray2561() public view returns(uint256[] memory) {\n\t\treturn array2561;\n\t}\n\n\tfunction getArray2562() public view returns(uint256[] memory) {\n\t\treturn array2562;\n\t}\n\n}\n"
    },
    "contracts/mocks/BurnableShortERC721Mock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../token/BurnableShortERC721.sol\";\n\n// Zeppelin ERC721 tests support\ncontract BurnableShortERC721Mock is BurnableShortERC721 {\n\t/**\n\t * @inheritdoc ShortERC721\n\t */\n\tuint256 public constant override TOKEN_UID = 0x8d4fb97da97378ef7d0ad259aec651f42bd22c200159282baa58486bb390286b;\n\n\tconstructor(string memory _name, string memory _symbol) BurnableShortERC721(_name, _symbol) AccessControl(msg.sender) {}\n}\n"
    },
    "contracts/mocks/ERC1363Mock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ERC1363Spec.sol\";\n\n/// @dev Mock for ERC1363Receiver/ERC1363Spender interfaces\ncontract ERC1363Mock is ERC1363Receiver, ERC1363Spender {\n\t// an event to be fired in `onTransferReceived`\n\tevent OnTransferReceived(address indexed operator, address indexed from, uint256 value, bytes data);\n\t// an event to be fired in `onApprovalReceived`\n\tevent OnApprovalReceived(address indexed owner, uint256 value, bytes data);\n\n\t/// @inheritdoc ERC1363Receiver\n\tfunction onTransferReceived(address operator, address from, uint256 value, bytes memory data) public override returns (bytes4) {\n\t\t// emit an event\n\t\temit OnTransferReceived(operator, from, value, data);\n\n\t\t// always return \"success\"\n\t\treturn ERC1363Receiver(this).onTransferReceived.selector;\n\t}\n\n\t/// @inheritdoc ERC1363Spender\n\tfunction onApprovalReceived(address owner, uint256 value, bytes memory data) external override returns (bytes4) {\n\t\t// emit an event\n\t\temit OnApprovalReceived(owner, value, data);\n\n\t\t// always return \"success\"\n\t\treturn ERC1363Spender(this).onApprovalReceived.selector;\n\t}\n}\n\n// mock class using IERC1363Receiver\ncontract ERC1363ReceiverMock is ERC1363Receiver {\n\tbytes4 private _retval;\n\tbool private _reverts;\n\n\tevent Received(\n\t\taddress operator,\n\t\taddress sender,\n\t\tuint256 amount,\n\t\tbytes data,\n\t\tuint256 gas\n\t);\n\n\tconstructor(bytes4 retval, bool reverts) {\n\t\t_retval = retval;\n\t\t_reverts = reverts;\n\t}\n\n\tfunction onTransferReceived(address operator, address sender, uint256 amount, bytes memory data) public override returns (bytes4) {\n\t\trequire(!_reverts, \"ERC1363ReceiverMock: throwing\");\n\t\temit Received(operator, sender, amount, data, gasleft());\n\t\treturn _retval;\n\t}\n}\n\n// mock class using IERC1363Spender\ncontract ERC1363SpenderMock is ERC1363Spender {\n\tbytes4 private _retval;\n\tbool private _reverts;\n\n\tevent Approved(\n\t\taddress sender,\n\t\tuint256 amount,\n\t\tbytes data,\n\t\tuint256 gas\n\t);\n\n\tconstructor(bytes4 retval, bool reverts) {\n\t\t_retval = retval;\n\t\t_reverts = reverts;\n\t}\n\n\tfunction onApprovalReceived(address sender, uint256 amount, bytes memory data) public override returns (bytes4) {\n\t\trequire(!_reverts, \"ERC1363SpenderMock: throwing\");\n\t\temit Approved(sender, amount, data, gasleft());\n\t\treturn _retval;\n\t}\n}\n"
    },
    "contracts/mocks/ERC165DenierMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title ERC165 Denier Mock\n *\n * @notice ERC165 Denier Mock a contract that always denies ERC165 support, used for testing purposes;\n */\ncontract ERC165DenierMock {\n  /**\n   * @dev always returns false\n   */\n  function supportsInterface(bytes4) public pure returns (bool) {\n    return false;\n  }\n}\n"
    },
    "contracts/mocks/ERC20InterfaceIdMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ERC20Spec.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n// A mock to support erc20_interface_id.js checking ERC20 interfaceId correctness\ncontract ERC20InterfaceIdMock {\n\t// Alethea ERC20 interfaceId\n\tfunction aletheaId() public pure returns(bytes4) {\n\t\treturn type(ERC20).interfaceId;\n\t}\n\n\t// Zeppelin ERC20 interfaceId\n\tfunction zeppelinId() public pure returns(bytes4) {\n\t\treturn type(IERC20).interfaceId;\n\t}\n}\n"
    },
    "contracts/mocks/ERC20Mock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract ERC20Mock is ERC20 {\n\tconstructor(\n\t\tstring memory name,\n\t\tstring memory symbol,\n\t\taddress initialHolder,\n\t\tuint256 initialSupply\n\t) ERC20(name, symbol) {\n\t\tif(initialSupply > 0) {\n\t\t\t_mint(initialHolder, initialSupply);\n\t\t}\n\t}\n}\n\n"
    },
    "contracts/mocks/FixedSupplySaleMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../protocol/FixedSupplySale.sol\";\n\n/// @dev Allows to override isActive() and now256() on the FixedSupplySale\ncontract FixedSupplySaleMock is FixedSupplySale {\n\t/// @dev Defines if isActive() should be overridden\n\tbool private _activeStateOverride;\n\n\t/// @dev Overrides isActive() if `_activeStateOverride` is true\n\tbool private _activeStateValue;\n\n\t/// @dev Overrides now256() if set (non-zero)\n\tuint256 private _now256;\n\n\t/// @dev Deploys FixedSupplySaleMock passing all the params to FixedSupplySale\n\tconstructor(address _ali, address _nft, address _personality, address _iNft)\n\t\tFixedSupplySale(_ali, _nft, _personality, _iNft) {}\n\n\t/// @inheritdoc FixedSupplySale\n\tfunction isActive() public view override returns(bool) {\n\t\t// override state if required, delegate to super otherwise\n\t\treturn _activeStateOverride ? _activeStateValue : super.isActive();\n\t}\n\n\t/// @inheritdoc FixedSupplySale\n\tfunction now256() public view override returns (uint256) {\n\t\t// override now256 if it is set, delegate to super otherwise\n\t\treturn _now256 > 0? _now256: super.now256();\n\t}\n\n\t/// @dev Sets isActive() override\n\tfunction setStateOverride(bool _value) public {\n\t\t_activeStateOverride = true;\n\t\t_activeStateValue = _value;\n\t}\n\n\t/// @dev Removes isActive() override\n\tfunction removeStateOverride() public {\n\t\t_activeStateOverride = false;\n\t}\n\n\t/// @dev Sets/removes now256() override (set to zero to remove)\n\tfunction setNow256(uint256 _value) public {\n\t\t_now256 = _value;\n\t}\n\n}\n"
    },
    "contracts/mocks/LockableShortERC721Mock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../token/ShortERC721.sol\";\n\ncontract LockableShortERC721Mock is ShortERC721 {\n\t/// @dev Used to override isTransferable behaviour\n\tmapping(uint256 => bool) transferable;\n\n\t/**\n\t * @inheritdoc ShortERC721\n\t */\n\tuint256 public constant override TOKEN_UID = 0xe76696cd154d0436a87c600fb76c141850c0be74a8a5d25d60187407b7383d1f;\n\n\tconstructor(string memory _name, string memory _symbol) ShortERC721(_name, _symbol) AccessControl(msg.sender) {}\n\n\t/// @dev Used to override isTransferable behaviour\n\tfunction setTransferable(uint256 _tokenId, bool _value) public {\n\t\ttransferable[_tokenId] = _value;\n\t}\n\n\t/**\n\t * @inheritdoc ShortERC721\n\t */\n\tfunction isTransferable(uint256 _tokenId) public view override returns(bool) {\n\t\treturn transferable[_tokenId];\n\t}\n}\n"
    },
    "contracts/mocks/LockableTinyERC721Mock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../token/TinyERC721.sol\";\n\ncontract LockableTinyERC721Mock is TinyERC721 {\n\t/// @dev Used to override isTransferable behaviour\n\tmapping(uint256 => bool) transferable;\n\n\t/**\n\t * @inheritdoc TinyERC721\n\t */\n\tuint256 public constant override TOKEN_UID = 0x10ea00872172d27aedaa569f59f69fd6de0bf0b041cca3d8fb52105bf9366c54;\n\n\tconstructor(string memory _name, string memory _symbol) TinyERC721(_name, _symbol) AccessControl(msg.sender) {}\n\n\t/// @dev Used to override isTransferable behaviour\n\tfunction setTransferable(uint256 _tokenId, bool _value) public {\n\t\ttransferable[_tokenId] = _value;\n\t}\n\n\t/**\n\t * @inheritdoc TinyERC721\n\t */\n\tfunction isTransferable(uint256 _tokenId) public view override returns(bool) {\n\t\treturn transferable[_tokenId];\n\t}\n}\n"
    },
    "contracts/mocks/LzEndpointMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@layerzerolabs/solidity-examples/contracts/contracts-upgradable/interfaces/ILayerZeroEndpointUpgradeable.sol\";\nimport \"@layerzerolabs/solidity-examples/contracts/contracts-upgradable/interfaces/ILayerZeroReceiverUpgradeable.sol\";\n\ncontract LzEndpointMock is ILayerZeroEndpointUpgradeable {\n\tILayerZeroEndpointUpgradeable public destinationEndpoint;\n\tILayerZeroReceiverUpgradeable public lzReceiver;\n\tuint64 public nonce;\n\n\t// ILayerZeroUserApplicationConfig events\n\tevent ConfigSet(uint16 _version, uint16 _chainId, uint _configType, bytes _config);\n\tevent SendVersionSet(uint16 _version);\n\tevent ReceiveVersionSet(uint16 _version);\n\tevent ForceResumeReceived(uint16 _srcChainId, bytes _srcAddress);\n\n\t// ILayerZeroEndpoint events\n\tevent MessageSent(uint16 _dstChainId, bytes _destination, bytes _payload, address payable _refundAddress, address _zroPaymentAddress, bytes _adapterParams);\n\tevent PayloadReceived(uint16 _srcChainId, bytes _srcAddress, address _dstAddress, uint64 _nonce, uint _gasLimit, bytes _payload);\n\tevent PayloadRetried(uint16 _srcChainId, bytes _srcAddress, bytes _payload);\n\n\tfunction setDestinationEndpoint(address _destinationEndpoint) public {\n\t\tdestinationEndpoint = ILayerZeroEndpointUpgradeable(_destinationEndpoint);\n\t}\n\n\tfunction setLzReceiver(address _lzReceiver) public {\n\t\tlzReceiver = ILayerZeroReceiverUpgradeable(_lzReceiver);\n\t}\n\n\t/**\n\t * @inheritdoc ILayerZeroUserApplicationConfigUpgradeable\n\t */\n\tfunction setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) public override {\n\t\temit ConfigSet(_version, _chainId, _configType, _config);\n\t}\n\n\t/**\n\t * @inheritdoc ILayerZeroUserApplicationConfigUpgradeable\n\t */\n\tfunction setSendVersion(uint16 _version) public override {\n\t\temit SendVersionSet(_version);\n\t}\n\n\t/**\n\t * @inheritdoc ILayerZeroUserApplicationConfigUpgradeable\n\t */\n\tfunction setReceiveVersion(uint16 _version) public override {\n\t\temit ReceiveVersionSet(_version);\n\t}\n\n\t/**\n\t * @inheritdoc ILayerZeroUserApplicationConfigUpgradeable\n\t */\n\tfunction forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) public override {\n\t\temit ForceResumeReceived(_srcChainId, _srcAddress);\n\t}\n\n\t/**\n\t * @inheritdoc ILayerZeroEndpointUpgradeable\n\t */\n\tfunction send(\n\t\tuint16 _dstChainId,\n\t\tbytes memory _destination,\n\t\tbytes calldata _payload,\n\t\taddress payable _refundAddress,\n\t\taddress _zroPaymentAddress,\n\t\tbytes calldata _adapterParams\n\t) public payable override {\n\t\tif(address(destinationEndpoint) != address(0)) {\n\t\t\taddress a1;\n\t\t\taddress a2;\n\t\t\tassembly {\n\t\t\t\ta1 := mload(add(_destination, 20))\n\t\t\t\ta2 := mload(add(_destination, 40))\n\t\t\t}\n\t\t\tdestinationEndpoint.receivePayload(101, abi.encodePacked(a2, a1), a1, nonce++, 200_000, _payload);\n\t\t}\n\n\t\temit MessageSent(_dstChainId, _destination, _payload, _refundAddress, _zroPaymentAddress, _adapterParams);\n\t}\n\n\t/**\n\t * @inheritdoc ILayerZeroEndpointUpgradeable\n\t */\n\tfunction receivePayload(\n\t\tuint16 _srcChainId,\n\t\tbytes calldata _srcAddress,\n\t\taddress _dstAddress,\n\t\tuint64 _nonce,\n\t\tuint _gasLimit,\n\t\tbytes calldata _payload\n\t) public override {\n\t\tif(address(lzReceiver) != address(0)) {\n\t\t\tlzReceiver.lzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n\t\t}\n\n\t\temit PayloadReceived(_srcChainId, _srcAddress, _dstAddress, _nonce, _gasLimit, _payload);\n\t}\n\n\t/**\n\t * @inheritdoc ILayerZeroEndpointUpgradeable\n\t */\n\tfunction getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress) public view override returns(uint64) {\n\t\treturn 1;\n\t}\n\n\t/**\n\t * @inheritdoc ILayerZeroEndpointUpgradeable\n\t */\n\tfunction getOutboundNonce(uint16 _dstChainId, address _srcAddress) public view override returns(uint64) {\n\t\treturn 1;\n\t}\n\n\t/**\n\t * @inheritdoc ILayerZeroEndpointUpgradeable\n\t */\n\tfunction estimateFees(\n\t\tuint16 _dstChainId,\n\t\taddress _userApplication,\n\t\tbytes calldata _payload,\n\t\tbool _payInZRO,\n\t\tbytes calldata _adapterParam\n\t) public view override returns(uint nativeFee, uint zroFee) {\n\t\treturn (1 gwei, 2 gwei);\n\t}\n\n\t/**\n\t * @inheritdoc ILayerZeroEndpointUpgradeable\n\t */\n\tfunction getChainId() public view override returns(uint16) {\n\t\treturn 101;\n\t}\n\n\t/**\n\t * @inheritdoc ILayerZeroEndpointUpgradeable\n\t */\n\tfunction retryPayload(uint16 _srcChainId, bytes calldata _srcAddress, bytes calldata _payload) public override {\n\t\temit PayloadRetried(_srcChainId, _srcAddress, _payload);\n\t}\n\n\t/**\n\t * @inheritdoc ILayerZeroEndpointUpgradeable\n\t */\n\tfunction hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) public view override returns(bool) {\n\t\treturn true;\n\t}\n\n\t/**\n\t * @inheritdoc ILayerZeroEndpointUpgradeable\n\t */\n\tfunction getSendLibraryAddress(address _userApplication) public view override returns(address) {\n\t\treturn address(1);\n\t}\n\n\t/**\n\t * @inheritdoc ILayerZeroEndpointUpgradeable\n\t */\n\tfunction getReceiveLibraryAddress(address _userApplication) public view override returns(address) {\n\t\treturn address(2);\n\t}\n\n\t/**\n\t * @inheritdoc ILayerZeroEndpointUpgradeable\n\t */\n\tfunction isSendingPayload() public view override returns(bool) {\n\t\treturn true;\n\t}\n\n\t/**\n\t * @inheritdoc ILayerZeroEndpointUpgradeable\n\t */\n\tfunction isReceivingPayload() public view override returns(bool) {\n\t\treturn true;\n\t}\n\n\t/**\n\t * @inheritdoc ILayerZeroEndpointUpgradeable\n\t */\n\tfunction getConfig(\n\t\tuint16 _version,\n\t\tuint16 _chainId,\n\t\taddress _userApplication,\n\t\tuint _configType\n\t) public view override returns(bytes memory) {\n\t\treturn bytes(\"\");\n\t}\n\n\t/**\n\t * @inheritdoc ILayerZeroEndpointUpgradeable\n\t */\n\tfunction getSendVersion(address _userApplication) public view override returns(uint16) {\n\t\treturn 1;\n\t}\n\n\t/**\n\t * @inheritdoc ILayerZeroEndpointUpgradeable\n\t */\n\tfunction getReceiveVersion(address _userApplication) public view override returns(uint16) {\n\t\treturn 1;\n\t}\n}\n"
    },
    "contracts/mocks/LzERC20TunnelsMocks.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../layer_zero/LzERC20RootTunnelV1.sol\";\nimport \"../layer_zero/LzERC20ChildTunnelV1.sol\";\n\ncontract LzERC20RootTunnelV1Mock is LzERC20RootTunnelV1 {\n\tfunction setLzEndpoint(address _lzEndpoint) public {\n\t\tlzEndpoint = ILayerZeroEndpointUpgradeable(_lzEndpoint);\n\t}\n\tfunction setTrustedRemote(uint16 _srcChainId, bytes calldata _path) public {\n\t\t_setTrustedRemote(_srcChainId, _path);\n\t}\n\tfunction setTrustedRemoteAddress(uint16 _remoteChainId, bytes calldata _remoteAddress) public {\n\t\t_setTrustedRemoteAddress(_remoteChainId, _remoteAddress);\n\t}\n}\n\ncontract LzERC20ChildTunnelV1Mock is LzERC20ChildTunnelV1 {\n\tfunction setLzEndpoint(address _lzEndpoint) public {\n\t\tlzEndpoint = ILayerZeroEndpointUpgradeable(_lzEndpoint);\n\t}\n\tfunction setTrustedRemote(uint16 _srcChainId, bytes calldata _path) public {\n\t\t_setTrustedRemote(_srcChainId, _path);\n\t}\n\tfunction setTrustedRemoteAddress(uint16 _remoteChainId, bytes calldata _remoteAddress) public {\n\t\t_setTrustedRemoteAddress(_remoteChainId, _remoteAddress);\n\t}\n}\n"
    },
    "contracts/mocks/MaliciousFeeDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../bonding_curves/ProtocolFeeDistributorV1.sol\";\n\n/**\n * @title Malicious Fee Distributor\n *\n * @notice Tries to consume all the gas when payment is sent\n */\ncontract MaliciousFeeDistributor is ProtocolFeeDistributorV1 {\n\t// Function to receive Ether. msg.data must be empty\n\treceive() external payable override {\n\t\t// try to consume all the gas and fail the entire transaction\n\t\tuint256 i = 0;\n\t\twhile(true) {\n\t\t\ti++;\n\t\t}\n\t}\n}\n"
    },
    "contracts/mocks/MaliciousHoldersRewardsDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../bonding_curves/HoldersRewardsDistributor.sol\";\nimport \"../utils/InitializableAccessControl.sol\";\n\ncontract MaliciousHoldersRewardsDistributor is HoldersRewardsDistributor, InitializableAccessControl {\n\taddress private paymentToken;\n\taddress private sharesContractAddress;\n\n\tconstructor(address, address _sharesContractAddress, address _paymentToken) initializer {\n\t\tpostConstruct(address(0), _sharesContractAddress, _paymentToken);\n\t}\n\n\tfunction postConstruct(address, address _sharesContractAddress, address _paymentToken) public initializer {\n\t\tsharesContractAddress = _sharesContractAddress;\n\t\tpaymentToken = _paymentToken;\n\t}\n\n\tfunction initializeSharesContractAddressIfRequired(address _sharesContractAddress) public {\n\t\trequire(sharesContractAddress == address(0) && _sharesContractAddress != address(0));\n\t\tsharesContractAddress = _sharesContractAddress;\n\t}\n\n\tfunction getPaymentToken() public view returns (address) {\n\t\treturn paymentToken;\n\t}\n\n\tfunction __sharesBought(address buyer, uint256 amountBought) private {\n\t\temit SharesTraded(buyer, true, amountBought);\n\t}\n\n\tfunction __sharesSold(address seller, uint256 amountSold) private {\n\t\temit SharesTraded(seller, false, amountSold);\n\t}\n\n\tfunction __accept(uint256 feeAmount) private {\n\t\tif(feeAmount == 0) {\n\t\t\treturn;\n\t\t}\n\t\temit FeeReceived(feeAmount);\n\t}\n\n\tfunction claimTheReward() public {\n\t\temit RewardClaimed(msg.sender, 0);\n\t}\n\n\tfunction pendingReward(address) public pure returns(uint256 rewardAmount) {\n\t\treturn 0;\n\t}\n\n\tfunction onTransferReceived(address operator, address, uint256 value, bytes memory data) public returns (bytes4) {\n\t\trequire(msg.sender == paymentToken);\n\t\trequire(operator == sharesContractAddress);\n\t\t__accept(value);\n\t\t__parseTrade(data);\n\t\t__consumeAllTheGasLeft();\n\t\treturn ERC1363Receiver(this).onTransferReceived.selector;\n\t}\n\n\treceive() external payable {\n\t\t__accept(msg.value);\n\t\t__consumeAllTheGasLeft();\n\t}\n\n\tfallback() external payable {\n\t\trequire(paymentToken == address(0));\n\t\trequire(msg.sender == sharesContractAddress);\n\t\t__accept(msg.value);\n\t\t__parseTrade(msg.data);\n\t\t__consumeAllTheGasLeft();\n\t}\n\n\tfunction __parseTrade(bytes memory data) private {\n\t\tif(data.length == 0) {\n\t\t\treturn;\n\t\t}\n\t\t(address trader, bool isBuy, uint256 sharesAmount) = abi.decode(data, (address, bool, uint256));\n\t\tif(isBuy) {\n\t\t\t__sharesBought(trader, sharesAmount);\n\t\t}\n\t\telse {\n\t\t\t__sharesSold(trader, sharesAmount);\n\t\t}\n\t}\n\n\tfunction __consumeAllTheGasLeft() private {\n\t\t// try to consume all the gas and fail the entire transaction\n\t\tuint256 i = 0;\n\t\twhile(true) {\n\t\t\ti++;\n\t\t}\n\t}\n}\n"
    },
    "contracts/mocks/MintableSaleMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../protocol/MintableSale.sol\";\n\n/// @dev Allows to override isActive() and now256() on the MintableSale\ncontract MintableSaleMock is MintableSale {\n\t/// @dev Defines if isActive() should be overridden\n\tbool private _activeStateOverride;\n\n\t/// @dev Overrides isActive() if `_activeStateOverride` is true\n\tbool private _activeStateValue;\n\n\t/// @dev Overrides now256() if set (non-zero)\n\tuint256 private _now256;\n\n\t/// @dev Deploys MintableSaleMock passing all the params to MintableSale\n\tconstructor(address _tokenContract) MintableSale(_tokenContract) {}\n\n\t/// @inheritdoc MintableSale\n\tfunction isActive() public view override returns(bool) {\n\t\t// override state if required, delegate to super otherwise\n\t\treturn _activeStateOverride ? _activeStateValue : super.isActive();\n\t}\n\n\t/// @inheritdoc MintableSale\n\tfunction now256() public view override returns (uint256) {\n\t\t// override now256 if it is set, delegate to super otherwise\n\t\treturn _now256 > 0? _now256: super.now256();\n\t}\n\n\t/// @dev Sets isActive() override\n\tfunction setStateOverride(bool _value) public {\n\t\t_activeStateOverride = true;\n\t\t_activeStateValue = _value;\n\t}\n\n\t/// @dev Removes isActive() override\n\tfunction removeStateOverride() public {\n\t\t_activeStateOverride = false;\n\t}\n\n\t/// @dev Sets/removes now256() override (set to zero to remove)\n\tfunction setNow256(uint256 _value) public {\n\t\t_now256 = _value;\n\t}\n\n}\n"
    },
    "contracts/mocks/NFTStakingMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../protocol/NFTStaking.sol\";\n\n/// @dev Allows to override now32() on the NFTStaking\ncontract NFTStakingMock is NFTStaking {\n\t/// @dev Overrides now32() if set (non-zero)\n\tuint32 private _now32;\n\n\t/// @dev Deploys NFTStakingMock passing all the params to NFTStaking\n\tconstructor(address _nft) NFTStaking(_nft) {}\n\n\t/// @inheritdoc NFTStaking\n\tfunction now32() public view override returns (uint32) {\n\t\t// override now32 if it is set, delegate to super otherwise\n\t\treturn _now32 > 0? _now32: super.now32();\n\t}\n\n\t/// @dev Sets/removes now32() override (set to zero to remove)\n\tfunction setNow32(uint32 _value) public {\n\t\t_now32 = _value;\n\t}\n}\n"
    },
    "contracts/mocks/ProxyRegistryMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../protocol/OpenSeaFactory.sol\";\n\ncontract ProxyRegistryMock is ProxyRegistry {\n\t// an address to return as proxies(address)\n\taddress private owner;\n\n\t// creates a registry returning msg.sender as proxies(address)\n\tconstructor() {\n\t\towner = msg.sender;\n\t}\n\n\t// allows to override the owner - proxies(address)\n\tfunction setOwner(address _owner) public {\n\t\towner = _owner;\n\t}\n\n\t/**\n\t * @inheritdoc ProxyRegistry\n\t */\n\tfunction proxies(address) public override view returns(OwnableDelegateProxy) {\n\t\treturn OwnableDelegateProxy(owner);\n\t}\n}\n"
    },
    "contracts/mocks/RoyalERC721Mock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../token/RoyalERC721.sol\";\n\n// Zeppelin ERC721 tests support\ncontract RoyalERC721Mock is RoyalERC721 {\n\t/**\n\t * @inheritdoc TinyERC721\n\t */\n\tuint256 public constant override TOKEN_UID = 0x0250bec6b1a03636668f5072a8f5675e5fbd3e485d8a1213fc8279b78cb6f33d;\n\n\tconstructor(string memory _name, string memory _symbol) RoyalERC721(_name, _symbol) AccessControl(msg.sender) {}\n}\n"
    },
    "contracts/mocks/ShortERC721Mock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../token/ShortERC721.sol\";\n\n// Zeppelin ERC721 tests support\ncontract ShortERC721Mock is ShortERC721 {\n\t/**\n\t * @inheritdoc ShortERC721\n\t */\n\tuint256 public constant override TOKEN_UID = 0x77a854386ba78c1ee8a3be2be18b485dd7f2f85e899d7dfe143cd3e1d5e4e877;\n\n\tconstructor(string memory _name, string memory _symbol) ShortERC721(_name, _symbol) AccessControl(msg.sender) {}\n}\n"
    },
    "contracts/mocks/TinyERC721Mock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../token/TinyERC721.sol\";\n\n// Zeppelin ERC721 tests support\ncontract TinyERC721Mock is TinyERC721 {\n\t/**\n\t * @inheritdoc TinyERC721\n\t */\n\tuint256 public constant override TOKEN_UID = 0x0250bec6b1a03636668f5072a8f5675e5fbd3e485d8a1213fc8279b78cb6f33d;\n\n\tconstructor(string memory _name, string memory _symbol) TinyERC721(_name, _symbol) AccessControl(msg.sender) {}\n}\n"
    },
    "contracts/mocks/ZeppelinERC20Mock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract ZeppelinERC20Mock is ERC20 {\n  constructor() payable ERC20(\"Mock\", \"MCK\") {}\n\n  function supportsInterface(bytes4 interfaceId) public pure returns (bool) {\n    return interfaceId == type(IERC20).interfaceId;\n  }\n\n  function mint(address account, uint256 amount) public {\n    _mint(account, amount);\n  }\n\n  function burn(address account, uint256 amount) public {\n    _burn(account, amount);\n  }\n\n  function transferInternal(\n    address from,\n    address to,\n    uint256 value\n  ) public {\n    _transfer(from, to, value);\n  }\n\n  function approveInternal(\n    address owner,\n    address spender,\n    uint256 value\n  ) public {\n    _approve(owner, spender, value);\n  }\n}\n"
    },
    "contracts/mocks/ZeppelinERC721Mock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ERC721SpecExt.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\";\n\n/**\n * @title Zeppelin ERC721 Mock\n *\n * @notice Zeppelin ERC721 Mock simulates an NFT token, used for testing purposes;\n *      it has unrestricted access to the mint() function and can be used to be bound to an iNFT\n */\ncontract ZeppelinERC721Mock is ERC721Enumerable, ERC721URIStorage, MintableERC721, BurnableERC721 {\n\t/**\n\t * @dev Creates/deploys an NFT Mock instance\n\t *\n\t * @param _name asset name (ERC721Metadata)\n\t * @param _symbol asset symbol (ERC721Metadata)\n\t */\n\tconstructor(string memory _name, string memory _symbol) ERC721(_name, _symbol) {}\n\n\t/**\n\t * @inheritdoc MintableERC721\n\t */\n\tfunction exists(uint256 _tokenId) public override view returns(bool) {\n\t\t// delegate to `_exists`\n\t\treturn _exists(_tokenId);\n\t}\n\n\t/**\n\t * @inheritdoc MintableERC721\n\t */\n\tfunction mint(address _to, uint256 _tokenId) public override {\n\t\t// mint token - delegate to `_mint`\n\t\t_mint(_to, _tokenId);\n\t}\n\n\t/**\n\t * @inheritdoc MintableERC721\n\t */\n\tfunction safeMint(address _to, uint256 _tokenId) public override {\n\t\t// mint token safely - delegate to `_safeMint`\n\t\t_safeMint(_to, _tokenId);\n\t}\n\n\t/**\n\t * @inheritdoc MintableERC721\n\t */\n\tfunction safeMint(address _to, uint256 _tokenId, bytes memory _data) public override {\n\t\t// mint token safely - delegate to `_safeMint`\n\t\t_safeMint(_to, _tokenId, _data);\n\t}\n\n\t/**\n\t * @inheritdoc BurnableERC721\n\t */\n\tfunction burn(uint256 _tokenId) public override {\n\t\t// burn token - delegate to `_burn`\n\t\t_burn(_tokenId);\n\t}\n\n\t/**\n\t * @inheritdoc ERC721\n\t */\n\tfunction _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual override(ERC721, ERC721Enumerable) {\n\t\tERC721Enumerable._beforeTokenTransfer(from, to, tokenId);\n\t}\n\n\t/**\n\t * @inheritdoc ERC721\n\t */\n\tfunction _burn(uint256 tokenId) internal virtual override(ERC721, ERC721URIStorage) {\n\t\tERC721URIStorage._burn(tokenId);\n\t}\n\n\t/**\n\t * @inheritdoc ERC721\n\t */\n\tfunction supportsInterface(bytes4 interfaceId) public view virtual override(ERC721, ERC721Enumerable) returns (bool) {\n\t\treturn ERC721Enumerable.supportsInterface(interfaceId)\n\t\t\t|| interfaceId == type(MintableERC721).interfaceId\n\t\t\t|| interfaceId == type(BurnableERC721).interfaceId;\n\t}\n\n\t/**\n\t * @inheritdoc ERC721\n\t */\n\tfunction tokenURI(uint256 tokenId) public view virtual override(ERC721, ERC721URIStorage) returns (string memory) {\n\t\treturn ERC721URIStorage.tokenURI(tokenId);\n\t}\n\n\t/**\n\t * @inheritdoc MintableERC721\n\t */\n\tfunction mintBatch(address _to, uint256 _tokenId, uint256 n) public override {\n\t\t// straightforward: mint one by one\n\t\tfor(uint256 i = 0; i < n; i++) {\n\t\t\t// delegate to `mint`\n\t\t\tmint(_to, _tokenId + i);\n\t\t}\n\t}\n\n\t/**\n\t * @inheritdoc MintableERC721\n\t */\n\tfunction safeMintBatch(address _to, uint256 _tokenId, uint256 n) public override {\n\t\t// delegate to `safeMint` with empty data\n\t\tsafeMintBatch(_to, _tokenId, n, \"\");\n\t}\n\n\t/**\n\t * @inheritdoc MintableERC721\n\t */\n\tfunction safeMintBatch(address _to, uint256 _tokenId, uint256 n, bytes memory _data) public override {\n\t\t// straightforward: mint one by one\n\t\tfor(uint256 i = 0; i < n; i++) {\n\t\t\t// delegate to `safeMint`\n\t\t\tsafeMint(_to, _tokenId + i, _data);\n\t\t}\n\t}\n}\n"
    },
    "contracts/mocks/ZeppelinERC721ReceiverMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ERC721Spec.sol\";\n\ncontract ZeppelinERC721ReceiverMock is ERC721TokenReceiver {\n\tenum Error {\n\t\tNone,\n\t\tRevertWithMessage,\n\t\tRevertWithoutMessage,\n\t\tPanic\n\t}\n\n\tbytes4 private immutable _retval;\n\tError private immutable _error;\n\n\tevent Received(address operator, address from, uint256 tokenId, bytes data, uint256 gas);\n\n\tconstructor(bytes4 retval, Error error) {\n\t\t_retval = retval;\n\t\t_error = error;\n\t}\n\n\tfunction onERC721Received(\n\t\taddress operator,\n\t\taddress from,\n\t\tuint256 tokenId,\n\t\tbytes memory data\n\t) public override returns (bytes4) {\n\t\tif (_error == Error.RevertWithMessage) {\n\t\t\trevert(\"ERC721ReceiverMock: reverting\");\n\t\t} else if (_error == Error.RevertWithoutMessage) {\n\t\t\trevert();\n\t\t} else if (_error == Error.Panic) {\n\t\t\tuint256 a = uint256(0) / uint256(0);\n\t\t\ta;\n\t\t}\n\t\temit Received(operator, from, tokenId, data, gasleft());\n\t\treturn _retval;\n\t}\n}\n"
    },
    "contracts/protocol/ERC721Drop.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ERC721Spec.sol\";\nimport \"../interfaces/ERC721SpecExt.sol\";\nimport \"../utils/AccessControl.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\n\n/**\n * @title ERC721 Airdrop\n *\n * @notice During the release 2.0 distribution event of 10,000 personality pods,\n *      it became clear there is a need to distribute around 10% for free, as an Airdrop.\n *\n * @notice ERC721Drop contract introduces a scalable mechanism to mint NFTs to an arbitrary\n *      amount of addresses by leveraging the power of Merkle trees to \"compress\" minting data.\n *\n * @notice The input data is an array of (address, tokenId) pairs; Merkle tree is built out\n *      from this array, and the tree root is stored on the contract by its data manager.\n *      When minting (address, tokenId), executor specifies also the Merkle proof for an\n *      element (address, tokenId) to mint.\n */\ncontract ERC721Drop is AccessControl {\n\t// Use Zeppelin MerkleProof Library to verify Merkle proofs\n\tusing MerkleProof for bytes32[];\n\n\t/**\n\t * @notice Input data root, Merkle tree root for an array of (address, tokenId) pairs,\n\t *      available for minting\n\t *\n\t * @notice Merkle root effectively \"compresses\" the (potentially) huge array of data elements\n\t *      and allows to store it in a single 256-bits storage slot on-chain\n\t */\n\tbytes32 public root;\n\n\t/**\n\t * @dev Mintable ERC721 contract address to mint tokens of\n\t */\n\taddress public immutable targetContract;\n\n\t/**\n\t * @notice Enables the airdrop, redeeming the tokens\n\t *\n\t * @dev Feature FEATURE_REDEEM_ACTIVE must be enabled in order for\n\t *      `mint()` function to succeed\n\t */\n\tuint32 public constant FEATURE_REDEEM_ACTIVE = 0x0000_0001;\n\n\t/**\n\t * @notice Data manager is responsible for supplying the valid input data array\n\t *      Merkle root which then can be used to mint tokens, meaning effectively,\n\t *      that data manager may act as a minter on the target NFT contract\n\t *\n\t * @dev Role ROLE_DATA_MANAGER allows setting the Merkle tree root via setInputDataRoot()\n\t */\n\tuint32 public constant ROLE_DATA_MANAGER = 0x0001_0000;\n\n\t/**\n\t * @dev Fired in setInputDataRoot()\n\t *\n\t * @param _by an address which executed the operation\n\t * @param _root new Merkle root value\n\t */\n\tevent RootChanged(address indexed _by, bytes32 _root);\n\n\t/**\n\t * @dev Fired in redeem()\n\t *\n\t * @param _by an address which executed the operation\n\t * @param _to an address the token was minted to\n\t * @param _tokenId token ID minted\n\t * @param _proof Merkle proof for the (_to, _tokenId) pair\n\t */\n\tevent Redeemed(address indexed _by, address indexed _to, uint256 indexed _tokenId, bytes32[] _proof);\n\n\t/**\n\t * @dev Creates/deploys ERC721Drop and binds it to ERC721 smart contract on construction\n\t *\n\t * @param _target deployed Mintable ERC721 smart contract; contract will mint NFTs of that type\n\t */\n\tconstructor(address _target) AccessControl(msg.sender) {\n\t\t// verify the input is set\n\t\trequire(_target != address(0), \"target contract is not set\");\n\n\t\t// verify the input is valid smart contract of the expected interfaces\n\t\trequire(\n\t\t\tERC165(_target).supportsInterface(type(ERC721).interfaceId)\n\t\t\t&& ERC165(_target).supportsInterface(type(MintableERC721).interfaceId),\n\t\t\t\"unexpected target type\"\n\t\t);\n\n\t\t// assign the address\n\t\ttargetContract = _target;\n\t}\n\n\t/**\n\t * @notice Restricted access function to update input data root (Merkle tree root),\n\t *       and to define, effectively, the tokens to be created by this smart contract\n\t *\n\t * @dev Requires executor to have `ROLE_DATA_MANAGER` permission\n\t *\n\t * @param _root Merkle tree root for the input data array\n\t */\n\tfunction setInputDataRoot(bytes32 _root) public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_DATA_MANAGER), \"access denied\");\n\n\t\t// update input data Merkle tree root\n\t\troot = _root;\n\n\t\t// emit an event\n\t\temit RootChanged(msg.sender, _root);\n\t}\n\n\t/**\n\t * @notice Verifies the validity of a `(_to, _tokenId)` pair supplied based on the Merkle root\n\t *      of the entire `(_to, _tokenId)` data array (pre-stored in the contract), and the Merkle\n\t *      proof `_proof` for the particular `(_to, _tokenId)` pair supplied\n\t *\n\t * @dev Merkle tree and proof can be constructed using the `web3-utils`, `merkletreejs`,\n\t *      and `keccak256` npm packages:\n\t *      1. Hash the original array data elements (_to, _tokenId) via `web3.utils.soliditySha3`,\n\t *         making sure the packing order and types are exactly as in `mint()` signature\n\t *      2. Create a sorted MerkleTree (`merkletreejs`) from the hashed array, use `keccak256`\n\t *         from the `keccak256` npm package as a hashing function, do not hash leaves\n\t *         (already hashed in step 1); Ex. MerkleTree options: {hashLeaves: false, sortPairs: true}\n\t *      3. For any given data element (_to, _tokenId) the proof is constructed by hashing it\n\t *         (as in step 1) and querying the MerkleTree for a proof, providing the hashed element\n\t *         as a leaf\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId token ID to mint\n\t * @param _proof Merkle proof for the (_to, _tokenId) pair supplied\n\t * @return true if Merkle proof is valid (data belongs to the original array), false otherwise\n\t */\n\tfunction isTokenValid(address _to, uint256 _tokenId, bytes32[] memory _proof) public view returns(bool) {\n\t\t// construct Merkle tree leaf from the inputs supplied\n\t\tbytes32 leaf = keccak256(abi.encodePacked(_to, _tokenId));\n\n\t\t// verify the proof supplied, and return the verification result\n\t\treturn _proof.verify(root, leaf);\n\t}\n\n\t/**\n\t * @notice Mints token `_tokenId` to an address `_to`, verifying the validity\n\t *      of a `(_to, _tokenId)` pair via the Merkle proof `_proof`\n\t *\n\t * @dev Merkle tree and proof can be constructed using the `web3-utils`, `merkletreejs`,\n\t *      and `keccak256` npm packages:\n\t *      1. Hash the original array data elements (_to, _tokenId) via `web3.utils.soliditySha3`,\n\t *         making sure the packing order and types are exactly as in `mint()` signature\n\t *      2. Create a sorted MerkleTree (`merkletreejs`) from the hashed array, use `keccak256`\n\t *         from the `keccak256` npm package as a hashing function, do not hash leaves\n\t *         (already hashed in step 1); Ex. MerkleTree options: {hashLeaves: false, sortPairs: true}\n\t *      3. For any given data element (_to, _tokenId) the proof is constructed by hashing it\n\t *         (as in step 1) and querying the MerkleTree for a proof, providing the hashed element\n\t *         as a leaf\n\t *\n\t * @dev Throws is the data or merkle proof supplied is not valid\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId token ID to mint\n\t * @param _proof Merkle proof for the (_to, _tokenId) pair supplied\n\t */\n\tfunction redeem(address _to, uint256 _tokenId, bytes32[] memory _proof) public {\n\t\t// verify airdrop is in active state\n\t\trequire(isFeatureEnabled(FEATURE_REDEEM_ACTIVE), \"redeems are disabled\");\n\n\t\t// verify the `(_to, _tokenId)` pair is valid\n\t\trequire(isTokenValid(_to, _tokenId, _proof), \"invalid token\");\n\n\t\t// mint the token\n\t\tMintableERC721(targetContract).safeMint(_to, _tokenId);\n\n\t\t// emit an event\n\t\temit Redeemed(msg.sender, _to, _tokenId, _proof);\n\t}\n}\n"
    },
    "contracts/protocol/FixedSupplySale.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ERC721SpecExt.sol\";\nimport \"./IntelligentNFTv2.sol\";\nimport \"../utils/AccessControl.sol\";\n\n/**\n * @title Fixed Supply Sale\n *\n * @notice Fixed Supply Sale sales fixed amount of iNFTs for a fixed price in a fixed period of time;\n *      underlying NFTs and AI Personalities are being minted as well as a part of the sale process\n *\n * @notice In restricted mode (FEATURE_PUBLIC_SALE feature disabled) sells the items only to\n *      accounts having `ROLE_BUYER` permission (used to mint first hundred iNFTs in the 10k sale campaign)\n *\n * @dev Technically, all the \"fixed\" parameters can be changed on the go after smart contract is deployed\n *      and operational, but this ability is reserved for quick fix-like adjustments, and to provide\n *      an ability to restart and run a similar sale after the previous one ends\n *\n * @dev When buying an iNFT from this smart contract:\n *      1) next NFT is minted to the transaction sender address\n *      2) next AI Personality is minted directly to iNFT smart contract for further locking\n *      3) next iNFT is created, bound to an NFT minted in step (1)\n *         and locking the AI Personality minted in step (2)\n *      4) no ALI tokens are minted, no ALI tokens are locked or consumed in the process\n *\n * @dev Deployment and setup:\n *      1. Deploy smart contract, specify smart contract addresses during the deployment\n *         - iNFT deployed instance address\n *         - NFT deployed instance address\n *         - AI Personality deployed instance address\n *      2. Execute `initialize` function and set up the sale parameters;\n *         sale is not active until it's initialized\n */\ncontract FixedSupplySale is AccessControl {\n\t// ----- SLOT.1 (256/256)\n\t/**\n\t * @notice Price of a single iNFT minted (with the underlying NFT and AI Personality minted)\n\t *      When buying several iNFTs at once the price accumulates accordingly, with no discount\n\t *\n\t * @dev Maximum item price is ~18.44 ETH\n\t */\n\tuint64 public itemPrice;\n\n\t/**\n\t * @dev Next iNFT / bound NFT / AI Personality ID to mint;\n\t *      initially this is the first \"free\" ID which can be minted;\n\t *      at any point in time this should point to a free, mintable ID\n\t *      for iNFT / bound NFT / AI Personality\n\t *\n\t * @dev `nextId` cannot be zero, we do not ever mint NFTs with zero IDs\n\t */\n\tuint32 public nextId = 1;\n\n\t/**\n\t * @dev Last iNFT / bound NFT / AI Personality ID to mint;\n\t *      once `nextId` exceeds `finalId` the sale pauses\n\t */\n\tuint32 public finalId;\n\n\t/**\n\t * @notice Sale start unix timestamp; the sale is active after the start (inclusive)\n\t */\n\tuint32 public saleStart;\n\n\t/**\n\t * @notice Sale end unix timestamp; the sale is active before the end (exclusive)\n\t */\n\tuint32 public saleEnd;\n\n\t/**\n\t * @notice Once set, limits the amount of iNFTs one can buy in a single transaction;\n\t *       When unset (zero) the amount of iNFTs is limited only by block size and\n\t *       amount of iNFTs left for sale\n\t */\n\tuint32 public batchLimit;\n\n\t/**\n\t * @notice Counter of the iNFTs sold (minted) by this sale smart contract\n\t */\n\tuint32 public soldCounter;\n\n\t// ----- NON-SLOTTED\n\t/**\n\t * @dev ALI ERC20 contract address to transfer tokens and bind to iNFTs created,\n\t *      should match with `iNftContract.aliContract`\n\t */\n\taddress public immutable aliContract;\n\n\t/**\n\t * @dev NFT ERC721 contract address to mint NFTs from and bind to iNFTs created\n\t */\n\taddress public immutable nftContract;\n\n\t/**\n\t * @dev Personality Pod ERC721 contract address to mint and lock into iNFTs created\n\t */\n\taddress public immutable personalityContract;\n\n\t/**\n\t * @dev iNFT contract address used to create iNFTs\n\t */\n\taddress public immutable iNftContract;\n\n\t// ----- SLOT.2\n\t/**\n\t * @dev iNFTs may get created with the ALI tokens bound to them.\n\t *      The tokens are transferred from the address specified.\n\t *      The address specified has to approve the sale to spend tokens.\n\t *\n\t * @dev Both `aliSource` and `aliValue` must be set in order to bind tokens\n\t *      to iNFTs sold\n\t *\n\t * @dev Both `aliSource` and `aliValue` can be either set or unset\n\t */\n\taddress public aliSource;\n\n\t/**\n\t * @dev iNFTs may get created with the ALI tokens bound to them.\n\t *      Specified amount of tokens is transferred from the address specified above\n\t *      for each iNFT created, and is bound within the iNFT\n\t *      The address specified above has to approve the sale to spend tokens.\n\t *\n\t * @dev Both `aliSource` and `aliValue` must be set in order to bind tokens\n\t *      to iNFTs sold\n\t *\n\t * @dev Both `aliSource` and `aliValue` can be either set or unset\n\t */\n\tuint96 public aliValue;\n\n\t/**\n\t * @notice Allows buying the items publicly, effectively ignoring the buyer permission\n\t *\n\t * @dev When `FEATURE_PUBLIC_SALE` is enabled, `ROLE_BUYER` is ignored and\n\t *      buying items via buy(), buyTo(), buySingle(), buySingleTo() becomes publicly accessible\n\t */\n\tuint32 public constant FEATURE_PUBLIC_SALE = 0x0000_0001;\n\n\t/**\n\t * @notice Sale manager is responsible for managing properties of the sale,\n\t *      such as sale price, amount, start/end dates, etc.\n\t *\n\t * @dev Role ROLE_SALE_MANAGER allows updating sale properties via initialize() function\n\t */\n\tuint32 public constant ROLE_SALE_MANAGER = 0x0001_0000;\n\n\t/**\n\t * @notice Withdrawal manager is responsible for withdrawing ETH obtained in sale\n\t *      from the sale smart contract\n\t *\n\t * @dev Role ROLE_WITHDRAWAL_MANAGER allows ETH withdrawals:\n\t *      - withdraw()\n\t *      - withdrawTo()\n\t */\n\tuint32 public constant ROLE_WITHDRAWAL_MANAGER = 0x0002_0000;\n\n\t/**\n\t * @notice Buyer can buy items via the restricted sale\n\t *\n\t * @dev Role ROLE_BUYER allows buying items via buy(), buyTo(), buySingle(), buySingleTo()\n\t */\n\tuint32 public constant ROLE_BUYER = 0x0004_0000;\n\n\t/**\n\t * @dev Fired in initialize()\n\t *\n\t * @param _by an address which executed the initialization\n\t * @param _itemPrice price of one iNFT created\n\t * @param _nextId next ID of the iNFT, NFT, and AI Pod to mint\n\t * @param _finalId final ID of the iNFT, NFT, and AI Pod to mint\n\t * @param _saleStart start of the sale, unix timestamp\n\t * @param _saleEnd end of the sale, unix timestamp\n\t * @param _batchLimit how many iNFTs is allowed to buy in a single transaction\n\t * @param _aliSource an address to transfer ALI tokens from to bind to iNFTs created\n\t * @param _aliValue an amount of ALI tokens to transfer and bind for each iNFT created\n\t */\n\tevent Initialized(\n\t\taddress indexed _by,\n\t\tuint64 _itemPrice,\n\t\tuint32 _nextId,\n\t\tuint32 _finalId,\n\t\tuint32 _saleStart,\n\t\tuint32 _saleEnd,\n\t\tuint32 _batchLimit,\n\t\taddress indexed _aliSource,\n\t\tuint96 _aliValue\n\t);\n\n\t/**\n\t * @dev Fired in buy(), buyTo(), buySingle(), and buySingleTo()\n\t *\n\t * @param _by an address which executed and payed the transaction, probably a buyer\n\t * @param _to an address which received token(s) and iNFT(s) minted\n\t * @param _amount number of tokens and iNFTs minted\n\t * @param _aliValue number of ALI tokens transferred\n\t * @param _value ETH amount charged\n\t */\n\tevent Bought(address indexed _by, address indexed _to, uint256 _amount, uint256 _aliValue, uint256 _value);\n\n\t/**\n\t * @dev Fired in withdraw() and withdrawTo()\n\t *\n\t * @param _by an address which executed the withdrawal\n\t * @param _to an address which received the ETH withdrawn\n\t * @param _value ETH amount withdrawn\n\t */\n\tevent Withdrawn(address indexed _by, address indexed _to, uint256 _value);\n\n\t/**\n\t * @dev Creates/deploys FixedSupplySale and binds it to NFT, AI Personality, and iNFT\n\t *      smart contracts on construction\n\t *\n\t * @param _ali deployed ALI ERC20 smart contract address; sale may bind tokens to iNFTs created\n\t * @param _iNft deployed iNFT smart contract address; sale will create iNFTs of that type\n\t * @param _nft deployed NFT smart contract address; sale will mint NFTs of that type\n\t *      and bind created iNFT to these NFTs\n\t * @param _personality deployed AI Personality smart contract; sale will mint AI Personality\n\t *      tokens of that type and lock them within iNFTs\n\t */\n\tconstructor(address _ali, address _nft, address _personality, address _iNft) AccessControl(msg.sender) {\n\t\t// verify the inputs are set\n\t\trequire(_ali != address(0), \"ALI Token contract is not set\");\n\t\trequire(_nft != address(0), \"NFT contract is not set\");\n\t\trequire(_personality != address(0), \"AI Personality contract is not set\");\n\t\trequire(_iNft != address(0), \"iNFT contract is not set\");\n\n\t\t// verify inputs are valid smart contracts of the expected interfaces\n\t\trequire(ERC165(_ali).supportsInterface(type(ERC20).interfaceId), \"unexpected ALI Token type\");\n\t\trequire(\n\t\t\tERC165(_nft).supportsInterface(type(ERC721).interfaceId)\n\t\t\t&& ERC165(_nft).supportsInterface(type(MintableERC721).interfaceId),\n\t\t\t\"unexpected NFT type\"\n\t\t);\n\t\trequire(\n\t\t\tERC165(_personality).supportsInterface(type(ERC721).interfaceId)\n\t\t\t&& ERC165(_personality).supportsInterface(type(MintableERC721).interfaceId),\n\t\t\t\"unexpected AI Personality type\"\n\t\t);\n\t\trequire(ERC165(_iNft).supportsInterface(type(IntelligentNFTv2Spec).interfaceId), \"unexpected iNFT type\");\n\n\t\t// assign the addresses\n\t\taliContract = _ali;\n\t\tnftContract = _nft;\n\t\tpersonalityContract = _personality;\n\t\tiNftContract = _iNft;\n\t}\n\n\t/**\n\t * @notice Number of iNFTs left on sale\n\t *\n\t * @dev Doesn't take into account if sale is active or not,\n\t *      if `nextId - finalId < 1` returns zero\n\t *\n\t * @return number of iNFTs left on sale\n\t */\n\tfunction itemsOnSale() public view returns(uint32) {\n\t\t// calculate items left on sale, taking into account that\n\t\t// finalId is on sale (inclusive bound)\n\t\treturn finalId > nextId? finalId + 1 - nextId: 0;\n\t}\n\n\t/**\n\t * @notice Number of iNFTs available on sale\n\t *\n\t * @dev Takes into account if sale is active or not, doesn't throw,\n\t *      returns zero if sale is inactive\n\t *\n\t * @return number of iNFTs available on sale\n\t */\n\tfunction itemsAvailable() public view returns(uint32) {\n\t\t// delegate to itemsOnSale() if sale is active, return zero otherwise\n\t\treturn isActive()? itemsOnSale(): 0;\n\t}\n\n\t/**\n\t * @notice Active sale is an operational sale capable of minting and selling\n\t *      iNFTs (together with minting the underlying assets - NFTs and AI Personalities)\n\t *\n\t * @dev The sale is active when all the requirements below are met:\n\t *      1. Price is set (`itemPrice` is not zero)\n\t *      2. `finalId` is not reached (`nextId <= finalId`)\n\t *      3. current timestamp is between `saleStart` (inclusive) and `saleEnd` (exclusive)\n\t *\n\t * @dev Function is marked as virtual to be overridden in the helper test smart contract (mock)\n\t *      in order to test how it affects the sale process\n\t *\n\t * @return true if sale is active (operational) and can sell iNFTs, false otherwise\n\t */\n\tfunction isActive() public view virtual returns(bool) {\n\t\t// evaluate sale state based on the internal state variables and return\n\t\treturn itemPrice > 0 && nextId <= finalId && saleStart <= now256() && saleEnd > now256();\n\t}\n\n\t/**\n\t * @dev Restricted access function to set up sale parameters, all at once,\n\t *      or any subset of them\n\t *\n\t * @dev To skip parameter initialization, set it to `-1`,\n\t *      that is a maximum value for unsigned integer of the corresponding type;\n\t *      `_aliSource` and `_aliValue` must both be either set or skipped\n\t *\n\t * @dev Example: following initialization will update only _itemPrice and _batchLimit,\n\t *      leaving the rest of the fields unchanged\n\t *      initialize(\n\t *          100000000000000000,\n\t *          0xFFFFFFFF,\n\t *          0xFFFFFFFF,\n\t *          0xFFFFFFFF,\n\t *          0xFFFFFFFF,\n\t *          10,\n\t *          0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF,\n\t *          0xFFFFFFFFFFFFFFFFFFFFFFFF\n\t *      )\n\t *\n\t * @dev Requires next ID to be greater than zero (strict): `_nextId > 0`\n\t * @dev Requires ALI source/value to be both either set or unset (zero);\n\t *      if set, ALI value must not be less than 1e12 (0.000001 ALI)\n\t *\n\t * @dev Requires transaction sender to have `ROLE_SALE_MANAGER` role\n\t *\n\t * @param _itemPrice price of one iNFT created (with NFT and AI Personality also minted);\n\t *      setting the price to zero deactivates the sale\n\t * @param _nextId next ID of the iNFT, NFT, and AI Pod to mint, will be increased\n\t *      in smart contract storage after every successful buy\n\t * @param _finalId final ID of the iNFT, NFT, and AI Pod to mint; sale is capable of producing\n\t *      `_finalId - _nextId + 1` iNFTs\n\t * @param _saleStart start of the sale, unix timestamp\n\t * @param _saleEnd end of the sale, unix timestamp; sale is active only\n\t *      when current time is within _saleStart (inclusive) and _saleEnd (exclusive)\n\t * @param _batchLimit how many iNFTs is allowed to buy in a single transaction,\n\t *      set to zero to disable the limit\n\t * @param _aliSource an address to transfer ALI tokens from to bind to iNFTs created\n\t * @param _aliValue an amount of ALI tokens to transfer and bind for each iNFT created\n\t */\n\tfunction initialize(\n\t\tuint64 _itemPrice,\t// <<<--- keep type in sync with the body type(uint64).max !!!\n\t\tuint32 _nextId,\t// <<<--- keep type in sync with the body type(uint32).max !!!\n\t\tuint32 _finalId,\t// <<<--- keep type in sync with the body type(uint32).max !!!\n\t\tuint32 _saleStart,\t// <<<--- keep type in sync with the body type(uint32).max !!!\n\t\tuint32 _saleEnd,\t// <<<--- keep type in sync with the body type(uint32).max !!!\n\t\tuint32 _batchLimit,\t// <<<--- keep type in sync with the body type(uint32).max !!!\n\t\taddress _aliSource,\t// <<<--- keep that in sync with the body type(uint160).max !!!\n\t\tuint96 _aliValue\t// <<<--- keep type in sync with the body type(uint96).max !!!\n\t) public {\n\t\t// check the access permission\n\t\trequire(isSenderInRole(ROLE_SALE_MANAGER), \"access denied\");\n\n\t\t// verify the inputs\n\t\trequire(_nextId > 0, \"zero nextId\");\n\t\t// ALI source/value should be either both set or both unset\n\t\t// ALI value must not be too low if set\n\t\trequire(_aliSource == address(0) && _aliValue == 0 || _aliSource != address(0) && _aliValue >= 1e12, \"invalid ALI source/value\");\n\n\t\t// no need to verify extra parameters - \"incorrect\" values will deactivate the sale\n\n\t\t// initialize contract state based on the values supplied\n\t\t// take into account our convention that value `-1` means \"do not set\"\n\t\t// 0xFFFFFFFFFFFFFFFF, 64 bits\n\t\tif(_itemPrice != type(uint64).max) {\n\t\t\titemPrice = _itemPrice;\n\t\t}\n\t\t// 0xFFFFFFFF, 32 bits\n\t\tif(_nextId != type(uint32).max) {\n\t\t\tnextId = _nextId;\n\t\t}\n\t\t// 0xFFFFFFFF, 32 bits\n\t\tif(_finalId != type(uint32).max) {\n\t\t\tfinalId = _finalId;\n\t\t}\n\t\t// 0xFFFFFFFF, 32 bits\n\t\tif(_saleStart != type(uint32).max) {\n\t\t\tsaleStart = _saleStart;\n\t\t}\n\t\t// 0xFFFFFFFF, 32 bits\n\t\tif(_saleEnd != type(uint32).max) {\n\t\t\tsaleEnd = _saleEnd;\n\t\t}\n\t\t// 0xFFFFFFFF, 32 bits\n\t\tif(_batchLimit != type(uint32).max) {\n\t\t\tbatchLimit = _batchLimit;\n\t\t}\n\t\t// 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF and 0xFFFFFFFFFFFFFFFFFFFFFFFF, 160 and 96 bits\n\t\tif(uint160(_aliSource) != type(uint160).max && _aliValue != type(uint96).max) {\n\t\t\taliSource = _aliSource;\n\t\t\taliValue = _aliValue;\n\t\t}\n\n\t\t// emit an event - read values from the storage since not all of them might be set\n\t\temit Initialized(\n\t\t\tmsg.sender,\n\t\t\titemPrice,\n\t\t\tnextId,\n\t\t\tfinalId,\n\t\t\tsaleStart,\n\t\t\tsaleEnd,\n\t\t\tbatchLimit,\n\t\t\taliSource,\n\t\t\taliValue\n\t\t);\n\t}\n\n\t/**\n\t * @notice Buys several (at least two) iNFTs in a batch.\n\t *      Accepts ETH as payment and creates iNFT with minted bound NFT and minted linked AI Personality\n\t *\n\t * @param _amount amount of iNFTs to create (same amount of NFTs and AI Personalities\n\t *      will be created and bound/locked to iNFT), two or more\n\t */\n\tfunction buy(uint32 _amount) public virtual payable {\n\t\t// delegate to `buyTo` with the transaction sender set to be a recipient\n\t\tbuyTo(msg.sender, _amount);\n\t}\n\n\t/**\n\t * @notice Buys several (at least two) iNFTs in a batch to an address specified.\n\t *      Accepts ETH as payment and creates iNFT with minted bound NFT and minted linked AI Personality\n\t *\n\t * @param _to address to mint tokens and iNFTs to\n\t * @param _amount amount of iNFTs to create (same amount of NFTs and AI Personalities\n\t *      will be created and bound/locked to iNFT), two or more\n\t */\n\tfunction buyTo(address _to, uint32 _amount) public virtual payable {\n\t\t// check the access permission\n\t\trequire(isFeatureEnabled(FEATURE_PUBLIC_SALE) || isSenderInRole(ROLE_BUYER), \"access denied\");\n\n\t\t// verify the inputs\n\t\trequire(_to != address(0), \"recipient not set\");\n\t\trequire(_amount > 1 && (batchLimit == 0 || _amount <= batchLimit), \"incorrect amount\");\n\n\t\t// verify there is enough items available to buy the amount\n\t\t// verifies sale is in active state under the hood\n\t\trequire(itemsAvailable() >= _amount, \"inactive sale or not enough items available\");\n\n\t\t// calculate the total price required and validate the transaction value\n\t\tuint256 totalPrice = uint256(itemPrice) * _amount;\n\t\trequire(msg.value >= totalPrice, \"not enough funds\");\n\n\t\t// based on ALI value set on the contract and amount of iNFTs to create\n\t\t// calculate the cumulative ALI value to be sent to iNFT\n\t\t// note: cumulative ALI value may overflow uint96, store it into uint256 on stack\n\t\tuint256 _aliValue = uint256(aliValue) * _amount;\n\t\t// if it's not zero (that is if ALI token binding is enabled)\n\t\tif(_aliValue != 0) {\n\t\t\t// transfer ALI amount required to iNFT smart contract\n\t\t\tERC20(aliContract).transferFrom(aliSource, iNftContract, _aliValue);\n\t\t}\n\n\t\t// mint NFTs to the recipient\n\t\tMintableERC721(nftContract).safeMintBatch(_to, nextId, _amount);\n\n\t\t// mint AI Personality directly to iNFT smart contract\n\t\tMintableERC721(personalityContract).mintBatch(iNftContract, nextId, _amount);\n\n\t\t// create iNFT bound to NFT minted and locking the AI Personality minted\n\t\tIntelligentNFTv2(iNftContract).mintBatch(\n\t\t\tnextId, // first recordId\n\t\t\taliValue, // ALI value\n\t\t\tpersonalityContract, // AI Personality contract address\n\t\t\tnextId, // first AI Personality ID\n\t\t\tnftContract, // NFT contract address\n\t\t\tnextId, // first target NFT ID\n\t\t\t_amount // amount of iNFTs to create\n\t\t);\n\n\t\t// increment `nextId`\n\t\tnextId += _amount;\n\t\t// increment `soldCounter`\n\t\tsoldCounter += _amount;\n\n\t\t// if ETH amount supplied exceeds the price\n\t\tif(msg.value > totalPrice) {\n\t\t\t// send excess amount back to sender\n\t\t\tpayable(msg.sender).transfer(msg.value - totalPrice);\n\t\t}\n\n\t\t// emit en event\n\t\temit Bought(msg.sender, _to, _amount, _aliValue, totalPrice);\n\t}\n\n\t/**\n\t * @notice Buys single iNFTs.\n\t *      Accepts ETH as payment and creates iNFT with minted bound NFT and minted linked AI Personality\n\t */\n\tfunction buySingle() public virtual payable {\n\t\t// delegate to `buySingleTo` with the transaction sender set to be a recipient\n\t\tbuySingleTo(msg.sender);\n\t}\n\n\t/**\n\t * @notice Buys single iNFTs to an address specified.\n\t *      Accepts ETH as payment and creates iNFT with minted bound NFT and minted linked AI Personality\n\t *\n\t * @param _to address to mint tokens and iNFT to\n\t */\n\tfunction buySingleTo(address _to) public virtual payable {\n\t\t// check the access permission\n\t\trequire(isFeatureEnabled(FEATURE_PUBLIC_SALE) || isSenderInRole(ROLE_BUYER), \"access denied\");\n\n\t\t// verify the inputs and transaction value\n\t\trequire(_to != address(0), \"recipient not set\");\n\t\trequire(msg.value >= itemPrice, \"not enough funds\");\n\n\t\t// verify sale is in active state\n\t\trequire(isActive(), \"inactive sale\");\n\n\t\t// if ALI token binding is enabled\n\t\tif(aliValue != 0) {\n\t\t\t// transfer ALI amount required to iNFT smart contract\n\t\t\tERC20(aliContract).transferFrom(aliSource, iNftContract, aliValue);\n\t\t}\n\t\t// mint NFT to the recipient\n\t\tMintableERC721(nftContract).safeMint(_to, nextId);\n\t\t// mint AI Personality directly to iNFT smart contract\n\t\tMintableERC721(personalityContract).mint(iNftContract, nextId);\n\t\t// create iNFT bound to NFT minted and locking the AI Personality minted\n\t\tIntelligentNFTv2(iNftContract).mint(nextId, aliValue, personalityContract, nextId, nftContract, nextId);\n\n\t\t// increment `nextId`\n\t\tnextId++;\n\t\t// increment `soldCounter`\n\t\tsoldCounter++;\n\n\t\t// if ETH amount supplied exceeds the price\n\t\tif(msg.value > itemPrice) {\n\t\t\t// send excess amount back to sender\n\t\t\tpayable(msg.sender).transfer(msg.value - itemPrice);\n\t\t}\n\n\t\t// emit en event\n\t\temit Bought(msg.sender, _to, 1, aliValue, itemPrice);\n\t}\n\n\t/**\n\t * @dev Restricted access function to withdraw ETH on the contract balance,\n\t *      sends ETH back to transaction sender\n\t */\n\tfunction withdraw() public {\n\t\t// delegate to `withdrawTo`\n\t\twithdrawTo(msg.sender);\n\t}\n\n\t/**\n\t * @dev Restricted access function to withdraw ETH on the contract balance,\n\t *      sends ETH to the address specified\n\t *\n\t * @param _to an address to send ETH to\n\t */\n\tfunction withdrawTo(address _to) public {\n\t\t// check the access permission\n\t\trequire(isSenderInRole(ROLE_WITHDRAWAL_MANAGER), \"access denied\");\n\n\t\t// verify withdrawal address is set\n\t\trequire(_to != address(0), \"address not set\");\n\n\t\t// ETH value to send\n\t\tuint256 _value = address(this).balance;\n\n\t\t// verify sale balance is positive (non-zero)\n\t\trequire(_value > 0, \"zero balance\");\n\n\t\t// send the entire balance to the transaction sender\n\t\tpayable(_to).transfer(_value);\n\n\t\t// emit en event\n\t\temit Withdrawn(msg.sender, _to, _value);\n\t}\n\n\t/**\n\t * @dev Testing time-dependent functionality may be difficult;\n\t *      we override time in the helper test smart contract (mock)\n\t *\n\t * @return `block.timestamp` in mainnet, custom values in testnets (if overridden)\n\t */\n\tfunction now256() public view virtual returns (uint256) {\n\t\t// return current block timestamp\n\t\treturn block.timestamp;\n\t}\n}\n"
    },
    "contracts/protocol/IntelligentNFTv2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ERC20Spec.sol\";\nimport \"../interfaces/ERC721Spec.sol\";\nimport \"../lib/StringUtils.sol\";\nimport \"../utils/AccessControl.sol\";\n\n/**\n * @title Intelligent NFT Interface\n *        Version 2\n *\n * @notice External interface of IntelligentNFTv2 declared to support ERC165 detection.\n *      Despite some similarity with ERC721 interfaces, iNFT is not ERC721, any similarity\n *      should be treated as coincidental. Client applications may benefit from this similarity\n *      to reuse some of the ERC721 client code for display/reading.\n *\n * @dev See Intelligent NFT documentation below.\n */\ninterface IntelligentNFTv2Spec {\n\t/**\n\t * @dev ERC20/ERC721 like name - Intelligent NFT\n\t *\n\t * @return \"Intelligent NFT\"\n\t */\n\tfunction name() external view returns (string memory);\n\n\t/**\n\t * @dev ERC20/ERC721 like symbol - iNFT\n\t *\n\t * @return \"iNFT\"\n\t */\n\tfunction symbol() external view returns (string memory);\n\n\t/**\n\t * @dev ERC721 like link to the iNFT metadata\n\t *\n\t * @param recordId iNFT ID to get metadata URI for\n\t */\n\tfunction tokenURI(uint256 recordId) external view returns (string memory);\n\n\t/**\n\t * @dev ERC20/ERC721 like counter of the iNFTs in existence (upper bound),\n\t *      some (or all) of which may not exist due to target NFT destruction\n\t *\n\t * @return amount of iNFT tracked by this smart contract\n\t */\n\tfunction totalSupply() external view returns (uint256);\n\n\t/**\n\t * @dev Check if iNFT binding with the given ID exists\n\t *\n\t * @return true if iNFT binding exist, false otherwise\n\t */\n\tfunction exists(uint256 recordId) external view returns (bool);\n\n\t/**\n\t * @dev ERC721 like function to get owner of the iNFT, which is by definition\n\t *      an owner of the underlying NFT\n\t */\n\tfunction ownerOf(uint256 recordId) external view returns (address);\n}\n\n/**\n * @title Intelligent NFT (iNFT)\n *        Version 2\n *\n * @notice Intelligent NFT (iNFT) represents an enhancement to an existing NFT\n *      (we call it a \"target\" or \"target NFT\"), it binds a GPT-3 prompt (a \"personality prompt\",\n *      delivered as a Personality Pod ERC721 token bound to iNFT)\n *      to the target to embed intelligence, is controlled and belongs to the owner of the target.\n *\n * @notice iNFT stores AI Personality and some amount of ALI tokens locked, available for\n *      unlocking when iNFT is destroyed\n *\n * @notice iNFT is not an ERC721 token, but it has some very limited similarity to an ERC721:\n *      every record is identified by ID and this ID has an owner, which is effectively the target NFT owner;\n *      still, it doesn't store ownership information itself and fully relies on the target ownership instead\n *\n * @dev Internally iNFTs consist of:\n *      - target NFT - smart contract address and ID of the NFT the iNFT is bound to\n *      - AI Personality - smart contract address and ID of the AI Personality used to produce given iNFT,\n *        representing a \"personality prompt\", and locked within an iNFT\n *      - ALI tokens amount - amount of the ALI tokens used to produce given iNFT, also locked\n *\n * @dev iNFTs can be\n *      - created, this process requires an AI Personality and ALI tokens to be locked\n *      - destroyed, this process releases an AI Personality and ALI tokens previously locked\n */\ncontract IntelligentNFTv2 is IntelligentNFTv2Spec, AccessControl, ERC165 {\n\t/**\n\t * @inheritdoc IntelligentNFTv2Spec\n\t */\n\tstring public override name = \"Intelligent NFT\";\n\n\t/**\n\t * @inheritdoc IntelligentNFTv2Spec\n\t */\n\tstring public override symbol = \"iNFT\";\n\n\t/**\n\t * @dev Each intelligent token, represented by its unique ID, is bound to the target NFT,\n\t *      defined by the pair of the target NFT smart contract address and unique token ID\n\t *      within the target NFT smart contract\n\t *\n\t * @dev Effectively iNFT is owned by the target NFT owner\n\t *\n\t * @dev Additionally, each token holds an AI Personality and some amount of ALI tokens bound to it\n\t *\n\t * @dev `IntelliBinding` keeps all the binding information, including target NFT coordinates,\n\t *      bound AI Personality ID, and amount of ALI ERC20 tokens bound to the iNFT\n\t */\n\tstruct IntelliBinding {\n\t\t// Note: structure members are reordered to fit into less memory slots, see EVM memory layout\n\t\t// ----- SLOT.1 (256/256)\n\t\t/**\n\t\t * @dev Specific AI Personality is defined by the pair of AI Personality smart contract address\n\t\t *       and AI Personality ID\n\t\t *\n\t\t * @dev Address of the AI Personality smart contract\n\t\t */\n\t\taddress personalityContract;\n\n\t\t/**\n\t\t * @dev AI Personality ID within the AI Personality smart contract\n\t\t */\n\t\tuint96 personalityId;\n\n\t\t// ----- SLOT.2 (256/256)\n\t\t/**\n\t\t * @dev Amount of an ALI ERC20 tokens bound to (owned by) the iNFTs\n\t\t *\n\t\t * @dev ALI ERC20 smart contract address is defined globally as `aliContract` constant\n\t\t */\n\t\tuint96 aliValue;\n\n\t\t/**\n\t\t * @dev Address of the target NFT deployed smart contract,\n\t\t *      this is a contract a particular iNFT is bound to\n\t\t */\n\t\taddress targetContract;\n\n\t\t// ----- SLOT.3 (256/256)\n\t\t/**\n\t\t * @dev Target NFT ID within the target NFT smart contract,\n\t\t *      effectively target NFT ID and contract address define the owner of an iNFT\n\t\t */\n\t\tuint256 targetId;\n\t}\n\n\t/**\n\t * @notice iNFT binding storage, stores binding information for each existing iNFT\n\t * @dev Maps iNFT ID to its binding data, which includes underlying NFT data\n\t */\n\tmapping(uint256 => IntelliBinding) public bindings;\n\n\t/**\n\t * @notice Reverse iNFT binding allows to find iNFT bound to a particular NFT\n\t * @dev Maps target NFT (smart contract address and unique token ID) to the iNFT ID:\n\t *      NFT Contract => NFT ID => iNFT ID\n\t */\n\tmapping(address => mapping(uint256 => uint256)) public reverseBindings;\n\n\t/**\n\t * @notice Ai Personality to iNFT binding allows to find iNFT bound to a particular Ai Personality\n\t * @dev Maps Ai Personality NFT (unique token ID) to the linked iNFT:\n\t *      AI Personality Contract => AI Personality ID => iNFT ID\n\t */\n\tmapping(address => mapping(uint256 => uint256)) public personalityBindings;\n\n\t/**\n\t * @notice Total amount (maximum value estimate) of iNFT in existence.\n\t *       This value can be higher than number of effectively accessible iNFTs\n\t *       since when underlying NFT gets burned this value doesn't get updated.\n\t */\n\tuint256 public override totalSupply;\n\n\t/**\n\t * @notice Each iNFT holds some ALI tokens, which are tracked by the ALI token ERC20 smart contract defined here\n\t */\n\taddress public immutable aliContract;\n\n\t/**\n\t * @notice ALI token balance the contract is aware of, cumulative ALI obligation,\n\t *      i.e. sum of all iNFT locked ALI balances\n\t *\n\t * @dev Sum of all `IntelliBinding.aliValue` for each iNFT in existence\n\t */\n\tuint256 public aliBalance;\n\n\t/**\n\t * @dev Base URI is used to construct ERC721Metadata.tokenURI as\n\t *      `base URI + token ID` if token URI is not set (not present in `_tokenURIs` mapping)\n\t *\n\t * @dev For example, if base URI is https://api.com/token/, then token #1\n\t *      will have an URI https://api.com/token/1\n\t *\n\t * @dev If token URI is set with `setTokenURI()` it will be returned as is via `tokenURI()`\n\t */\n\tstring public baseURI = \"\";\n\n\t/**\n\t * @dev Optional mapping for token URIs to be returned as is when `tokenURI()`\n\t *      is called; if mapping doesn't exist for token, the URI is constructed\n\t *      as `base URI + token ID`, where plus (+) denotes string concatenation\n\t */\n\tmapping(uint256 => string) internal _tokenURIs;\n\n\t/**\n\t * @notice Minter is responsible for creating (minting) iNFTs\n\t *\n\t * @dev Role ROLE_MINTER allows minting iNFTs (calling `mint` function)\n\t */\n\tuint32 public constant ROLE_MINTER = 0x0001_0000;\n\n\t/**\n\t * @notice Burner is responsible for destroying (burning) iNFTs\n\t *\n\t * @dev Role ROLE_BURNER allows burning iNFTs (calling `burn` function)\n\t */\n\tuint32 public constant ROLE_BURNER = 0x0002_0000;\n\n\t/**\n\t * @notice Editor is responsible for editing (updating) iNFT records in general,\n\t *      adding/removing locked ALI tokens to/from iNFT in particular\n\t *\n\t * @dev Role ROLE_EDITOR allows editing iNFTs (calling `increaseAli`, `decreaseAli` functions)\n\t */\n\tuint32 public constant ROLE_EDITOR = 0x0004_0000;\n\n\t/**\n\t * @notice URI manager is responsible for managing base URI\n\t *      part of the token URI ERC721Metadata interface\n\t *\n\t * @dev Role ROLE_URI_MANAGER allows updating the base URI\n\t *      (executing `setBaseURI` function)\n\t */\n\tuint32 public constant ROLE_URI_MANAGER = 0x0010_0000;\n\n\t/**\n\t * @dev Fired in setBaseURI()\n\t *\n\t * @param _by an address which executed update\n\t * @param _oldVal old _baseURI value\n\t * @param _newVal new _baseURI value\n\t */\n\tevent BaseURIUpdated(address indexed _by, string _oldVal, string _newVal);\n\n\t/**\n\t * @dev Fired in setTokenURI()\n\t *\n\t * @param _by an address which executed update\n\t * @param _tokenId token ID which URI was updated\n\t * @param _oldVal old _baseURI value\n\t * @param _newVal new _baseURI value\n\t */\n\tevent TokenURIUpdated(address indexed _by, uint256 indexed _tokenId, string _oldVal, string _newVal);\n\n\t/**\n\t * @dev Fired in mint() when new iNFT is created\n\t *\n\t * @param _by an address which executed the mint function\n\t * @param _owner current owner of the NFT\n\t * @param _recordId ID of the iNFT minted (created, bound)\n\t * @param _aliValue amount of ALI tokens locked within newly created iNFT\n\t * @param _personalityContract AI Personality smart contract address\n\t * @param _personalityId ID of the AI Personality locked within newly created iNFT\n\t * @param _targetContract target NFT smart contract address\n\t * @param _targetId target NFT ID (where this iNFT binds to and belongs to)\n\t */\n\tevent Minted(\n\t\taddress indexed _by,\n\t\taddress indexed _owner,\n\t\tuint256 indexed _recordId,\n\t\tuint96 _aliValue,\n\t\taddress _personalityContract,\n\t\tuint96 _personalityId,\n\t\taddress _targetContract,\n\t\tuint256 _targetId\n\t);\n\n\t/**\n\t * @dev Fired in increaseAli() and decreaseAli() when iNFT record is updated\n\t *\n\t * @param _by an address which executed the update\n\t * @param _owner iNFT (target NFT) owner\n\t * @param _recordId ID of the updated iNFT\n\t * @param _oldAliValue amount of ALI tokens locked within iNFT before update\n\t * @param _newAliValue amount of ALI tokens locked within iNFT after update\n\t */\n\tevent Updated(\n\t\taddress indexed _by,\n\t\taddress indexed _owner,\n\t\tuint256 indexed _recordId,\n\t\tuint96 _oldAliValue,\n\t\tuint96 _newAliValue\n\t);\n\n\t/**\n\t * @dev Fired in burn() when an existing iNFT gets destroyed\n\t *\n\t * @param _by an address which executed the burn function\n\t * @param _recordId ID of the iNFT burnt (destroyed, unbound)\n\t * @param _recipient and address which received unlocked AI Personality and ALI tokens\n\t * @param _aliValue amount of ALI tokens transferred from the destroyed iNFT\n\t * @param _personalityContract AI Personality smart contract address\n\t * @param _personalityId ID of the AI Personality transferred from the destroyed iNFT\n\t * @param _targetContract target NFT smart contract\n\t * @param _targetId target NFT ID (where this iNFT was bound to and belonged to)\n\t */\n\tevent Burnt(\n\t\taddress indexed _by,\n\t\tuint256 indexed _recordId,\n\t\taddress indexed _recipient,\n\t\tuint96 _aliValue,\n\t\taddress _personalityContract,\n\t\tuint96 _personalityId,\n\t\taddress _targetContract,\n\t\tuint256 _targetId\n\t);\n\n\t/**\n\t * @dev Creates/deploys an iNFT instance bound to already deployed ALI token instance\n\t *\n\t * @param _ali address of the deployed ALI ERC20 Token instance the iNFT is bound to\n\t */\n\tconstructor(address _ali) AccessControl(msg.sender) {\n\t\t// verify the inputs are set\n\t\trequire(_ali != address(0), \"ALI Token addr is not set\");\n\n\t\t// verify _ali is a valid ERC20\n\t\trequire(ERC165(_ali).supportsInterface(type(ERC20).interfaceId), \"unexpected ALI Token type\");\n\n\t\t// setup smart contract internal state\n\t\taliContract = _ali;\n\t}\n\n\t/**\n\t * @inheritdoc ERC165\n\t */\n\tfunction supportsInterface(bytes4 interfaceId) public pure override returns (bool) {\n\t\t// reconstruct from current interface and super interface\n\t\treturn interfaceId == type(IntelligentNFTv2Spec).interfaceId;\n\t}\n\n\t/**\n\t * @dev Restricted access function which updates base URI used to construct\n\t *      ERC721Metadata.tokenURI\n\t *\n\t * @param _baseURI new base URI to set\n\t */\n\tfunction setBaseURI(string memory _baseURI) public virtual {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_URI_MANAGER), \"access denied\");\n\n\t\t// emit an event first - to log both old and new values\n\t\temit BaseURIUpdated(msg.sender, baseURI, _baseURI);\n\n\t\t// and update base URI\n\t\tbaseURI = _baseURI;\n\t}\n\n\t/**\n\t * @dev Returns token URI if it was previously set with `setTokenURI`,\n\t *      otherwise constructs it as base URI + token ID\n\t *\n\t * @param _recordId iNFT ID to query metadata link URI for\n\t * @return URI link to fetch iNFT metadata from\n\t */\n\tfunction tokenURI(uint256 _recordId) public view override returns (string memory) {\n\t\t// verify token exists\n\t\trequire(exists(_recordId), \"iNFT doesn't exist\");\n\n\t\t// read the token URI for the token specified\n\t\tstring memory _tokenURI = _tokenURIs[_recordId];\n\n\t\t// if token URI is set\n\t\tif(bytes(_tokenURI).length > 0) {\n\t\t\t// just return it\n\t\t\treturn _tokenURI;\n\t\t}\n\n\t\t// if base URI is not set\n\t\tif(bytes(baseURI).length == 0) {\n\t\t\t// return an empty string\n\t\t\treturn \"\";\n\t\t}\n\n\t\t// otherwise concatenate base URI + token ID\n\t\treturn StringUtils.concat(baseURI, StringUtils.itoa(_recordId, 10));\n\t}\n\n\t/**\n\t * @dev Sets the token URI for the token defined by its ID\n\t *\n\t * @param _tokenId an ID of the token to set URI for\n\t * @param _tokenURI token URI to set\n\t */\n\tfunction setTokenURI(uint256 _tokenId, string memory _tokenURI) public virtual {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_URI_MANAGER), \"access denied\");\n\n\t\t// we do not verify token existence: we want to be able to\n\t\t// preallocate token URIs before tokens are actually minted\n\n\t\t// emit an event first - to log both old and new values\n\t\temit TokenURIUpdated(msg.sender, _tokenId, _tokenURIs[_tokenId], _tokenURI);\n\n\t\t// and update token URI\n\t\t_tokenURIs[_tokenId] = _tokenURI;\n\t}\n\n\t/**\n\t * @notice Verifies if given iNFT exists\n\t *\n\t * @param recordId iNFT ID to verify existence of\n\t * @return true if iNFT exists, false otherwise\n\t */\n\tfunction exists(uint256 recordId) public view override returns (bool) {\n\t\t// verify if biding exists for that tokenId and return the result\n\t\treturn bindings[recordId].targetContract != address(0);\n\t}\n\n\t/**\n\t * @notice Returns an owner of the given iNFT.\n\t *      By definition iNFT owner is an owner of the target NFT\n\t *\n\t * @param recordId iNFT ID to query ownership information for\n\t * @return address of the given iNFT owner\n\t */\n\tfunction ownerOf(uint256 recordId) public view override returns (address) {\n\t\t// get the link to the token binding (we need to access only one field)\n\t\tIntelliBinding storage binding = bindings[recordId];\n\n\t\t// verify the binding exists and throw standard Zeppelin message if not\n\t\trequire(binding.targetContract != address(0), \"iNFT doesn't exist\");\n\n\t\t// delegate `ownerOf` call to the target NFT smart contract\n\t\treturn ERC721(binding.targetContract).ownerOf(binding.targetId);\n\t}\n\n\t/**\n\t * @dev Restricted access function which creates an iNFT, binding it to the specified\n\t *      NFT, locking the AI Personality specified, and funded with the amount of ALI specified\n\t *\n\t * @dev Locks AI Personality defined by its ID within iNFT smart contract;\n\t *      AI Personality must be transferred to the iNFT smart contract\n\t *      prior to calling the `mint`, but in the same transaction with `mint`\n\t *\n\t * @dev Locks specified amount of ALI token within iNFT smart contract;\n\t *      ALI token amount must be transferred to the iNFT smart contract\n\t *      prior to calling the `mint`, but in the same transaction with `mint`\n\t *\n\t * @dev To summarize, minting transaction (a transaction which executes `mint`) must\n\t *      1) transfer AI Personality\n\t *      2) transfer ALI tokens if they are to be locked\n\t *      3) mint iNFT\n\t *      NOTE: breaking the items above into multiple transactions is not acceptable!\n\t *            (results in a security risk)\n\t *\n\t * @dev The NFT to be linked to is not required to owned by the funder, but it must exist;\n\t *      throws if target NFT doesn't exist\n\t *\n\t * @dev This is a restricted function which is accessed by iNFT Linker\n\t *\n\t * @param recordId ID of the iNFT to mint (create, bind)\n\t * @param aliValue amount of ALI tokens to bind to newly created iNFT\n\t * @param personalityContract AI Personality contract address\n\t * @param personalityId ID of the AI Personality to bind to newly created iNFT\n\t * @param targetContract target NFT smart contract\n\t * @param targetId target NFT ID (where this iNFT binds to and belongs to)\n\t */\n\tfunction mint(\n\t\tuint256 recordId,\n\t\tuint96 aliValue,\n\t\taddress personalityContract,\n\t\tuint96 personalityId,\n\t\taddress targetContract,\n\t\tuint256 targetId\n\t) public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_MINTER), \"access denied\");\n\n\t\t// verify personalityContract is a valid ERC721\n\t\trequire(ERC165(personalityContract).supportsInterface(type(ERC721).interfaceId), \"personality is not ERC721\");\n\n\t\t// verify targetContract is a valid ERC721\n\t\trequire(ERC165(targetContract).supportsInterface(type(ERC721).interfaceId), \"target NFT is not ERC721\");\n\n\t\t// verify this iNFT is not yet minted\n\t\trequire(!exists(recordId), \"iNFT already exists\");\n\n\t\t// verify target NFT is not yet bound to\n\t\trequire(reverseBindings[targetContract][targetId] == 0, \"NFT is already bound\");\n\n\t\t// verify AI Personality is not yet locked\n\t\trequire(personalityBindings[personalityContract][personalityId] == 0, \"personality already linked\");\n\n\t\t// verify if AI Personality is already transferred to iNFT\n\t\trequire(ERC721(personalityContract).ownerOf(personalityId) == address(this), \"personality is not yet transferred\");\n\n\t\t// retrieve NFT owner and verify if target NFT exists\n\t\taddress owner = ERC721(targetContract).ownerOf(targetId);\n\t\t// Note: we do not require funder to be NFT owner,\n\t\t// if required this constraint should be added by the caller (iNFT Linker)\n\t\trequire(owner != address(0), \"target NFT doesn't exist\");\n\n\t\t// in case when ALI tokens are expected to be locked within iNFT\n\t\tif(aliValue > 0) {\n\t\t\t// verify ALI tokens are already transferred to iNFT\n\t\t\trequire(aliBalance + aliValue <= ERC20(aliContract).balanceOf(address(this)), \"ALI tokens not yet transferred\");\n\n\t\t\t// update ALI balance on the contract\n\t\t\taliBalance += aliValue;\n\t\t}\n\n\t\t// bind AI Personality transferred and ALI ERC20 value transferred to an NFT specified\n\t\tbindings[recordId] = IntelliBinding({\n\t\t\tpersonalityContract : personalityContract,\n\t\t\tpersonalityId : personalityId,\n\t\t\taliValue : aliValue,\n\t\t\ttargetContract : targetContract,\n\t\t\ttargetId : targetId\n\t\t});\n\n\t\t// fill in the reverse binding\n\t\treverseBindings[targetContract][targetId] = recordId;\n\n\t\t// fill in the AI Personality to iNFT binding\n\t\tpersonalityBindings[personalityContract][personalityId] = recordId;\n\n\t\t// increase total supply counter\n\t\ttotalSupply++;\n\n\t\t// emit an event\n\t\temit Minted(\n\t\t\tmsg.sender,\n\t\t\towner,\n\t\t\trecordId,\n\t\t\taliValue,\n\t\t\tpersonalityContract,\n\t\t\tpersonalityId,\n\t\t\ttargetContract,\n\t\t\ttargetId\n\t\t);\n\t}\n\n\t/**\n\t * @dev Restricted access function which creates several iNFTs, binding them to the specified\n\t *      NFTs, locking the AI Personalities specified, each funded with the amount of ALI specified\n\t *\n\t * @dev Locks AI Personalities defined by their IDs within iNFT smart contract;\n\t *      AI Personalities must be transferred to the iNFT smart contract\n\t *      prior to calling the `mintBatch`, but in the same transaction with `mintBatch`\n\t *\n\t * @dev Locks specified amount of ALI token within iNFT smart contract for each iNFT minted;\n\t *      ALI token amount must be transferred to the iNFT smart contract\n\t *      prior to calling the `mintBatch`, but in the same transaction with `mintBatch`\n\t *\n\t * @dev To summarize, minting transaction (a transaction which executes `mintBatch`) must\n\t *      1) transfer AI Personality\n\t *      2) transfer ALI tokens if they are to be locked\n\t *      3) mint iNFT\n\t *      NOTE: breaking the items above into multiple transactions is not acceptable!\n\t *            (results in a security risk)\n\t *\n\t * @dev The NFTs to be linked to are not required to owned by the funder, but they must exist;\n\t *      throws if target NFTs don't exist\n\t *\n\t * @dev iNFT IDs to be minted: [recordId, recordId + n)\n\t * @dev AI Personality IDs to be locked: [personalityId, personalityId + n)\n\t * @dev NFT IDs to be bound to: [targetId, targetId + n)\n\t *\n\t * @dev n must be greater or equal 2: `n > 1`\n\t *\n\t * @dev This is a restricted function which is accessed by iNFT Linker\n\t *\n\t * @param recordId ID of the first iNFT to mint (create, bind)\n\t * @param aliValue amount of ALI tokens to bind to each newly created iNFT\n\t * @param personalityContract AI Personality contract address\n\t * @param personalityId ID of the first AI Personality to bind to newly created iNFT\n\t * @param targetContract target NFT smart contract\n\t * @param targetId first target NFT ID (where this iNFT binds to and belongs to)\n\t * @param n how many iNFTs to mint, sequentially increasing the recordId, personalityId, and targetId\n\t */\n\tfunction mintBatch(\n\t\tuint256 recordId,\n\t\tuint96 aliValue,\n\t\taddress personalityContract,\n\t\tuint96 personalityId,\n\t\taddress targetContract,\n\t\tuint256 targetId,\n\t\tuint96 n\n\t) public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_MINTER), \"access denied\");\n\n\t\t// verify n is set properly\n\t\trequire(n > 1, \"n is too small\");\n\n\t\t// verify personalityContract is a valid ERC721\n\t\trequire(ERC165(personalityContract).supportsInterface(type(ERC721).interfaceId), \"personality is not ERC721\");\n\n\t\t// verify targetContract is a valid ERC721\n\t\trequire(ERC165(targetContract).supportsInterface(type(ERC721).interfaceId), \"target NFT is not ERC721\");\n\n\t\t// verifications: for each iNFT in a batch\n\t\tfor(uint96 i = 0; i < n; i++) {\n\t\t\t// verify this token ID is not yet bound\n\t\t\trequire(!exists(recordId + i), \"iNFT already exists\");\n\n\t\t\t// verify the AI Personality is not yet bound\n\t\t\trequire(personalityBindings[personalityContract][personalityId + i] == 0, \"personality already linked\");\n\n\t\t\t// verify if AI Personality is already transferred to iNFT\n\t\t\trequire(ERC721(personalityContract).ownerOf(personalityId + i) == address(this), \"personality is not yet transferred\");\n\n\t\t\t// retrieve NFT owner and verify if target NFT exists\n\t\t\taddress owner = ERC721(targetContract).ownerOf(targetId + i);\n\t\t\t// Note: we do not require funder to be NFT owner,\n\t\t\t// if required this constraint should be added by the caller (iNFT Linker)\n\t\t\trequire(owner != address(0), \"target NFT doesn't exist\");\n\n\t\t\t// emit an event - we log owner for each iNFT\n\t\t\t// and its convenient to do it here when we have the owner inline\n\t\t\temit Minted(\n\t\t\t\tmsg.sender,\n\t\t\t\towner,\n\t\t\t\trecordId + i,\n\t\t\t\taliValue,\n\t\t\t\tpersonalityContract,\n\t\t\t\tpersonalityId + i,\n\t\t\t\ttargetContract,\n\t\t\t\ttargetId + i\n\t\t\t);\n\t\t}\n\n\t\t// cumulative ALI value may overflow uint96, store it into uint256 on stack\n\t\tuint256 _aliValue = uint256(aliValue) * n;\n\n\t\t// in case when ALI tokens are expected to be locked within iNFT\n\t\tif(_aliValue > 0) {\n\t\t\t// verify ALI tokens are already transferred to iNFT\n\t\t\trequire(aliBalance + _aliValue <= ERC20(aliContract).balanceOf(address(this)), \"ALI tokens not yet transferred\");\n\t\t\t// update ALI balance on the contract\n\t\t\taliBalance += _aliValue;\n\t\t}\n\n\t\t// minting: for each iNFT in a batch\n\t\tfor(uint96 i = 0; i < n; i++) {\n\t\t\t// bind AI Personality transferred and ALI ERC20 value transferred to an NFT specified\n\t\t\tbindings[recordId + i] = IntelliBinding({\n\t\t\t\tpersonalityContract : personalityContract,\n\t\t\t\tpersonalityId : personalityId + i,\n\t\t\t\taliValue : aliValue,\n\t\t\t\ttargetContract : targetContract,\n\t\t\t\ttargetId : targetId + i\n\t\t\t});\n\n\t\t\t// fill in the AI Personality to iNFT binding\n\t\t\tpersonalityBindings[personalityContract][personalityId + i] = recordId + i;\n\n\t\t\t// fill in the reverse binding\n\t\t\treverseBindings[targetContract][targetId + i] = recordId + i;\n\t\t}\n\n\t\t// increase total supply counter\n\t\ttotalSupply += n;\n\t}\n\n\t/**\n\t * @dev Restricted access function which destroys an iNFT, unbinding it from the\n\t *      linked NFT, releasing an AI Personality, and ALI tokens locked in the iNFT\n\t *\n\t * @dev Transfers an AI Personality locked in iNFT to its owner via ERC721.safeTransferFrom;\n\t *      owner must be an EOA or implement ERC721Receiver.onERC721Received properly\n\t * @dev Transfers ALI tokens locked in iNFT to its owner\n\t * @dev Since iNFT owner is determined as underlying NFT owner, this underlying NFT must\n\t *      exist and its ownerOf function must not throw and must return non-zero owner address\n\t *      for the underlying NFT ID\n\t *\n\t * @dev Doesn't verify if it's safe to send ALI tokens to the NFT owner, this check\n\t *      must be handled by the transaction executor\n\t *\n\t * @dev This is a restricted function which is accessed by iNFT Linker\n\t *\n\t * @param recordId ID of the iNFT to burn (destroy, unbind)\n\t */\n\tfunction burn(uint256 recordId) public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_BURNER), \"access denied\");\n\n\t\t// decrease total supply counter\n\t\ttotalSupply--;\n\n\t\t// read the token binding (we'll need to access all the fields)\n\t\tIntelliBinding memory binding = bindings[recordId];\n\n\t\t// verify binding exists\n\t\trequire(binding.targetContract != address(0), \"not bound\");\n\n\t\t// destroy binding first to protect from any reentrancy possibility\n\t\tdelete bindings[recordId];\n\n\t\t// free the reverse binding\n\t\tdelete reverseBindings[binding.targetContract][binding.targetId];\n\n\t\t// free the AI Personality binding\n\t\tdelete personalityBindings[binding.personalityContract][binding.personalityId];\n\n\t\t// determine an owner of the underlying NFT\n\t\taddress owner = ERC721(binding.targetContract).ownerOf(binding.targetId);\n\n\t\t// verify that owner address is set (not a zero address)\n\t\trequire(owner != address(0), \"no such NFT\");\n\n\t\t// transfer the AI Personality to the NFT owner\n\t\t// using safe transfer since we don't know if owner address can accept the AI Personality right now\n\t\tERC721(binding.personalityContract).safeTransferFrom(address(this), owner, binding.personalityId);\n\n\t\t// in case when ALI tokens were locked within iNFT\n\t\tif(binding.aliValue > 0) {\n\t\t\t// update ALI balance on the contract prior to token transfer (reentrancy style)\n\t\t\taliBalance -= binding.aliValue;\n\n\t\t\t// transfer the ALI tokens to the NFT owner\n\t\t\tERC20(aliContract).transfer(owner, binding.aliValue);\n\t\t}\n\n\t\t// emit an event\n\t\temit Burnt(\n\t\t\tmsg.sender,\n\t\t\trecordId,\n\t\t\towner,\n\t\t\tbinding.aliValue,\n\t\t\tbinding.personalityContract,\n\t\t\tbinding.personalityId,\n\t\t\tbinding.targetContract,\n\t\t\tbinding.targetId\n\t\t);\n\t}\n\n\t/**\n\t * @dev Restricted access function which updates iNFT record by increasing locked ALI tokens value,\n\t *      effectively locking additional ALI tokens to the iNFT\n\t *\n\t * @dev Locks specified amount of ALI token within iNFT smart contract;\n\t *      ALI token amount must be transferred to the iNFT smart contract\n\t *      prior to calling the `increaseAli`, but in the same transaction with `increaseAli`\n\t *\n\t * @dev To summarize, update transaction (a transaction which executes `increaseAli`) must\n\t *      1) transfer ALI tokens\n\t *      2) update the iNFT\n\t *      NOTE: breaking the items above into multiple transactions is not acceptable!\n\t *            (results in a security risk)\n\t *\n\t * @dev This is a restricted function which is accessed by iNFT Linker\n\t *\n\t * @param recordId ID of the iNFT to update\n\t * @param aliDelta amount of ALI tokens to lock\n\t */\n\tfunction increaseAli(uint256 recordId, uint96 aliDelta) public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_EDITOR), \"access denied\");\n\n\t\t// verify the inputs are set\n\t\trequire(aliDelta != 0, \"zero value\");\n\n\t\t// get iNFT owner for logging (check iNFT record exists under the hood)\n\t\taddress owner = ownerOf(recordId);\n\n\t\t// cache the ALI value of the record\n\t\tuint96 aliValue = bindings[recordId].aliValue;\n\n\t\t// verify ALI tokens are already transferred to iNFT\n\t\trequire(aliBalance + aliDelta <= ERC20(aliContract).balanceOf(address(this)), \"ALI tokens not yet transferred\");\n\n\t\t// update ALI balance on the contract\n\t\taliBalance += aliDelta;\n\n\t\t// update ALI balance on the binding\n\t\tbindings[recordId].aliValue = aliValue + aliDelta;\n\n\t\t// emit an event\n\t\temit Updated(msg.sender, owner, recordId, aliValue, aliValue + aliDelta);\n\t}\n\n\t/**\n\t * @dev Restricted access function which updates iNFT record by decreasing locked ALI tokens value,\n\t *      effectively unlocking some or all ALI tokens from the iNFT\n\t *\n\t * @dev Unlocked tokens are sent to the recipient address specified\n\t *\n\t * @dev This is a restricted function which is accessed by iNFT Linker\n\t *\n\t * @param recordId ID of the iNFT to update\n\t * @param aliDelta amount of ALI tokens to unlock\n\t * @param recipient an address to send unlocked tokens to\n\t */\n\tfunction decreaseAli(uint256 recordId, uint96 aliDelta, address recipient) public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_EDITOR), \"access denied\");\n\n\t\t// verify the inputs are set\n\t\trequire(aliDelta != 0, \"zero value\");\n\t\trequire(recipient != address(0), \"zero address\");\n\n\t\t// get iNFT owner for logging (check iNFT record exists under the hood)\n\t\taddress owner = ownerOf(recordId);\n\n\t\t// cache the ALI value of the record\n\t\tuint96 aliValue = bindings[recordId].aliValue;\n\n\t\t// positive or zero resulting balance check\n\t\trequire(aliValue >= aliDelta, \"not enough ALI\");\n\n\t\t// update ALI balance on the contract\n\t\taliBalance -= aliDelta;\n\n\t\t// update ALI balance on the binding\n\t\tbindings[recordId].aliValue = aliValue - aliDelta;\n\n\t\t// transfer the ALI tokens to the recipient\n\t\tERC20(aliContract).transfer(recipient, aliDelta);\n\n\t\t// emit an event\n\t\temit Updated(msg.sender, owner, recordId, aliValue, aliValue - aliDelta);\n\t}\n\n\t/**\n\t * @notice Determines how many tokens are locked in a particular iNFT\n\t *\n\t * @dev A shortcut for bindings(recordId).aliValue\n\t * @dev Throws if iNFT specified doesn't exist\n\t *\n\t * @param recordId iNFT ID to query locked tokens balance for\n\t * @return locked tokens balance, bindings[recordId].aliValue\n\t */\n\tfunction lockedValue(uint256 recordId) public view returns(uint96) {\n\t\t// ensure iNFT exists\n\t\trequire(exists(recordId), \"iNFT doesn't exist\");\n\n\t\t// read and return ALI value locked in the binding\n\t\treturn bindings[recordId].aliValue;\n\t}\n}\n"
    },
    "contracts/protocol/IntelliLinker.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ERC721Spec.sol\";\nimport \"./IntelligentNFTv2.sol\";\n\n/**\n * @title Intelligent Token Linker (iNFT Linker)\n *\n * @notice iNFT Linker is a helper smart contract responsible for managing iNFTs.\n *      It creates and destroys iNFTs, determines iNFT creation price and destruction fee.\n *\n * @dev Known limitations (to be resolved in the future releases):\n *      - doesn't check AI Personality / target NFT compatibility: any personality\n *        can be linked to any NFT (NFT contract must be whitelisted)\n *      - doesn't support unlinking + linking in a single transaction\n *      - doesn't support AI Personality smart contract upgrades: in case when new\n *        AI Personality contract is deployed, new iNFT Linker should also be deployed\n */\ncontract IntelliLinker is AccessControl {\n\t/**\n\t * @dev iNFT Linker locks/unlocks ALI tokens defined by `aliContract` to mint/burn iNFT\n\t */\n\taddress public immutable aliContract;\n\n\t/**\n\t * @dev iNFT Linker locks/unlocks AI Personality defined by `personalityContract` to mint/burn iNFT\n\t */\n\taddress public immutable personalityContract;\n\n\t/**\n\t * @dev iNFT Linker mints/burns iNFTs defined by `iNftContract`\n\t */\n\taddress public immutable iNftContract;\n\n\t/**\n\t * @dev iNFTs may get created with the ALI tokens bound to them,\n\t *      linking fee may get charged when creating an iNFT\n\t *\n\t * @dev Linking price, how much ALI tokens is charged upon iNFT creation;\n\t *      `linkPrice - linkFee` is locked within the iNFT created\n\t */\n\tuint96 public linkPrice = 2_000 ether; // we use \"ether\" suffix instead of \"e18\"\n\n\t/**\n\t * @dev iNFTs may get created with the ALI tokens bound to them,\n\t *      linking fee may get charged when creating an iNFT\n\t *\n\t * @dev Linking fee, how much ALI tokens is sent into treasury `feeDestination`\n\t *      upon iNFT creation\n\t *\n\t * @dev Both `linkFee` and `feeDestination` must be set for the fee to be charged;\n\t *      both `linkFee` and `feeDestination` can be either set or unset\n\t */\n\tuint96 public linkFee;\n\n\t/**\n\t * @dev iNFTs may get created with the ALI tokens bound to them,\n\t *      linking fee may get charged when creating an iNFT\n\t *\n\t * @dev Treasury `feeDestination` is an address to send linking fee to upon iNFT creation\n\t *\n\t * @dev Both `linkFee` and `feeDestination` must be set for the fee to be charged;\n\t *      both `linkFee` and `feeDestination` can be either set or unset\n\t */\n\taddress public feeDestination;\n\n\t/**\n\t/**\n\t * @dev Next iNFT ID to mint; initially this is the first \"free\" ID which can be minted;\n\t *      at any point in time this should point to a free, mintable ID for iNFT\n\t *\n\t * @dev iNFT ID space up to 0xFFFF_FFFF (uint32 max) is reserved for the sales\n\t */\n\tuint256 public nextId = 0x1_0000_0000;\n\n\t/**\n\t * @dev Target NFT Contracts allowed iNFT to be linked to;\n\t *      is not taken into account if FEATURE_ALLOW_ANY_NFT_CONTRACT is enabled\n\t */\n\tmapping(address => bool) public whitelistedTargetContracts;\n\n\t/**\n\t * @notice Enables iNFT linking (creation)\n\t *\n\t * @dev Feature FEATURE_LINKING must be enabled\n\t *      as a prerequisite for `link()` function to succeed\n\t */\n\tuint32 public constant FEATURE_LINKING = 0x0000_0001;\n\n\t/**\n\t * @notice Enables iNFT unlinking (destruction)\n\t *\n\t * @dev Feature FEATURE_UNLINKING must be enabled\n\t *      for the `unlink()` and `unlinkNFT()` functions to succeed\n\t */\n\tuint32 public constant FEATURE_UNLINKING = 0x0000_0002;\n\n\t/**\n\t * @notice Allows linker to link (mint) iNFT bound to any target NFT contract,\n\t *      independently whether it was previously whitelisted or not\n\t * @dev Feature FEATURE_ALLOW_ANY_NFT_CONTRACT allows linking (minting) iNFTs\n\t *      bound to any target NFT contract, without a check if it's whitelisted in\n\t *      `whitelistedTargetContracts` or not\n\t */\n\tuint32 public constant FEATURE_ALLOW_ANY_NFT_CONTRACT = 0x0000_0004;\n\n\t/**\n\t * @notice Enables depositing more ALI to already existing iNFTs\n\t *\n\t * @dev Feature FEATURE_DEPOSITS must be enabled\n\t *      for the `deposit()` function to succeed\n\t */\n\tuint32 public constant FEATURE_DEPOSITS = 0x0000_0008;\n\n\t/**\n\t * @notice Enables ALI withdrawals from the iNFT (without destroying them)\n\t *\n\t * @dev Feature FEATURE_WITHDRAWALS must be enabled\n\t *      for the `withdraw()` function to succeed\n\t */\n\tuint32 public constant FEATURE_WITHDRAWALS = 0x0000_0010;\n\n\t/**\n\t * @notice Link price manager is responsible for updating linking price\n\t *\n\t * @dev Role ROLE_LINK_PRICE_MANAGER allows `updateLinkPrice` execution,\n\t *      and `linkPrice` modification\n\t */\n\tuint32 public constant ROLE_LINK_PRICE_MANAGER = 0x0001_0000;\n\n\t/**\n\t * @notice Next ID manager is responsible for updating `nextId` variable,\n\t *      pointing to the next iNFT ID free slot\n\t *\n\t * @dev Role ROLE_NEXT_ID_MANAGER allows `updateNextId` execution,\n\t *     and `nextId` modification\n\t */\n\tuint32 public constant ROLE_NEXT_ID_MANAGER = 0x0002_0000;\n\n\t/**\n\t * @notice Whitelist manager is responsible for managing the target NFT contracts\n\t *     whitelist, which are the contracts iNFT is allowed to be bound to\n\t *\n\t * @dev Role ROLE_WHITELIST_MANAGER allows `whitelistTargetContract` execution,\n\t *     and `whitelistedTargetContracts` mapping modification\n\t */\n\tuint32 public constant ROLE_WHITELIST_MANAGER = 0x0004_0000;\n\n\t/**\n\t * @dev Fired in link() when new iNFT is created\n\t *\n\t * @param _by an address which executed (and funded) the link function\n\t * @param _iNftId ID of the iNFT minted\n\t * @param _linkPrice amount of ALI tokens locked (transferred) to newly created iNFT\n\t * @param _linkFee amount of ALI tokens charged as a fee and sent to the treasury\n\t * @param _personalityContract AI Personality contract address\n\t * @param _personalityId ID of the AI Personality locked (transferred) to newly created iNFT\n\t * @param _targetContract target NFT smart contract\n\t * @param _targetId target NFT ID (where this iNFT binds to and belongs to)\n\t */\n\tevent Linked(\n\t\taddress indexed _by,\n\t\tuint256 _iNftId,\n\t\tuint96 _linkPrice,\n\t\tuint96 _linkFee,\n\t\taddress indexed _personalityContract,\n\t\tuint96 indexed _personalityId,\n\t\taddress _targetContract,\n\t\tuint256 _targetId\n\t);\n\n\t/**\n\t * @dev Fired in unlink() when an existing iNFT gets destroyed\n\t *\n\t * @param _by an address which executed the unlink function\n\t *      (and which received unlocked AI Personality and ALI tokens)\n\t * @param _iNftId ID of the iNFT burnt\n\t */\n\tevent Unlinked(address indexed _by, uint256 indexed _iNftId);\n\n\t/**\n\t * @dev Fired in deposit(), withdraw() when an iNFT ALI balance gets changed\n\t *\n\t * @param _by an address which executed the deposit/withdraw function\n\t *      (in case of withdraw it received unlocked ALI tokens)\n\t * @param _iNftId ID of the iNFT to update\n\t * @param _aliDelta locked ALI tokens delta, positive for deposit, negative for withdraw\n\t * @param _feeValue amount of ALI tokens charged as a fee\n\t */\n\tevent LinkUpdated(address indexed _by, uint256 indexed _iNftId, int128 _aliDelta, uint96 _feeValue);\n\n\t/**\n\t * @dev Fired in updateLinkPrice()\n\t *\n\t * @param _by an address which executed the operation\n\t * @param _linkPrice new linking price set\n\t * @param _linkFee new linking fee set\n\t * @param _feeDestination new treasury address set\n\t */\n\tevent LinkPriceChanged(address indexed _by, uint96 _linkPrice, uint96 _linkFee, address indexed _feeDestination);\n\n\t/**\n\t * @dev Fired in updateNextId()\n\t *\n\t * @param _by an address which executed the operation\n\t * @param _oldVal old nextId value\n\t * @param _newVal new nextId value\n\t */\n\tevent NextIdChanged(address indexed _by, uint256 _oldVal, uint256 _newVal);\n\n\t/**\n\t * @dev Fired in whitelistTargetContract()\n\t *\n\t * @param _by an address which executed the operation\n\t * @param _targetContract target NFT contract address affected\n\t * @param _oldVal old whitelisted value\n\t * @param _newVal new whitelisted value\n\t */\n\tevent TargetContractWhitelisted(address indexed _by, address indexed _targetContract, bool _oldVal, bool _newVal);\n\n\t/**\n\t * @dev Creates/deploys an iNFT Linker instance bound to already deployed\n\t *      iNFT, AI Personality and ALI Token instances\n\t *\n\t * @param _ali address of the deployed ALI ERC20 Token instance the iNFT Linker is bound to\n\t * @param _personality address of the deployed AI Personality instance the iNFT Linker is bound to\n\t * @param _iNft address of the deployed iNFT instance the iNFT Linker is bound to\n\t */\n\tconstructor(address _ali, address _personality, address _iNft) AccessControl(msg.sender) {\n\t\t// verify inputs are set\n\t\trequire(_ali != address(0), \"ALI Token addr is not set\");\n\t\trequire(_personality != address(0), \"AI Personality addr is not set\");\n\t\trequire(_iNft != address(0), \"iNFT addr is not set\");\n\n\t\t// verify inputs are valid smart contracts of the expected interfaces\n\t\trequire(ERC165(_ali).supportsInterface(type(ERC20).interfaceId), \"unexpected ALI Token type\");\n\t\trequire(ERC165(_personality).supportsInterface(type(ERC721).interfaceId), \"unexpected AI Personality type\");\n\t\trequire(ERC165(_iNft).supportsInterface(type(IntelligentNFTv2Spec).interfaceId), \"unexpected iNFT type\");\n\n\t\t// setup smart contract internal state\n\t\taliContract = _ali;\n\t\tpersonalityContract = _personality;\n\t\tiNftContract = _iNft;\n\t}\n\n\t/**\n\t * @notice Links given AI Personality with the given NFT and forms an iNFT.\n\t *      AI Personality specified and `linkPrice` ALI are transferred into minted iNFT\n\t *      and are effectively locked within an iNFT until it is destructed (burnt)\n\t *\n\t * @dev AI Personality and ALI tokens are transferred from the transaction sender account\n\t *      to iNFT smart contract\n\t * @dev Sender must approve both AI Personality and ALI tokens transfers to be\n\t *      performed by the linker contract\n\t *\n\t * @param personalityId AI Personality ID to be locked into iNFT\n\t * @param targetContract NFT address iNFT to be linked to\n\t * @param targetId NFT ID iNFT to be linked to\n\t */\n\tfunction link(uint96 personalityId, address targetContract, uint256 targetId) public {\n\t\t// verify linking is enabled\n\t\trequire(isFeatureEnabled(FEATURE_LINKING), \"linking is disabled\");\n\n\t\t// verify AI Personality belongs to transaction sender\n\t\trequire(ERC721(personalityContract).ownerOf(personalityId) == msg.sender, \"access denied\");\n\t\t// verify NFT contract is either whitelisted or any NFT contract is allowed globally\n\t\trequire(whitelistedTargetContracts[targetContract] || isFeatureEnabled(FEATURE_ALLOW_ANY_NFT_CONTRACT), \"not a whitelisted NFT contract\");\n\n\t\t// if linking fee is set\n\t\tif(linkFee > 0) {\n\t\t\t// transfer ALI tokens to the treasury - `feeDestination`\n\t\t\tERC20(aliContract).transferFrom(msg.sender, feeDestination, linkFee);\n\t\t}\n\n\t\t// if linking price is set\n\t\tif(linkPrice > 0) {\n\t\t\t// transfer ALI tokens to iNFT contract to be locked\n\t\t\tERC20(aliContract).transferFrom(msg.sender, iNftContract, linkPrice - linkFee);\n\t\t}\n\n\t\t// transfer AI Personality to iNFT contract to be locked\n\t\tERC721(personalityContract).transferFrom(msg.sender, iNftContract, personalityId);\n\n\t\t// mint the next iNFT, increment next iNFT ID to be minted\n\t\tIntelligentNFTv2(iNftContract).mint(nextId++, linkPrice - linkFee, personalityContract, personalityId, targetContract, targetId);\n\n\t\t// emit an event\n\t\temit Linked(msg.sender, nextId - 1, linkPrice, linkFee, personalityContract, personalityId, targetContract, targetId);\n\t}\n\n\t/**\n\t * @notice Destroys given iNFT, unlinking it from underlying NFT and unlocking\n\t *      the AI Personality and ALI tokens locked in iNFT.\n\t *      AI Personality and ALI tokens are transferred to the underlying NFT owner\n\t *\n\t * @dev Can be executed only by iNFT owner (effectively underlying NFT owner)\n\t *\n\t * @param iNftId ID of the iNFT to unlink\n\t */\n\tfunction unlink(uint256 iNftId) public {\n\t\t// verify unlinking is enabled\n\t\trequire(isFeatureEnabled(FEATURE_UNLINKING), \"unlinking is disabled\");\n\n\t\t// get a link to an iNFT contract to perform several actions with it\n\t\tIntelligentNFTv2 iNFT = IntelligentNFTv2(iNftContract);\n\n\t\t// verify the transaction is executed by iNFT owner (effectively by underlying NFT owner)\n\t\trequire(iNFT.ownerOf(iNftId) == msg.sender, \"not an iNFT owner\");\n\n\t\t// burn the iNFT unlocking the AI Personality and ALI tokens - delegate to `IntelligentNFTv2.burn`\n\t\tiNFT.burn(iNftId);\n\n\t\t// emit an event\n\t\temit Unlinked(msg.sender, iNftId);\n\t}\n\n\t/**\n\t * @notice Unlinks given NFT by destroying iNFTs and unlocking\n\t *      the AI Personality and ALI tokens locked in iNFTs.\n\t *      AI Personality and ALI tokens are transferred to the underlying NFT owner\n\t *\n\t * @dev Can be executed only by NFT owner (effectively underlying NFT owner)\n\t *\n\t * @param nftContract NFT address iNFTs to be unlinked to\n\t * @param nftId NFT ID iNFTs to be unlinked to\n\t */\n\tfunction unlinkNFT(address nftContract, uint256 nftId) public {\n\t\t// verify unlinking is enabled\n\t\trequire(isFeatureEnabled(FEATURE_UNLINKING), \"unlinking is disabled\");\n\n\t\t// get a link to an iNFT contract to perform several actions with it\n\t\tIntelligentNFTv2 iNFT = IntelligentNFTv2(iNftContract);\n\n\t\t// verify the transaction is executed by NFT owner\n\t\trequire(ERC721(nftContract).ownerOf(nftId) == msg.sender, \"not an NFT owner\");\n\n\t\t// get iNFT ID linked with given NFT\n\t\tuint256 iNftId = iNFT.reverseBindings(nftContract, nftId);\n\n\t\t// burn the iNFT unlocking the AI Personality and ALI tokens - delegate to `IntelligentNFTv2.burn`\n\t\tiNFT.burn(iNftId);\n\n\t\t// emit an event\n\t\temit Unlinked(msg.sender, iNftId);\n\t}\n\n\t/**\n\t * @notice Deposits additional ALI tokens into already existing iNFT\n\t *\n\t * @dev Can be executed only by NFT owner (effectively underlying NFT owner)\n\t *\n\t * @dev ALI tokens are transferred from the transaction sender account to iNFT smart contract\n\t *      Sender must approve ALI tokens transfers to be performed by the linker contract\n\t *\n\t * @param iNftId ID of the iNFT to transfer (and lock) tokens to\n\t * @param aliValue amount of ALI tokens to transfer (and lock)\n\t */\n\tfunction deposit(uint256 iNftId, uint96 aliValue) public {\n\t\t// verify deposits are enabled\n\t\trequire(isFeatureEnabled(FEATURE_DEPOSITS), \"deposits are disabled\");\n\n\t\t// get a link to an iNFT contract to perform several actions with it\n\t\tIntelligentNFTv2 iNFT = IntelligentNFTv2(iNftContract);\n\n\t\t// verify the transaction is executed by iNFT owner (effectively by underlying NFT owner)\n\t\trequire(iNFT.ownerOf(iNftId) == msg.sender, \"not an iNFT owner\");\n\n\t\t// effective ALI value locked in iNFT may get altered according to the linking fee set\n\t\t// init effective fee as if linking fee is not set\n\t\tuint96 _linkFee = 0;\n\t\t// init effective ALI value locked as if linking fee is not set\n\t\tuint96 _aliValue = aliValue;\n\t\t// in case when link price/fee are set (effectively meaning fee percent is set)\n\t\tif(linkPrice != 0 && linkFee != 0) {\n\t\t\t// we need to make sure the fee is charged from the value supplied\n\t\t\t// proportionally to the value supplied and fee percent\n\t\t\t_linkFee = uint96(uint256(_aliValue) * linkFee / linkPrice);\n\n\t\t\t// recalculate ALI value to be locked accordingly\n\t\t\t_aliValue = aliValue - _linkFee;\n\n\t\t\t// transfer ALI tokens to the treasury - `feeDestination`\n\t\t\tERC20(aliContract).transferFrom(msg.sender, feeDestination, _linkFee);\n\t\t}\n\n\t\t// transfer ALI tokens to iNFT contract to be locked\n\t\tERC20(aliContract).transferFrom(msg.sender, iNftContract, _aliValue);\n\n\t\t// update the iNFT record\n\t\tiNFT.increaseAli(iNftId, _aliValue);\n\n\t\t// emit an event\n\t\temit LinkUpdated(msg.sender, iNftId, int128(uint128(_aliValue)), _linkFee);\n\t}\n\n\t/**\n\t * @notice Withdraws some ALI tokens from already existing iNFT without destroying it\n\t *\n\t * @dev Can be executed only by NFT owner (effectively underlying NFT owner)\n\t *\n\t * @dev ALI tokens are transferred to the iNFT owner (transaction executor)\n\t *\n\t * @param iNftId ID of the iNFT to unlock tokens from\n\t * @param aliValue amount of ALI tokens to unlock\n\t */\n\tfunction withdraw(uint256 iNftId, uint96 aliValue) public {\n\t\t// verify withdrawals are enabled\n\t\trequire(isFeatureEnabled(FEATURE_WITHDRAWALS), \"withdrawals are disabled\");\n\n\t\t// get a link to an iNFT contract to perform several actions with it\n\t\tIntelligentNFTv2 iNFT = IntelligentNFTv2(iNftContract);\n\n\t\t// verify the transaction is executed by iNFT owner (effectively by underlying NFT owner)\n\t\trequire(iNFT.ownerOf(iNftId) == msg.sender, \"not an iNFT owner\");\n\n\t\t// ensure iNFT locked balance doesn't go below `linkPrice - linkFee`\n\t\trequire(iNFT.lockedValue(iNftId) >= aliValue + linkPrice, \"deposit too low\");\n\n\t\t// update the iNFT record and transfer tokens back to the iNFT owner\n\t\tiNFT.decreaseAli(iNftId, aliValue, msg.sender);\n\n\t\t// emit an event\n\t\temit LinkUpdated(msg.sender, iNftId, -int128(uint128(aliValue)), 0);\n\t}\n\n\t/**\n\t * @dev Restricted access function to modify\n\t *      - linking price `linkPrice`,\n\t *      - linking fee `linkFee`, and\n\t *      - treasury address `feeDestination`\n\t *\n\t * @dev Requires executor to have ROLE_LINK_PRICE_MANAGER permission\n\t * @dev Requires linking price to be either unset (zero), or not less than 1e12 (0.000001 ALI)\n\t * @dev Requires both linking fee and treasury address to be either set or unset (zero);\n\t *      if set, linking fee must not be less than 1e12 (0.000001 ALI);\n\t *      if set, linking fee must not exceed linking price\n\t *\n\t * @param _linkPrice new linking price to be set\n\t * @param _linkFee new linking fee to be set\n\t * @param _feeDestination treasury address\n\t */\n\tfunction updateLinkPrice(uint96 _linkPrice, uint96 _linkFee, address _feeDestination) public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_LINK_PRICE_MANAGER), \"access denied\");\n\n\t\t// verify the price is not too low if it's set\n\t\trequire(_linkPrice == 0 || _linkPrice >= 1e12, \"invalid price\");\n\n\t\t// linking fee/treasury should be either both set or both unset\n\t\t// linking fee must not be too low if set\n\t\trequire(_linkFee == 0 && _feeDestination == address(0) || _linkFee >= 1e12 && _feeDestination != address(0), \"invalid linking fee/treasury\");\n\t\t// linking fee must not exceed linking price\n\t\trequire(_linkFee <= _linkPrice, \"linking fee exceeds linking price\");\n\n\t\t// update the linking price, fee, and treasury address\n\t\tlinkPrice = _linkPrice;\n\t\tlinkFee = _linkFee;\n\t\tfeeDestination = _feeDestination;\n\n\t\t// emit an event\n\t\temit LinkPriceChanged(msg.sender, _linkPrice, _linkFee, _feeDestination);\n\t}\n\n\t/**\n\t * @dev Restricted access function to modify next iNFT ID `nextId`\n\t *\n\t * @param _nextId new next iNFT ID to be set\n\t */\n\tfunction updateNextId(uint256 _nextId) public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_NEXT_ID_MANAGER), \"access denied\");\n\n\t\t// verify nextId is in safe bounds\n\t\trequire(_nextId > 0xFFFF_FFFF, \"value too low\");\n\n\t\t// emit a event\n\t\temit NextIdChanged(msg.sender, nextId, _nextId);\n\n\t\t// update next ID\n\t\tnextId = _nextId;\n\t}\n\n\t/**\n\t * @dev Restricted access function to manage whitelisted NFT contracts mapping `whitelistedTargetContracts`\n\t *\n\t * @dev Requires executor to have ROLE_WHITELIST_MANAGER permission\n\t *\n\t * @param targetContract target NFT contract address to add/remove to/from the whitelist\n\t * @param whitelist true to add, false to remove to/from whitelist\n\t */\n\tfunction whitelistTargetContract(address targetContract, bool whitelist) public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_WHITELIST_MANAGER), \"access denied\");\n\n\t\t// verify the address is set\n\t\trequire(targetContract != address(0), \"zero address\");\n\n\t\t// delisting is always possible, whitelisting - only for valid ERC721\n\t\tif(whitelist) {\n\t\t\t// verify targetContract is a valid ERC721\n\t\t\trequire(ERC165(targetContract).supportsInterface(type(ERC721).interfaceId), \"target NFT is not ERC721\");\n\t\t}\n\n\t\t// emit an event\n\t\temit TargetContractWhitelisted(msg.sender, targetContract, whitelistedTargetContracts[targetContract], whitelist);\n\n\t\t// add/remove the contract address to/from the whitelist\n\t\twhitelistedTargetContracts[targetContract] = whitelist;\n\t}\n}\n"
    },
    "contracts/protocol/IntelliLinkerV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ERC721Spec.sol\";\nimport \"./IntelligentNFTv2.sol\";\nimport \"../utils/UpgradeableAccessControl.sol\";\n\n/**\n * @title Intelligent Token Linker (iNFT Linker)\n *\n * @notice iNFT Linker is a helper smart contract responsible for managing iNFTs.\n *      It creates and destroys iNFTs, determines iNFT creation price and destruction fee.\n *\n * @dev Known limitations (to be resolved in the future releases):\n *      - doesn't check AI Personality / target NFT compatibility: any personality\n *        can be linked to any NFT (NFT contract must be whitelisted)\n *      - doesn't support unlinking + linking in a single transaction\n *      - doesn't support AI Personality smart contract upgrades: in case when new\n *        AI Personality contract is deployed, new iNFT Linker should also be deployed\n *\n * @dev V2 modification\n *      - supports two separate whitelists for linking and unlinking\n *      - is upgradeable\n */\ncontract IntelliLinkerV2 is UpgradeableAccessControl {\n\t/**\n\t * @dev iNFT Linker locks/unlocks ALI tokens defined by `aliContract` to mint/burn iNFT\n\t */\n\taddress public aliContract;\n\n\t/**\n\t * @dev iNFT Linker locks/unlocks AI Personality defined by `personalityContract` to mint/burn iNFT\n\t */\n\taddress public personalityContract;\n\n\t/**\n\t * @dev iNFT Linker mints/burns iNFTs defined by `iNftContract`\n\t */\n\taddress public iNftContract;\n\n\t/**\n\t * @dev iNFTs may get created with the ALI tokens bound to them,\n\t *      linking fee may get charged when creating an iNFT\n\t *\n\t * @dev Linking price, how much ALI tokens is charged upon iNFT creation;\n\t *      `linkPrice - linkFee` is locked within the iNFT created\n\t */\n\tuint96 public linkPrice;\n\n\t/**\n\t * @dev iNFTs may get created with the ALI tokens bound to them,\n\t *      linking fee may get charged when creating an iNFT\n\t *\n\t * @dev Linking fee, how much ALI tokens is sent into treasury `feeDestination`\n\t *      upon iNFT creation\n\t *\n\t * @dev Both `linkFee` and `feeDestination` must be set for the fee to be charged;\n\t *      both `linkFee` and `feeDestination` can be either set or unset\n\t */\n\tuint96 public linkFee;\n\n\t/**\n\t * @dev iNFTs may get created with the ALI tokens bound to them,\n\t *      linking fee may get charged when creating an iNFT\n\t *\n\t * @dev Treasury `feeDestination` is an address to send linking fee to upon iNFT creation\n\t *\n\t * @dev Both `linkFee` and `feeDestination` must be set for the fee to be charged;\n\t *      both `linkFee` and `feeDestination` can be either set or unset\n\t */\n\taddress public feeDestination;\n\n\t/**\n\t/**\n\t * @dev Next iNFT ID to mint; initially this is the first \"free\" ID which can be minted;\n\t *      at any point in time this should point to a free, mintable ID for iNFT\n\t *\n\t * @dev iNFT ID space up to 0xFFFF_FFFF (uint32 max) is reserved for the sales\n\t */\n\tuint256 public nextId;\n\n\t/**\n\t * @dev Target NFT Contracts allowed iNFT to be linked to;\n\t *      is not taken into account if FEATURE_ALLOW_ANY_NFT_CONTRACT is enabled\n\t * @dev Lowest bit (zero) defines if contract is allowed to be linked to;\n\t *      Next bit (one) defines if contract is allowed to be unlinked from\n\t */\n\tmapping(address => uint8) public whitelistedTargetContracts;\n\n\t/**\n\t * @notice Enables iNFT linking (creation)\n\t *\n\t * @dev Feature FEATURE_LINKING must be enabled\n\t *      as a prerequisite for `link()` function to succeed\n\t */\n\tuint32 public constant FEATURE_LINKING = 0x0000_0001;\n\n\t/**\n\t * @notice Enables iNFT unlinking (destruction)\n\t *\n\t * @dev Feature FEATURE_UNLINKING must be enabled\n\t *      for the `unlink()` and `unlinkNFT()` functions to succeed\n\t */\n\tuint32 public constant FEATURE_UNLINKING = 0x0000_0002;\n\n\t/**\n\t * @notice Allows linker to link (mint) iNFT bound to any target NFT contract,\n\t *      independently whether it was previously whitelisted or not\n\t * @dev Feature FEATURE_ALLOW_ANY_NFT_CONTRACT allows linking (minting) iNFTs\n\t *      bound to any target NFT contract, without a check if it's whitelisted in\n\t *      `whitelistedTargetContracts` or not\n\t */\n\tuint32 public constant FEATURE_ALLOW_ANY_NFT_CONTRACT = 0x0000_0004;\n\n\t/**\n\t * @notice Enables depositing more ALI to already existing iNFTs\n\t *\n\t * @dev Feature FEATURE_DEPOSITS must be enabled\n\t *      for the `deposit()` function to succeed\n\t */\n\tuint32 public constant FEATURE_DEPOSITS = 0x0000_0008;\n\n\t/**\n\t * @notice Enables ALI withdrawals from the iNFT (without destroying them)\n\t *\n\t * @dev Feature FEATURE_WITHDRAWALS must be enabled\n\t *      for the `withdraw()` function to succeed\n\t */\n\tuint32 public constant FEATURE_WITHDRAWALS = 0x0000_0010;\n\n\t/**\n\t * @notice Link price manager is responsible for updating linking price\n\t *\n\t * @dev Role ROLE_LINK_PRICE_MANAGER allows `updateLinkPrice` execution,\n\t *      and `linkPrice` modification\n\t */\n\tuint32 public constant ROLE_LINK_PRICE_MANAGER = 0x0001_0000;\n\n\t/**\n\t * @notice Next ID manager is responsible for updating `nextId` variable,\n\t *      pointing to the next iNFT ID free slot\n\t *\n\t * @dev Role ROLE_NEXT_ID_MANAGER allows `updateNextId` execution,\n\t *     and `nextId` modification\n\t */\n\tuint32 public constant ROLE_NEXT_ID_MANAGER = 0x0002_0000;\n\n\t/**\n\t * @notice Whitelist manager is responsible for managing the target NFT contracts\n\t *     whitelist, which are the contracts iNFT is allowed to be bound to\n\t *\n\t * @dev Role ROLE_WHITELIST_MANAGER allows `whitelistTargetContract` execution,\n\t *     and `whitelistedTargetContracts` mapping modification\n\t */\n\tuint32 public constant ROLE_WHITELIST_MANAGER = 0x0004_0000;\n\n\t/**\n\t * @dev Fired in link() when new iNFT is created\n\t *\n\t * @param _by an address which executed (and funded) the link function\n\t * @param _iNftId ID of the iNFT minted\n\t * @param _linkPrice amount of ALI tokens locked (transferred) to newly created iNFT\n\t * @param _linkFee amount of ALI tokens charged as a fee and sent to the treasury\n\t * @param _personalityContract AI Personality contract address\n\t * @param _personalityId ID of the AI Personality locked (transferred) to newly created iNFT\n\t * @param _targetContract target NFT smart contract\n\t * @param _targetId target NFT ID (where this iNFT binds to and belongs to)\n\t */\n\tevent Linked(\n\t\taddress indexed _by,\n\t\tuint256 _iNftId,\n\t\tuint96 _linkPrice,\n\t\tuint96 _linkFee,\n\t\taddress indexed _personalityContract,\n\t\tuint96 indexed _personalityId,\n\t\taddress _targetContract,\n\t\tuint256 _targetId\n\t);\n\n\t/**\n\t * @dev Fired in unlink() when an existing iNFT gets destroyed\n\t *\n\t * @param _by an address which executed the unlink function\n\t *      (and which received unlocked AI Personality and ALI tokens)\n\t * @param _iNftId ID of the iNFT burnt\n\t */\n\tevent Unlinked(address indexed _by, uint256 indexed _iNftId);\n\n\t/**\n\t * @dev Fired in deposit(), withdraw() when an iNFT ALI balance gets changed\n\t *\n\t * @param _by an address which executed the deposit/withdraw function\n\t *      (in case of withdraw it received unlocked ALI tokens)\n\t * @param _iNftId ID of the iNFT to update\n\t * @param _aliDelta locked ALI tokens delta, positive for deposit, negative for withdraw\n\t * @param _feeValue amount of ALI tokens charged as a fee\n\t */\n\tevent LinkUpdated(address indexed _by, uint256 indexed _iNftId, int128 _aliDelta, uint96 _feeValue);\n\n\t/**\n\t * @dev Fired in updateLinkPrice()\n\t *\n\t * @param _by an address which executed the operation\n\t * @param _linkPrice new linking price set\n\t * @param _linkFee new linking fee set\n\t * @param _feeDestination new treasury address set\n\t */\n\tevent LinkPriceChanged(address indexed _by, uint96 _linkPrice, uint96 _linkFee, address indexed _feeDestination);\n\n\t/**\n\t * @dev Fired in updateNextId()\n\t *\n\t * @param _by an address which executed the operation\n\t * @param _oldVal old nextId value\n\t * @param _newVal new nextId value\n\t */\n\tevent NextIdChanged(address indexed _by, uint256 _oldVal, uint256 _newVal);\n\n\t/**\n\t * @dev Fired in whitelistTargetContract()\n\t *\n\t * @param _by an address which executed the operation\n\t * @param _targetContract target NFT contract address affected\n\t * @param _oldVal old whitelisted raw value (contains both linking/unlinking flags)\n\t * @param _newVal new whitelisted raw value (contains both linking/unlinking flags)\n\t */\n\tevent TargetContractWhitelisted(address indexed _by, address indexed _targetContract, uint8 _oldVal, uint8 _newVal);\n\n\t/**\n\t * @dev \"Constructor replacement\" for upgradeable, must be execute immediately after deployment\n\t *      see https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#initializers\n\t *\n\t * @dev Binds an iNFT Linker instance to already deployed\n\t *      iNFT, AI Personality and ALI Token instances\n\t *\n\t * @param _ali address of the deployed ALI ERC20 Token instance the iNFT Linker is bound to\n\t * @param _personality address of the deployed AI Personality instance the iNFT Linker is bound to\n\t * @param _iNft address of the deployed iNFT instance the iNFT Linker is bound to\n\t */\n\tfunction postConstruct(address _ali, address _personality, address _iNft) public virtual initializer {\n\t\t// execute parent initializer\n\t\t_postConstruct(msg.sender);\n\n\t\t// verify inputs are set\n\t\trequire(_ali != address(0), \"ALI Token addr is not set\");\n\t\trequire(_personality != address(0), \"AI Personality addr is not set\");\n\t\trequire(_iNft != address(0), \"iNFT addr is not set\");\n\n\t\t// verify inputs are valid smart contracts of the expected interfaces\n\t\trequire(ERC165(_ali).supportsInterface(type(ERC20).interfaceId), \"unexpected ALI Token type\");\n\t\trequire(ERC165(_personality).supportsInterface(type(ERC721).interfaceId), \"unexpected AI Personality type\");\n\t\trequire(ERC165(_iNft).supportsInterface(type(IntelligentNFTv2Spec).interfaceId), \"unexpected iNFT type\");\n\n\t\t// setup smart contract internal state\n\t\taliContract = _ali;\n\t\tpersonalityContract = _personality;\n\t\tiNftContract = _iNft;\n\n\t\t// setup the defaults\n\t\t// linkPrice = 2_000 ether; // we use \"ether\" suffix instead of \"e18\"\n\t\t// iNFT ID space up to 0xFFFF_FFFF (uint32 max) is reserved for the sales\n\t\t// iNFT ID space up to 0x1_FFFF_FFFF is reserved for IntelliLinker (v1, non-upgradeable)\n\t\tnextId = 0x2_0000_0000;\n\t}\n\n\t/**\n\t * @notice Links given AI Personality with the given NFT and forms an iNFT.\n\t *      AI Personality specified and `linkPrice` ALI are transferred into minted iNFT\n\t *      and are effectively locked within an iNFT until it is destructed (burnt)\n\t *\n\t * @dev AI Personality and ALI tokens are transferred from the transaction sender account\n\t *      to iNFT smart contract\n\t * @dev Sender must approve both AI Personality and ALI tokens transfers to be\n\t *      performed by the linker contract\n\t *\n\t * @param personalityId AI Personality ID to be locked into iNFT\n\t * @param targetContract NFT address iNFT to be linked to\n\t * @param targetId NFT ID iNFT to be linked to\n\t */\n\tfunction link(uint96 personalityId, address targetContract, uint256 targetId) public virtual {\n\t\t// verify linking is enabled\n\t\trequire(isFeatureEnabled(FEATURE_LINKING), \"linking is disabled\");\n\n\t\t// verify AI Personality belongs to transaction sender\n\t\trequire(ERC721(personalityContract).ownerOf(personalityId) == msg.sender, \"access denied\");\n\t\t// verify NFT contract is either whitelisted or any NFT contract is allowed globally\n\t\trequire(\n\t\t\tisAllowedForLinking(targetContract) || isFeatureEnabled(FEATURE_ALLOW_ANY_NFT_CONTRACT),\n\t\t\t\"not a whitelisted NFT contract\"\n\t\t);\n\n\t\t// if linking fee is set\n\t\tif(linkFee > 0) {\n\t\t\t// transfer ALI tokens to the treasury - `feeDestination`\n\t\t\tERC20(aliContract).transferFrom(msg.sender, feeDestination, linkFee);\n\t\t}\n\n\t\t// if linking price is set\n\t\tif(linkPrice > 0) {\n\t\t\t// transfer ALI tokens to iNFT contract to be locked\n\t\t\tERC20(aliContract).transferFrom(msg.sender, iNftContract, linkPrice - linkFee);\n\t\t}\n\n\t\t// transfer AI Personality to iNFT contract to be locked\n\t\tERC721(personalityContract).transferFrom(msg.sender, iNftContract, personalityId);\n\n\t\t// mint the next iNFT, increment next iNFT ID to be minted\n\t\tIntelligentNFTv2(iNftContract).mint(nextId++, linkPrice - linkFee, personalityContract, personalityId, targetContract, targetId);\n\n\t\t// emit an event\n\t\temit Linked(msg.sender, nextId - 1, linkPrice, linkFee, personalityContract, personalityId, targetContract, targetId);\n\t}\n\n\t/**\n\t * @notice Destroys given iNFT, unlinking it from underlying NFT and unlocking\n\t *      the AI Personality and ALI tokens locked in iNFT.\n\t *      AI Personality and ALI tokens are transferred to the underlying NFT owner\n\t *\n\t * @dev Can be executed only by iNFT owner (effectively underlying NFT owner)\n\t *\n\t * @param iNftId ID of the iNFT to unlink\n\t */\n\tfunction unlink(uint256 iNftId) public virtual {\n\t\t// verify unlinking is enabled\n\t\trequire(isFeatureEnabled(FEATURE_UNLINKING), \"unlinking is disabled\");\n\n\t\t// get a link to an iNFT contract to perform several actions with it\n\t\tIntelligentNFTv2 iNFT = IntelligentNFTv2(iNftContract);\n\n\t\t// get target NFT contract address from the iNFT binding\n\t\t(,,,address targetContract,) = iNFT.bindings(iNftId);\n\t\t// verify NFT contract is either whitelisted or any NFT contract is allowed globally\n\t\trequire(\n\t\t\tisAllowedForUnlinking(targetContract) || isFeatureEnabled(FEATURE_ALLOW_ANY_NFT_CONTRACT),\n\t\t\t\"not a whitelisted NFT contract\"\n\t\t);\n\n\t\t// verify the transaction is executed by iNFT owner (effectively by underlying NFT owner)\n\t\trequire(iNFT.ownerOf(iNftId) == msg.sender, \"not an iNFT owner\");\n\n\t\t// burn the iNFT unlocking the AI Personality and ALI tokens - delegate to `IntelligentNFTv2.burn`\n\t\tiNFT.burn(iNftId);\n\n\t\t// emit an event\n\t\temit Unlinked(msg.sender, iNftId);\n\t}\n\n\t/**\n\t * @notice Unlinks given NFT by destroying iNFTs and unlocking\n\t *      the AI Personality and ALI tokens locked in iNFTs.\n\t *      AI Personality and ALI tokens are transferred to the underlying NFT owner\n\t *\n\t * @dev Can be executed only by NFT owner (effectively underlying NFT owner)\n\t *\n\t * @param nftContract NFT address iNFTs to be unlinked to\n\t * @param nftId NFT ID iNFTs to be unlinked to\n\t */\n\tfunction unlinkNFT(address nftContract, uint256 nftId) public virtual {\n\t\t// verify unlinking is enabled\n\t\trequire(isFeatureEnabled(FEATURE_UNLINKING), \"unlinking is disabled\");\n\n\t\t// get a link to an iNFT contract to perform several actions with it\n\t\tIntelligentNFTv2 iNFT = IntelligentNFTv2(iNftContract);\n\n\t\t// verify the transaction is executed by NFT owner\n\t\trequire(ERC721(nftContract).ownerOf(nftId) == msg.sender, \"not an NFT owner\");\n\n\t\t// get iNFT ID linked with given NFT\n\t\tuint256 iNftId = iNFT.reverseBindings(nftContract, nftId);\n\n\t\t// verify NFT contract is either whitelisted or any NFT contract is allowed globally\n\t\trequire(\n\t\t\tisAllowedForUnlinking(nftContract) || isFeatureEnabled(FEATURE_ALLOW_ANY_NFT_CONTRACT),\n\t\t\t\"not a whitelisted NFT contract\"\n\t\t);\n\n\t\t// burn the iNFT unlocking the AI Personality and ALI tokens - delegate to `IntelligentNFTv2.burn`\n\t\tiNFT.burn(iNftId);\n\n\t\t// emit an event\n\t\temit Unlinked(msg.sender, iNftId);\n\t}\n\n\t/**\n\t * @notice Deposits additional ALI tokens into already existing iNFT\n\t *\n\t * @dev Can be executed only by NFT owner (effectively underlying NFT owner)\n\t *\n\t * @dev ALI tokens are transferred from the transaction sender account to iNFT smart contract\n\t *      Sender must approve ALI tokens transfers to be performed by the linker contract\n\t *\n\t * @param iNftId ID of the iNFT to transfer (and lock) tokens to\n\t * @param aliValue amount of ALI tokens to transfer (and lock)\n\t */\n\tfunction deposit(uint256 iNftId, uint96 aliValue) public virtual {\n\t\t// verify deposits are enabled\n\t\trequire(isFeatureEnabled(FEATURE_DEPOSITS), \"deposits are disabled\");\n\n\t\t// get a link to an iNFT contract to perform several actions with it\n\t\tIntelligentNFTv2 iNFT = IntelligentNFTv2(iNftContract);\n\n\t\t// verify the transaction is executed by iNFT owner (effectively by underlying NFT owner)\n\t\trequire(iNFT.ownerOf(iNftId) == msg.sender, \"not an iNFT owner\");\n\n\t\t// effective ALI value locked in iNFT may get altered according to the linking fee set\n\t\t// init effective fee as if linking fee is not set\n\t\tuint96 _linkFee = 0;\n\t\t// init effective ALI value locked as if linking fee is not set\n\t\tuint96 _aliValue = aliValue;\n\t\t// in case when link price/fee are set (effectively meaning fee percent is set)\n\t\tif(linkPrice != 0 && linkFee != 0) {\n\t\t\t// we need to make sure the fee is charged from the value supplied\n\t\t\t// proportionally to the value supplied and fee percent\n\t\t\t_linkFee = uint96(uint256(_aliValue) * linkFee / linkPrice);\n\n\t\t\t// recalculate ALI value to be locked accordingly\n\t\t\t_aliValue = aliValue - _linkFee;\n\n\t\t\t// transfer ALI tokens to the treasury - `feeDestination`\n\t\t\tERC20(aliContract).transferFrom(msg.sender, feeDestination, _linkFee);\n\t\t}\n\n\t\t// transfer ALI tokens to iNFT contract to be locked\n\t\tERC20(aliContract).transferFrom(msg.sender, iNftContract, _aliValue);\n\n\t\t// update the iNFT record\n\t\tiNFT.increaseAli(iNftId, _aliValue);\n\n\t\t// emit an event\n\t\temit LinkUpdated(msg.sender, iNftId, int128(uint128(_aliValue)), _linkFee);\n\t}\n\n\t/**\n\t * @notice Withdraws some ALI tokens from already existing iNFT without destroying it\n\t *\n\t * @dev Can be executed only by NFT owner (effectively underlying NFT owner)\n\t *\n\t * @dev ALI tokens are transferred to the iNFT owner (transaction executor)\n\t *\n\t * @param iNftId ID of the iNFT to unlock tokens from\n\t * @param aliValue amount of ALI tokens to unlock\n\t */\n\tfunction withdraw(uint256 iNftId, uint96 aliValue) public virtual {\n\t\t// verify withdrawals are enabled\n\t\trequire(isFeatureEnabled(FEATURE_WITHDRAWALS), \"withdrawals are disabled\");\n\n\t\t// get a link to an iNFT contract to perform several actions with it\n\t\tIntelligentNFTv2 iNFT = IntelligentNFTv2(iNftContract);\n\n\t\t// verify the transaction is executed by iNFT owner (effectively by underlying NFT owner)\n\t\trequire(iNFT.ownerOf(iNftId) == msg.sender, \"not an iNFT owner\");\n\n\t\t// ensure iNFT locked balance doesn't go below `linkPrice - linkFee`\n\t\trequire(iNFT.lockedValue(iNftId) >= aliValue + linkPrice, \"deposit too low\");\n\n\t\t// update the iNFT record and transfer tokens back to the iNFT owner\n\t\tiNFT.decreaseAli(iNftId, aliValue, msg.sender);\n\n\t\t// emit an event\n\t\temit LinkUpdated(msg.sender, iNftId, -int128(uint128(aliValue)), 0);\n\t}\n\n\t/**\n\t * @dev Restricted access function to modify\n\t *      - linking price `linkPrice`,\n\t *      - linking fee `linkFee`, and\n\t *      - treasury address `feeDestination`\n\t *\n\t * @dev Requires executor to have ROLE_LINK_PRICE_MANAGER permission\n\t * @dev Requires linking price to be either unset (zero), or not less than 1e12 (0.000001 ALI)\n\t * @dev Requires both linking fee and treasury address to be either set or unset (zero);\n\t *      if set, linking fee must not be less than 1e12 (0.000001 ALI);\n\t *      if set, linking fee must not exceed linking price\n\t *\n\t * @param _linkPrice new linking price to be set\n\t * @param _linkFee new linking fee to be set\n\t * @param _feeDestination treasury address\n\t */\n\tfunction updateLinkPrice(uint96 _linkPrice, uint96 _linkFee, address _feeDestination) public virtual {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_LINK_PRICE_MANAGER), \"access denied\");\n\n\t\t// verify the price is not too low if it's set\n\t\trequire(_linkPrice == 0 || _linkPrice >= 1e12, \"invalid price\");\n\n\t\t// linking fee/treasury should be either both set or both unset\n\t\t// linking fee must not be too low if set\n\t\trequire(_linkFee == 0 && _feeDestination == address(0) || _linkFee >= 1e12 && _feeDestination != address(0), \"invalid linking fee/treasury\");\n\t\t// linking fee must not exceed linking price\n\t\trequire(_linkFee <= _linkPrice, \"linking fee exceeds linking price\");\n\n\t\t// update the linking price, fee, and treasury address\n\t\tlinkPrice = _linkPrice;\n\t\tlinkFee = _linkFee;\n\t\tfeeDestination = _feeDestination;\n\n\t\t// emit an event\n\t\temit LinkPriceChanged(msg.sender, _linkPrice, _linkFee, _feeDestination);\n\t}\n\n\t/**\n\t * @dev Restricted access function to modify next iNFT ID `nextId`\n\t *\n\t * @param _nextId new next iNFT ID to be set\n\t */\n\tfunction updateNextId(uint256 _nextId) public virtual {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_NEXT_ID_MANAGER), \"access denied\");\n\n\t\t// verify nextId is in safe bounds\n\t\trequire(_nextId > 0xFFFF_FFFF, \"value too low\");\n\n\t\t// emit a event\n\t\temit NextIdChanged(msg.sender, nextId, _nextId);\n\n\t\t// update next ID\n\t\tnextId = _nextId;\n\t}\n\n\t/**\n\t * @dev Restricted access function to manage whitelisted NFT contracts mapping `whitelistedTargetContracts`\n\t *\n\t * @dev Requires executor to have ROLE_WHITELIST_MANAGER permission\n\t *\n\t * @param targetContract target NFT contract address to add/remove to/from the whitelist\n\t * @param allowedForLinking true to add, false to remove to/from whitelist (allowed for linking)\n\t * @param allowedForUnlinking true to add, false to remove to/from whitelist (allowed for unlinking)\n\t */\n\tfunction whitelistTargetContract(\n\t\taddress targetContract,\n\t\tbool allowedForLinking,\n\t\tbool allowedForUnlinking\n\t) public virtual {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_WHITELIST_MANAGER), \"access denied\");\n\n\t\t// verify the address is set\n\t\trequire(targetContract != address(0), \"zero address\");\n\n\t\t// delisting is always possible, whitelisting - only for valid ERC721\n\t\tif(allowedForLinking) {\n\t\t\t// verify targetContract is a valid ERC721\n\t\t\trequire(ERC165(targetContract).supportsInterface(type(ERC721).interfaceId), \"target NFT is not ERC721\");\n\t\t}\n\n\t\t// derive the uint8 value representing two boolean flags:\n\t\t// Lowest bit (zero) defines if contract is allowed to be linked to;\n\t\t// Next bit (one) defines if contract is allowed to be unlinked from\n\t\tuint8 newVal = (allowedForLinking? 0x1: 0x0) | (allowedForUnlinking? 0x2: 0x0);\n\n\t\t// emit an event\n\t\temit TargetContractWhitelisted(msg.sender, targetContract, whitelistedTargetContracts[targetContract], newVal);\n\n\t\t// update the contract address in the whitelist\n\t\twhitelistedTargetContracts[targetContract] = newVal;\n\t}\n\n\t/**\n\t * @notice Checks if specified target NFT contract is allowed to be linked to\n\t *\n\t * @dev Using this function can be more convenient than accessing the\n\t *      `whitelistedTargetContracts` directly since the mapping contains linking/unlinking\n\t *      flags packed into uint8\n\t *\n\t * @param targetContract target NFT contract address to query for\n\t * @return true if target NFT contract is allowed to be linked to, false otherwise\n\t */\n\tfunction isAllowedForLinking(address targetContract) public view virtual returns (bool) {\n\t\t// read the mapping and extract the lowest bit (zero) containing information required\n\t\treturn whitelistedTargetContracts[targetContract] & 0x1 == 0x1;\n\t}\n\n\t/**\n\t * @notice Checks if specified target NFT contract is allowed to be unlinked from\n\t *\n\t * @dev Using this function can be more convenient than accessing the\n\t *      `whitelistedTargetContracts` directly since the mapping contains linking/unlinking\n\t *      flags packed into uint8\n\t *\n\t * @param targetContract target NFT contract address to query for\n\t * @return true if target NFT contract is allowed to be unlinked from, false otherwise\n\t */\n\tfunction isAllowedForUnlinking(address targetContract) public view virtual returns (bool) {\n\t\t// read the mapping and extract the next bit (one) containing information required\n\t\treturn whitelistedTargetContracts[targetContract] & 0x2 == 0x2;\n\t}\n}\n"
    },
    "contracts/protocol/IntelliLinkerV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ERC721Spec.sol\";\nimport \"./IntelligentNFTv2.sol\";\nimport \"../utils/UpgradeableAccessControl.sol\";\n\n/**\n * @title Intelligent Token Linker (iNFT Linker)\n *\n * @notice iNFT Linker is a helper smart contract responsible for managing iNFTs.\n *      It creates and destroys iNFTs, determines iNFT creation price and destruction fee.\n *\n * @dev Known limitations (to be resolved in the future releases):\n *      - doesn't check AI Personality / target NFT compatibility: any personality\n *        can be linked to any NFT (NFT contract must be whitelisted)\n *      - doesn't support unlinking + linking in a single transaction\n *      - doesn't support AI Personality smart contract upgrades: in case when new\n *        AI Personality contract is deployed, new iNFT Linker should also be deployed\n *\n * @dev V2 modification\n *      - supports two separate whitelists for linking and unlinking\n *      - is upgradeable\n *\n * @dev V3 modification: \"custom iNFT request\" feature\n *      - separates feature \"ALLOW_ANY_NFT_CONTRACT\" into \"ALLOW_ANY_NFT_CONTRACT_FOR_LINKING\"\n *        and \"ALLOW_ANY_NFT_CONTRACT_FOR_UNLINKING\"\n *      - introduces two separate blacklists for linking and unlinking, having the priority over\n *        the whitelists introduced in V2\n *\n * @dev NOTE: Contract MUST NOT be deployed from scratch, only V2 -> V3 upgrade is supported!\n */\ncontract IntelliLinkerV3 is UpgradeableAccessControl {\n\t/**\n\t * @dev iNFT Linker locks/unlocks ALI tokens defined by `aliContract` to mint/burn iNFT\n\t */\n\taddress public aliContract;\n\n\t/**\n\t * @dev iNFT Linker locks/unlocks AI Personality defined by `personalityContract` to mint/burn iNFT\n\t */\n\taddress public personalityContract;\n\n\t/**\n\t * @dev iNFT Linker mints/burns iNFTs defined by `iNftContract`\n\t */\n\taddress public iNftContract;\n\n\t/**\n\t * @dev iNFTs may get created with the ALI tokens bound to them,\n\t *      linking fee may get charged when creating an iNFT\n\t *\n\t * @dev Linking price, how much ALI tokens is charged upon iNFT creation;\n\t *      `linkPrice - linkFee` is locked within the iNFT created\n\t */\n\tuint96 public linkPrice;\n\n\t/**\n\t * @dev iNFTs may get created with the ALI tokens bound to them,\n\t *      linking fee may get charged when creating an iNFT\n\t *\n\t * @dev Linking fee, how much ALI tokens is sent into treasury `feeDestination`\n\t *      upon iNFT creation\n\t *\n\t * @dev Both `linkFee` and `feeDestination` must be set for the fee to be charged;\n\t *      both `linkFee` and `feeDestination` can be either set or unset\n\t */\n\tuint96 public linkFee;\n\n\t/**\n\t * @dev iNFTs may get created with the ALI tokens bound to them,\n\t *      linking fee may get charged when creating an iNFT\n\t *\n\t * @dev Treasury `feeDestination` is an address to send linking fee to upon iNFT creation\n\t *\n\t * @dev Both `linkFee` and `feeDestination` must be set for the fee to be charged;\n\t *      both `linkFee` and `feeDestination` can be either set or unset\n\t */\n\taddress public feeDestination;\n\n\t/**\n\t/**\n\t * @dev Next iNFT ID to mint; initially this is the first \"free\" ID which can be minted;\n\t *      at any point in time this should point to a free, mintable ID for iNFT\n\t *\n\t * @dev iNFT ID space up to 0xFFFF_FFFF (uint32 max) is reserved for the sales\n\t */\n\tuint256 public nextId;\n\n\t/**\n\t * @notice Whitelist / blacklist mapping storing special linking / unlinking permissions\n\t *\n\t * @dev Target NFT Contracts which have special permissions (allowed or forbidden)\n\t *      for iNFT to be linked to / unlinked from;\n\t *      allowance permissions are not taken into account if features\n\t *      ALLOW_ANY_NFT_CONTRACT_FOR_LINKING / ALLOW_ANY_NFT_CONTRACT_FOR_UNLINKING are enabled\n\t *      forbiddance permissions are not taken into account if features\n\t *      ALLOW_ANY_NFT_CONTRACT_FOR_LINKING / ALLOW_ANY_NFT_CONTRACT_FOR_UNLINKING are disabled\n\t *\n\t * @dev Lowest bit (zero) defines if contract is allowed to be linked to;\n\t *      Next bit (one) defines if contract is allowed to be unlinked from;\n\t *      Next bit (two) defines if contract is forbidden to be linked to;\n\t *      Next bit (three) defines if contract is forbidden to be unlinked from;\n\t */\n\tmapping(address => uint8) public whitelistedTargetContracts;\n\n\t/**\n\t * @notice Enables iNFT linking (creation)\n\t *\n\t * @dev Feature FEATURE_LINKING must be enabled\n\t *      as a prerequisite for `link()` function to succeed\n\t */\n\tuint32 public constant FEATURE_LINKING = 0x0000_0001;\n\n\t/**\n\t * @notice Enables iNFT unlinking (destruction)\n\t *\n\t * @dev Feature FEATURE_UNLINKING must be enabled\n\t *      for the `unlink()` and `unlinkNFT()` functions to succeed\n\t */\n\tuint32 public constant FEATURE_UNLINKING = 0x0000_0002;\n\n\t/**\n\t * @notice Allows linker to link (mint) iNFT to any target NFT contract,\n\t *      independently whether it was previously whitelisted or not\n\t * @dev Feature FEATURE_ALLOW_ANY_NFT_CONTRACT_FOR_LINKING allows linking (minting) iNFTs\n\t *      to any target NFT contract, without a check if it's whitelisted in\n\t *      `whitelistedTargetContracts` or not\n\t */\n\tuint32 public constant FEATURE_ALLOW_ANY_NFT_CONTRACT_FOR_LINKING = 0x0000_0004;\n\n\t/**\n\t * @notice Allows linker to unlink (burn) iNFT bound to any target NFT contract,\n\t *      independently whether it was previously whitelisted or not\n\t * @dev Feature FEATURE_ALLOW_ANY_NFT_CONTRACT_FOR_UNLINKING allows unlinking (burning) iNFTs\n\t *      bound to any target NFT contract, without a check if it's whitelisted in\n\t *      `whitelistedTargetContracts` or not\n\t */\n\tuint32 public constant FEATURE_ALLOW_ANY_NFT_CONTRACT_FOR_UNLINKING = 0x0000_0040;\n\n\t/**\n\t * @notice Enables depositing more ALI to already existing iNFTs\n\t *\n\t * @dev Feature FEATURE_DEPOSITS must be enabled\n\t *      for the `deposit()` function to succeed\n\t */\n\tuint32 public constant FEATURE_DEPOSITS = 0x0000_0008;\n\n\t/**\n\t * @notice Enables ALI withdrawals from the iNFT (without destroying them)\n\t *\n\t * @dev Feature FEATURE_WITHDRAWALS must be enabled\n\t *      for the `withdraw()` function to succeed\n\t */\n\tuint32 public constant FEATURE_WITHDRAWALS = 0x0000_0010;\n\n\t/**\n\t * @notice Link price manager is responsible for updating linking price\n\t *\n\t * @dev Role ROLE_LINK_PRICE_MANAGER allows `updateLinkPrice` execution,\n\t *      and `linkPrice` modification\n\t */\n\tuint32 public constant ROLE_LINK_PRICE_MANAGER = 0x0001_0000;\n\n\t/**\n\t * @notice Next ID manager is responsible for updating `nextId` variable,\n\t *      pointing to the next iNFT ID free slot\n\t *\n\t * @dev Role ROLE_NEXT_ID_MANAGER allows `updateNextId` execution,\n\t *     and `nextId` modification\n\t */\n\tuint32 public constant ROLE_NEXT_ID_MANAGER = 0x0002_0000;\n\n\t/**\n\t * @notice Whitelist manager is responsible for managing the target NFT contracts\n\t *     whitelist, which are the contracts iNFT is allowed to be bound to\n\t *\n\t * @dev Role ROLE_WHITELIST_MANAGER allows `whitelistTargetContract` execution,\n\t *     and `whitelistedTargetContracts` mapping modification\n\t */\n\tuint32 public constant ROLE_WHITELIST_MANAGER = 0x0004_0000;\n\n\t/**\n\t * @dev Fired in link() when new iNFT is created\n\t *\n\t * @param _by an address which executed (and funded) the link function\n\t * @param _iNftId ID of the iNFT minted\n\t * @param _linkPrice amount of ALI tokens locked (transferred) to newly created iNFT\n\t * @param _linkFee amount of ALI tokens charged as a fee and sent to the treasury\n\t * @param _personalityContract AI Personality contract address\n\t * @param _personalityId ID of the AI Personality locked (transferred) to newly created iNFT\n\t * @param _targetContract target NFT smart contract\n\t * @param _targetId target NFT ID (where this iNFT binds to and belongs to)\n\t */\n\tevent Linked(\n\t\taddress indexed _by,\n\t\tuint256 _iNftId,\n\t\tuint96 _linkPrice,\n\t\tuint96 _linkFee,\n\t\taddress indexed _personalityContract,\n\t\tuint96 indexed _personalityId,\n\t\taddress _targetContract,\n\t\tuint256 _targetId\n\t);\n\n\t/**\n\t * @dev Fired in unlink() when an existing iNFT gets destroyed\n\t *\n\t * @param _by an address which executed the unlink function\n\t *      (and which received unlocked AI Personality and ALI tokens)\n\t * @param _iNftId ID of the iNFT burnt\n\t */\n\tevent Unlinked(address indexed _by, uint256 indexed _iNftId);\n\n\t/**\n\t * @dev Fired in deposit(), withdraw() when an iNFT ALI balance gets changed\n\t *\n\t * @param _by an address which executed the deposit/withdraw function\n\t *      (in case of withdraw it received unlocked ALI tokens)\n\t * @param _iNftId ID of the iNFT to update\n\t * @param _aliDelta locked ALI tokens delta, positive for deposit, negative for withdraw\n\t * @param _feeValue amount of ALI tokens charged as a fee\n\t */\n\tevent LinkUpdated(address indexed _by, uint256 indexed _iNftId, int128 _aliDelta, uint96 _feeValue);\n\n\t/**\n\t * @dev Fired in updateLinkPrice()\n\t *\n\t * @param _by an address which executed the operation\n\t * @param _linkPrice new linking price set\n\t * @param _linkFee new linking fee set\n\t * @param _feeDestination new treasury address set\n\t */\n\tevent LinkPriceChanged(address indexed _by, uint96 _linkPrice, uint96 _linkFee, address indexed _feeDestination);\n\n\t/**\n\t * @dev Fired in updateNextId()\n\t *\n\t * @param _by an address which executed the operation\n\t * @param _oldVal old nextId value\n\t * @param _newVal new nextId value\n\t */\n\tevent NextIdChanged(address indexed _by, uint256 _oldVal, uint256 _newVal);\n\n\t/**\n\t * @dev Fired in whitelistTargetContract()\n\t *\n\t * @param _by an address which executed the operation\n\t * @param _targetContract target NFT contract address affected\n\t * @param _oldVal old whitelisted raw value (contains 4 flags)\n\t * @param _newVal new whitelisted raw value (contains 4 flags)\n\t */\n\tevent TargetContractWhitelisted(address indexed _by, address indexed _targetContract, uint8 _oldVal, uint8 _newVal);\n\n\t/**\n\t * @dev NOTE: No postConstruct() initializer function!\n\t *      Contract must not be deployed from scratch, only V2 -> V3 upgrade is supported\n\t */\n\n\t/**\n\t * @notice Links given AI Personality with the given NFT and forms an iNFT.\n\t *      AI Personality specified and `linkPrice` ALI are transferred into minted iNFT\n\t *      and are effectively locked within an iNFT until it is destructed (burnt)\n\t *\n\t * @dev AI Personality and ALI tokens are transferred from the transaction sender account\n\t *      to iNFT smart contract\n\t * @dev Sender must approve both AI Personality and ALI tokens transfers to be\n\t *      performed by the linker contract\n\t *\n\t * @param personalityId AI Personality ID to be locked into iNFT\n\t * @param targetContract NFT address iNFT to be linked to\n\t * @param targetId NFT ID iNFT to be linked to\n\t */\n\tfunction link(uint96 personalityId, address targetContract, uint256 targetId) public virtual {\n\t\t// verify linking is enabled\n\t\trequire(isFeatureEnabled(FEATURE_LINKING), \"linking is disabled\");\n\n\t\t// verify AI Personality belongs to transaction sender\n\t\trequire(ERC721(personalityContract).ownerOf(personalityId) == msg.sender, \"access denied\");\n\t\t// verify NFT contract is either whitelisted or any NFT contract is allowed globally\n\t\trequire(isAllowedForLinking(targetContract), \"not a whitelisted NFT contract\");\n\n\t\t// if linking fee is set\n\t\tif(linkFee > 0) {\n\t\t\t// transfer ALI tokens to the treasury - `feeDestination`\n\t\t\tERC20(aliContract).transferFrom(msg.sender, feeDestination, linkFee);\n\t\t}\n\n\t\t// if linking price is set\n\t\tif(linkPrice > 0) {\n\t\t\t// transfer ALI tokens to iNFT contract to be locked\n\t\t\tERC20(aliContract).transferFrom(msg.sender, iNftContract, linkPrice - linkFee);\n\t\t}\n\n\t\t// transfer AI Personality to iNFT contract to be locked\n\t\tERC721(personalityContract).transferFrom(msg.sender, iNftContract, personalityId);\n\n\t\t// mint the next iNFT, increment next iNFT ID to be minted\n\t\tIntelligentNFTv2(iNftContract).mint(nextId++, linkPrice - linkFee, personalityContract, personalityId, targetContract, targetId);\n\n\t\t// emit an event\n\t\temit Linked(msg.sender, nextId - 1, linkPrice, linkFee, personalityContract, personalityId, targetContract, targetId);\n\t}\n\n\t/**\n\t * @notice Destroys given iNFT, unlinking it from underlying NFT and unlocking\n\t *      the AI Personality and ALI tokens locked in iNFT.\n\t *      AI Personality and ALI tokens are transferred to the underlying NFT owner\n\t *\n\t * @dev Can be executed only by iNFT owner (effectively underlying NFT owner)\n\t *\n\t * @param iNftId ID of the iNFT to unlink\n\t */\n\tfunction unlink(uint256 iNftId) public virtual {\n\t\t// verify unlinking is enabled\n\t\trequire(isFeatureEnabled(FEATURE_UNLINKING), \"unlinking is disabled\");\n\n\t\t// get a link to an iNFT contract to perform several actions with it\n\t\tIntelligentNFTv2 iNFT = IntelligentNFTv2(iNftContract);\n\n\t\t// get target NFT contract address from the iNFT binding\n\t\t(,,,address targetContract,) = iNFT.bindings(iNftId);\n\t\t// verify NFT contract is either whitelisted or any NFT contract is allowed globally\n\t\trequire(isAllowedForUnlinking(targetContract), \"not a whitelisted NFT contract\");\n\n\t\t// verify the transaction is executed by iNFT owner (effectively by underlying NFT owner)\n\t\trequire(iNFT.ownerOf(iNftId) == msg.sender, \"not an iNFT owner\");\n\n\t\t// burn the iNFT unlocking the AI Personality and ALI tokens - delegate to `IntelligentNFTv2.burn`\n\t\tiNFT.burn(iNftId);\n\n\t\t// emit an event\n\t\temit Unlinked(msg.sender, iNftId);\n\t}\n\n\t/**\n\t * @notice Unlinks given NFT by destroying iNFTs and unlocking\n\t *      the AI Personality and ALI tokens locked in iNFTs.\n\t *      AI Personality and ALI tokens are transferred to the underlying NFT owner\n\t *\n\t * @dev Can be executed only by NFT owner (effectively underlying NFT owner)\n\t *\n\t * @param nftContract NFT address iNFTs to be unlinked to\n\t * @param nftId NFT ID iNFTs to be unlinked to\n\t */\n\tfunction unlinkNFT(address nftContract, uint256 nftId) public virtual {\n\t\t// verify unlinking is enabled\n\t\trequire(isFeatureEnabled(FEATURE_UNLINKING), \"unlinking is disabled\");\n\n\t\t// get a link to an iNFT contract to perform several actions with it\n\t\tIntelligentNFTv2 iNFT = IntelligentNFTv2(iNftContract);\n\n\t\t// verify the transaction is executed by NFT owner\n\t\trequire(ERC721(nftContract).ownerOf(nftId) == msg.sender, \"not an NFT owner\");\n\n\t\t// get iNFT ID linked with given NFT\n\t\tuint256 iNftId = iNFT.reverseBindings(nftContract, nftId);\n\n\t\t// verify NFT contract is either whitelisted or any NFT contract is allowed globally\n\t\trequire(isAllowedForUnlinking(nftContract), \"not a whitelisted NFT contract\");\n\n\t\t// burn the iNFT unlocking the AI Personality and ALI tokens - delegate to `IntelligentNFTv2.burn`\n\t\tiNFT.burn(iNftId);\n\n\t\t// emit an event\n\t\temit Unlinked(msg.sender, iNftId);\n\t}\n\n\t/**\n\t * @notice Deposits additional ALI tokens into already existing iNFT\n\t *\n\t * @dev Can be executed only by NFT owner (effectively underlying NFT owner)\n\t *\n\t * @dev ALI tokens are transferred from the transaction sender account to iNFT smart contract\n\t *      Sender must approve ALI tokens transfers to be performed by the linker contract\n\t *\n\t * @param iNftId ID of the iNFT to transfer (and lock) tokens to\n\t * @param aliValue amount of ALI tokens to transfer (and lock)\n\t */\n\tfunction deposit(uint256 iNftId, uint96 aliValue) public virtual {\n\t\t// verify deposits are enabled\n\t\trequire(isFeatureEnabled(FEATURE_DEPOSITS), \"deposits are disabled\");\n\n\t\t// get a link to an iNFT contract to perform several actions with it\n\t\tIntelligentNFTv2 iNFT = IntelligentNFTv2(iNftContract);\n\n\t\t// verify the transaction is executed by iNFT owner (effectively by underlying NFT owner)\n\t\trequire(iNFT.ownerOf(iNftId) == msg.sender, \"not an iNFT owner\");\n\n\t\t// effective ALI value locked in iNFT may get altered according to the linking fee set\n\t\t// init effective fee as if linking fee is not set\n\t\tuint96 _linkFee = 0;\n\t\t// init effective ALI value locked as if linking fee is not set\n\t\tuint96 _aliValue = aliValue;\n\t\t// in case when link price/fee are set (effectively meaning fee percent is set)\n\t\tif(linkPrice != 0 && linkFee != 0) {\n\t\t\t// we need to make sure the fee is charged from the value supplied\n\t\t\t// proportionally to the value supplied and fee percent\n\t\t\t_linkFee = uint96(uint256(_aliValue) * linkFee / linkPrice);\n\n\t\t\t// recalculate ALI value to be locked accordingly\n\t\t\t_aliValue = aliValue - _linkFee;\n\n\t\t\t// transfer ALI tokens to the treasury - `feeDestination`\n\t\t\tERC20(aliContract).transferFrom(msg.sender, feeDestination, _linkFee);\n\t\t}\n\n\t\t// transfer ALI tokens to iNFT contract to be locked\n\t\tERC20(aliContract).transferFrom(msg.sender, iNftContract, _aliValue);\n\n\t\t// update the iNFT record\n\t\tiNFT.increaseAli(iNftId, _aliValue);\n\n\t\t// emit an event\n\t\temit LinkUpdated(msg.sender, iNftId, int128(uint128(_aliValue)), _linkFee);\n\t}\n\n\t/**\n\t * @notice Withdraws some ALI tokens from already existing iNFT without destroying it\n\t *\n\t * @dev Can be executed only by NFT owner (effectively underlying NFT owner)\n\t *\n\t * @dev ALI tokens are transferred to the iNFT owner (transaction executor)\n\t *\n\t * @param iNftId ID of the iNFT to unlock tokens from\n\t * @param aliValue amount of ALI tokens to unlock\n\t */\n\tfunction withdraw(uint256 iNftId, uint96 aliValue) public virtual {\n\t\t// verify withdrawals are enabled\n\t\trequire(isFeatureEnabled(FEATURE_WITHDRAWALS), \"withdrawals are disabled\");\n\n\t\t// get a link to an iNFT contract to perform several actions with it\n\t\tIntelligentNFTv2 iNFT = IntelligentNFTv2(iNftContract);\n\n\t\t// verify the transaction is executed by iNFT owner (effectively by underlying NFT owner)\n\t\trequire(iNFT.ownerOf(iNftId) == msg.sender, \"not an iNFT owner\");\n\n\t\t// ensure iNFT locked balance doesn't go below `linkPrice - linkFee`\n\t\trequire(iNFT.lockedValue(iNftId) >= aliValue + linkPrice, \"deposit too low\");\n\n\t\t// update the iNFT record and transfer tokens back to the iNFT owner\n\t\tiNFT.decreaseAli(iNftId, aliValue, msg.sender);\n\n\t\t// emit an event\n\t\temit LinkUpdated(msg.sender, iNftId, -int128(uint128(aliValue)), 0);\n\t}\n\n\t/**\n\t * @dev Restricted access function to modify\n\t *      - linking price `linkPrice`,\n\t *      - linking fee `linkFee`, and\n\t *      - treasury address `feeDestination`\n\t *\n\t * @dev Requires executor to have ROLE_LINK_PRICE_MANAGER permission\n\t * @dev Requires linking price to be either unset (zero), or not less than 1e12 (0.000001 ALI)\n\t * @dev Requires both linking fee and treasury address to be either set or unset (zero);\n\t *      if set, linking fee must not be less than 1e12 (0.000001 ALI);\n\t *      if set, linking fee must not exceed linking price\n\t *\n\t * @param _linkPrice new linking price to be set\n\t * @param _linkFee new linking fee to be set\n\t * @param _feeDestination treasury address\n\t */\n\tfunction updateLinkPrice(uint96 _linkPrice, uint96 _linkFee, address _feeDestination) public virtual {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_LINK_PRICE_MANAGER), \"access denied\");\n\n\t\t// verify the price is not too low if it's set\n\t\trequire(_linkPrice == 0 || _linkPrice >= 1e12, \"invalid price\");\n\n\t\t// linking fee/treasury should be either both set or both unset\n\t\t// linking fee must not be too low if set\n\t\trequire(_linkFee == 0 && _feeDestination == address(0) || _linkFee >= 1e12 && _feeDestination != address(0), \"invalid linking fee/treasury\");\n\t\t// linking fee must not exceed linking price\n\t\trequire(_linkFee <= _linkPrice, \"linking fee exceeds linking price\");\n\n\t\t// update the linking price, fee, and treasury address\n\t\tlinkPrice = _linkPrice;\n\t\tlinkFee = _linkFee;\n\t\tfeeDestination = _feeDestination;\n\n\t\t// emit an event\n\t\temit LinkPriceChanged(msg.sender, _linkPrice, _linkFee, _feeDestination);\n\t}\n\n\t/**\n\t * @dev Restricted access function to modify next iNFT ID `nextId`\n\t *\n\t * @param _nextId new next iNFT ID to be set\n\t */\n\tfunction updateNextId(uint256 _nextId) public virtual {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_NEXT_ID_MANAGER), \"access denied\");\n\n\t\t// verify nextId is in safe bounds\n\t\trequire(_nextId > 0xFFFF_FFFF, \"value too low\");\n\n\t\t// emit a event\n\t\temit NextIdChanged(msg.sender, nextId, _nextId);\n\n\t\t// update next ID\n\t\tnextId = _nextId;\n\t}\n\n\t/**\n\t * @dev Restricted access function to manage whitelisted / blacklisted NFT contracts mapping\n\t *      `whitelistedTargetContracts`\n\t *\n\t * @dev Requires executor to have ROLE_WHITELIST_MANAGER permission\n\t *\n\t * @param targetContract target NFT contract address to add/remove to/from the whitelist\n\t * @param allowedForLinking true to add, false to remove to/from whitelist (allowed for linking)\n\t * @param allowedForUnlinking true to add, false to remove to/from whitelist (allowed for unlinking)\n\t * @param forbiddenForLinking true to add, false to remove to/from blacklist (forbidden for linking)\n\t * @param forbiddenForUnlinking true to add, false to remove to/from blacklist (forbidden for unlinking)\n\t */\n\tfunction whitelistTargetContract(\n\t\taddress targetContract,\n\t\tbool allowedForLinking,\n\t\tbool allowedForUnlinking,\n\t\tbool forbiddenForLinking,\n\t\tbool forbiddenForUnlinking\n\t) public virtual {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_WHITELIST_MANAGER), \"access denied\");\n\n\t\t// verify the address is set\n\t\trequire(targetContract != address(0), \"zero address\");\n\n\t\t// delisting is always possible, whitelisting - only for valid ERC721\n\t\tif(allowedForLinking) {\n\t\t\t// verify targetContract is a valid ERC721\n\t\t\trequire(ERC165(targetContract).supportsInterface(type(ERC721).interfaceId), \"target NFT is not ERC721\");\n\t\t}\n\n\t\t// derive the uint8 value representing two boolean flags:\n\t\t// Lowest bit (zero) defines if contract is allowed to be linked to;\n\t\t// Next bit (one) defines if contract is allowed to be unlinked from\n\t\tuint8 newVal = (allowedForLinking?     0x1: 0x0)\n\t\t             | (allowedForUnlinking?   0x2: 0x0)\n\t\t             | (forbiddenForLinking?   0x4: 0x0)\n\t\t             | (forbiddenForUnlinking? 0x8: 0x0);\n\n\t\t// emit an event\n\t\temit TargetContractWhitelisted(msg.sender, targetContract, whitelistedTargetContracts[targetContract], newVal);\n\n\t\t// update the contract address in the whitelist\n\t\twhitelistedTargetContracts[targetContract] = newVal;\n\t}\n\n\t/**\n\t * @notice Decodes the bit packed integer in whitelistedTargetContracts into boolean tuple\n\t *\n\t * @dev This function returns the values previously set with `whitelistTargetContract` or\n\t *      (false, false, false, false) if the values were not set\n\t *\n\t * @param targetContract target NFT contract address to read the data from whitelist for\n\t * @return allowedForLinking allowed for linking flag\n\t * @return allowedForUnlinking allowed for unlinking flag\n\t * @return forbiddenForLinking forbidden for linking flag\n\t * @return forbiddenForUnlinking forbidden for unlinking flag\n\t */\n\tfunction isWhitelisted(address targetContract) public view virtual returns(\n\t\tbool allowedForLinking,\n\t\tbool allowedForUnlinking,\n\t\tbool forbiddenForLinking,\n\t\tbool forbiddenForUnlinking\n\t) {\n\t\t// read the int (bit packed) value\n\t\tuint8 val = whitelistedTargetContracts[targetContract];\n\n\t\t// decode into boolean values\n\t\tallowedForLinking     = val & 0x1 == 0x1;\n\t\tallowedForUnlinking   = val & 0x2 == 0x2;\n\t\tforbiddenForLinking   = val & 0x4 == 0x4;\n\t\tforbiddenForUnlinking = val & 0x8 == 0x8;\n\n\t\t// results are returned implicitly\n\t}\n\n\t/**\n\t * @notice Checks if specified target NFT contract is allowed to be linked to\n\t *\n\t * @dev Using this function can be more convenient than accessing the\n\t *      `whitelistedTargetContracts` directly since the mapping contains linking/unlinking\n\t *      flags packed into uint8\n\t *\n\t * @param targetContract target NFT contract address to query for\n\t * @return true if target NFT contract is allowed to be linked to, false otherwise\n\t */\n\tfunction isAllowedForLinking(address targetContract) public view virtual returns (bool) {\n\t\t// extract the information required from the mapping using helper function\n\t\t(bool allowedForLinking,, bool forbiddenForLinking,) = isWhitelisted(targetContract);\n\n\t\t// evaluate the result based on the values read\n\t\treturn !forbiddenForLinking && (allowedForLinking || isFeatureEnabled(FEATURE_ALLOW_ANY_NFT_CONTRACT_FOR_LINKING));\n\t}\n\n\t/**\n\t * @notice Checks if specified target NFT contract is allowed to be unlinked from\n\t *\n\t * @dev Using this function can be more convenient than accessing the\n\t *      `whitelistedTargetContracts` directly since the mapping contains linking/unlinking\n\t *      flags packed into uint8\n\t *\n\t * @param targetContract target NFT contract address to query for\n\t * @return true if target NFT contract is allowed to be unlinked from, false otherwise\n\t */\n\tfunction isAllowedForUnlinking(address targetContract) public view virtual returns (bool) {\n\t\t// extract the information required from the mapping using helper function\n\t\t(, bool allowedForUnlinking,, bool forbiddenForUnlinking) = isWhitelisted(targetContract);\n\n\t\t// evaluate the result based on the values read\n\t\treturn !forbiddenForUnlinking && (allowedForUnlinking || isFeatureEnabled(FEATURE_ALLOW_ANY_NFT_CONTRACT_FOR_UNLINKING));\n\t}\n}\n"
    },
    "contracts/protocol/MintableSale.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ERC721SpecExt.sol\";\nimport \"../interfaces/ERC721Spec.sol\";\nimport \"../utils/AccessControl.sol\";\n\n/**\n * @title Mintable Sale\n *\n * @notice Mintable Sale sales fixed amount of NFTs (tokens) for a fixed price in a fixed period of time;\n *      it is used in 10k sale campaign to sell AI Personalities, but smart contract is generic and\n *      can sell any type of mintable NFT (see MintableERC721 interface)\n *\n * @dev Technically, all the \"fixed\" parameters can be changed on the go after smart contract is deployed\n *      and operational, but this ability is reserved for quick fix-like adjustments, and to provide\n *      an ability to restart and run a similar sale after the previous one ends\n *\n * @dev When buying a token from this smart contract, next token is minted to the recipient\n *\n * @dev Deployment and setup:\n *      1. Deploy smart contract, specify smart contract address during the deployment:\n *         - Mintable ER721 deployed instance address\n *      2. Execute `initialize` function and set up the sale parameters;\n *         sale is not active until it's initialized\n */\ncontract MintableSale is AccessControl {\n\t// ----- SLOT.1 (256/256)\n\t/**\n\t * @notice Price of a single item (token) minted\n\t *      When buying several tokens at once the price accumulates accordingly, with no discount\n\t *\n\t * @dev Maximum item price is ~18.44 ETH\n\t */\n\tuint64 public itemPrice;\n\n\t/**\n\t * @dev Next token ID to mint;\n\t *      initially this is the first \"free\" ID which can be minted;\n\t *      at any point in time this should point to a free, mintable ID\n\t *      for the token\n\t *\n\t * @dev `nextId` cannot be zero, we do not ever mint NFTs with zero IDs\n\t */\n\tuint32 public nextId = 1;\n\n\t/**\n\t * @dev Last token ID to mint;\n\t *      once `nextId` exceeds `finalId` the sale pauses\n\t */\n\tuint32 public finalId;\n\n\t/**\n\t * @notice Sale start unix timestamp; the sale is active after the start (inclusive)\n\t */\n\tuint32 public saleStart;\n\n\t/**\n\t * @notice Sale end unix timestamp; the sale is active before the end (exclusive)\n\t */\n\tuint32 public saleEnd;\n\n\t/**\n\t * @notice Once set, limits the amount of tokens one can buy in a single transaction;\n\t *       When unset (zero) the amount of tokens is limited only by block size and\n\t *       amount of tokens left for sale\n\t */\n\tuint32 public batchLimit;\n\n\t/**\n\t * @notice Counter of the tokens sold (minted) by this sale smart contract\n\t */\n\tuint32 public soldCounter;\n\n\t// ----- NON-SLOTTED\n\t/**\n\t * @dev Mintable ERC721 contract address to mint\n\t */\n\taddress public immutable tokenContract;\n\n\t/**\n\t * @notice Sale manager is responsible for managing properties of the sale,\n\t *      such as sale price, amount, start/end dates, etc.\n\t *\n\t * @dev Role ROLE_SALE_MANAGER allows updating sale properties via initialize() function\n\t */\n\tuint32 public constant ROLE_SALE_MANAGER = 0x0001_0000;\n\n\t/**\n\t * @notice Withdrawal manager is responsible for withdrawing ETH obtained in sale\n\t *      from the sale smart contract\n\t *\n\t * @dev Role ROLE_WITHDRAWAL_MANAGER allows ETH withdrawals:\n\t *      - withdraw()\n\t *      - withdrawTo()\n\t */\n\tuint32 public constant ROLE_WITHDRAWAL_MANAGER = 0x0002_0000;\n\n\t/**\n\t * @dev Fired in initialize()\n\t *\n\t * @param _by an address which executed the initialization\n\t * @param _itemPrice price of one token created\n\t * @param _nextId next ID of the token to mint\n\t * @param _finalId final ID of the token to mint\n\t * @param _saleStart start of the sale, unix timestamp\n\t * @param _saleEnd end of the sale, unix timestamp\n\t * @param _batchLimit how many tokens is allowed to buy in a single transaction\n\t */\n\tevent Initialized(\n\t\taddress indexed _by,\n\t\tuint64 _itemPrice,\n\t\tuint32 _nextId,\n\t\tuint32 _finalId,\n\t\tuint32 _saleStart,\n\t\tuint32 _saleEnd,\n\t\tuint32 _batchLimit\n\t);\n\n\t/**\n\t * @dev Fired in buy(), buyTo(), buySingle(), and buySingleTo()\n\t *\n\t * @param _by an address which executed and payed the transaction, probably a buyer\n\t * @param _to an address which received token(s) minted\n\t * @param _amount number of tokens minted\n\t * @param _value ETH amount charged\n\t */\n\tevent Bought(address indexed _by, address indexed _to, uint256 _amount, uint256 _value);\n\n\t/**\n\t * @dev Fired in withdraw() and withdrawTo()\n\t *\n\t * @param _by an address which executed the withdrawal\n\t * @param _to an address which received the ETH withdrawn\n\t * @param _value ETH amount withdrawn\n\t */\n\tevent Withdrawn(address indexed _by, address indexed _to, uint256 _value);\n\n\t/**\n\t * @dev Creates/deploys MintableSale and binds it to Mintable ERC721\n\t *      smart contract on construction\n\t *\n\t * @param _tokenContract deployed Mintable ERC721 smart contract; sale will mint ERC721\n\t *      tokens of that type to the recipient\n\t */\n\tconstructor(address _tokenContract) AccessControl(msg.sender) {\n\t\t// verify the input is set\n\t\trequire(_tokenContract != address(0), \"token contract is not set\");\n\t\t\n\t\t// verify input is valid smart contract of the expected interfaces\n\t\trequire(\n\t\t\tERC165(_tokenContract).supportsInterface(type(ERC721).interfaceId)\n\t\t\t&& ERC165(_tokenContract).supportsInterface(type(MintableERC721).interfaceId),\n\t\t\t\"unexpected token contract type\"\n\t\t);\n\t\t\n\t\t// assign the addresses\n\t\ttokenContract = _tokenContract;\n\t}\n\n\t/**\n\t * @notice Number of tokens left on sale\n\t *\n\t * @dev Doesn't take into account if sale is active or not,\n\t *      if `nextId - finalId < 1` returns zero\n\t *\n\t * @return number of tokens left on sale\n\t */\n\tfunction itemsOnSale() public view returns(uint32) {\n\t\t// calculate items left on sale, taking into account that\n\t\t// finalId is on sale (inclusive bound)\n\t\treturn finalId > nextId? finalId + 1 - nextId: 0;\n\t}\n\n\t/**\n\t * @notice Number of tokens available on sale\n\t *\n\t * @dev Takes into account if sale is active or not, doesn't throw,\n\t *      returns zero if sale is inactive\n\t *\n\t * @return number of tokens available on sale\n\t */\n\tfunction itemsAvailable() public view returns(uint32) {\n\t\t// delegate to itemsOnSale() if sale is active, return zero otherwise\n\t\treturn isActive()? itemsOnSale(): 0;\n\t}\n\n\t/**\n\t * @notice Active sale is an operational sale capable of minting and selling tokens\n\t *\n\t * @dev The sale is active when all the requirements below are met:\n\t *      1. Price is set (`itemPrice` is not zero)\n\t *      2. `finalId` is not reached (`nextId <= finalId`)\n\t *      3. current timestamp is between `saleStart` (inclusive) and `saleEnd` (exclusive)\n\t *\n\t * @dev Function is marked as virtual to be overridden in the helper test smart contract (mock)\n\t *      in order to test how it affects the sale process\n\t *\n\t * @return true if sale is active (operational) and can sell tokens, false otherwise\n\t */\n\tfunction isActive() public view virtual returns(bool) {\n\t\t// evaluate sale state based on the internal state variables and return\n\t\treturn itemPrice > 0 && nextId <= finalId && saleStart <= now256() && saleEnd > now256();\n\t}\n\n\t/**\n\t * @dev Restricted access function to set up sale parameters, all at once,\n\t *      or any subset of them\n\t *\n\t * @dev To skip parameter initialization, set it to `-1`,\n\t *      that is a maximum value for unsigned integer of the corresponding type;\n\t *      `_aliSource` and `_aliValue` must both be either set or skipped\n\t *\n\t * @dev Example: following initialization will update only _itemPrice and _batchLimit,\n\t *      leaving the rest of the fields unchanged\n\t *      initialize(\n\t *          100000000000000000,\n\t *          0xFFFFFFFF,\n\t *          0xFFFFFFFF,\n\t *          0xFFFFFFFF,\n\t *          0xFFFFFFFF,\n\t *          10\n\t *      )\n\t *\n\t * @dev Requires next ID to be greater than zero (strict): `_nextId > 0`\n\t *\n\t * @dev Requires transaction sender to have `ROLE_SALE_MANAGER` role\n\t *\n\t * @param _itemPrice price of one token created;\n\t *      setting the price to zero deactivates the sale\n\t * @param _nextId next ID of the token to mint, will be increased\n\t *      in smart contract storage after every successful buy\n\t * @param _finalId final ID of the token to mint; sale is capable of producing\n\t *      `_finalId - _nextId + 1` tokens\n\t * @param _saleStart start of the sale, unix timestamp\n\t * @param _saleEnd end of the sale, unix timestamp; sale is active only\n\t *      when current time is within _saleStart (inclusive) and _saleEnd (exclusive)\n\t * @param _batchLimit how many tokens is allowed to buy in a single transaction,\n\t *      set to zero to disable the limit\n\t */\n\tfunction initialize(\n\t\tuint64 _itemPrice,\t// <<<--- keep type in sync with the body type(uint64).max !!!\n\t\tuint32 _nextId,\t// <<<--- keep type in sync with the body type(uint32).max !!!\n\t\tuint32 _finalId,\t// <<<--- keep type in sync with the body type(uint32).max !!!\n\t\tuint32 _saleStart,\t// <<<--- keep type in sync with the body type(uint32).max !!!\n\t\tuint32 _saleEnd,\t// <<<--- keep type in sync with the body type(uint32).max !!!\n\t\tuint32 _batchLimit\t// <<<--- keep type in sync with the body type(uint32).max !!!\n\t) public {\n\t\t// check the access permission\n\t\trequire(isSenderInRole(ROLE_SALE_MANAGER), \"access denied\");\n\n\t\t// verify the inputs\n\t\trequire(_nextId > 0, \"zero nextId\");\n\t\t\n\t\t// no need to verify extra parameters - \"incorrect\" values will deactivate the sale\n\n\t\t// initialize contract state based on the values supplied\n\t\t// take into account our convention that value `-1` means \"do not set\"\n\t\t// 0xFFFFFFFFFFFFFFFF, 64 bits\n\t\tif(_itemPrice != type(uint64).max) {\n\t\t\titemPrice = _itemPrice;\n\t\t}\n\t\t// 0xFFFFFFFF, 32 bits\n\t\tif(_nextId != type(uint32).max) {\n\t\t\tnextId = _nextId;\n\t\t}\n\t\t// 0xFFFFFFFF, 32 bits\n\t\tif(_finalId != type(uint32).max) {\n\t\t\tfinalId = _finalId;\n\t\t}\n\t\t// 0xFFFFFFFF, 32 bits\n\t\tif(_saleStart != type(uint32).max) {\n\t\t\tsaleStart = _saleStart;\n\t\t}\n\t\t// 0xFFFFFFFF, 32 bits\n\t\tif(_saleEnd != type(uint32).max) {\n\t\t\tsaleEnd = _saleEnd;\n\t\t}\n\t\t// 0xFFFFFFFF, 32 bits\n\t\tif(_batchLimit != type(uint32).max) {\n\t\t\tbatchLimit = _batchLimit;\n\t\t}\n\n\t\t// emit an event - read values from the storage since not all of them might be set\n\t\temit Initialized(\n\t\t\tmsg.sender,\n\t\t\titemPrice,\n\t\t\tnextId,\n\t\t\tfinalId,\n\t\t\tsaleStart,\n\t\t\tsaleEnd,\n\t\t\tbatchLimit\n\t\t);\n\t}\n\n\t/**\n\t * @notice Buys several (at least two) tokens in a batch.\n\t *      Accepts ETH as payment and mints a token\n\t *\n\t * @param _amount amount of tokens to create, two or more\n\t */\n\tfunction buy(uint32 _amount) public payable {\n\t\t// delegate to `buyTo` with the transaction sender set to be a recipient\n\t\tbuyTo(msg.sender, _amount);\n\t}\n\n\t/**\n\t * @notice Buys several (at least two) tokens in a batch to an address specified.\n\t *      Accepts ETH as payment and mints tokens\n\t *\n\t * @param _to address to mint tokens to\n\t * @param _amount amount of tokens to create, two or more\n\t */\n\tfunction buyTo(address _to, uint32 _amount) public payable {\n\t\t// verify the inputs\n\t\trequire(_to != address(0), \"recipient not set\");\n\t\trequire(_amount > 1 && (batchLimit == 0 || _amount <= batchLimit), \"incorrect amount\");\n\n\t\t// verify there is enough items available to buy the amount\n\t\t// verifies sale is in active state under the hood\n\t\trequire(itemsAvailable() >= _amount, \"inactive sale or not enough items available\");\n\n\t\t// calculate the total price required and validate the transaction value\n\t\tuint256 totalPrice = uint256(itemPrice) * _amount;\n\t\trequire(msg.value >= totalPrice, \"not enough funds\");\n\n\t\t// mint token to to the recipient\n\t\tMintableERC721(tokenContract).mintBatch(_to, nextId, _amount);\n\n\t\t// increment `nextId`\n\t\tnextId += _amount;\n\t\t// increment `soldCounter`\n\t\tsoldCounter += _amount;\n\n\t\t// if ETH amount supplied exceeds the price\n\t\tif(msg.value > totalPrice) {\n\t\t\t// send excess amount back to sender\n\t\t\tpayable(msg.sender).transfer(msg.value - totalPrice);\n\t\t}\n\n\t\t// emit en event\n\t\temit Bought(msg.sender, _to, _amount, totalPrice);\n\t}\n\n\t/**\n\t * @notice Buys single token.\n\t *      Accepts ETH as payment and mints a token\n\t */\n\tfunction buySingle() public payable {\n\t\t// delegate to `buySingleTo` with the transaction sender set to be a recipient\n\t\tbuySingleTo(msg.sender);\n\t}\n\n\t/**\n\t * @notice Buys single token to an address specified.\n\t *      Accepts ETH as payment and mints a token\n\t *\n\t * @param _to address to mint token to\n\t */\n\tfunction buySingleTo(address _to) public payable {\n\t\t// verify the inputs and transaction value\n\t\trequire(_to != address(0), \"recipient not set\");\n\t\trequire(msg.value >= itemPrice, \"not enough funds\");\n\n\t\t// verify sale is in active state\n\t\trequire(isActive(), \"inactive sale\");\n\n\t\t// mint token to the recipient\n\t\tMintableERC721(tokenContract).mint(_to, nextId);\n\t\t\n\t\t// increment `nextId`\n\t\tnextId++;\n\t\t// increment `soldCounter`\n\t\tsoldCounter++;\n\n\t\t// if ETH amount supplied exceeds the price\n\t\tif(msg.value > itemPrice) {\n\t\t\t// send excess amount back to sender\n\t\t\tpayable(msg.sender).transfer(msg.value - itemPrice);\n\t\t}\n\n\t\t// emit en event\n\t\temit Bought(msg.sender, _to, 1, itemPrice);\n\t}\n\n\t/**\n\t * @dev Restricted access function to withdraw ETH on the contract balance,\n\t *      sends ETH back to transaction sender\n\t */\n\tfunction withdraw() public {\n\t\t// delegate to `withdrawTo`\n\t\twithdrawTo(msg.sender);\n\t}\n\n\t/**\n\t * @dev Restricted access function to withdraw ETH on the contract balance,\n\t *      sends ETH to the address specified\n\t *\n\t * @param _to an address to send ETH to\n\t */\n\tfunction withdrawTo(address _to) public {\n\t\t// check the access permission\n\t\trequire(isSenderInRole(ROLE_WITHDRAWAL_MANAGER), \"access denied\");\n\n\t\t// verify withdrawal address is set\n\t\trequire(_to != address(0), \"address not set\");\n\n\t\t// ETH value to send\n\t\tuint256 _value = address(this).balance;\n\n\t\t// verify sale balance is positive (non-zero)\n\t\trequire(_value > 0, \"zero balance\");\n\n\t\t// send the entire balance to the transaction sender\n\t\tpayable(_to).transfer(_value);\n\n\t\t// emit en event\n\t\temit Withdrawn(msg.sender, _to, _value);\n\t}\n\n\t/**\n\t * @dev Testing time-dependent functionality may be difficult;\n\t *      we override time in the helper test smart contract (mock)\n\t *\n\t * @return `block.timestamp` in mainnet, custom values in testnets (if overridden)\n\t */\n\tfunction now256() public view virtual returns (uint256) {\n\t\t// return current block timestamp\n\t\treturn block.timestamp;\n\t}\n}\n"
    },
    "contracts/protocol/NFTFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ERC721SpecExt.sol\";\nimport \"../utils/AccessControl.sol\";\nimport \"../lib/ECDSA.sol\";\n\n/**\n * @title Alethea NFT Factory\n *\n * @notice NFT Factory is a helper smart contract responsible for minting arbitrary NFTs\n *\n * @notice It supports two mechanisms:\n *      - minting delegation: authorized address executes mint function on the helper,\n *        and helper executes minting function on the target ERC721 contract as an internal transaction\n *      - meta transaction minting or minting with an authorization: authorized address signs\n *        the minting authorization message and any address executes mint function on the helper\n *\n * @notice Second mechanism allows to shift the gas costs for the transaction to any address\n *      (usually this is the NFT beneficiary - an address which receives an NFT)\n *\n * @dev The signature is constructed via EIP-712 similar to EIP-2612, or EIP-3009\n *\n * @dev Target ERC721 contract(s) must allow helper to mint the tokens, this should be configured\n *      as part of the deployment or setup processes\n */\ncontract NFTFactory is AccessControl {\n\t/**\n\t * @dev A record of used nonces for EIP-712 transactions\n\t *\n\t * @dev A record of used nonces for signing/validating signatures\n\t *      in `mintWithAuthorization` for every mint\n\t *\n\t * @dev Maps authorizer address => nonce => true/false (used unused)\n\t */\n\tmapping(address => mapping(bytes32 => bool)) private usedNonces;\n\n\t/**\n\t * @notice EIP-712 contract's domain separator,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator\n\t */\n\tbytes32 public immutable DOMAIN_SEPARATOR;\n\n\t/**\n\t * @notice EIP-712 contract's domain typeHash,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\n\t *\n\t * @dev Note: we do not include version into the domain typehash/separator,\n\t *      it is implied version is concatenated to the name field, like \"NFTFactoryV2\"\n\t */\n\t// keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\")\n\tbytes32 public constant DOMAIN_TYPEHASH = 0x8cad95687ba82c2ce50e74f7b754645e5117c3a5bec8151c0726d5857980a866;\n\n\t/**\n\t * @notice EIP-712 MintWithAuthorization struct typeHash,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\n\t */\n\t// keccak256(\"MintWithAuthorization(address contract,address to,uint256 tokenId,uint256 validAfter,uint256 validBefore,bytes32 nonce)\")\n\tbytes32 public constant MINT_WITH_AUTHORIZATION_TYPEHASH = 0x495835d970a03ff092657fca9abde67d34a0bb73a0bba258a5fa90c4ce4340f6;\n\n\t/**\n\t * @notice EIP-712 CancelAuthorization struct typeHash,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\n\t */\n\t// keccak256(\"CancelAuthorization(address authorizer,bytes32 nonce)\")\n\tbytes32 public constant CANCEL_AUTHORIZATION_TYPEHASH = 0x158b0a9edf7a828aad02f63cd515c68ef2f50ba807396f6d12842833a1597429;\n\n\t/**\n\t * @notice Enables meta transaction minting (minting with an authorization\n\t *      via an EIP712 signature)\n\t * @dev Feature FEATURE_MINTING_WITH_AUTH must be enabled in order for\n\t *      `mintWithAuthorization()` function to succeed\n\t */\n\tuint32 public constant FEATURE_MINTING_WITH_AUTH = 0x0000_0001;\n\n\t/**\n\t * @notice Factory minter is responsible for creating (minting)\n\t *      tokens to an arbitrary address\n\t * @dev Role ROLE_FACTORY_MINTER allows minting tokens\n\t *      (executing `mint` function)\n\t */\n\tuint32 public constant ROLE_FACTORY_MINTER = 0x0001_0000;\n\n\t/**\n\t * @dev Fired in mint() and mintWithAuthorization() after an NFT is minted\n\t *\n\t * @param erc721Address ERC721 contract address which was minted\n\t * @param to an address NFT was minted to\n\t * @param tokenId NFT ID which was minted\n\t */\n\tevent Minted(address indexed erc721Address, address indexed to, uint256 indexed tokenId);\n\n\t/**\n\t * @dev Fired whenever the nonce gets used (ex.: `transferWithAuthorization`, `receiveWithAuthorization`)\n\t *\n\t * @param authorizer an address which has used the nonce\n\t * @param nonce the nonce used\n\t */\n\tevent AuthorizationUsed(address indexed authorizer, bytes32 indexed nonce);\n\n\t/**\n\t * @dev Fired whenever the nonce gets cancelled (ex.: `cancelAuthorization`)\n\t *\n\t * @dev Both `AuthorizationUsed` and `AuthorizationCanceled` imply the nonce\n\t *      cannot be longer used, the only difference is that `AuthorizationCanceled`\n\t *      implies no smart contract state change made (except the nonce marked as cancelled)\n\t *\n\t * @param authorizer an address which has cancelled the nonce\n\t * @param nonce the nonce cancelled\n\t */\n\tevent AuthorizationCanceled(address indexed authorizer, bytes32 indexed nonce);\n\n\t/**\n\t * Deploys the helper contract and initializes DOMAIN_SEPARATOR using the created smart contract address\n\t */\n\tconstructor() AccessControl(msg.sender) {\n\t\t// build the EIP-712 contract domain separator, see https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator\n\t\t// note: we specify contract version in its name\n\t\tDOMAIN_SEPARATOR = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(\"NFTFactoryV1\")), block.chainid, address(this)));\n\t}\n\n\t/**\n\t * @notice Restricted access function to mint an NFT\n\t *\n\t * @dev Doesn't allow minting the token with ID zero\n\t * @dev Requires an executor to have ROLE_MINTER permission\n\t * @dev Requires target ERC721 contract to be mintable (`MintableERC721`)\n\t * @dev Requires target ERC721 contract instance to allow minting via helper\n\t *\n\t * @param _mintableErc721 target ERC721 contract instance to mint token on,\n\t *      compatible with `MintableERC721`\n\t * @param _to an address to mint token to\n\t * @param _tokenId target ERC721 token ID to mint\n\t */\n\tfunction mint(address _mintableErc721, address _to, uint256 _tokenId) public {\n\t\t// delegate to _mint()\n\t\t__mint(msg.sender, _mintableErc721, _to, _tokenId);\n\t}\n\n\t/**\n\t * @dev Auxiliary internally used function to mint an NFT\n\t *\n\t * @dev Unsafe: doesn't verify real tx executor (msg.sender) permissions, but the permissions of\n\t *      the address specified as an executor, must be kept private at all times\n\t *\n\t * @dev Doesn't allow minting the token with ID zero\n\t * @dev Requires an executor to have ROLE_MINTER permission\n\t * @dev Requires target ERC721 contract to be mintable (`MintableERC721`)\n\t * @dev Requires target ERC721 contract instance to allow minting via helper\n\t *\n\t * @param _executor an address on which behalf the operation is executed,\n\t *      this is usually `msg.sender` but this can be different address for\n\t *      the EIP-712 like transactions (mint with authorization)\n\t * @param _mintableErc721 target ERC721 contract instance to mint token on,\n\t *      compatible with `MintableERC721`\n\t * @param _to an address to mint token to\n\t * @param _tokenId target ERC721 token ID to mint\n\t */\n\tfunction __mint(address _executor, address _mintableErc721, address _to, uint256 _tokenId) private {\n\t\t// verify the access permission\n\t\trequire(isOperatorInRole(_executor, ROLE_FACTORY_MINTER), \"access denied\");\n\n\t\t// verify the inputs\n\t\trequire(_mintableErc721 != address(0), \"ERC721 instance addr is not set\");\n\t\trequire(_to != address(0), \"NFT receiver addr is not set\");\n\t\trequire(_tokenId != 0, \"token ID is not set\");\n\n\t\t// delegate to the target ERC721 contract\n\t\tMintableERC721(_mintableErc721).safeMint(_to, _tokenId);\n\n\t\t// emit an event\n\t\temit Minted(_mintableErc721, _to, _tokenId);\n\t}\n\n\t/**\n\t * @notice Executes a mint function with a signed authorization\n\t *\n\t * @param _mintableErc721 target ERC721 contract instance to mint token on,\n\t *      compatible with `MintableERC721`\n\t * @param _to an address to mint token to\n\t * @param _tokenId target ERC721 token ID to mint\n\t * @param _validAfter signature valid after time (unix timestamp)\n\t * @param _validBefore signature valid before time (unix timestamp)\n\t * @param _nonce unique random nonce\n\t * @param v the recovery byte of the signature\n\t * @param r half of the ECDSA signature pair\n\t * @param s half of the ECDSA signature pair\n\t */\n\tfunction mintWithAuthorization(\n\t\taddress _mintableErc721,\n\t\taddress _to,\n\t\tuint256 _tokenId,\n\t\tuint256 _validAfter,\n\t\tuint256 _validBefore,\n\t\tbytes32 _nonce,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) public {\n\t\t// ensure EIP-712 minting with authorization is enabled\n\t\trequire(isFeatureEnabled(FEATURE_MINTING_WITH_AUTH), \"minting with auth is disabled\");\n\n\t\t// derive signer of the EIP712 MintWithAuthorization message\n\t\taddress signer = __deriveSigner(\n\t\t\tabi.encode(MINT_WITH_AUTHORIZATION_TYPEHASH, _mintableErc721, _to, _tokenId, _validAfter, _validBefore, _nonce),\n\t\t\tv,\n\t\t\tr,\n\t\t\ts\n\t\t);\n\n\t\t// perform message integrity and security validations\n\t\trequire(block.timestamp > _validAfter, \"signature not yet valid\");\n\t\trequire(block.timestamp < _validBefore, \"signature expired\");\n\n\t\t// use the nonce supplied (verify, mark as used, emit event)\n\t\t__useNonce(signer, _nonce, false);\n\n\t\t// delegate call to `_mint` - execute the logic required\n\t\t__mint(signer, _mintableErc721, _to, _tokenId);\n\t}\n\n\t/**\n\t * @notice Returns the state of an authorization, more specifically\n\t *      if the specified nonce was already used by the address specified\n\t *\n\t * @dev Nonces are expected to be client-side randomly generated 32-byte data\n\t *      unique to the authorizer's address\n\t *\n\t * @param _authorizer Authorizer's address\n\t * @param _nonce Nonce of the authorization\n\t * @return true if the nonce is used\n\t */\n\tfunction authorizationState(\n\t\taddress _authorizer,\n\t\tbytes32 _nonce\n\t) external view returns (bool) {\n\t\t// simply return the value from the mapping\n\t\treturn usedNonces[_authorizer][_nonce];\n\t}\n\n\t/**\n\t * @notice Cancels the authorization (using EIP-712 signature)\n\t *\n\t * @param _authorizer transaction authorizer\n\t * @param _nonce unique random nonce to cancel (mark as used)\n\t * @param v the recovery byte of the signature\n\t * @param r half of the ECDSA signature pair\n\t * @param s half of the ECDSA signature pair\n\t */\n\tfunction cancelAuthorization(\n\t\taddress _authorizer,\n\t\tbytes32 _nonce,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) public {\n\t\t// derive signer of the EIP712 ReceiveWithAuthorization message\n\t\taddress signer = __deriveSigner(abi.encode(CANCEL_AUTHORIZATION_TYPEHASH, _authorizer, _nonce), v, r, s);\n\n\t\t// perform message integrity and security validations\n\t\trequire(signer == _authorizer, \"invalid signature\");\n\n\t\t// cancel the nonce supplied (verify, mark as used, emit event)\n\t\t__useNonce(_authorizer, _nonce, true);\n\t}\n\n\t/**\n\t * @notice Cancels the authorization\n\t *\n\t * @param _nonce unique random nonce to cancel (mark as used)\n\t */\n\tfunction cancelAuthorization(bytes32 _nonce) public {\n\t\t// cancel the nonce supplied (verify, mark as used, emit event)\n\t\t__useNonce(msg.sender, _nonce, true);\n\t}\n\n\t/**\n\t * @dev Auxiliary function to verify structured EIP712 message signature and derive its signer\n\t *\n\t * @param abiEncodedTypehash abi.encode of the message typehash together with all its parameters\n\t * @param v the recovery byte of the signature\n\t * @param r half of the ECDSA signature pair\n\t * @param s half of the ECDSA signature pair\n\t */\n\tfunction __deriveSigner(bytes memory abiEncodedTypehash, uint8 v, bytes32 r, bytes32 s) private view returns(address) {\n\t\t// build the EIP-712 hashStruct of the message\n\t\tbytes32 hashStruct = keccak256(abiEncodedTypehash);\n\n\t\t// calculate the EIP-712 digest \"\\x19\\x01\" ‖ domainSeparator ‖ hashStruct(message)\n\t\tbytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR, hashStruct));\n\n\t\t// recover the address which signed the message with v, r, s\n\t\taddress signer = ECDSA.recover(digest, v, r, s);\n\n\t\t// return the signer address derived from the signature\n\t\treturn signer;\n\t}\n\n\t/**\n\t * @dev Auxiliary function to use/cancel the nonce supplied for a given authorizer:\n\t *      1. Verifies the nonce was not used before\n\t *      2. Marks the nonce as used\n\t *      3. Emits an event that the nonce was used/cancelled\n\t *\n\t * @dev Set `_cancellation` to false (default) to use nonce,\n\t *      set `_cancellation` to true to cancel nonce\n\t *\n\t * @dev It is expected that the nonce supplied is a randomly\n\t *      generated uint256 generated by the client\n\t *\n\t * @param _authorizer an address to use/cancel nonce for\n\t * @param _nonce random nonce to use\n\t * @param _cancellation true to emit `AuthorizationCancelled`, false to emit `AuthorizationUsed` event\n\t */\n\tfunction __useNonce(address _authorizer, bytes32 _nonce, bool _cancellation) private {\n\t\t// verify nonce was not used before\n\t\trequire(!usedNonces[_authorizer][_nonce], \"invalid nonce\");\n\n\t\t// update the nonce state to \"used\" for that particular signer to avoid replay attack\n\t\tusedNonces[_authorizer][_nonce] = true;\n\n\t\t// depending on the usage type (use/cancel)\n\t\tif(_cancellation) {\n\t\t\t// emit an event regarding the nonce cancelled\n\t\t\temit AuthorizationCanceled(_authorizer, _nonce);\n\t\t}\n\t\telse {\n\t\t\t// emit an event regarding the nonce used\n\t\t\temit AuthorizationUsed(_authorizer, _nonce);\n\t\t}\n\t}\n}\n"
    },
    "contracts/protocol/NFTFactoryV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ERC721Spec.sol\";\nimport \"../interfaces/ERC721SpecExt.sol\";\nimport \"../utils/AccessControl.sol\";\nimport \"../lib/ECDSA.sol\";\n\n/**\n * @title Alethea NFT Factory\n *\n * @notice NFT Factory is a helper smart contract responsible for minting arbitrary NFTs\n *\n * @notice It supports two mechanisms:\n *      - minting delegation: authorized address executes mint function on the helper,\n *        and helper executes minting function on the target ERC721 contract as an internal transaction\n *      - meta transaction minting or minting with an authorization: authorized address signs\n *        the minting authorization message and any address executes mint function on the helper\n *\n * @notice Second mechanism allows to shift the gas costs for the transaction to any address\n *      (usually this is the NFT beneficiary - an address which receives an NFT)\n *\n * @dev The signature is constructed via EIP-712 similar to EIP-2612, or EIP-3009\n *\n * @dev Target ERC721 contract(s) must allow helper to mint the tokens, this should be configured\n *      as part of the deployment or setup processes\n *\n * @dev Version 2 (NFTFactoryV2) adds total supply limiting feature allowing to set the NFT total\n *     supply hardcap; factory stops minting when total supply of the ERC721 to mint reaches the hardcap\n */\ncontract NFTFactoryV2 is AccessControl {\n\t/**\n\t * @notice Total Supply Hardcap affects factory capability to mint: once\n\t *      target ERC721 total supply reaches the hardcap, factory stops minting it\n\t *\n\t * @dev The factory `mint` and `mintWithAuthorization` function throws\n\t *      if target ERC721 `totalSupply` value is equal or bigger than `totalSupplyHardcap`\n\t */\n\tuint256 public immutable totalSupplyHardcap;\n\n\t/**\n\t * @dev A record of used nonces for EIP-712 transactions\n\t *\n\t * @dev A record of used nonces for signing/validating signatures\n\t *      in `mintWithAuthorization` for every mint\n\t *\n\t * @dev Maps authorizer address => nonce => true/false (used unused)\n\t */\n\tmapping(address => mapping(bytes32 => bool)) private usedNonces;\n\n\t/**\n\t * @notice EIP-712 contract's domain separator,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator\n\t */\n\tbytes32 public immutable DOMAIN_SEPARATOR;\n\n\t/**\n\t * @notice EIP-712 contract's domain typeHash,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\n\t *\n\t * @dev Note: we do not include version into the domain typehash/separator,\n\t *      it is implied version is concatenated to the name field, like \"NFTFactoryV2\"\n\t */\n\t// keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\")\n\tbytes32 public constant DOMAIN_TYPEHASH = 0x8cad95687ba82c2ce50e74f7b754645e5117c3a5bec8151c0726d5857980a866;\n\n\t/**\n\t * @notice EIP-712 MintWithAuthorization struct typeHash,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\n\t */\n\t// keccak256(\"MintWithAuthorization(address contract,address to,uint256 tokenId,uint256 validAfter,uint256 validBefore,bytes32 nonce)\")\n\tbytes32 public constant MINT_WITH_AUTHORIZATION_TYPEHASH = 0x495835d970a03ff092657fca9abde67d34a0bb73a0bba258a5fa90c4ce4340f6;\n\n\t/**\n\t * @notice EIP-712 CancelAuthorization struct typeHash,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\n\t */\n\t// keccak256(\"CancelAuthorization(address authorizer,bytes32 nonce)\")\n\tbytes32 public constant CANCEL_AUTHORIZATION_TYPEHASH = 0x158b0a9edf7a828aad02f63cd515c68ef2f50ba807396f6d12842833a1597429;\n\n\t/**\n\t * @notice Enables meta transaction minting (minting with an authorization\n\t *      via an EIP712 signature)\n\t * @dev Feature FEATURE_MINTING_WITH_AUTH must be enabled in order for\n\t *      `mintWithAuthorization()` function to succeed\n\t */\n\tuint32 public constant FEATURE_MINTING_WITH_AUTH = 0x0000_0001;\n\n\t/**\n\t * @notice Factory minter is responsible for creating (minting)\n\t *      tokens to an arbitrary address\n\t * @dev Role ROLE_FACTORY_MINTER allows minting tokens\n\t *      (executing `mint` function)\n\t */\n\tuint32 public constant ROLE_FACTORY_MINTER = 0x0001_0000;\n\n\t/**\n\t * @dev Fired in mint() and mintWithAuthorization() after an NFT is minted\n\t *\n\t * @param erc721Address ERC721 contract address which was minted\n\t * @param to an address NFT was minted to\n\t * @param tokenId NFT ID which was minted\n\t */\n\tevent Minted(address indexed erc721Address, address indexed to, uint256 indexed tokenId);\n\n\t/**\n\t * @dev Fired whenever the nonce gets used (ex.: `transferWithAuthorization`, `receiveWithAuthorization`)\n\t *\n\t * @param authorizer an address which has used the nonce\n\t * @param nonce the nonce used\n\t */\n\tevent AuthorizationUsed(address indexed authorizer, bytes32 indexed nonce);\n\n\t/**\n\t * @dev Fired whenever the nonce gets cancelled (ex.: `cancelAuthorization`)\n\t *\n\t * @dev Both `AuthorizationUsed` and `AuthorizationCanceled` imply the nonce\n\t *      cannot be longer used, the only difference is that `AuthorizationCanceled`\n\t *      implies no smart contract state change made (except the nonce marked as cancelled)\n\t *\n\t * @param authorizer an address which has cancelled the nonce\n\t * @param nonce the nonce cancelled\n\t */\n\tevent AuthorizationCanceled(address indexed authorizer, bytes32 indexed nonce);\n\n\t/**\n\t * Deploys the helper contract and initializes DOMAIN_SEPARATOR using the created smart contract address\n\t *\n\t * @param _totalSupplyHardcap ERC721 total supply limit, factory stops minting the ERC721\n\t *      if its total supply (ERC721.totalSupply()) reaches the total supply had cap\n\t */\n\tconstructor(uint256 _totalSupplyHardcap) AccessControl(msg.sender) {\n\t\t// build the EIP-712 contract domain separator, see https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator\n\t\t// note: we specify contract version in its name\n\t\tDOMAIN_SEPARATOR = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(\"NFTFactoryV2\")), block.chainid, address(this)));\n\n\t\t// verify the hardcap is set\n\t\trequire(_totalSupplyHardcap != 0, \"hardcap is not set\");\n\n\t\t// set the total supply hardcap\n\t\ttotalSupplyHardcap = _totalSupplyHardcap;\n\t}\n\n\t/**\n\t * @notice Restricted access function to mint an NFT\n\t *\n\t * @dev Doesn't allow minting the token with ID zero\n\t * @dev Requires an executor to have ROLE_MINTER permission\n\t * @dev Requires target ERC721 contract to be mintable (`MintableERC721`)\n\t * @dev Requires target ERC721 contract instance to allow minting via helper\n\t *\n\t * @param _targetErc721 target ERC721 contract instance to mint token on,\n\t *      compatible with `MintableERC721`\n\t * @param _to an address to mint token to\n\t * @param _tokenId target ERC721 token ID to mint\n\t */\n\tfunction mint(address _targetErc721, address _to, uint256 _tokenId) external {\n\t\t// delegate to _mint()\n\t\t__mint(msg.sender, _targetErc721, _to, _tokenId);\n\t}\n\n\t/**\n\t * @dev Auxiliary internally used function to mint an NFT\n\t *\n\t * @dev Unsafe: doesn't verify real tx executor (msg.sender) permissions, but the permissions of\n\t *      the address specified as an executor, must be kept private at all times\n\t *\n\t * @dev Doesn't allow minting the token with ID zero\n\t * @dev Requires an executor to have ROLE_MINTER permission\n\t * @dev Requires target ERC721 contract to be mintable (`MintableERC721`)\n\t * @dev Requires target ERC721 contract instance to allow minting via helper\n\t *\n\t * @param _executor an address on which behalf the operation is executed,\n\t *      this is usually `msg.sender` but this can be different address for\n\t *      the EIP-712 like transactions (mint with authorization)\n\t * @param _targetErc721 target ERC721 contract instance to mint token on,\n\t *      compatible with `MintableERC721`\n\t * @param _to an address to mint token to\n\t * @param _tokenId target ERC721 token ID to mint\n\t */\n\tfunction __mint(address _executor, address _targetErc721, address _to, uint256 _tokenId) private {\n\t\t// verify the access permission\n\t\trequire(isOperatorInRole(_executor, ROLE_FACTORY_MINTER), \"access denied\");\n\n\t\t// verify the inputs\n\t\trequire(_targetErc721 != address(0), \"ERC721 instance addr is not set\");\n\t\trequire(_to != address(0), \"NFT receiver addr is not set\");\n\t\trequire(_tokenId != 0, \"token ID is not set\");\n\n\t\t// verify if total supply hardcap is reached\n\t\trequire(ERC721Enumerable(_targetErc721).totalSupply() < totalSupplyHardcap, \"hardcap reached\");\n\n\t\t// delegate to the target ERC721 contract\n\t\tMintableERC721(_targetErc721).safeMint(_to, _tokenId);\n\n\t\t// emit an event\n\t\temit Minted(_targetErc721, _to, _tokenId);\n\t}\n\n\t/**\n\t * @notice Executes a mint function with a signed authorization\n\t *\n\t * @param _targetErc721 target ERC721 contract instance to mint token on,\n\t *      compatible with `MintableERC721`\n\t * @param _to an address to mint token to\n\t * @param _tokenId target ERC721 token ID to mint\n\t * @param _validAfter signature valid after time (unix timestamp)\n\t * @param _validBefore signature valid before time (unix timestamp)\n\t * @param _nonce unique random nonce\n\t * @param v the recovery byte of the signature\n\t * @param r half of the ECDSA signature pair\n\t * @param s half of the ECDSA signature pair\n\t */\n\tfunction mintWithAuthorization(\n\t\taddress _targetErc721,\n\t\taddress _to,\n\t\tuint256 _tokenId,\n\t\tuint256 _validAfter,\n\t\tuint256 _validBefore,\n\t\tbytes32 _nonce,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) external {\n\t\t// ensure EIP-712 minting with authorization is enabled\n\t\trequire(isFeatureEnabled(FEATURE_MINTING_WITH_AUTH), \"minting with auth is disabled\");\n\n\t\t// derive signer of the EIP712 MintWithAuthorization message\n\t\taddress signer = __deriveSigner(\n\t\t\tabi.encode(MINT_WITH_AUTHORIZATION_TYPEHASH, _targetErc721, _to, _tokenId, _validAfter, _validBefore, _nonce),\n\t\t\tv,\n\t\t\tr,\n\t\t\ts\n\t\t);\n\n\t\t// perform message integrity and security validations\n\t\trequire(block.timestamp > _validAfter, \"signature not yet valid\");\n\t\trequire(block.timestamp < _validBefore, \"signature expired\");\n\n\t\t// use the nonce supplied (verify, mark as used, emit event)\n\t\t__useNonce(signer, _nonce, false);\n\n\t\t// delegate call to `_mint` - execute the logic required\n\t\t__mint(signer, _targetErc721, _to, _tokenId);\n\t}\n\n\t/**\n\t * @notice Returns the state of an authorization, more specifically\n\t *      if the specified nonce was already used by the address specified\n\t *\n\t * @dev Nonces are expected to be client-side randomly generated 32-byte data\n\t *      unique to the authorizer's address\n\t *\n\t * @param _authorizer Authorizer's address\n\t * @param _nonce Nonce of the authorization\n\t * @return true if the nonce is used\n\t */\n\tfunction authorizationState(\n\t\taddress _authorizer,\n\t\tbytes32 _nonce\n\t) external view returns (bool) {\n\t\t// simply return the value from the mapping\n\t\treturn usedNonces[_authorizer][_nonce];\n\t}\n\n\t/**\n\t * @notice Cancels the authorization (using EIP-712 signature)\n\t *\n\t * @param _authorizer transaction authorizer\n\t * @param _nonce unique random nonce to cancel (mark as used)\n\t * @param v the recovery byte of the signature\n\t * @param r half of the ECDSA signature pair\n\t * @param s half of the ECDSA signature pair\n\t */\n\tfunction cancelAuthorization(\n\t\taddress _authorizer,\n\t\tbytes32 _nonce,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) external {\n\t\t// derive signer of the EIP712 ReceiveWithAuthorization message\n\t\taddress signer = __deriveSigner(abi.encode(CANCEL_AUTHORIZATION_TYPEHASH, _authorizer, _nonce), v, r, s);\n\n\t\t// perform message integrity and security validations\n\t\trequire(signer == _authorizer, \"invalid signature\");\n\n\t\t// cancel the nonce supplied (verify, mark as used, emit event)\n\t\t__useNonce(_authorizer, _nonce, true);\n\t}\n\n\t/**\n\t * @notice Cancels the authorization\n\t *\n\t * @param _nonce unique random nonce to cancel (mark as used)\n\t */\n\tfunction cancelAuthorization(bytes32 _nonce) public {\n\t\t// cancel the nonce supplied (verify, mark as used, emit event)\n\t\t__useNonce(msg.sender, _nonce, true);\n\t}\n\n\t/**\n\t * @dev Auxiliary function to verify structured EIP712 message signature and derive its signer\n\t *\n\t * @param abiEncodedTypehash abi.encode of the message typehash together with all its parameters\n\t * @param v the recovery byte of the signature\n\t * @param r half of the ECDSA signature pair\n\t * @param s half of the ECDSA signature pair\n\t */\n\tfunction __deriveSigner(bytes memory abiEncodedTypehash, uint8 v, bytes32 r, bytes32 s) private view returns(address) {\n\t\t// build the EIP-712 hashStruct of the message\n\t\tbytes32 hashStruct = keccak256(abiEncodedTypehash);\n\n\t\t// calculate the EIP-712 digest \"\\x19\\x01\" ‖ domainSeparator ‖ hashStruct(message)\n\t\tbytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR, hashStruct));\n\n\t\t// recover the address which signed the message with v, r, s\n\t\taddress signer = ECDSA.recover(digest, v, r, s);\n\n\t\t// return the signer address derived from the signature\n\t\treturn signer;\n\t}\n\n\t/**\n\t * @dev Auxiliary function to use/cancel the nonce supplied for a given authorizer:\n\t *      1. Verifies the nonce was not used before\n\t *      2. Marks the nonce as used\n\t *      3. Emits an event that the nonce was used/cancelled\n\t *\n\t * @dev Set `_cancellation` to false (default) to use nonce,\n\t *      set `_cancellation` to true to cancel nonce\n\t *\n\t * @dev It is expected that the nonce supplied is a randomly\n\t *      generated uint256 generated by the client\n\t *\n\t * @param _authorizer an address to use/cancel nonce for\n\t * @param _nonce random nonce to use\n\t * @param _cancellation true to emit `AuthorizationCancelled`, false to emit `AuthorizationUsed` event\n\t */\n\tfunction __useNonce(address _authorizer, bytes32 _nonce, bool _cancellation) private {\n\t\t// verify nonce was not used before\n\t\trequire(!usedNonces[_authorizer][_nonce], \"invalid nonce\");\n\n\t\t// update the nonce state to \"used\" for that particular signer to avoid replay attack\n\t\tusedNonces[_authorizer][_nonce] = true;\n\n\t\t// depending on the usage type (use/cancel)\n\t\tif(_cancellation) {\n\t\t\t// emit an event regarding the nonce cancelled\n\t\t\temit AuthorizationCanceled(_authorizer, _nonce);\n\t\t}\n\t\telse {\n\t\t\t// emit an event regarding the nonce used\n\t\t\temit AuthorizationUsed(_authorizer, _nonce);\n\t\t}\n\t}\n}\n"
    },
    "contracts/protocol/NFTFactoryV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ERC721Spec.sol\";\nimport \"../interfaces/ERC721SpecExt.sol\";\nimport \"../utils/AccessControl.sol\";\nimport \"../lib/ECDSA.sol\";\n\n/**\n * @title Alethea NFT Factory\n *\n * @notice NFT Factory is a helper smart contract responsible for minting arbitrary NFTs\n *\n * @notice It supports two mechanisms:\n *\t  - minting delegation: authorized address executes mint function on the helper,\n *\t\tand helper executes minting function on the target ERC721 contract as an internal transaction\n *\t  - meta transaction minting or minting with an authorization: authorized address signs\n *\t\tthe minting authorization message and any address executes mint function on the helper\n *\n * @notice Second mechanism allows to shift the gas costs for the transaction to any address\n *\t  (usually this is the NFT beneficiary - an address which receives an NFT)\n *\n * @dev The signature is constructed via EIP-712 similar to EIP-2612, or EIP-3009\n *\n * @dev Target ERC721 contract(s) must allow helper to mint the tokens, this should be configured\n *\t  as part of the deployment or setup processes\n *\n * @dev Version 3 (NFTFactoryV3) adds total mint limiting feature allowing to set the NFT total\n *\t mint hardcap; factory stops minting when total mint of the contract reaches the hardcap\n */\ncontract NFTFactoryV3 is AccessControl {\n\t/**\n\t * @dev Number of ERC721 token been minted by NFTFactoryV3\n\t */\n\tuint256 public totalMinted;\n\t\n\t/**\n\t * @notice Total Mint Hardcap affects factory capability to mint: once\n\t *\t  factory total mint reaches the hardcap, factory stops minting it\n\t *\n\t * @dev The factory `mint` and `mintWithAuthorization` function throws\n\t *\t  if factory `totalMinted` value is equal or bigger than `totalMintHardcap`\n\t */\n\tuint256 public totalMintHardcap;\n\n\t/**\n\t * @dev A record of used nonces for EIP-712 transactions\n\t *\n\t * @dev A record of used nonces for signing/validating signatures\n\t *\t  in `mintWithAuthorization` for every mint\n\t *\n\t * @dev Maps authorizer address => nonce => true/false (used unused)\n\t */\n\tmapping(address => mapping(bytes32 => bool)) private usedNonces;\n\n\t/**\n\t * @notice Calculates the EIP-712 contract's domain separator,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator\n\t *\n\t * @dev Note: the name of the function and its location is a source code is against\n\t *      Solidity coding styles. This is intentional to maintain backwards compatibility\n\t *      with earlier versions of the contract and with other contract already deployed\n\t *      into mainnet.\n\t *\n\t * @return EIP-712 contract's domain separator\n\t */\n\tfunction DOMAIN_SEPARATOR() public view returns (bytes32) {\n\t\t// build the EIP-712 contract domain separator, see https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator\n\t\t// note: we specify contract version in its name\n\t\treturn keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(\"NFTFactoryV3\")), block.chainid, address(this)));\n\t}\n\n\t/**\n\t * @notice EIP-712 contract's domain typeHash,\n\t *\t  see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\n\t *\n\t * @dev Note: we do not include version into the domain typehash/separator,\n\t *\t  it is implied version is concatenated to the name field, like \"NFTFactoryV2\"\n\t */\n\t// keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\")\n\tbytes32 public constant DOMAIN_TYPEHASH = 0x8cad95687ba82c2ce50e74f7b754645e5117c3a5bec8151c0726d5857980a866;\n\n\t/**\n\t * @notice EIP-712 MintWithAuthorization struct typeHash,\n\t *\t  see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\n\t */\n\t// keccak256(\"MintWithAuthorization(address contract,address to,uint256 tokenId,uint256 validAfter,uint256 validBefore,bytes32 nonce)\")\n\tbytes32 public constant MINT_WITH_AUTHORIZATION_TYPEHASH = 0x495835d970a03ff092657fca9abde67d34a0bb73a0bba258a5fa90c4ce4340f6;\n\n\t/**\n\t * @notice EIP-712 CancelAuthorization struct typeHash,\n\t *\t  see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\n\t */\n\t// keccak256(\"CancelAuthorization(address authorizer,bytes32 nonce)\")\n\tbytes32 public constant CANCEL_AUTHORIZATION_TYPEHASH = 0x158b0a9edf7a828aad02f63cd515c68ef2f50ba807396f6d12842833a1597429;\n\n\t/**\n\t * @notice Enables meta transaction minting (minting with an authorization\n\t *\t  via an EIP712 signature)\n\t * @dev Feature FEATURE_MINTING_WITH_AUTH must be enabled in order for\n\t *\t  `mintWithAuthorization()` function to succeed\n\t */\n\tuint32 public constant FEATURE_MINTING_WITH_AUTH = 0x0000_0001;\n\n\t/**\n\t * @notice Factory minter is responsible for creating (minting)\n\t *\t  tokens to an arbitrary address\n\t * @dev Role ROLE_FACTORY_MINTER allows minting tokens\n\t *\t  (executing `mint` function)\n\t */\n\tuint32 public constant ROLE_FACTORY_MINTER = 0x0001_0000;\n\n\t/**\n\t * @notice Mint hardcap manager is responsible for updating\n\t *\t  NFTFactoryV3 total mint hardcap\n\t *\n\t * @dev Role ROLE_MINT_HARDCAP_MANAGER allows updating total mint hardcap\n\t *\t  (executing `updateTotalMintHardcap` function)\n\t */\n\tuint32 public constant ROLE_MINT_HARDCAP_MANAGER = 0x0002_0000;\n\n\t/**\n\t * @dev Fired whenever total mint hardcap is updated (ex.: `updateTotalMintHardcap`)\n\t *\n\t * @param authorizer an address which has updated total mint hardcap\n\t * @param oldLimit old total mint hardcap\n\t * @param newLimit new total mint hardcap\n\t */\n\tevent TotalMintHardcapUpdated(address indexed authorizer, uint256 oldLimit, uint256 newLimit);\n\n\t/**\n\t * @dev Fired in mint() and mintWithAuthorization() after an NFT is minted\n\t *\n\t * @param erc721Address ERC721 contract address which was minted\n\t * @param to an address NFT was minted to\n\t * @param tokenId NFT ID which was minted\n\t */\n\tevent Minted(address indexed erc721Address, address indexed to, uint256 indexed tokenId);\n\n\t/**\n\t * @dev Fired whenever the nonce gets used (ex.: `transferWithAuthorization`, `receiveWithAuthorization`)\n\t *\n\t * @param authorizer an address which has used the nonce\n\t * @param nonce the nonce used\n\t */\n\tevent AuthorizationUsed(address indexed authorizer, bytes32 indexed nonce);\n\n\t/**\n\t * @dev Fired whenever the nonce gets cancelled (ex.: `cancelAuthorization`)\n\t *\n\t * @dev Both `AuthorizationUsed` and `AuthorizationCanceled` imply the nonce\n\t *\t  cannot be longer used, the only difference is that `AuthorizationCanceled`\n\t *\t  implies no smart contract state change made (except the nonce marked as cancelled)\n\t *\n\t * @param authorizer an address which has cancelled the nonce\n\t * @param nonce the nonce cancelled\n\t */\n\tevent AuthorizationCanceled(address indexed authorizer, bytes32 indexed nonce);\n\n\t/**\n\t * Deploys the helper contract and initializes DOMAIN_SEPARATOR using the created smart contract address\n\t *\n\t * @param _totalMintHardcap NFTFactoryV3 total mint limit, factory stops minting the ERC721\n\t *\t  if its total mint (totalMinted()) reaches the total mint hardcap (totalMintHardcap())\n\t */\n\tconstructor(uint256 _totalMintHardcap) AccessControl(msg.sender) {\n\t\t// verify the hardcap is set\n\t\trequire(_totalMintHardcap != 0, \"hardcap is not set\");\n\n\t\t// set the total supply hardcap\n\t\ttotalMintHardcap = _totalMintHardcap;\n\t}\n\n\t/**\n\t * @notice Updates total mint hardcap of NFTFactoryV3 contract.\n\t *\n\t * @dev Requires transaction sender to have `ROLE_MINT_HARDCAP_MANAGER` permission\n\t *\n\t * @param _totalMintHardcap new NFTFactoryV3 total mint hardcap\n\t */\n\tfunction updateTotalMintHardcap(uint256 _totalMintHardcap) public {\n\t\t// caller must have a permission to update total mint hardcap\n\t\trequire(isSenderInRole(ROLE_MINT_HARDCAP_MANAGER), \"access denied\");\n\n\t\t// emit an event\n\t\temit TotalMintHardcapUpdated(msg.sender, totalMintHardcap, _totalMintHardcap);\n\n\t\t// update total mint hardcap\n\t\ttotalMintHardcap = _totalMintHardcap;\n\t}\n\n\t/**\n\t * @notice Restricted access function to mint an NFT\n\t *\n\t * @dev Doesn't allow minting the token with ID zero\n\t * @dev Requires an executor to have ROLE_MINTER permission\n\t * @dev Requires target ERC721 contract to be mintable (`MintableERC721`)\n\t * @dev Requires target ERC721 contract instance to allow minting via helper\n\t *\n\t * @param _targetErc721 target ERC721 contract instance to mint token on,\n\t *\t  compatible with `MintableERC721`\n\t * @param _to an address to mint token to\n\t * @param _tokenId target ERC721 token ID to mint\n\t */\n\tfunction mint(address _targetErc721, address _to, uint256 _tokenId) external {\n\t\t// delegate to _mint()\n\t\t__mint(msg.sender, _targetErc721, _to, _tokenId);\n\t}\n\n\t/**\n\t * @dev Auxiliary internally used function to mint an NFT\n\t *\n\t * @dev Unsafe: doesn't verify real tx executor (msg.sender) permissions, but the permissions of\n\t *\t  the address specified as an executor, must be kept private at all times\n\t *\n\t * @dev Doesn't allow minting the token with ID zero\n\t * @dev Requires an executor to have ROLE_MINTER permission\n\t * @dev Requires target ERC721 contract to be mintable (`MintableERC721`)\n\t * @dev Requires target ERC721 contract instance to allow minting via helper\n\t *\n\t * @param _executor an address on which behalf the operation is executed,\n\t *\t  this is usually `msg.sender` but this can be different address for\n\t *\t  the EIP-712 like transactions (mint with authorization)\n\t * @param _targetErc721 target ERC721 contract instance to mint token on,\n\t *\t  compatible with `MintableERC721`\n\t * @param _to an address to mint token to\n\t * @param _tokenId target ERC721 token ID to mint\n\t */\n\tfunction __mint(address _executor, address _targetErc721, address _to, uint256 _tokenId) private {\n\t\t// verify the access permission\n\t\trequire(isOperatorInRole(_executor, ROLE_FACTORY_MINTER), \"access denied\");\n\n\t\t// verify the inputs\n\t\trequire(_targetErc721 != address(0), \"ERC721 instance addr is not set\");\n\t\trequire(_to != address(0), \"NFT receiver addr is not set\");\n\t\trequire(_tokenId != 0, \"token ID is not set\");\n\n\t\t// verify if total mint hardcap is reached\n\t\trequire(totalMinted < totalMintHardcap, \"hardcap reached\");\n\n\t\t// increase total mint counter\n\t\ttotalMinted++;\n\n\t\t// delegate to the target ERC721 contract\n\t\tMintableERC721(_targetErc721).safeMint(_to, _tokenId);\n\n\t\t// emit an event\n\t\temit Minted(_targetErc721, _to, _tokenId);\n\t}\n\n\t/**\n\t * @notice Executes a mint function with a signed authorization\n\t *\n\t * @param _targetErc721 target ERC721 contract instance to mint token on,\n\t *\t  compatible with `MintableERC721`\n\t * @param _to an address to mint token to\n\t * @param _tokenId target ERC721 token ID to mint\n\t * @param _validAfter signature valid after time (unix timestamp)\n\t * @param _validBefore signature valid before time (unix timestamp)\n\t * @param _nonce unique random nonce\n\t * @param v the recovery byte of the signature\n\t * @param r half of the ECDSA signature pair\n\t * @param s half of the ECDSA signature pair\n\t */\n\tfunction mintWithAuthorization(\n\t\taddress _targetErc721,\n\t\taddress _to,\n\t\tuint256 _tokenId,\n\t\tuint256 _validAfter,\n\t\tuint256 _validBefore,\n\t\tbytes32 _nonce,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) external {\n\t\t// ensure EIP-712 minting with authorization is enabled\n\t\trequire(isFeatureEnabled(FEATURE_MINTING_WITH_AUTH), \"minting with auth is disabled\");\n\n\t\t// perform message integrity and security validations\n\t\trequire(block.timestamp > _validAfter, \"signature not yet valid\");\n\t\trequire(block.timestamp < _validBefore, \"signature expired\");\n\n\t\t// derive signer of the EIP712 MintWithAuthorization message\n\t\taddress signer = __deriveSigner(\n\t\t\tabi.encode(MINT_WITH_AUTHORIZATION_TYPEHASH, _targetErc721, _to, _tokenId, _validAfter, _validBefore, _nonce),\n\t\t\tv,\n\t\t\tr,\n\t\t\ts\n\t\t);\n\n\t\t// use the nonce supplied (verify, mark as used, emit event)\n\t\t__useNonce(signer, _nonce, false);\n\n\t\t// delegate call to `_mint` - execute the logic required\n\t\t__mint(signer, _targetErc721, _to, _tokenId);\n\t}\n\n\t/**\n\t * @notice Returns the state of an authorization, more specifically\n\t *\t  if the specified nonce was already used by the address specified\n\t *\n\t * @dev Nonces are expected to be client-side randomly generated 32-byte data\n\t *\t  unique to the authorizer's address\n\t *\n\t * @param _authorizer Authorizer's address\n\t * @param _nonce Nonce of the authorization\n\t * @return true if the nonce is used\n\t */\n\tfunction authorizationState(\n\t\taddress _authorizer,\n\t\tbytes32 _nonce\n\t) external view returns (bool) {\n\t\t// simply return the value from the mapping\n\t\treturn usedNonces[_authorizer][_nonce];\n\t}\n\n\t/**\n\t * @notice Cancels the authorization (using EIP-712 signature)\n\t *\n\t * @param _authorizer transaction authorizer\n\t * @param _nonce unique random nonce to cancel (mark as used)\n\t * @param v the recovery byte of the signature\n\t * @param r half of the ECDSA signature pair\n\t * @param s half of the ECDSA signature pair\n\t */\n\tfunction cancelAuthorization(\n\t\taddress _authorizer,\n\t\tbytes32 _nonce,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) external {\n\t\t// derive signer of the EIP712 ReceiveWithAuthorization message\n\t\taddress signer = __deriveSigner(abi.encode(CANCEL_AUTHORIZATION_TYPEHASH, _authorizer, _nonce), v, r, s);\n\n\t\t// perform message integrity and security validations\n\t\trequire(signer == _authorizer, \"invalid signature\");\n\n\t\t// cancel the nonce supplied (verify, mark as used, emit event)\n\t\t__useNonce(_authorizer, _nonce, true);\n\t}\n\n\t/**\n\t * @notice Cancels the authorization\n\t *\n\t * @param _nonce unique random nonce to cancel (mark as used)\n\t */\n\tfunction cancelAuthorization(bytes32 _nonce) public {\n\t\t// cancel the nonce supplied (verify, mark as used, emit event)\n\t\t__useNonce(msg.sender, _nonce, true);\n\t}\n\n\t/**\n\t * @dev Auxiliary function to verify structured EIP712 message signature and derive its signer\n\t *\n\t * @param abiEncodedTypehash abi.encode of the message typehash together with all its parameters\n\t * @param v the recovery byte of the signature\n\t * @param r half of the ECDSA signature pair\n\t * @param s half of the ECDSA signature pair\n\t */\n\tfunction __deriveSigner(bytes memory abiEncodedTypehash, uint8 v, bytes32 r, bytes32 s) private view returns(address) {\n\t\t// build the EIP-712 hashStruct of the message\n\t\tbytes32 hashStruct = keccak256(abiEncodedTypehash);\n\n\t\t// calculate the EIP-712 digest \"\\x19\\x01\" ‖ domainSeparator ‖ hashStruct(message)\n\t\tbytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR(), hashStruct));\n\n\t\t// recover the address which signed the message with v, r, s\n\t\taddress signer = ECDSA.recover(digest, v, r, s);\n\n\t\t// check if the signer address is valid\n\t\t// according to EIP3009 spec, zero address must be rejected when using ecrecover\n\t\trequire(signer != address(0), \"invalid signature\");\n\n\t\t// return the signer address derived from the signature\n\t\treturn signer;\n\t}\n\n\t/**\n\t * @dev Auxiliary function to use/cancel the nonce supplied for a given authorizer:\n\t *\t  1. Verifies the nonce was not used before\n\t *\t  2. Marks the nonce as used\n\t *\t  3. Emits an event that the nonce was used/cancelled\n\t *\n\t * @dev Set `_cancellation` to false (default) to use nonce,\n\t *\t  set `_cancellation` to true to cancel nonce\n\t *\n\t * @dev It is expected that the nonce supplied is a randomly\n\t *\t  generated uint256 generated by the client\n\t *\n\t * @param _authorizer an address to use/cancel nonce for\n\t * @param _nonce random nonce to use\n\t * @param _cancellation true to emit `AuthorizationCancelled`, false to emit `AuthorizationUsed` event\n\t */\n\tfunction __useNonce(address _authorizer, bytes32 _nonce, bool _cancellation) private {\n\t\t// verify nonce was not used before\n\t\trequire(!usedNonces[_authorizer][_nonce], \"invalid nonce\");\n\n\t\t// update the nonce state to \"used\" for that particular signer to avoid replay attack\n\t\tusedNonces[_authorizer][_nonce] = true;\n\n\t\t// depending on the usage type (use/cancel)\n\t\tif(_cancellation) {\n\t\t\t// emit an event regarding the nonce cancelled\n\t\t\temit AuthorizationCanceled(_authorizer, _nonce);\n\t\t}\n\t\telse {\n\t\t\t// emit an event regarding the nonce used\n\t\t\temit AuthorizationUsed(_authorizer, _nonce);\n\t\t}\n\t}\n}\n"
    },
    "contracts/protocol/NFTStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ERC20Spec.sol\";\nimport \"../interfaces/ERC721Spec.sol\";\nimport \"../utils/AccessControl.sol\";\n\n/**\n * @title NFT Staking\n *\n * @notice Enables NFT staking for a given NFT smart contract defined on deployment\n *\n * @notice Doesn't introduce any rewards, just tracks the stake/unstake dates for each\n *      token/owner, this data will be used later on to process the rewards\n */\ncontract NFTStaking is AccessControl {\n\t/**\n\t * @dev Main staking data structure keeping track of a stake,\n\t *      used in `tokenStakes` array mapping\n\t */\n\tstruct StakeData {\n\t\t/**\n\t\t * @dev Who owned and staked the token, who will be the token\n\t\t *      returned to once unstaked\n\t\t */\n\t\taddress owner;\n\n\t\t/**\n\t\t * @dev When the token was staked and transferred from the owner,\n\t\t *      unix timestamp\n\t\t */\n\t\tuint32 stakedOn;\n\n\t\t/**\n\t\t * @dev When token was unstaked and returned back to the owner,\n\t\t *      unix timestamp\n\t\t * @dev Zero value means the token is still staked\n\t\t */\n\t\tuint32 unstakedOn;\n\t}\n\n\t/**\n\t * @dev Auxiliary data structure to help iterate over NFT owner stakes,\n\t *      used in `userStakes` array mapping\n\t */\n\tstruct StakeIndex {\n\t\t/**\n\t\t * @dev Staked token ID\n\t\t */\n\t\tuint32 tokenId;\n\n\t\t/**\n\t\t * @dev Where to look for main staking data `StakeData`\n\t\t *      in `tokenStakes` array mapping\n\t\t */\n\t\tuint32 index;\n\t}\n\n\t/**\n\t * @dev NFT smart contract to stake/unstake tokens of\n\t */\n\taddress public immutable targetContract;\n\n\t/**\n\t * @notice For each token ID stores the history of its stakes,\n\t *      last element of the history may be \"open\" (unstakedOn = 0),\n\t *      meaning the token is still staked and is ot be returned to the `owner`\n\t *\n\t * @dev Maps token ID => StakeData[]\n\t */\n\tmapping(uint32 => StakeData[]) public tokenStakes;\n\n\t/**\n\t * @notice For each owner address stores the links to its stakes,\n\t *      the link is represented as StakeIndex data struct\n\t *\n\t * @dev Maps owner address => StakeIndex[]\n\t */\n\tmapping(address => StakeIndex[]) public userStakes;\n\n\t/**\n\t * @dev Enables staking, stake(), stakeBatch()\n\t */\n\tuint32 public constant FEATURE_STAKING = 0x0000_0001;\n\n\t/**\n\t * @dev Enables unstaking, unstake(), unstakeBatch()\n\t */\n\tuint32 public constant FEATURE_UNSTAKING = 0x0000_0002;\n\n\t/**\n\t * @notice People do mistake and may send tokens by mistake; since\n\t *      staking contract is not designed to accept the tokens directly,\n\t *      it allows the rescue manager to \"rescue\" such lost tokens\n\t *\n\t * @notice Rescue manager is responsible for \"rescuing\" ERC20/ERC721 tokens\n\t *      accidentally sent to the smart contract\n\t *\n\t * @dev Role ROLE_RESCUE_MANAGER allows withdrawing non-staked ERC20/ERC721\n\t *      tokens stored on the smart contract balance\n\t */\n\tuint32 public constant ROLE_RESCUE_MANAGER = 0x0001_0000;\n\n\t/**\n\t * @dev Fired in stake(), stakeBatch()\n\t *\n\t * @param _by token owner, tx executor\n\t * @param _tokenId token ID staked and transferred into the smart contract\n\t * @param _when unix timestamp of when staking happened\n\t */\n\tevent Staked(address indexed _by, uint32 indexed _tokenId, uint32 _when);\n\n\t/**\n\t * @dev Fired in unstake(), unstakeBatch()\n\t *\n\t * @param _by token owner, tx executor\n\t * @param _tokenId token ID unstaked and transferred back to owner\n\t * @param _when unix timestamp of when unstaking happened\n\t */\n\tevent Unstaked(address indexed _by, uint32 indexed _tokenId, uint32 _when);\n\n\t/**\n\t * @dev Creates/deploys NFT staking contract bound to the already deployed\n\t *      target NFT ERC721 smart contract to be staked\n\t *\n\t * @param _nft address of the deployed NFT smart contract instance\n\t */\n\tconstructor(address _nft) AccessControl(msg.sender) {\n\t\t// verify input is set\n\t\trequire(_nft != address(0), \"target contract is not set\");\n\n\t\t// verify input is valid smart contract of the expected interface\n\t\trequire(ERC165(_nft).supportsInterface(type(ERC721).interfaceId), \"unexpected target type\");\n\n\t\t// setup smart contract internal state\n\t\ttargetContract = _nft;\n\t}\n\n\t/**\n\t * @notice How many times a particular token was staked\n\t *\n\t * @dev Used to iterate `tokenStakes(tokenId, i)`, `i < numStakes(tokenId)`\n\t *\n\t * @param tokenId token ID to query number of times staked for\n\t * @return number of times token was staked\n\t */\n\tfunction numStakes(uint32 tokenId) public view returns(uint256) {\n\t\t// just read the array length and return it\n\t\treturn tokenStakes[tokenId].length;\n\t}\n\n\t/**\n\t * @notice How many stakes a particular address has done\n\t *\n\t * @dev Used to iterate `userStakes(owner, i)`, `i < numStakes(owner)`\n\t *\n\t * @param owner an address to query number of times it staked\n\t * @return number of times a particular address has staked\n\t */\n\tfunction numStakes(address owner) public view returns(uint256) {\n\t\t// just read the array length and return it\n\t\treturn userStakes[owner].length;\n\t}\n\n\t/**\n\t * @notice Determines if the token is currently staked or not\n\t *\n\t * @param tokenId token ID to check state for\n\t * @return true if token is staked, false otherwise\n\t */\n\tfunction isStaked(uint32 tokenId) public view returns(bool) {\n\t\t// get an idea of current stakes for the token\n\t\tuint256 n = tokenStakes[tokenId].length;\n\n\t\t// evaluate based on the last stake element in the array\n\t\treturn n > 0 && tokenStakes[tokenId][n - 1].unstakedOn == 0;\n\t}\n\n\t/**\n\t * @notice Stakes the NFT; the token is transferred from its owner to the staking contract;\n\t *      token must be owned by the tx executor and be transferable by staking contract\n\t *\n\t * @param tokenId token ID to stake\n\t */\n\tfunction stake(uint32 tokenId) public {\n\t\t// verify staking is enabled\n\t\trequire(isFeatureEnabled(FEATURE_STAKING), \"staking is disabled\");\n\n\t\t// get an idea of current stakes for the token\n\t\tuint256 n = tokenStakes[tokenId].length;\n\n\t\t// verify the token is not currently staked\n\t\trequire(n == 0 || tokenStakes[tokenId][n - 1].unstakedOn != 0, \"already staked\");\n\n\t\t// verify token belongs to the address which executes staking\n\t\trequire(ERC721(targetContract).ownerOf(tokenId) == msg.sender, \"access denied\");\n\n\t\t// transfer the token from owner into the staking contract\n\t\tERC721(targetContract).transferFrom(msg.sender, address(this), tokenId);\n\n\t\t// current timestamp to be set as `stakedOn`\n\t\tuint32 stakedOn = now32();\n\n\t\t// save token stake data\n\t\ttokenStakes[tokenId].push(StakeData({\n\t\t\towner: msg.sender,\n\t\t\tstakedOn: stakedOn,\n\t\t\tunstakedOn: 0\n\t\t}));\n\n\t\t// save token stake index\n\t\tuserStakes[msg.sender].push(StakeIndex({\n\t\t\ttokenId: tokenId,\n\t\t\tindex: uint32(n)\n\t\t}));\n\n\t\t// emit an event\n\t\temit Staked(msg.sender, tokenId, stakedOn);\n\t}\n\n\t/**\n\t * @notice Stakes several NFTs; tokens are transferred from their owner to the staking contract;\n\t *      tokens must be owned by the tx executor and be transferable by staking contract\n\t *\n\t * @param tokenIds token IDs to stake\n\t */\n\tfunction stakeBatch(uint32[] memory tokenIds) public {\n\t\t// iterate the collection passed\n\t\tfor(uint256 i = 0; i < tokenIds.length; i++) {\n\t\t\t// and stake each token one by one\n\t\t\tstake(tokenIds[i]);\n\t\t}\n\t}\n\n\t/**\n\t * @notice Unstakes the NFT; the token is transferred from staking contract back\n\t *      its previous owner\n\t *\n\t * @param tokenId token ID to unstake\n\t */\n\tfunction unstake(uint32 tokenId) public {\n\t\t// verify staking is enabled\n\t\trequire(isFeatureEnabled(FEATURE_UNSTAKING), \"unstaking is disabled\");\n\n\t\t// get an idea of current stakes for the token\n\t\tuint256 n = tokenStakes[tokenId].length;\n\n\t\t// verify the token is currently staked\n\t\trequire(n != 0, \"not staked\");\n\t\trequire(tokenStakes[tokenId][n - 1].unstakedOn == 0, \"already unstaked\");\n\n\t\t// verify token belongs to the address which executes unstaking\n\t\trequire(tokenStakes[tokenId][n - 1].owner == msg.sender, \"access denied\");\n\n\t\t// current timestamp to be set as `unstakedOn`\n\t\tuint32 unstakedOn = now32();\n\n\t\t// update token stake data\n\t\ttokenStakes[tokenId][n - 1].unstakedOn = unstakedOn;\n\n\t\t// transfer the token back to owner\n\t\tERC721(targetContract).transferFrom(address(this), msg.sender, tokenId);\n\n\t\t// emit an event\n\t\temit Unstaked(msg.sender, tokenId, unstakedOn);\n\t}\n\n\t/**\n\t * @notice Unstakes several NFTs; tokens are transferred from staking contract back\n\t *      their previous owner\n\t *\n\t * @param tokenIds token IDs to unstake\n\t */\n\tfunction unstakeBatch(uint32[] memory tokenIds) public {\n\t\t// iterate the collection passed\n\t\tfor(uint256 i = 0; i < tokenIds.length; i++) {\n\t\t\t// and unstake each token one by one\n\t\t\tunstake(tokenIds[i]);\n\t\t}\n\t}\n\n\t/**\n\t * @dev Restricted access function to rescue accidentally sent ERC20 tokens,\n\t *      the tokens are rescued via `transfer` function call on the\n\t *      contract address specified and with the parameters specified:\n\t *      `_contract.transfer(_to, _value)`\n\t *\n\t * @dev Requires executor to have `ROLE_RESCUE_MANAGER` permission\n\t *\n\t * @param _contract smart contract address to execute `transfer` function on\n\t * @param _to to address in `transfer(_to, _value)`\n\t * @param _value value to transfer in `transfer(_to, _value)`\n\t */\n\tfunction rescueErc20(address _contract, address _to, uint256 _value) public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_RESCUE_MANAGER), \"access denied\");\n\n\t\t// perform the transfer as requested, without any checks\n\t\tERC20(_contract).transfer(_to, _value);\n\t}\n\n\t/**\n\t * @dev Restricted access function to rescue accidentally sent ERC721 tokens,\n\t *      the tokens are rescued via `transferFrom` function call on the\n\t *      contract address specified and with the parameters specified:\n\t *      `_contract.transferFrom(this, _to, _tokenId)`\n\t *\n\t * @dev Requires executor to have `ROLE_RESCUE_MANAGER` permission\n\t *\n\t * @param _contract smart contract address to execute `transferFrom` function on\n\t * @param _to to address in `transferFrom(this, _to, _tokenId)`\n\t * @param _tokenId token ID to transfer in `transferFrom(this, _to, _tokenId)`\n\t */\n\tfunction rescueErc721(address _contract, address _to, uint256 _tokenId) public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_RESCUE_MANAGER), \"access denied\");\n\n\t\t// verify the NFT is not staked\n\t\trequire(_contract != targetContract || !isStaked(uint32(_tokenId)), \"token is staked\");\n\n\t\t// perform the transfer as requested, without any checks\n\t\tERC721(_contract).transferFrom(address(this), _to, _tokenId);\n\t}\n\n\t/**\n\t * @dev Testing time-dependent functionality may be difficult;\n\t *      we override time in the helper test smart contract (mock)\n\t *\n\t * @return `block.timestamp` in mainnet, custom values in testnets (if overridden)\n\t */\n\tfunction now32() public view virtual returns (uint32) {\n\t\t// return current block timestamp\n\t\treturn uint32(block.timestamp);\n\t}\n}\n"
    },
    "contracts/protocol/OpenSeaFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ERC165Spec.sol\";\nimport \"../interfaces/ERC721Spec.sol\";\nimport \"../interfaces/ERC721SpecExt.sol\";\nimport \"../lib/StringUtils.sol\";\nimport \"../utils/AccessControl.sol\";\n\n/**\n * @title OpenSea ERC721 Factory interface\n *\n * @notice In order to mint items only when they're purchased, OpenSea provides a Factory interface\n *      that is used to define how the items will be minted.\n *      See https://docs.opensea.io/docs/2-custom-item-sale-contract\n *\n * @notice This is a generic factory contract that can be used to mint tokens. The configuration\n *      for minting is specified by an _optionId, which can be used to delineate various\n *      ways of minting.\n *\n * @dev Copy of the OpenSea interface:\n *      https://github.com/ProjectOpenSea/opensea-creatures/blob/master/contracts/IFactoryERC721.sol\n */\ninterface OpenSeaFactoryERC721 is ERC165 {\n\t/**\n\t * @dev Returns the name of this factory.\n\t */\n\tfunction name() external view returns (string memory);\n\n\t/**\n\t * @dev Returns the symbol for this factory.\n\t */\n\tfunction symbol() external view returns (string memory);\n\n\t/**\n\t * @dev Number of options the factory supports.\n\t */\n\tfunction numOptions() external view returns (uint256);\n\n\t/**\n\t * @dev Returns whether the option ID can be minted. Can return false if the developer wishes to\n\t *      restrict a total supply per option ID (or overall).\n\t */\n\tfunction canMint(uint256 _optionId) external view returns (bool);\n\n\t/**\n\t * @dev Returns a URL specifying some metadata about the option. This metadata can be of the\n\t *      same structure as the ERC721 metadata.\n\t */\n\tfunction tokenURI(uint256 _optionId) external view returns (string memory);\n\n\t/**\n\t * @dev Indicates that this is a factory contract. Ideally would use EIP 165 supportsInterface()\n\t */\n\tfunction supportsFactoryInterface() external view returns (bool);\n\n\t/**\n\t * @dev Mints asset(s) in accordance to a specific address with a particular \"option\". This should be\n\t *      callable only by the contract owner or the owner's Wyvern Proxy (later universal login will solve this).\n\t *      Options should also be delineated 0 - (numOptions() - 1) for convenient indexing.\n\t * @param _optionId the option id\n\t * @param _toAddress address of the future owner of the asset(s)\n\t */\n\tfunction mint(uint256 _optionId, address _toAddress) external;\n}\n\n/**\n * @dev An OpenSea delegate proxy interface which we use in ProxyRegistry.\n *      We use it to give compiler a hint that ProxyRegistry.proxies() needs to be\n *      converted to the address type explicitly\n */\ninterface OwnableDelegateProxy {}\n\n/**\n * @dev OpenSea Proxy Registry determines which address (wrapped as OwnableDelegateProxy)\n *      is allowed to mint an option at any given time\n * @dev OpenSea takes care to set it properly when an option is being bought\n */\ninterface ProxyRegistry {\n\t/**\n\t * @dev Maps owner address => eligible option minter address wrapped as OwnableDelegateProxy\n\t */\n\tfunction proxies(address) external view returns(OwnableDelegateProxy);\n}\n\n/**\n * @title OpenSea ERC721 Factory implementation\n *\n * @notice OpenSea Factory interface implementation, NFT minter contract,\n *      powers the OpenSea sale of the 9,900 personalities of the 10k sale campaign\n *\n * @dev Links to PersonalityPodERC721 smart contract on deployment, allows OpenSea to mint\n *      PersonalityPodERC721 from 101 to 10,000 (both bounds inclusive)\n *\n * @dev Each OpenSea Factory option ID is used to signify the minting of one random type of\n *      Personality Pod\n */\ncontract OpenSeaFactoryImpl is OpenSeaFactoryERC721, AccessControl {\n\t/**\n\t * @dev OpenSea expects Factory to be \"Ownable\", that is having an \"owner\",\n\t *      we introduce a fake \"owner\" here with no authority\n\t */\n\taddress public owner;\n\n\t/**\n\t * @dev NFT ERC721 contract address to mint NFTs from and bind to iNFTs created\n\t */\n\taddress public immutable nftContract;\n\n\t/**\n\t * @dev OpenSea Proxy Registry determines which address is allowed to mint\n\t *      an option at any given time\n\t * @dev OpenSea takes care to set it to the NFT buyer address when they buy an option\n\t */\n\taddress public immutable proxyRegistry;\n\n\t/**\n\t * @dev Number of options the factory supports,\n\t *      options start from zero and end at `options` (exclusive)\n\t */\n\tuint32 private options;\n\n\t/**\n\t * @dev Base URI is used to construct option URI as\n\t *      `base URI + option ID`\n\t *\n\t * @dev For example, if base URI is https://api.com/option/, then option #1\n\t *      will have an URI https://api.com/option/1\n\t */\n\tstring public baseURI = \"\";\n\n\t/**\n\t * @dev Initialized with the tokenId each optionId should start minting from,\n\t *      incremented each time the option is minted\n\t *\n\t * @dev For each option, [currentTokenId[optionId], tokenIdUpperBound[optionId])\n\t *      is the range of token IDs left to be minted\n\t *\n\t * @dev Maps optionId => next available (current) token ID for an option\n\t */\n\tmapping(uint256 => uint256) public currentTokenId;\n\n\t/**\n\t * @dev At what tokenId each optionId should end minting at (exclusive)\n\t *\n\t * @dev For each option, [currentTokenId[optionId], tokenIdUpperBound[optionId])\n\t *      is the range of token IDs left to be minted\n\t *\n\t * @dev Maps optionId => final token ID (exclusive) for an option\n\t */\n\tmapping(uint256 => uint256) public tokenIdUpperBound;\n\n\t/**\n\t * @notice Minter is responsible for creating (minting) iNFTs\n\t *\n\t * @dev Role ROLE_MINTER allows minting iNFTs (calling `mint` function)\n\t */\n\tuint32 public constant ROLE_MINTER = 0x0001_0000;\n\n\t/**\n\t * @notice URI manager is responsible for managing base URI\n\t *      which is used to construct URIs for each option\n\t *\n\t * @dev Role ROLE_URI_MANAGER allows updating the base URI\n\t *      (executing `setBaseURI` function)\n\t */\n\tuint32 public constant ROLE_URI_MANAGER = 0x0010_0000;\n\n\t/**\n\t * @notice OpenSea manager is responsible for registering the factory\n\t *      in OpenSea via \"Transfer\" event mechanism\n\t *\n\t * @dev Role ROLE_OS_MANAGER allows notifying OpenSea about the contract\n\t *      \"owner\" change via emitting \"Transfer\" events read by the OpenSea\n\t *      (executing `fireTransferEvents` function)\n\t */\n\tuint32 public constant ROLE_OS_MANAGER = 0x0040_0000;\n\n\t/**\n\t * @dev Fired in mint() when Alethea NFT is created\n\t *\n\t * @param _by an address which executed the mint function\n\t * @param _optionId OpenSea option ID\n\t * @param _to an address NFT was minted to\n\t */\n\tevent Minted(address indexed _by, uint256 _optionId, address indexed _to);\n\n\t/**\n\t * @dev Fired in setBaseURI()\n\t *\n\t * @param _by an address which executed update\n\t * @param _oldVal old _baseURI value\n\t * @param _newVal new _baseURI value\n\t */\n\tevent BaseURIUpdated(address indexed _by, string _oldVal, string _newVal);\n\n\t/**\n\t * @dev An event caught by the OpenSea for automatic factory registration\n\t *      and assigning option \"owner\" to `to` address defined in the event\n\t * @dev See: OpenSea docs and source code examples,\n\t *      https://docs.opensea.io/docs/2-custom-sale-contract-viewing-your-sale-assets-on-opensea\n\t */\n\tevent Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n\t/**\n\t * @dev Creates/deploys the factory and binds it to NFT smart contract on construction\n\t *\n\t * @param _nft deployed NFT smart contract address; factory will mint NFTs of that type\n\t * @param _proxyRegistry OpenSea proxy registry address\n\t * @param _rangeBounds token ID ranges foreach option - the initial `currentTokenId` and `tokenIdUpperBound`\n\t */\n\tconstructor(address _nft, address _proxyRegistry, uint32[] memory _rangeBounds) AccessControl(msg.sender) {\n\t\t// verify the inputs are set\n\t\trequire(_nft != address(0), \"NFT contract is not set\");\n\t\trequire(_proxyRegistry != address(0), \"OpenSea proxy registry is not set\");\n\n\t\t// ensure there is at least one option (2 numbers for 1 range)\n\t\trequire(_rangeBounds.length > 1, \"invalid number of options\");\n\n\t\t// verify range bound initial element is greater than 100\n\t\trequire(_rangeBounds[0] > 100, \"invalid range bound initial element\");\n\n\t\t// verify inputs are valid smart contracts of the expected interfaces\n\t\trequire(ERC165(_nft).supportsInterface(type(ERC721).interfaceId), \"unexpected NFT type\");\n\t\trequire(ERC165(_nft).supportsInterface(type(ERC721Metadata).interfaceId), \"unexpected NFT type\");\n\t\trequire(ERC165(_nft).supportsInterface(type(MintableERC721).interfaceId), \"unexpected NFT type\");\n\n\t\t// verify that range bounds elements increase (monotonically increasing)\n\t\tfor(uint256 i = 0; i < _rangeBounds.length - 1; i++) {\n\t\t\t// compare current element and next element\n\t\t\trequire(_rangeBounds[i] < _rangeBounds[i + 1], \"invalid range bounds\");\n\t\t}\n\n\t\t// assign the NFT address\n\t\tnftContract = _nft;\n\t\t// assign owner\n\t\towner = msg.sender;\n\t\t// assign OpenSea Proxy Registry address\n\t\tproxyRegistry = _proxyRegistry;\n\t\t// number of options is derived from the range bounds array\n\t\toptions = uint32(_rangeBounds.length - 1);\n\n\t\t// assign the appropriate start and upper bound for each optionId\n\t\tfor(uint256 i = 0; i < _rangeBounds.length - 1; i++) {\n\t\t\tcurrentTokenId[i] = _rangeBounds[i];\n\t\t\ttokenIdUpperBound[i] = _rangeBounds[i + 1];\n\t\t}\n\n\t\t// fire events for each option\n\t\tfireTransferEvents(address(0), msg.sender);\n\t}\n\n\t/**\n\t * @dev Restricted access function which updates base URI for optionIds\n\t *\n\t * @param _baseURI new base URI to set\n\t */\n\tfunction setBaseURI(string memory _baseURI) public virtual {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_URI_MANAGER), \"access denied\");\n\n\t\t// emit an event first - to log both old and new values\n\t\temit BaseURIUpdated(msg.sender, baseURI, _baseURI);\n\n\t\t// and update base URI\n\t\tbaseURI = _baseURI;\n\t}\n\n\t/**\n\t * @inheritdoc ERC165\n\t */\n\tfunction supportsInterface(bytes4 interfaceId) public pure override returns (bool) {\n\t\t// reconstruct from current interface and super interface\n\t\treturn interfaceId == type(OpenSeaFactoryERC721).interfaceId;\n\t}\n\n\t/**\n\t * @inheritdoc OpenSeaFactoryERC721\n\t */\n\tfunction name() public override view returns (string memory) {\n\t\t// delegate to super implementation\n\t\treturn ERC721Metadata(nftContract).name();\n\t}\n\n\t/**\n\t * @inheritdoc OpenSeaFactoryERC721\n\t */\n\tfunction symbol() public override view returns (string memory) {\n\t\t// delegate to super implementation\n\t\treturn ERC721Metadata(nftContract).symbol();\n\t}\n\n\t/**\n\t * @inheritdoc OpenSeaFactoryERC721\n\t */\n\tfunction numOptions() public override view returns (uint256) {\n\t\t// calculate based on 0-indexed options\n\t\treturn options;\n\t}\n\n\t/**\n\t * @inheritdoc OpenSeaFactoryERC721\n\t */\n\tfunction canMint(uint256 _optionId) public override view returns (bool) {\n\t\t// check valid optionId, bounds\n\t\treturn _optionId < options && currentTokenId[_optionId] < tokenIdUpperBound[_optionId];\n\t}\n\n\t/**\n\t * @inheritdoc OpenSeaFactoryERC721\n\t */\n\tfunction tokenURI(uint256 _optionId) public override view returns (string memory) {\n\t\t// concatenate base URI + token ID\n\t\treturn StringUtils.concat(baseURI, StringUtils.itoa(_optionId, 10));\n\t}\n\n\t/**\n\t * @inheritdoc OpenSeaFactoryERC721\n\t */\n\tfunction supportsFactoryInterface() public override pure returns (bool) {\n\t\t// use ERC165 supportsInterface to return `true`\n\t\treturn supportsInterface(type(OpenSeaFactoryERC721).interfaceId);\n\t}\n\n\t/**\n\t * @inheritdoc OpenSeaFactoryERC721\n\t */\n\tfunction mint(uint256 _optionId, address _toAddress) public override {\n\t\t// verify the access permission\n\t\trequire(address(ProxyRegistry(proxyRegistry).proxies(owner)) == msg.sender, \"access denied\");\n\n\t\t// verify option ID can be minted\n\t\trequire(canMint(_optionId), \"cannot mint\");\n\n\t\t// do the mint\n\t\tMintableERC721(nftContract).mint(_toAddress, currentTokenId[_optionId]);\n\n\t\t// emit an event before increasing\n\t\temit Minted(msg.sender, currentTokenId[_optionId], _toAddress);\n\n\t\t// increment next tokenId\n\t\tcurrentTokenId[_optionId]++;\n\t}\n\n\t/**\n\t * @dev Fires transfer events for each option. Used to change contract \"owner\"\n\t *      See: OpenSea docs and source code examples,\n\t *      https://docs.opensea.io/docs/2-custom-sale-contract-viewing-your-sale-assets-on-opensea\n\t *\n\t * @param _from transfer optionIds from\n\t * @param _to transfer optionIds to\n\t */\n\tfunction fireTransferEvents(address _from, address _to) public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_OS_MANAGER), \"access denied\");\n\n\t\t// fire events for each option\n\t\tfor (uint256 i = 0; i < options; i++) {\n\t\t\temit Transfer(_from, _to, i);\n\t\t}\n\t}\n\n\t/**\n\t * Hack to get things to work automatically on OpenSea.\n\t * Use transferFrom so the frontend doesn't have to worry about different method names.\n\t */\n\tfunction transferFrom(address, address _to, uint256 _tokenId) public {\n\t\t// simply delegate to `mint`\n\t\tmint(_tokenId, _to);\n\t}\n\n\t/**\n\t * Hack to get things to work automatically on OpenSea.\n\t * Use isApprovedForAll so the frontend doesn't have to worry about different method names.\n\t */\n\tfunction isApprovedForAll(address _owner, address _operator) public view returns (bool) {\n\t\t// true if called by contract \"owner\" which is the token owner itself\n\t\tif(owner == _owner && _owner == _operator) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// lookup the registry\n\t\treturn owner == _owner && address(ProxyRegistry(proxyRegistry).proxies(_owner)) == _operator;\n\t}\n\n\t/**\n\t * Hack to get things to work automatically on OpenSea.\n\t * Use isApprovedForAll so the frontend doesn't have to worry about different method names.\n\t */\n\tfunction ownerOf(uint256) public view returns (address _owner) {\n\t\t// return smart contract \"owner\"\n\t\treturn owner;\n\t}\n}\n"
    },
    "contracts/token/AletheaNFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./RoyalERC721.sol\";\n\n/**\n * @title Alethea NFT\n *\n * @notice Alethea NFT is an ERC721 token used as a target NFT for iNFT protocol\n *\n * @dev Alethea NFT is a Tiny ERC721, it supports minting and burning,\n *      its token ID space is limited to 32 bits\n */\ncontract AletheaNFT is RoyalERC721 {\n\t/**\n\t * @inheritdoc TinyERC721\n\t */\n\tuint256 public constant override TOKEN_UID = 0x275ee64af649fe998ccbaec4f443dc216eef3bab6f11080eeeedfbdd303c59a6;\n\n\t/**\n\t * @dev Constructs/deploys Alethea NFT instance\n\t *      with the name and symbol defined during the deployment\n\t */\n\tconstructor(string memory _name, string memory _symbol) RoyalERC721(_name, _symbol) AccessControl(msg.sender) {}\n}\n"
    },
    "contracts/token/AliERC20v2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// use non-strict version pragma to simplify contract imports in other projects\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ERC1363Spec.sol\";\nimport \"../interfaces/EIP2612.sol\";\nimport \"../interfaces/EIP3009.sol\";\nimport \"../utils/AccessControl.sol\";\nimport \"../lib/AddressUtils.sol\";\nimport \"../lib/ECDSA.sol\";\n\n/**\n * @title Artificial Liquid Intelligence ERC20 Token (Alethea, ALI)\n *\n * @notice ALI is the native utility token of the Alethea AI Protocol.\n *      It serves as protocol currency, participates in iNFTs lifecycle,\n *      (locked when iNFT is created, released when iNFT is destroyed,\n *      consumed when iNFT is upgraded).\n *      ALI token powers up the governance protocol (Alethea DAO)\n *\n * @notice Token Summary:\n *      - Symbol: ALI\n *      - Name: Artificial Liquid Intelligence Token\n *      - Decimals: 18\n *      - Initial/maximum total supply: 10,000,000,000 ALI\n *      - Initial supply holder (initial holder) address: 0x0738F702D1a7364d356729Cb8845701885C487A1 (configurable)\n *      - Mintability: configurable (initially enabled, but possible to revoke forever)\n *      - Burnability: configurable (initially enabled, but possible to revoke forever)\n *      - DAO Support: supports voting delegation\n *\n * @notice Features Summary:\n *      - Supports atomic allowance modification, resolves well-known ERC20 issue with approve (arXiv:1907.00903)\n *      - Voting delegation and delegation on behalf via EIP-712 (like in Compound CMP token) - gives the token\n *        powerful governance capabilities by allowing holders to form voting groups by electing delegates\n *      - Unlimited approval feature (like in 0x ZRX token) - saves gas for transfers on behalf\n *        by eliminating the need to update “unlimited” allowance value\n *      - ERC-1363 Payable Token - ERC721-like callback execution mechanism for transfers,\n *        transfers on behalf and approvals; allows creation of smart contracts capable of executing callbacks\n *        in response to transfer or approval in a single transaction\n *      - EIP-2612: permit - 712-signed approvals - improves user experience by allowing to use a token\n *        without having an ETH to pay gas fees\n *      - EIP-3009: Transfer With Authorization - improves user experience by allowing to use a token\n *        without having an ETH to pay gas fees\n *\n * @dev Even though smart contract has mint() function which is used to mint initial token supply,\n *      the function is disabled forever after smart contract deployment by revoking `TOKEN_CREATOR`\n *      permission from the deployer account\n *\n * @dev Token balances and total supply are effectively 192 bits long, meaning that maximum\n *      possible total supply smart contract is able to track is 2^192 (close to 10^40 tokens)\n *\n * @dev Smart contract doesn't use safe math. All arithmetic operations are overflow/underflow safe.\n *      Additionally, Solidity 0.8.7 enforces overflow/underflow safety.\n *\n * @dev Multiple Withdrawal Attack on ERC20 Tokens (arXiv:1907.00903) - resolved\n *      Related events and functions are marked with \"arXiv:1907.00903\" tag:\n *        - event Transfer(address indexed _by, address indexed _from, address indexed _to, uint256 _value)\n *        - event Approve(address indexed _owner, address indexed _spender, uint256 _oldValue, uint256 _value)\n *        - function increaseAllowance(address _spender, uint256 _value) public returns (bool)\n *        - function decreaseAllowance(address _spender, uint256 _value) public returns (bool)\n *      See: https://arxiv.org/abs/1907.00903v1\n *           https://ieeexplore.ieee.org/document/8802438\n *      See: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n *\n * @dev Reviewed\n *      ERC-20   - according to https://eips.ethereum.org/EIPS/eip-20\n *      ERC-1363 - according to https://eips.ethereum.org/EIPS/eip-1363\n *      EIP-2612 - according to https://eips.ethereum.org/EIPS/eip-2612\n *      EIP-3009 - according to https://eips.ethereum.org/EIPS/eip-3009\n *\n * @dev ERC20: contract has passed\n *      - OpenZeppelin ERC20 tests\n *        https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/test/token/ERC20/ERC20.behavior.js\n *        https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/test/token/ERC20/ERC20.test.js\n *      - Ref ERC1363 tests\n *        https://github.com/vittominacori/erc1363-payable-token/blob/master/test/token/ERC1363/ERC1363.behaviour.js\n *      - OpenZeppelin EIP2612 tests\n *        https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/test/token/ERC20/extensions/draft-ERC20Permit.test.js\n *      - Coinbase EIP3009 tests\n *        https://github.com/CoinbaseStablecoin/eip-3009/blob/master/test/EIP3009.test.ts\n *      - Compound voting delegation tests\n *        https://github.com/compound-finance/compound-protocol/blob/master/tests/Governance/CompTest.js\n *        https://github.com/compound-finance/compound-protocol/blob/master/tests/Utils/EIP712.js\n *      - OpenZeppelin voting delegation tests\n *        https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/test/token/ERC20/extensions/ERC20Votes.test.js\n *      See adopted copies of all the tests in the project test folder\n *\n * @dev Compound-like voting delegation functions', public getters', and events' names\n *      were changed for better code readability (Alethea Name <- Comp/Zeppelin name):\n *      - votingDelegates           <- delegates\n *      - votingPowerHistory        <- checkpoints\n *      - votingPowerHistoryLength  <- numCheckpoints\n *      - totalSupplyHistory        <- _totalSupplyCheckpoints (private)\n *      - usedNonces                <- nonces (note: nonces are random instead of sequential)\n *      - DelegateChanged (unchanged)\n *      - VotingPowerChanged        <- DelegateVotesChanged\n *      - votingPowerOf             <- getCurrentVotes\n *      - votingPowerAt             <- getPriorVotes\n *      - totalSupplyAt             <- getPriorTotalSupply\n *      - delegate (unchanged)\n *      - delegateWithAuthorization <- delegateBySig\n * @dev Compound-like voting delegation improved to allow the use of random nonces like in EIP-3009,\n *      instead of sequential; same `usedNonces` EIP-3009 mapping is used to track nonces\n *\n * @dev Reference implementations \"used\":\n *      - Atomic allowance:    https://github.com/OpenZeppelin/openzeppelin-contracts\n *      - Unlimited allowance: https://github.com/0xProject/protocol\n *      - Voting delegation:   https://github.com/compound-finance/compound-protocol\n *                             https://github.com/OpenZeppelin/openzeppelin-contracts\n *      - ERC-1363:            https://github.com/vittominacori/erc1363-payable-token\n *      - EIP-2612:            https://github.com/Uniswap/uniswap-v2-core\n *      - EIP-3009:            https://github.com/centrehq/centre-tokens\n *                             https://github.com/CoinbaseStablecoin/eip-3009\n *      - Meta transactions:   https://github.com/0xProject/protocol\n *\n * @dev Includes resolutions for ALI ERC20 Audit by Miguel Palhas, https://hackmd.io/@naps62/alierc20-audit\n */\ncontract AliERC20v2Base is ERC1363, EIP2612, EIP3009, AccessControl {\n\t/**\n\t * @dev Smart contract unique identifier, a random number\n\t *\n\t * @dev Should be regenerated each time smart contact source code is changed\n\t *      and changed smart contract itself is to be redeployed\n\t *\n\t * @dev Generated using https://www.random.org/bytes/\n\t */\n\tuint256 public constant TOKEN_UID = 0x12bd2f619fc10a5ea1163ac859bc851ba1c0453e21abcd5d64f633889e432674;\n\n\t/**\n\t * @notice Name of the token: Artificial Liquid Intelligence Token\n\t *\n\t * @notice ERC20 name of the token (long name)\n\t *\n\t * @dev ERC20 `function name() public view returns (string)`\n\t *\n\t * @dev Field is declared public: getter name() is created when compiled,\n\t *      it returns the name of the token.\n\t */\n\tstring public constant name = \"Artificial Liquid Intelligence Token\";\n\n\t/**\n\t * @notice Symbol of the token: ALI\n\t *\n\t * @notice ERC20 symbol of that token (short name)\n\t *\n\t * @dev ERC20 `function symbol() public view returns (string)`\n\t *\n\t * @dev Field is declared public: getter symbol() is created when compiled,\n\t *      it returns the symbol of the token\n\t */\n\tstring public constant symbol = \"ALI\";\n\n\t/**\n\t * @notice Decimals of the token: 18\n\t *\n\t * @dev ERC20 `function decimals() public view returns (uint8)`\n\t *\n\t * @dev Field is declared public: getter decimals() is created when compiled,\n\t *      it returns the number of decimals used to get its user representation.\n\t *      For example, if `decimals` equals `6`, a balance of `1,500,000` tokens should\n\t *      be displayed to a user as `1,5` (`1,500,000 / 10 ** 6`).\n\t *\n\t * @dev NOTE: This information is only used for _display_ purposes: it in\n\t *      no way affects any of the arithmetic of the contract, including balanceOf() and transfer().\n\t */\n\tuint8 public constant decimals = 18;\n\n\t/**\n\t * @notice Total supply of the token: initially 10,000,000,000,\n\t *      with the potential to decline over time as some tokens may get burnt but not minted\n\t *\n\t * @dev ERC20 `function totalSupply() public view returns (uint256)`\n\t *\n\t * @dev Field is declared public: getter totalSupply() is created when compiled,\n\t *      it returns the amount of tokens in existence.\n\t */\n\tuint256 public override totalSupply; // is set to 10 billion * 10^18 in the constructor\n\n\t/**\n\t * @dev A record of all the token balances\n\t * @dev This mapping keeps record of all token owners:\n\t *      owner => balance\n\t */\n\tmapping(address => uint256) private tokenBalances;\n\n\t/**\n\t * @notice A record of each account's voting delegate\n\t *\n\t * @dev Auxiliary data structure used to sum up an account's voting power\n\t *\n\t * @dev This mapping keeps record of all voting power delegations:\n\t *      voting delegator (token owner) => voting delegate\n\t */\n\tmapping(address => address) public votingDelegates;\n\n\t/**\n\t * @notice Auxiliary structure to store key-value pair, used to store:\n\t *      - voting power record (key: block.timestamp, value: voting power)\n\t *      - total supply record (key: block.timestamp, value: total supply)\n\t * @notice A voting power record binds voting power of a delegate to a particular\n\t *      block when the voting power delegation change happened\n\t *         k: block.number when delegation has changed; starting from\n\t *            that block voting power value is in effect\n\t *         v: cumulative voting power a delegate has obtained starting\n\t *            from the block stored in blockNumber\n\t * @notice Total supply record binds total token supply to a particular\n\t *      block when total supply change happened (due to mint/burn operations)\n\t */\n\tstruct KV {\n\t\t/*\n\t\t * @dev key, a block number\n\t\t */\n\t\tuint64 k;\n\n\t\t/*\n\t\t * @dev value, token balance or voting power\n\t\t */\n\t\tuint192 v;\n\t}\n\n\t/**\n\t * @notice A record of each account's voting power historical data\n\t *\n\t * @dev Primarily data structure to store voting power for each account.\n\t *      Voting power sums up from the account's token balance and delegated\n\t *      balances.\n\t *\n\t * @dev Stores current value and entire history of its changes.\n\t *      The changes are stored as an array of checkpoints (key-value pairs).\n\t *      Checkpoint is an auxiliary data structure containing voting\n\t *      power (number of votes) and block number when the checkpoint is saved\n\t *\n\t * @dev Maps voting delegate => voting power record\n\t */\n\tmapping(address => KV[]) public votingPowerHistory;\n\n\t/**\n\t * @notice A record of total token supply historical data\n\t *\n\t * @dev Primarily data structure to store total token supply.\n\t *\n\t * @dev Stores current value and entire history of its changes.\n\t *      The changes are stored as an array of checkpoints (key-value pairs).\n\t *      Checkpoint is an auxiliary data structure containing total\n\t *      token supply and block number when the checkpoint is saved\n\t */\n\tKV[] public totalSupplyHistory;\n\n\t/**\n\t * @dev A record of nonces for signing/validating signatures in EIP-2612 `permit`\n\t *\n\t * @dev Note: EIP2612 doesn't imply a possibility for nonce randomization like in EIP-3009\n\t *\n\t * @dev Maps delegate address => delegate nonce\n\t */\n\tmapping(address => uint256) public override nonces;\n\n\t/**\n\t * @dev A record of used nonces for EIP-3009 transactions\n\t *\n\t * @dev A record of used nonces for signing/validating signatures\n\t *      in `delegateWithAuthorization` for every delegate\n\t *\n\t * @dev Maps authorizer address => nonce => true/false (used unused)\n\t */\n\tmapping(address => mapping(bytes32 => bool)) private usedNonces;\n\n\t/**\n\t * @notice A record of all the allowances to spend tokens on behalf\n\t * @dev Maps token owner address to an address approved to spend\n\t *      some tokens on behalf, maps approved address to that amount\n\t * @dev owner => spender => value\n\t */\n\tmapping(address => mapping(address => uint256)) private transferAllowances;\n\n\t/**\n\t * @notice Enables ERC20 transfers of the tokens\n\t *      (transfer by the token owner himself)\n\t * @dev Feature FEATURE_TRANSFERS must be enabled in order for\n\t *      `transfer()` function to succeed\n\t */\n\tuint32 public constant FEATURE_TRANSFERS = 0x0000_0001;\n\n\t/**\n\t * @notice Enables ERC20 transfers on behalf\n\t *      (transfer by someone else on behalf of token owner)\n\t * @dev Feature FEATURE_TRANSFERS_ON_BEHALF must be enabled in order for\n\t *      `transferFrom()` function to succeed\n\t * @dev Token owner must call `approve()` first to authorize\n\t *      the transfer on behalf\n\t */\n\tuint32 public constant FEATURE_TRANSFERS_ON_BEHALF = 0x0000_0002;\n\n\t/**\n\t * @dev Defines if the default behavior of `transfer` and `transferFrom`\n\t *      checks if the receiver smart contract supports ERC20 tokens\n\t * @dev When feature FEATURE_UNSAFE_TRANSFERS is enabled the transfers do not\n\t *      check if the receiver smart contract supports ERC20 tokens,\n\t *      i.e. `transfer` and `transferFrom` behave like `unsafeTransferFrom`\n\t * @dev When feature FEATURE_UNSAFE_TRANSFERS is disabled (default) the transfers\n\t *      check if the receiver smart contract supports ERC20 tokens,\n\t *      i.e. `transfer` and `transferFrom` behave like `transferFromAndCall`\n\t */\n\tuint32 public constant FEATURE_UNSAFE_TRANSFERS = 0x0000_0004;\n\n\t/**\n\t * @notice Enables token owners to burn their own tokens\n\t *\n\t * @dev Feature FEATURE_OWN_BURNS must be enabled in order for\n\t *      `burn()` function to succeed when called by token owner\n\t */\n\tuint32 public constant FEATURE_OWN_BURNS = 0x0000_0008;\n\n\t/**\n\t * @notice Enables approved operators to burn tokens on behalf of their owners\n\t *\n\t * @dev Feature FEATURE_BURNS_ON_BEHALF must be enabled in order for\n\t *      `burn()` function to succeed when called by approved operator\n\t */\n\tuint32 public constant FEATURE_BURNS_ON_BEHALF = 0x0000_0010;\n\n\t/**\n\t * @notice Enables delegators to elect delegates\n\t * @dev Feature FEATURE_DELEGATIONS must be enabled in order for\n\t *      `delegate()` function to succeed\n\t */\n\tuint32 public constant FEATURE_DELEGATIONS = 0x0000_0020;\n\n\t/**\n\t * @notice Enables delegators to elect delegates on behalf\n\t *      (via an EIP712 signature)\n\t * @dev Feature FEATURE_DELEGATIONS_ON_BEHALF must be enabled in order for\n\t *      `delegateWithAuthorization()` function to succeed\n\t */\n\tuint32 public constant FEATURE_DELEGATIONS_ON_BEHALF = 0x0000_0040;\n\n\t/**\n\t * @notice Enables ERC-1363 transfers with callback\n\t * @dev Feature FEATURE_ERC1363_TRANSFERS must be enabled in order for\n\t *      ERC-1363 `transferFromAndCall` functions to succeed\n\t */\n\tuint32 public constant FEATURE_ERC1363_TRANSFERS = 0x0000_0080;\n\n\t/**\n\t * @notice Enables ERC-1363 approvals with callback\n\t * @dev Feature FEATURE_ERC1363_APPROVALS must be enabled in order for\n\t *      ERC-1363 `approveAndCall` functions to succeed\n\t */\n\tuint32 public constant FEATURE_ERC1363_APPROVALS = 0x0000_0100;\n\n\t/**\n\t * @notice Enables approvals on behalf (EIP2612 permits\n\t *      via an EIP712 signature)\n\t * @dev Feature FEATURE_EIP2612_PERMITS must be enabled in order for\n\t *      `permit()` function to succeed\n\t */\n\tuint32 public constant FEATURE_EIP2612_PERMITS = 0x0000_0200;\n\n\t/**\n\t * @notice Enables meta transfers on behalf (EIP3009 transfers\n\t *      via an EIP712 signature)\n\t * @dev Feature FEATURE_EIP3009_TRANSFERS must be enabled in order for\n\t *      `transferWithAuthorization()` function to succeed\n\t */\n\tuint32 public constant FEATURE_EIP3009_TRANSFERS = 0x0000_0400;\n\n\t/**\n\t * @notice Enables meta transfers on behalf (EIP3009 transfers\n\t *      via an EIP712 signature)\n\t * @dev Feature FEATURE_EIP3009_RECEPTIONS must be enabled in order for\n\t *      `receiveWithAuthorization()` function to succeed\n\t */\n\tuint32 public constant FEATURE_EIP3009_RECEPTIONS = 0x0000_0800;\n\n\t/**\n\t * @notice Token creator is responsible for creating (minting)\n\t *      tokens to an arbitrary address\n\t * @dev Role ROLE_TOKEN_CREATOR allows minting tokens\n\t *      (calling `mint` function)\n\t */\n\tuint32 public constant ROLE_TOKEN_CREATOR = 0x0001_0000;\n\n\t/**\n\t * @notice Token destroyer is responsible for destroying (burning)\n\t *      tokens owned by an arbitrary address\n\t * @dev Role ROLE_TOKEN_DESTROYER allows burning tokens\n\t *      (calling `burn` function)\n\t */\n\tuint32 public constant ROLE_TOKEN_DESTROYER = 0x0002_0000;\n\n\t/**\n\t * @notice ERC20 receivers are allowed to receive tokens without ERC20 safety checks,\n\t *      which may be useful to simplify tokens transfers into \"legacy\" smart contracts\n\t * @dev When `FEATURE_UNSAFE_TRANSFERS` is not enabled addresses having\n\t *      `ROLE_ERC20_RECEIVER` permission are allowed to receive tokens\n\t *      via `transfer` and `transferFrom` functions in the same way they\n\t *      would via `unsafeTransferFrom` function\n\t * @dev When `FEATURE_UNSAFE_TRANSFERS` is enabled `ROLE_ERC20_RECEIVER` permission\n\t *      doesn't affect the transfer behaviour since\n\t *      `transfer` and `transferFrom` behave like `unsafeTransferFrom` for any receiver\n\t * @dev ROLE_ERC20_RECEIVER is a shortening for ROLE_UNSAFE_ERC20_RECEIVER\n\t */\n\tuint32 public constant ROLE_ERC20_RECEIVER = 0x0004_0000;\n\n\t/**\n\t * @notice ERC20 senders are allowed to send tokens without ERC20 safety checks,\n\t *      which may be useful to simplify tokens transfers into \"legacy\" smart contracts\n\t * @dev When `FEATURE_UNSAFE_TRANSFERS` is not enabled senders having\n\t *      `ROLE_ERC20_SENDER` permission are allowed to send tokens\n\t *      via `transfer` and `transferFrom` functions in the same way they\n\t *      would via `unsafeTransferFrom` function\n\t * @dev When `FEATURE_UNSAFE_TRANSFERS` is enabled `ROLE_ERC20_SENDER` permission\n\t *      doesn't affect the transfer behaviour since\n\t *      `transfer` and `transferFrom` behave like `unsafeTransferFrom` for any receiver\n\t * @dev ROLE_ERC20_SENDER is a shortening for ROLE_UNSAFE_ERC20_SENDER\n\t */\n\tuint32 public constant ROLE_ERC20_SENDER = 0x0008_0000;\n\n\t/**\n\t * @notice EIP-712 contract's domain typeHash,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\n\t *\n\t * @dev Note: we do not include version into the domain typehash/separator,\n\t *      it is implied version is concatenated to the name field, like \"AliERC20v2\"\n\t */\n\t// keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\")\n\tbytes32 public constant DOMAIN_TYPEHASH = 0x8cad95687ba82c2ce50e74f7b754645e5117c3a5bec8151c0726d5857980a866;\n\n\t/**\n\t * @notice EIP-712 contract domain separator,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator\n\t *      note: we specify contract version in its name\n\t */\n\tfunction DOMAIN_SEPARATOR() public view override returns(bytes32) {\n\t\t// build the EIP-712 contract domain separator, see https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator\n\t\t// note: we specify contract version in its name\n\t\treturn keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(\"AliERC20v2\")), block.chainid, address(this)));\n\t}\n\n\t/**\n\t * @notice EIP-712 delegation struct typeHash,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\n\t */\n\t// keccak256(\"Delegation(address delegate,uint256 nonce,uint256 expiry)\")\n\tbytes32 public constant DELEGATION_TYPEHASH = 0xff41620983935eb4d4a3c7384a066ca8c1d10cef9a5eca9eb97ca735cd14a755;\n\n\t/**\n\t * @notice EIP-712 permit (EIP-2612) struct typeHash,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\n\t */\n\t// keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\")\n\tbytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n\t/**\n\t * @notice EIP-712 TransferWithAuthorization (EIP-3009) struct typeHash,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\n\t */\n\t// keccak256(\"TransferWithAuthorization(address from,address to,uint256 value,uint256 validAfter,uint256 validBefore,bytes32 nonce)\")\n\tbytes32 public constant TRANSFER_WITH_AUTHORIZATION_TYPEHASH = 0x7c7c6cdb67a18743f49ec6fa9b35f50d52ed05cbed4cc592e13b44501c1a2267;\n\n\t/**\n\t * @notice EIP-712 ReceiveWithAuthorization (EIP-3009) struct typeHash,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\n\t */\n\t// keccak256(\"ReceiveWithAuthorization(address from,address to,uint256 value,uint256 validAfter,uint256 validBefore,bytes32 nonce)\")\n\tbytes32 public constant RECEIVE_WITH_AUTHORIZATION_TYPEHASH = 0xd099cc98ef71107a616c4f0f941f04c322d8e254fe26b3c6668db87aae413de8;\n\n\t/**\n\t * @notice EIP-712 CancelAuthorization (EIP-3009) struct typeHash,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\n\t */\n\t// keccak256(\"CancelAuthorization(address authorizer,bytes32 nonce)\")\n\tbytes32 public constant CANCEL_AUTHORIZATION_TYPEHASH = 0x158b0a9edf7a828aad02f63cd515c68ef2f50ba807396f6d12842833a1597429;\n\n\t/**\n\t * @dev Fired in mint() function\n\t *\n\t * @param by an address which minted some tokens (transaction sender)\n\t * @param to an address the tokens were minted to\n\t * @param value an amount of tokens minted\n\t */\n\tevent Minted(address indexed by, address indexed to, uint256 value);\n\n\t/**\n\t * @dev Fired in burn() function\n\t *\n\t * @param by an address which burned some tokens (transaction sender)\n\t * @param from an address the tokens were burnt from\n\t * @param value an amount of tokens burnt\n\t */\n\tevent Burnt(address indexed by, address indexed from, uint256 value);\n\n\t/**\n\t * @dev Resolution for the Multiple Withdrawal Attack on ERC20 Tokens (arXiv:1907.00903)\n\t *\n\t * @dev Similar to ERC20 Transfer event, but also logs an address which executed transfer\n\t *\n\t * @dev Fired in transfer(), transferFrom() and some other (non-ERC20) functions\n\t *\n\t * @param by an address which performed the transfer\n\t * @param from an address tokens were consumed from\n\t * @param to an address tokens were sent to\n\t * @param value number of tokens transferred\n\t */\n\tevent Transfer(address indexed by, address indexed from, address indexed to, uint256 value);\n\n\t/**\n\t * @dev Resolution for the Multiple Withdrawal Attack on ERC20 Tokens (arXiv:1907.00903)\n\t *\n\t * @dev Similar to ERC20 Approve event, but also logs old approval value\n\t *\n\t * @dev Fired in approve(), increaseAllowance(), decreaseAllowance() functions,\n\t *      may get fired in transfer functions\n\t *\n\t * @param owner an address which granted a permission to transfer\n\t *      tokens on its behalf\n\t * @param spender an address which received a permission to transfer\n\t *      tokens on behalf of the owner `_owner`\n\t * @param oldValue previously granted amount of tokens to transfer on behalf\n\t * @param value new granted amount of tokens to transfer on behalf\n\t */\n\tevent Approval(address indexed owner, address indexed spender, uint256 oldValue, uint256 value);\n\n\t/**\n\t * @dev Notifies that a key-value pair in `votingDelegates` mapping has changed,\n\t *      i.e. a delegator address has changed its delegate address\n\t *\n\t * @param source delegator address, a token owner, effectively transaction sender (`by`)\n\t * @param from old delegate, an address which delegate right is revoked\n\t * @param to new delegate, an address which received the voting power\n\t */\n\tevent DelegateChanged(address indexed source, address indexed from, address indexed to);\n\n\t/**\n\t * @dev Notifies that a key-value pair in `votingPowerHistory` mapping has changed,\n\t *      i.e. a delegate's voting power has changed.\n\t *\n\t * @param by an address which executed delegate, mint, burn, or transfer operation\n\t *      which had led to delegate voting power change\n\t * @param target delegate whose voting power has changed\n\t * @param fromVal previous number of votes delegate had\n\t * @param toVal new number of votes delegate has\n\t */\n\tevent VotingPowerChanged(address indexed by, address indexed target, uint256 fromVal, uint256 toVal);\n\n\t/**\n\t * @dev Deploys the token smart contract,\n\t *      assigns initial token supply to the address specified\n\t *\n\t * @param _initialHolder owner of the initial token supply\n\t * @param _initialSupply initial token supply value\n\t */\n\tconstructor(address _initialHolder, uint256 _initialSupply) AccessControl(msg.sender) {\n\t\t// verify initial holder address non-zero (is set) if there is an initial supply to mint\n\t\trequire(_initialSupply == 0 || _initialHolder != address(0), \"_initialHolder not set (zero address)\");\n\n\t\t// if there is an initial supply to mint\n\t\tif(_initialSupply != 0) {\n\t\t\t// mint the initial supply\n\t\t\tmint(_initialHolder, _initialSupply);\n\t\t}\n\t}\n\n\t/**\n\t * @inheritdoc ERC165\n\t */\n\tfunction supportsInterface(bytes4 interfaceId) public pure virtual override returns (bool) {\n\t\t// reconstruct from current interface(s) and super interface(s) (if any)\n\t\treturn interfaceId == type(ERC165).interfaceId\n\t\t    || interfaceId == type(ERC20).interfaceId\n\t\t    || interfaceId == type(ERC1363).interfaceId\n\t\t    || interfaceId == type(EIP2612).interfaceId\n\t\t    || interfaceId == type(EIP3009).interfaceId;\n\t}\n\n\t// ===== Start: ERC-1363 functions =====\n\n\t/**\n\t * @notice Transfers some tokens and then executes `onTransferReceived` callback on the receiver\n\t *\n\t * @inheritdoc ERC1363\n\t *\n\t * @dev Called by token owner (an address which has a\n\t *      positive token balance tracked by this smart contract)\n\t * @dev Throws on any error like\n\t *      * insufficient token balance or\n\t *      * incorrect `_to` address:\n\t *          * zero address or\n\t *          * same as `_from` address (self transfer)\n\t *          * EOA or smart contract which doesn't support ERC1363Receiver interface\n\t * @dev Returns true on success, throws otherwise\n\t *\n\t * @param _to an address to transfer tokens to,\n\t *      must be a smart contract, implementing ERC1363Receiver\n\t * @param _value amount of tokens to be transferred,, zero\n\t *      value is allowed\n\t * @return true unless throwing\n\t */\n\tfunction transferAndCall(address _to, uint256 _value) public override returns (bool) {\n\t\t// delegate to `transferFromAndCall` passing `msg.sender` as `_from`\n\t\treturn transferFromAndCall(msg.sender, _to, _value);\n\t}\n\n\t/**\n\t * @notice Transfers some tokens and then executes `onTransferReceived` callback on the receiver\n\t *\n\t * @inheritdoc ERC1363\n\t *\n\t * @dev Called by token owner (an address which has a\n\t *      positive token balance tracked by this smart contract)\n\t * @dev Throws on any error like\n\t *      * insufficient token balance or\n\t *      * incorrect `_to` address:\n\t *          * zero address or\n\t *          * same as `_from` address (self transfer)\n\t *          * EOA or smart contract which doesn't support ERC1363Receiver interface\n\t * @dev Returns true on success, throws otherwise\n\t *\n\t * @param _to an address to transfer tokens to,\n\t *      must be a smart contract, implementing ERC1363Receiver\n\t * @param _value amount of tokens to be transferred,, zero\n\t *      value is allowed\n\t * @param _data [optional] additional data with no specified format,\n\t *      sent in onTransferReceived call to `_to`\n\t * @return true unless throwing\n\t */\n\tfunction transferAndCall(address _to, uint256 _value, bytes memory _data) public override returns (bool) {\n\t\t// delegate to `transferFromAndCall` passing `msg.sender` as `_from`\n\t\treturn transferFromAndCall(msg.sender, _to, _value, _data);\n\t}\n\n\t/**\n\t * @notice Transfers some tokens on behalf of address `_from' (token owner)\n\t *      to some other address `_to` and then executes `onTransferReceived` callback on the receiver\n\t *\n\t * @inheritdoc ERC1363\n\t *\n\t * @dev Called by token owner on his own or approved address,\n\t *      an address approved earlier by token owner to\n\t *      transfer some amount of tokens on its behalf\n\t * @dev Throws on any error like\n\t *      * insufficient token balance or\n\t *      * incorrect `_to` address:\n\t *          * zero address or\n\t *          * same as `_from` address (self transfer)\n\t *          * EOA or smart contract which doesn't support ERC1363Receiver interface\n\t * @dev Returns true on success, throws otherwise\n\t *\n\t * @param _from token owner which approved caller (transaction sender)\n\t *      to transfer `_value` of tokens on its behalf\n\t * @param _to an address to transfer tokens to,\n\t *      must be a smart contract, implementing ERC1363Receiver\n\t * @param _value amount of tokens to be transferred,, zero\n\t *      value is allowed\n\t * @return true unless throwing\n\t */\n\tfunction transferFromAndCall(address _from, address _to, uint256 _value) public override returns (bool) {\n\t\t// delegate to `transferFromAndCall` passing empty data param\n\t\treturn transferFromAndCall(_from, _to, _value, \"\");\n\t}\n\n\t/**\n\t * @notice Transfers some tokens on behalf of address `_from' (token owner)\n\t *      to some other address `_to` and then executes a `onTransferReceived` callback on the receiver\n\t *\n\t * @inheritdoc ERC1363\n\t *\n\t * @dev Called by token owner on his own or approved address,\n\t *      an address approved earlier by token owner to\n\t *      transfer some amount of tokens on its behalf\n\t * @dev Throws on any error like\n\t *      * insufficient token balance or\n\t *      * incorrect `_to` address:\n\t *          * zero address or\n\t *          * same as `_from` address (self transfer)\n\t *          * EOA or smart contract which doesn't support ERC1363Receiver interface\n\t * @dev Returns true on success, throws otherwise\n\t *\n\t * @param _from token owner which approved caller (transaction sender)\n\t *      to transfer `_value` of tokens on its behalf\n\t * @param _to an address to transfer tokens to,\n\t *      must be a smart contract, implementing ERC1363Receiver\n\t * @param _value amount of tokens to be transferred,, zero\n\t *      value is allowed\n\t * @param _data [optional] additional data with no specified format,\n\t *      sent in onTransferReceived call to `_to`\n\t * @return true unless throwing\n\t */\n\tfunction transferFromAndCall(address _from, address _to, uint256 _value, bytes memory _data) public override returns (bool) {\n\t\t// ensure ERC-1363 transfers are enabled\n\t\trequire(isFeatureEnabled(FEATURE_ERC1363_TRANSFERS), \"ERC1363 transfers are disabled\");\n\n\t\t// first delegate call to `unsafeTransferFrom` to perform the unsafe token(s) transfer\n\t\tunsafeTransferFrom(_from, _to, _value);\n\n\t\t// after the successful transfer - check if receiver supports\n\t\t// ERC1363Receiver and execute a callback handler `onTransferReceived`,\n\t\t// reverting whole transaction on any error\n\t\t_notifyTransferred(_from, _to, _value, _data, false);\n\n\t\t// function throws on any error, so if we're here - it means operation successful, just return true\n\t\treturn true;\n\t}\n\n\t/**\n\t * @notice Approves address called `_spender` to transfer some amount\n\t *      of tokens on behalf of the owner, then executes a `onApprovalReceived` callback on `_spender`\n\t *\n\t * @inheritdoc ERC1363\n\t *\n\t * @dev Caller must not necessarily own any tokens to grant the permission\n\t *\n\t * @dev Throws if `_spender` is an EOA or a smart contract which doesn't support ERC1363Spender interface\n\t *\n\t * @param _spender an address approved by the caller (token owner)\n\t *      to spend some tokens on its behalf\n\t * @param _value an amount of tokens spender `_spender` is allowed to\n\t *      transfer on behalf of the token owner\n\t * @return true unless throwing\n\t */\n\tfunction approveAndCall(address _spender, uint256 _value) public override returns (bool) {\n\t\t// delegate to `approveAndCall` passing empty data\n\t\treturn approveAndCall(_spender, _value, \"\");\n\t}\n\n\t/**\n\t * @notice Approves address called `_spender` to transfer some amount\n\t *      of tokens on behalf of the owner, then executes a callback on `_spender`\n\t *\n\t * @inheritdoc ERC1363\n\t *\n\t * @dev Caller must not necessarily own any tokens to grant the permission\n\t *\n\t * @param _spender an address approved by the caller (token owner)\n\t *      to spend some tokens on its behalf\n\t * @param _value an amount of tokens spender `_spender` is allowed to\n\t *      transfer on behalf of the token owner\n\t * @param _data [optional] additional data with no specified format,\n\t *      sent in onApprovalReceived call to `_spender`\n\t * @return true unless throwing\n\t */\n\tfunction approveAndCall(address _spender, uint256 _value, bytes memory _data) public override returns (bool) {\n\t\t// ensure ERC-1363 approvals are enabled\n\t\trequire(isFeatureEnabled(FEATURE_ERC1363_APPROVALS), \"ERC1363 approvals are disabled\");\n\n\t\t// execute regular ERC20 approve - delegate to `approve`\n\t\tapprove(_spender, _value);\n\n\t\t// after the successful approve - check if receiver supports\n\t\t// ERC1363Spender and execute a callback handler `onApprovalReceived`,\n\t\t// reverting whole transaction on any error\n\t\t_notifyApproved(_spender, _value, _data);\n\n\t\t// function throws on any error, so if we're here - it means operation successful, just return true\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Auxiliary function to invoke `onTransferReceived` on a target address\n\t *      The call is not executed if the target address is not a contract; in such\n\t *      a case function throws if `allowEoa` is set to false, succeeds if it's true\n\t *\n\t * @dev Throws on any error; returns silently on success\n\t *\n\t * @param _from representing the previous owner of the given token value\n\t * @param _to target address that will receive the tokens\n\t * @param _value the amount mount of tokens to be transferred\n\t * @param _data [optional] data to send along with the call\n\t * @param allowEoa indicates if function should fail if `_to` is an EOA\n\t */\n\tfunction _notifyTransferred(address _from, address _to, uint256 _value, bytes memory _data, bool allowEoa) private {\n\t\t// if recipient `_to` is EOA\n\t\tif (!AddressUtils.isContract(_to)) {\n\t\t\t// ensure EOA recipient is allowed\n\t\t\trequire(allowEoa, \"EOA recipient\");\n\n\t\t\t// exit if successful\n\t\t\treturn;\n\t\t}\n\n\t\t// otherwise - if `_to` is a contract - execute onTransferReceived\n\t\tbytes4 response = ERC1363Receiver(_to).onTransferReceived(msg.sender, _from, _value, _data);\n\n\t\t// expected response is ERC1363Receiver(_to).onTransferReceived.selector\n\t\t// bytes4(keccak256(\"onTransferReceived(address,address,uint256,bytes)\"))\n\t\trequire(response == ERC1363Receiver(_to).onTransferReceived.selector, \"invalid onTransferReceived response\");\n\t}\n\n\t/**\n\t * @dev Auxiliary function to invoke `onApprovalReceived` on a target address\n\t *      The call is not executed if the target address is not a contract; in such\n\t *      a case function throws if `allowEoa` is set to false, succeeds if it's true\n\t *\n\t * @dev Throws on any error; returns silently on success\n\t *\n\t * @param _spender the address which will spend the funds\n\t * @param _value the amount of tokens to be spent\n\t * @param _data [optional] data to send along with the call\n\t */\n\tfunction _notifyApproved(address _spender, uint256 _value, bytes memory _data) private {\n\t\t// ensure recipient is not EOA\n\t\trequire(AddressUtils.isContract(_spender), \"EOA spender\");\n\n\t\t// otherwise - if `_to` is a contract - execute onApprovalReceived\n\t\tbytes4 response = ERC1363Spender(_spender).onApprovalReceived(msg.sender, _value, _data);\n\n\t\t// expected response is ERC1363Spender(_to).onApprovalReceived.selector\n\t\t// bytes4(keccak256(\"onApprovalReceived(address,uint256,bytes)\"))\n\t\trequire(response == ERC1363Spender(_spender).onApprovalReceived.selector, \"invalid onApprovalReceived response\");\n\t}\n\t// ===== End: ERC-1363 functions =====\n\n\t// ===== Start: ERC20 functions =====\n\n\t/**\n\t * @notice Gets the balance of a particular address\n\t *\n\t * @inheritdoc ERC20\n\t *\n\t * @param _owner the address to query the the balance for\n\t * @return balance an amount of tokens owned by the address specified\n\t */\n\tfunction balanceOf(address _owner) public view override returns (uint256 balance) {\n\t\t// read the balance and return\n\t\treturn tokenBalances[_owner];\n\t}\n\n\t/**\n\t * @notice Transfers some tokens to an external address or a smart contract\n\t *\n\t * @inheritdoc ERC20\n\t *\n\t * @dev Called by token owner (an address which has a\n\t *      positive token balance tracked by this smart contract)\n\t * @dev Throws on any error like\n\t *      * insufficient token balance or\n\t *      * incorrect `_to` address:\n\t *          * zero address or\n\t *          * self address or\n\t *          * smart contract which doesn't support ERC20\n\t *\n\t * @param _to an address to transfer tokens to,\n\t *      must be either an external address or a smart contract,\n\t *      compliant with the ERC20 standard\n\t * @param _value amount of tokens to be transferred,, zero\n\t *      value is allowed\n\t * @return success true on success, throws otherwise\n\t */\n\tfunction transfer(address _to, uint256 _value) public override returns (bool success) {\n\t\t// just delegate call to `transferFrom`,\n\t\t// `FEATURE_TRANSFERS` is verified inside it\n\t\treturn transferFrom(msg.sender, _to, _value);\n\t}\n\n\t/**\n\t * @notice Transfers some tokens on behalf of address `_from' (token owner)\n\t *      to some other address `_to`\n\t *\n\t * @inheritdoc ERC20\n\t *\n\t * @dev Called by token owner on his own or approved address,\n\t *      an address approved earlier by token owner to\n\t *      transfer some amount of tokens on its behalf\n\t * @dev Throws on any error like\n\t *      * insufficient token balance or\n\t *      * incorrect `_to` address:\n\t *          * zero address or\n\t *          * same as `_from` address (self transfer)\n\t *          * smart contract which doesn't support ERC20\n\t *\n\t * @param _from token owner which approved caller (transaction sender)\n\t *      to transfer `_value` of tokens on its behalf\n\t * @param _to an address to transfer tokens to,\n\t *      must be either an external address or a smart contract,\n\t *      compliant with the ERC20 standard\n\t * @param _value amount of tokens to be transferred,, zero\n\t *      value is allowed\n\t * @return success true on success, throws otherwise\n\t */\n\tfunction transferFrom(address _from, address _to, uint256 _value) public override returns (bool success) {\n\t\t// depending on `FEATURE_UNSAFE_TRANSFERS` we execute either safe (default)\n\t\t// or unsafe transfer\n\t\t// if `FEATURE_UNSAFE_TRANSFERS` is enabled\n\t\t// or receiver has `ROLE_ERC20_RECEIVER` permission\n\t\t// or sender has `ROLE_ERC20_SENDER` permission\n\t\tif(isFeatureEnabled(FEATURE_UNSAFE_TRANSFERS)\n\t\t\t|| isOperatorInRole(_to, ROLE_ERC20_RECEIVER)\n\t\t\t|| isSenderInRole(ROLE_ERC20_SENDER)) {\n\t\t\t// we execute unsafe transfer - delegate call to `unsafeTransferFrom`,\n\t\t\t// `FEATURE_TRANSFERS` is verified inside it\n\t\t\tunsafeTransferFrom(_from, _to, _value);\n\t\t}\n\t\t// otherwise - if `FEATURE_UNSAFE_TRANSFERS` is disabled\n\t\t// and receiver doesn't have `ROLE_ERC20_RECEIVER` permission\n\t\telse {\n\t\t\t// we execute safe transfer - delegate call to `safeTransferFrom`, passing empty `_data`,\n\t\t\t// `FEATURE_TRANSFERS` is verified inside it\n\t\t\tsafeTransferFrom(_from, _to, _value, \"\");\n\t\t}\n\n\t\t// both `unsafeTransferFrom` and `safeTransferFrom` throw on any error, so\n\t\t// if we're here - it means operation successful,\n\t\t// just return true\n\t\treturn true;\n\t}\n\n\t/**\n\t * @notice Transfers some tokens on behalf of address `_from' (token owner)\n\t *      to some other address `_to` and then executes `onTransferReceived` callback\n\t *      on the receiver if it is a smart contract (not an EOA)\n\t *\n\t * @dev Called by token owner on his own or approved address,\n\t *      an address approved earlier by token owner to\n\t *      transfer some amount of tokens on its behalf\n\t * @dev Throws on any error like\n\t *      * insufficient token balance or\n\t *      * incorrect `_to` address:\n\t *          * zero address or\n\t *          * same as `_from` address (self transfer)\n\t *          * smart contract which doesn't support ERC1363Receiver interface\n\t * @dev Returns true on success, throws otherwise\n\t *\n\t * @param _from token owner which approved caller (transaction sender)\n\t *      to transfer `_value` of tokens on its behalf\n\t * @param _to an address to transfer tokens to,\n\t *      must be either an external address or a smart contract,\n\t *      implementing ERC1363Receiver\n\t * @param _value amount of tokens to be transferred,, zero\n\t *      value is allowed\n\t * @param _data [optional] additional data with no specified format,\n\t *      sent in onTransferReceived call to `_to` in case if its a smart contract\n\t * @return true unless throwing\n\t */\n\tfunction safeTransferFrom(address _from, address _to, uint256 _value, bytes memory _data) public returns (bool) {\n\t\t// first delegate call to `unsafeTransferFrom` to perform the unsafe token(s) transfer\n\t\tunsafeTransferFrom(_from, _to, _value);\n\n\t\t// after the successful transfer - check if receiver supports\n\t\t// ERC1363Receiver and execute a callback handler `onTransferReceived`,\n\t\t// reverting whole transaction on any error\n\t\t_notifyTransferred(_from, _to, _value, _data, true);\n\n\t\t// function throws on any error, so if we're here - it means operation successful, just return true\n\t\treturn true;\n\t}\n\n\t/**\n\t * @notice Transfers some tokens on behalf of address `_from' (token owner)\n\t *      to some other address `_to`\n\t *\n\t * @dev In contrast to `transferFromAndCall` doesn't check recipient\n\t *      smart contract to support ERC20 tokens (ERC1363Receiver)\n\t * @dev Designed to be used by developers when the receiver is known\n\t *      to support ERC20 tokens but doesn't implement ERC1363Receiver interface\n\t * @dev Called by token owner on his own or approved address,\n\t *      an address approved earlier by token owner to\n\t *      transfer some amount of tokens on its behalf\n\t * @dev Throws on any error like\n\t *      * insufficient token balance or\n\t *      * incorrect `_to` address:\n\t *          * zero address or\n\t *          * same as `_from` address (self transfer)\n\t * @dev Returns silently on success, throws otherwise\n\t *\n\t * @param _from token sender, token owner which approved caller (transaction sender)\n\t *      to transfer `_value` of tokens on its behalf\n\t * @param _to token receiver, an address to transfer tokens to\n\t * @param _value amount of tokens to be transferred,, zero\n\t *      value is allowed\n\t */\n\tfunction unsafeTransferFrom(address _from, address _to, uint256 _value) public {\n\t\t// make an internal transferFrom - delegate to `__transferFrom`\n\t\t__transferFrom(msg.sender, _from, _to, _value);\n\t}\n\n\t/**\n\t * @dev Powers the meta transactions for `unsafeTransferFrom` - EIP-3009 `transferWithAuthorization`\n\t *      and `receiveWithAuthorization`\n\t *\n\t * @dev See `unsafeTransferFrom` and `transferFrom` soldoc for details\n\t *\n\t * @param _by an address executing the transfer, it can be token owner itself,\n\t *      or an operator previously approved with `approve()`\n\t * @param _from token sender, token owner which approved caller (transaction sender)\n\t *      to transfer `_value` of tokens on its behalf\n\t * @param _to token receiver, an address to transfer tokens to\n\t * @param _value amount of tokens to be transferred,, zero\n\t *      value is allowed\n\t */\n\tfunction __transferFrom(address _by, address _from, address _to, uint256 _value) private {\n\t\t// if `_from` is equal to sender, require transfers feature to be enabled\n\t\t// otherwise require transfers on behalf feature to be enabled\n\t\trequire(_from == _by && isFeatureEnabled(FEATURE_TRANSFERS)\n\t\t     || _from != _by && isFeatureEnabled(FEATURE_TRANSFERS_ON_BEHALF),\n\t\t        _from == _by? \"transfers are disabled\": \"transfers on behalf are disabled\");\n\n\t\t// non-zero source address check - Zeppelin\n\t\t// obviously, zero source address is a client mistake\n\t\t// it's not part of ERC20 standard but it's reasonable to fail fast\n\t\t// since for zero value transfer transaction succeeds otherwise\n\t\trequire(_from != address(0), \"transfer from the zero address\");\n\n\t\t// non-zero recipient address check\n\t\trequire(_to != address(0), \"transfer to the zero address\");\n\n\t\t// according to the Ethereum ERC20 token standard, it is possible to transfer\n\t\t// tokens to oneself using the transfer or transferFrom functions.\n\t\t// In both cases, the transfer will succeed as long as the sender has a sufficient balance of tokens.\n\t\t// require(_from != _to, \"sender and recipient are the same (_from = _to)\");\n\n\t\t// sending tokens to the token smart contract itself is a client mistake\n\t\trequire(_to != address(this), \"invalid recipient (transfer to the token smart contract itself)\");\n\n\t\t// according to ERC-20 Token Standard, https://eips.ethereum.org/EIPS/eip-20\n\t\t// \"Transfers of 0 values MUST be treated as normal transfers and fire the Transfer event.\"\n\t\tif(_value == 0) {\n\t\t\t// emit an improved transfer event (arXiv:1907.00903)\n\t\t\temit Transfer(_by, _from, _to, _value);\n\n\t\t\t// emit an ERC20 transfer event\n\t\t\temit Transfer(_from, _to, _value);\n\n\t\t\t// don't forget to return - we're done\n\t\t\treturn;\n\t\t}\n\n\t\t// no need to make arithmetic overflow check on the _value - by design of mint()\n\n\t\t// in case of transfer on behalf\n\t\tif(_from != _by) {\n\t\t\t// read allowance value - the amount of tokens allowed to transfer - into the stack\n\t\t\tuint256 _allowance = transferAllowances[_from][_by];\n\n\t\t\t// verify sender has an allowance to transfer amount of tokens requested\n\t\t\trequire(_allowance >= _value, \"transfer amount exceeds allowance\");\n\n\t\t\t// we treat max uint256 allowance value as an \"unlimited\" and\n\t\t\t// do not decrease allowance when it is set to \"unlimited\" value\n\t\t\tif(_allowance < type(uint256).max) {\n\t\t\t\t// update allowance value on the stack\n\t\t\t\t_allowance -= _value;\n\n\t\t\t\t// update the allowance value in storage\n\t\t\t\ttransferAllowances[_from][_by] = _allowance;\n\n\t\t\t\t// emit an improved atomic approve event\n\t\t\t\temit Approval(_from, _by, _allowance + _value, _allowance);\n\n\t\t\t\t// emit an ERC20 approval event to reflect the decrease\n\t\t\t\temit Approval(_from, _by, _allowance);\n\t\t\t}\n\t\t}\n\n\t\t// verify sender has enough tokens to transfer on behalf\n\t\trequire(tokenBalances[_from] >= _value, \"transfer amount exceeds balance\");\n\n\t\t// perform the transfer:\n\t\t// decrease token owner (sender) balance\n\t\ttokenBalances[_from] -= _value;\n\n\t\t// increase `_to` address (receiver) balance\n\t\ttokenBalances[_to] += _value;\n\n\t\t// move voting power associated with the tokens transferred\n\t\t__moveVotingPower(_by, votingDelegates[_from], votingDelegates[_to], _value);\n\n\t\t// emit an improved transfer event (arXiv:1907.00903)\n\t\temit Transfer(_by, _from, _to, _value);\n\n\t\t// emit an ERC20 transfer event\n\t\temit Transfer(_from, _to, _value);\n\t}\n\n\t/**\n\t * @notice Approves address called `_spender` to transfer some amount\n\t *      of tokens on behalf of the owner (transaction sender)\n\t *\n\t * @inheritdoc ERC20\n\t *\n\t * @dev Transaction sender must not necessarily own any tokens to grant the permission\n\t *\n\t * @param _spender an address approved by the caller (token owner)\n\t *      to spend some tokens on its behalf\n\t * @param _value an amount of tokens spender `_spender` is allowed to\n\t *      transfer on behalf of the token owner\n\t * @return success true on success, throws otherwise\n\t */\n\tfunction approve(address _spender, uint256 _value) public override returns (bool success) {\n\t\t// make an internal approve - delegate to `__approve`\n\t\t__approve(msg.sender, _spender, _value);\n\n\t\t// operation successful, return true\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Powers the meta transaction for `approve` - EIP-2612 `permit`\n\t *\n\t * @dev Approves address called `_spender` to transfer some amount\n\t *      of tokens on behalf of the `_owner`\n\t *\n\t * @dev `_owner` must not necessarily own any tokens to grant the permission\n\t * @dev Throws if `_spender` is a zero address\n\t *\n\t * @param _owner owner of the tokens to set approval on behalf of\n\t * @param _spender an address approved by the token owner\n\t *      to spend some tokens on its behalf\n\t * @param _value an amount of tokens spender `_spender` is allowed to\n\t *      transfer on behalf of the token owner\n\t */\n\tfunction __approve(address _owner, address _spender, uint256 _value) private {\n\t\t// non-zero spender address check - Zeppelin\n\t\t// obviously, zero spender address is a client mistake\n\t\t// it's not part of ERC20 standard but it's reasonable to fail fast\n\t\trequire(_spender != address(0), \"approve to the zero address\");\n\n\t\t// read old approval value to emmit an improved event (arXiv:1907.00903)\n\t\tuint256 _oldValue = transferAllowances[_owner][_spender];\n\n\t\t// perform an operation: write value requested into the storage\n\t\ttransferAllowances[_owner][_spender] = _value;\n\n\t\t// emit an improved atomic approve event (arXiv:1907.00903)\n\t\temit Approval(_owner, _spender, _oldValue, _value);\n\n\t\t// emit an ERC20 approval event\n\t\temit Approval(_owner, _spender, _value);\n\t}\n\n\t/**\n\t * @notice Returns the amount which _spender is still allowed to withdraw from _owner.\n\t *\n\t * @inheritdoc ERC20\n\t *\n\t * @dev A function to check an amount of tokens owner approved\n\t *      to transfer on its behalf by some other address called \"spender\"\n\t *\n\t * @param _owner an address which approves transferring some tokens on its behalf\n\t * @param _spender an address approved to transfer some tokens on behalf\n\t * @return remaining an amount of tokens approved address `_spender` can transfer on behalf\n\t *      of token owner `_owner`\n\t */\n\tfunction allowance(address _owner, address _spender) public view override returns (uint256 remaining) {\n\t\t// read the value from storage and return\n\t\treturn transferAllowances[_owner][_spender];\n\t}\n\n\t// ===== End: ERC20 functions =====\n\n\t// ===== Start: Resolution for the Multiple Withdrawal Attack on ERC20 Tokens (arXiv:1907.00903) =====\n\n\t/**\n\t * @notice Increases the allowance granted to `spender` by the transaction sender\n\t *\n\t * @dev Resolution for the Multiple Withdrawal Attack on ERC20 Tokens (arXiv:1907.00903)\n\t *\n\t * @dev Throws if value to increase by is zero or too big and causes arithmetic overflow\n\t *\n\t * @param _spender an address approved by the caller (token owner)\n\t *      to spend some tokens on its behalf\n\t * @param _value an amount of tokens to increase by\n\t * @return true unless throwing\n\t */\n\tfunction increaseAllowance(address _spender, uint256 _value) public returns (bool) {\n\t\t// read current allowance value\n\t\tuint256 currentVal = transferAllowances[msg.sender][_spender];\n\n\t\t// non-zero _value and arithmetic overflow check on the allowance\n\t\tunchecked {\n\t\t\t// put operation into unchecked block to display user-friendly overflow error message for Solidity 0.8+\n\t\t\trequire(currentVal + _value > currentVal, \"zero value approval increase or arithmetic overflow\");\n\t\t}\n\n\t\t// delegate call to `approve` with the new value\n\t\treturn approve(_spender, currentVal + _value);\n\t}\n\n\t/**\n\t * @notice Decreases the allowance granted to `spender` by the caller.\n\t *\n\t * @dev Resolution for the Multiple Withdrawal Attack on ERC20 Tokens (arXiv:1907.00903)\n\t *\n\t * @dev Throws if value to decrease by is zero or is greater than currently allowed value\n\t *\n\t * @param _spender an address approved by the caller (token owner)\n\t *      to spend some tokens on its behalf\n\t * @param _value an amount of tokens to decrease by\n\t * @return true unless throwing\n\t */\n\tfunction decreaseAllowance(address _spender, uint256 _value) public returns (bool) {\n\t\t// read current allowance value\n\t\tuint256 currentVal = transferAllowances[msg.sender][_spender];\n\n\t\t// non-zero _value check on the allowance\n\t\trequire(_value > 0, \"zero value approval decrease\");\n\n\t\t// verify allowance decrease doesn't underflow\n\t\trequire(currentVal >= _value, \"ERC20: decreased allowance below zero\");\n\n\t\t// delegate call to `approve` with the new value\n\t\treturn approve(_spender, currentVal - _value);\n\t}\n\n\t// ===== End: Resolution for the Multiple Withdrawal Attack on ERC20 Tokens (arXiv:1907.00903) =====\n\n\t// ===== Start: Minting/burning extension =====\n\n\t/**\n\t * @dev Mints (creates) some tokens to address specified\n\t * @dev The value specified is treated as is without taking\n\t *      into account what `decimals` value is\n\t *\n\t * @dev Requires executor to have `ROLE_TOKEN_CREATOR` permission\n\t *\n\t * @dev Throws on overflow, if totalSupply + _value doesn't fit into uint192\n\t *\n\t * @param _to an address to mint tokens to\n\t * @param _value an amount of tokens to mint (create)\n\t */\n\tfunction mint(address _to, uint256 _value) public virtual {\n\t\t// check if caller has sufficient permissions to mint tokens\n\t\trequire(isSenderInRole(ROLE_TOKEN_CREATOR), \"access denied\");\n\n\t\t// delegate call to unsafe `__mint`\n\t\t__mint(_to, _value);\n\t}\n\n\t/**\n\t * @dev Mints (creates) some tokens to address specified\n\t * @dev The value specified is treated as is without taking\n\t *      into account what `decimals` value is\n\t *\n\t * @dev Unsafe: doesn't verify the executor (msg.sender) permissions,\n\t *      must be kept private at all times\n\t *\n\t * @dev Throws on overflow, if totalSupply + _value doesn't fit into uint256\n\t *\n\t * @param _to an address to mint tokens to\n\t * @param _value an amount of tokens to mint (create)\n\t */\n\tfunction __mint(address _to, uint256 _value) private {\n\t\t// non-zero recipient address check\n\t\trequire(_to != address(0), \"zero address\");\n\n\t\t// non-zero _value and arithmetic overflow check on the total supply\n\t\t// this check automatically secures arithmetic overflow on the individual balance\n\t\tunchecked {\n\t\t\t// put operation into unchecked block to display user-friendly overflow error message for Solidity 0.8+\n\t\t\trequire(totalSupply + _value > totalSupply, \"zero value or arithmetic overflow\");\n\t\t}\n\n\t\t// uint192 overflow check (required by voting delegation)\n\t\trequire(totalSupply + _value <= type(uint192).max, \"total supply overflow (uint192)\");\n\n\t\t// perform mint:\n\t\t// increase total amount of tokens value\n\t\ttotalSupply += _value;\n\n\t\t// increase `_to` address balance\n\t\ttokenBalances[_to] += _value;\n\n\t\t// update total token supply history\n\t\t__updateHistory(totalSupplyHistory, add, _value);\n\n\t\t// create voting power associated with the tokens minted\n\t\t__moveVotingPower(msg.sender, address(0), votingDelegates[_to], _value);\n\n\t\t// fire a minted event\n\t\temit Minted(msg.sender, _to, _value);\n\n\t\t// emit an improved transfer event (arXiv:1907.00903)\n\t\temit Transfer(msg.sender, address(0), _to, _value);\n\n\t\t// fire ERC20 compliant transfer event\n\t\temit Transfer(address(0), _to, _value);\n\t}\n\n\t/**\n\t * @dev Burns (destroys) some tokens from the address specified\n\t *\n\t * @dev The value specified is treated as is without taking\n\t *      into account what `decimals` value is\n\t *\n\t * @dev Requires executor to have `ROLE_TOKEN_DESTROYER` permission\n\t *      or FEATURE_OWN_BURNS/FEATURE_BURNS_ON_BEHALF features to be enabled\n\t *\n\t * @dev Can be disabled by the contract creator forever by disabling\n\t *      FEATURE_OWN_BURNS/FEATURE_BURNS_ON_BEHALF features and then revoking\n\t *      its own roles to burn tokens and to enable burning features\n\t *\n\t * @param _from an address to burn some tokens from\n\t * @param _value an amount of tokens to burn (destroy)\n\t */\n\tfunction burn(address _from, uint256 _value) public virtual {\n\t\t// check if caller has sufficient permissions to burn tokens\n\t\t// and if not - check for possibility to burn own tokens or to burn on behalf\n\t\tif(!isSenderInRole(ROLE_TOKEN_DESTROYER)) {\n\t\t\t// if `_from` is equal to sender, require own burns feature to be enabled\n\t\t\t// otherwise require burns on behalf feature to be enabled\n\t\t\trequire(_from == msg.sender && isFeatureEnabled(FEATURE_OWN_BURNS)\n\t\t\t     || _from != msg.sender && isFeatureEnabled(FEATURE_BURNS_ON_BEHALF),\n\t\t\t        _from == msg.sender? \"burns are disabled\": \"burns on behalf are disabled\");\n\n\t\t\t// in case of burn on behalf\n\t\t\tif(_from != msg.sender) {\n\t\t\t\t// read allowance value - the amount of tokens allowed to be burnt - into the stack\n\t\t\t\tuint256 _allowance = transferAllowances[_from][msg.sender];\n\n\t\t\t\t// verify sender has an allowance to burn amount of tokens requested\n\t\t\t\trequire(_allowance >= _value, \"burn amount exceeds allowance\");\n\n\t\t\t\t// we treat max uint256 allowance value as an \"unlimited\" and\n\t\t\t\t// do not decrease allowance when it is set to \"unlimited\" value\n\t\t\t\tif(_allowance < type(uint256).max) {\n\t\t\t\t\t// update allowance value on the stack\n\t\t\t\t\t_allowance -= _value;\n\n\t\t\t\t\t// update the allowance value in storage\n\t\t\t\t\ttransferAllowances[_from][msg.sender] = _allowance;\n\n\t\t\t\t\t// emit an improved atomic approve event (arXiv:1907.00903)\n\t\t\t\t\temit Approval(msg.sender, _from, _allowance + _value, _allowance);\n\n\t\t\t\t\t// emit an ERC20 approval event to reflect the decrease\n\t\t\t\t\temit Approval(_from, msg.sender, _allowance);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// at this point we know that either sender is ROLE_TOKEN_DESTROYER or\n\t\t// we burn own tokens or on behalf (in latest case we already checked and updated allowances)\n\t\t// we have left to execute balance checks and burning logic itself\n\n\t\t// non-zero burn value check\n\t\trequire(_value != 0, \"zero value burn\");\n\n\t\t// non-zero source address check - Zeppelin\n\t\trequire(_from != address(0), \"burn from the zero address\");\n\n\t\t// verify `_from` address has enough tokens to destroy\n\t\t// (basically this is a arithmetic overflow check)\n\t\trequire(tokenBalances[_from] >= _value, \"burn amount exceeds balance\");\n\n\t\t// perform burn:\n\t\t// decrease `_from` address balance\n\t\ttokenBalances[_from] -= _value;\n\n\t\t// decrease total amount of tokens value\n\t\ttotalSupply -= _value;\n\n\t\t// update total token supply history\n\t\t__updateHistory(totalSupplyHistory, sub, _value);\n\n\t\t// destroy voting power associated with the tokens burnt\n\t\t__moveVotingPower(msg.sender, votingDelegates[_from], address(0), _value);\n\n\t\t// fire a burnt event\n\t\temit Burnt(msg.sender, _from, _value);\n\n\t\t// emit an improved transfer event (arXiv:1907.00903)\n\t\temit Transfer(msg.sender, _from, address(0), _value);\n\n\t\t// fire ERC20 compliant transfer event\n\t\temit Transfer(_from, address(0), _value);\n\t}\n\n\t// ===== End: Minting/burning extension =====\n\n\t// ===== Start: EIP-2612 functions =====\n\n\t/**\n\t * @inheritdoc EIP2612\n\t *\n\t * @dev Executes approve(_spender, _value) on behalf of the owner who EIP-712\n\t *      signed the transaction, i.e. as if transaction sender is the EIP712 signer\n\t *\n\t * @dev Sets the `_value` as the allowance of `_spender` over `_owner` tokens,\n\t *      given `_owner` EIP-712 signed approval\n\t *\n\t * @dev Inherits the Multiple Withdrawal Attack on ERC20 Tokens (arXiv:1907.00903)\n\t *      vulnerability in the same way as ERC20 `approve`, use standard ERC20 workaround\n\t *      if this might become an issue:\n\t *      https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit\n\t *\n\t * @dev Emits `Approval` event(s) in the same way as `approve` does\n\t *\n\t * @dev Requires:\n\t *     - `_spender` to be non-zero address\n\t *     - `_exp` to be a timestamp in the future\n\t *     - `v`, `r` and `s` to be a valid `secp256k1` signature from `_owner`\n\t *        over the EIP712-formatted function arguments.\n\t *     - the signature to use `_owner` current nonce (see `nonces`).\n\t *\n\t * @dev For more information on the signature format, see the\n\t *      https://eips.ethereum.org/EIPS/eip-2612#specification\n\t *\n\t * @param _owner owner of the tokens to set approval on behalf of,\n\t *      an address which signed the EIP-712 message\n\t * @param _spender an address approved by the token owner\n\t *      to spend some tokens on its behalf\n\t * @param _value an amount of tokens spender `_spender` is allowed to\n\t *      transfer on behalf of the token owner\n\t * @param _exp signature expiration time (unix timestamp)\n\t * @param v the recovery byte of the signature\n\t * @param r half of the ECDSA signature pair\n\t * @param s half of the ECDSA signature pair\n\t */\n\tfunction permit(address _owner, address _spender, uint256 _value, uint256 _exp, uint8 v, bytes32 r, bytes32 s) public override {\n\t\t// verify permits are enabled\n\t\trequire(isFeatureEnabled(FEATURE_EIP2612_PERMITS), \"EIP2612 permits are disabled\");\n\n\t\t// derive signer of the EIP712 Permit message, and\n\t\t// update the nonce for that particular signer to avoid replay attack!!! --------->>> ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓\n\t\taddress signer = __deriveSigner(abi.encode(PERMIT_TYPEHASH, _owner, _spender, _value, nonces[_owner]++, _exp), v, r, s);\n\n\t\t// perform message integrity and security validations\n\t\trequire(signer == _owner, \"invalid signature\");\n\t\trequire(block.timestamp < _exp, \"signature expired\");\n\n\t\t// delegate call to `__approve` - execute the logic required\n\t\t__approve(_owner, _spender, _value);\n\t}\n\n\t// ===== End: EIP-2612 functions =====\n\n\t// ===== Start: EIP-3009 functions =====\n\n\t/**\n\t * @inheritdoc EIP3009\n\t *\n\t * @notice Checks if specified nonce was already used\n\t *\n\t * @dev Nonces are expected to be client-side randomly generated 32-byte values\n\t *      unique to the authorizer's address\n\t *\n\t * @dev Alias for usedNonces(authorizer, nonce)\n\t *\n\t * @param _authorizer an address to check nonce for\n\t * @param _nonce a nonce to check\n\t * @return true if the nonce was used, false otherwise\n\t */\n\tfunction authorizationState(address _authorizer, bytes32 _nonce) public override view returns (bool) {\n\t\t// simply return the value from the mapping\n\t\treturn usedNonces[_authorizer][_nonce];\n\t}\n\n\t/**\n\t * @inheritdoc EIP3009\n\t *\n\t * @notice Execute a transfer with a signed authorization\n\t *\n\t * @param _from token sender and transaction authorizer\n\t * @param _to token receiver\n\t * @param _value amount to be transferred\n\t * @param _validAfter signature valid after time (unix timestamp)\n\t * @param _validBefore signature valid before time (unix timestamp)\n\t * @param _nonce unique random nonce\n\t * @param v the recovery byte of the signature\n\t * @param r half of the ECDSA signature pair\n\t * @param s half of the ECDSA signature pair\n\t */\n\tfunction transferWithAuthorization(\n\t\taddress _from,\n\t\taddress _to,\n\t\tuint256 _value,\n\t\tuint256 _validAfter,\n\t\tuint256 _validBefore,\n\t\tbytes32 _nonce,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) public override {\n\t\t// ensure EIP-3009 transfers are enabled\n\t\trequire(isFeatureEnabled(FEATURE_EIP3009_TRANSFERS), \"EIP3009 transfers are disabled\");\n\n\t\t// derive signer of the EIP712 TransferWithAuthorization message\n\t\taddress signer = __deriveSigner(abi.encode(TRANSFER_WITH_AUTHORIZATION_TYPEHASH, _from, _to, _value, _validAfter, _validBefore, _nonce), v, r, s);\n\n\t\t// perform message integrity and security validations\n\t\trequire(signer == _from, \"invalid signature\");\n\t\trequire(block.timestamp > _validAfter, \"signature not yet valid\");\n\t\trequire(block.timestamp < _validBefore, \"signature expired\");\n\n\t\t// use the nonce supplied (verify, mark as used, emit event)\n\t\t__useNonce(_from, _nonce, false);\n\n\t\t// delegate call to `__transferFrom` - execute the logic required\n\t\t__transferFrom(signer, _from, _to, _value);\n\t}\n\n\t/**\n\t * @inheritdoc EIP3009\n\t *\n\t * @notice Receive a transfer with a signed authorization from the payer\n\t *\n\t * @dev This has an additional check to ensure that the payee's address\n\t *      matches the caller of this function to prevent front-running attacks.\n\t *\n\t * @param _from token sender and transaction authorizer\n\t * @param _to token receiver\n\t * @param _value amount to be transferred\n\t * @param _validAfter signature valid after time (unix timestamp)\n\t * @param _validBefore signature valid before time (unix timestamp)\n\t * @param _nonce unique random nonce\n\t * @param v the recovery byte of the signature\n\t * @param r half of the ECDSA signature pair\n\t * @param s half of the ECDSA signature pair\n\t */\n\tfunction receiveWithAuthorization(\n\t\taddress _from,\n\t\taddress _to,\n\t\tuint256 _value,\n\t\tuint256 _validAfter,\n\t\tuint256 _validBefore,\n\t\tbytes32 _nonce,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) public override {\n\t\t// verify EIP3009 receptions are enabled\n\t\trequire(isFeatureEnabled(FEATURE_EIP3009_RECEPTIONS), \"EIP3009 receptions are disabled\");\n\n\t\t// derive signer of the EIP712 ReceiveWithAuthorization message\n\t\taddress signer = __deriveSigner(abi.encode(RECEIVE_WITH_AUTHORIZATION_TYPEHASH, _from, _to, _value, _validAfter, _validBefore, _nonce), v, r, s);\n\n\t\t// perform message integrity and security validations\n\t\trequire(signer == _from, \"invalid signature\");\n\t\trequire(block.timestamp > _validAfter, \"signature not yet valid\");\n\t\trequire(block.timestamp < _validBefore, \"signature expired\");\n\t\trequire(_to == msg.sender, \"access denied\");\n\n\t\t// use the nonce supplied (verify, mark as used, emit event)\n\t\t__useNonce(_from, _nonce, false);\n\n\t\t// delegate call to `__transferFrom` - execute the logic required\n\t\t__transferFrom(signer, _from, _to, _value);\n\t}\n\n\t/**\n\t * @inheritdoc EIP3009\n\t *\n\t * @notice Attempt to cancel an authorization\n\t *\n\t * @param _authorizer transaction authorizer\n\t * @param _nonce unique random nonce to cancel (mark as used)\n\t * @param v the recovery byte of the signature\n\t * @param r half of the ECDSA signature pair\n\t * @param s half of the ECDSA signature pair\n\t */\n\tfunction cancelAuthorization(\n\t\taddress _authorizer,\n\t\tbytes32 _nonce,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) public override {\n\t\t// derive signer of the EIP712 ReceiveWithAuthorization message\n\t\taddress signer = __deriveSigner(abi.encode(CANCEL_AUTHORIZATION_TYPEHASH, _authorizer, _nonce), v, r, s);\n\n\t\t// perform message integrity and security validations\n\t\trequire(signer == _authorizer, \"invalid signature\");\n\n\t\t// cancel the nonce supplied (verify, mark as used, emit event)\n\t\t__useNonce(_authorizer, _nonce, true);\n\t}\n\n\t/**\n\t * @dev Auxiliary function to verify structured EIP712 message signature and derive its signer\n\t *\n\t * @param abiEncodedTypehash abi.encode of the message typehash together with all its parameters\n\t * @param v the recovery byte of the signature\n\t * @param r half of the ECDSA signature pair\n\t * @param s half of the ECDSA signature pair\n\t */\n\tfunction __deriveSigner(bytes memory abiEncodedTypehash, uint8 v, bytes32 r, bytes32 s) private view returns(address) {\n\t\t// build the EIP-712 hashStruct of the message\n\t\tbytes32 hashStruct = keccak256(abiEncodedTypehash);\n\n\t\t// calculate the EIP-712 digest \"\\x19\\x01\" ‖ domainSeparator ‖ hashStruct(message)\n\t\tbytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR(), hashStruct));\n\n\t\t// recover the address which signed the message with v, r, s\n\t\taddress signer = ECDSA.recover(digest, v, r, s);\n\n\t\t// according to EIP3009 spec, zero address must be rejected when using ecrecover\n\t\t// this check already happened inside `ECDSA.recover`\n\n\t\t// return the signer address derived from the signature\n\t\treturn signer;\n\t}\n\n\t/**\n\t * @dev Auxiliary function to use/cancel the nonce supplied for a given authorizer:\n\t *      1. Verifies the nonce was not used before\n\t *      2. Marks the nonce as used\n\t *      3. Emits an event that the nonce was used/cancelled\n\t *\n\t * @dev Set `_cancellation` to false (default) to use nonce,\n\t *      set `_cancellation` to true to cancel nonce\n\t *\n\t * @dev It is expected that the nonce supplied is a randomly\n\t *      generated uint256 generated by the client\n\t *\n\t * @param _authorizer an address to use/cancel nonce for\n\t * @param _nonce random nonce to use\n\t * @param _cancellation true to emit `AuthorizationCancelled`, false to emit `AuthorizationUsed` event\n\t */\n\tfunction __useNonce(address _authorizer, bytes32 _nonce, bool _cancellation) private {\n\t\t// verify nonce was not used before\n\t\trequire(!usedNonces[_authorizer][_nonce], \"invalid nonce\");\n\n\t\t// update the nonce state to \"used\" for that particular signer to avoid replay attack\n\t\tusedNonces[_authorizer][_nonce] = true;\n\n\t\t// depending on the usage type (use/cancel)\n\t\tif(_cancellation) {\n\t\t\t// emit an event regarding the nonce cancelled\n\t\t\temit AuthorizationCanceled(_authorizer, _nonce);\n\t\t}\n\t\telse {\n\t\t\t// emit an event regarding the nonce used\n\t\t\temit AuthorizationUsed(_authorizer, _nonce);\n\t\t}\n\t}\n\n\t// ===== End: EIP-3009 functions =====\n\n\t// ===== Start: DAO Support (Compound-like voting delegation) =====\n\n\t/**\n\t * @notice Gets current voting power of the account `_of`\n\t *\n\t * @param _of the address of account to get voting power of\n\t * @return current cumulative voting power of the account,\n\t *      sum of token balances of all its voting delegators\n\t */\n\tfunction votingPowerOf(address _of) public view returns (uint256) {\n\t\t// get a link to an array of voting power history records for an address specified\n\t\tKV[] storage history = votingPowerHistory[_of];\n\n\t\t// lookup the history and return latest element\n\t\treturn history.length == 0? 0: history[history.length - 1].v;\n\t}\n\n\t/**\n\t * @notice Gets past voting power of the account `_of` at some block `_blockNum`\n\t *\n\t * @dev Throws if `_blockNum` is not in the past (not the finalized block)\n\t *\n\t * @param _of the address of account to get voting power of\n\t * @param _blockNum block number to get the voting power at\n\t * @return past cumulative voting power of the account,\n\t *      sum of token balances of all its voting delegators at block number `_blockNum`\n\t */\n\tfunction votingPowerAt(address _of, uint256 _blockNum) public view returns (uint256) {\n\t\t// make sure block number is in the past (the finalized block)\n\t\trequire(_blockNum < block.number, \"block not yet mined\"); // Compound msg not yet determined\n\n\t\t// `votingPowerHistory[_of]` is an array ordered by `blockNumber`, ascending;\n\t\t// apply binary search on `votingPowerHistory[_of]` to find such an entry number `i`, that\n\t\t// `votingPowerHistory[_of][i].k <= _blockNum`, but in the same time\n\t\t// `votingPowerHistory[_of][i + 1].k > _blockNum`\n\t\t// return the result - voting power found at index `i`\n\t\treturn __binaryLookup(votingPowerHistory[_of], _blockNum);\n\t}\n\n\t/**\n\t * @dev Reads an entire voting power history array for the delegate specified\n\t *\n\t * @param _of delegate to query voting power history for\n\t * @return voting power history array for the delegate of interest\n\t */\n\tfunction votingPowerHistoryOf(address _of) public view returns(KV[] memory) {\n\t\t// return an entire array as memory\n\t\treturn votingPowerHistory[_of];\n\t}\n\n\t/**\n\t * @dev Returns length of the voting power history array for the delegate specified;\n\t *      useful since reading an entire array just to get its length is expensive (gas cost)\n\t *\n\t * @param _of delegate to query voting power history length for\n\t * @return voting power history array length for the delegate of interest\n\t */\n\tfunction votingPowerHistoryLength(address _of) public view returns(uint256) {\n\t\t// read array length and return\n\t\treturn votingPowerHistory[_of].length;\n\t}\n\n\t/**\n\t * @notice Gets past total token supply value at some block `_blockNum`\n\t *\n\t * @dev Throws if `_blockNum` is not in the past (not the finalized block)\n\t *\n\t * @param _blockNum block number to get the total token supply at\n\t * @return past total token supply at block number `_blockNum`\n\t */\n\tfunction totalSupplyAt(uint256 _blockNum) public view returns(uint256) {\n\t\t// make sure block number is in the past (the finalized block)\n\t\trequire(_blockNum < block.number, \"block not yet mined\");\n\n\t\t// `totalSupplyHistory` is an array ordered by `k`, ascending;\n\t\t// apply binary search on `totalSupplyHistory` to find such an entry number `i`, that\n\t\t// `totalSupplyHistory[i].k <= _blockNum`, but in the same time\n\t\t// `totalSupplyHistory[i + 1].k > _blockNum`\n\t\t// return the result - value `totalSupplyHistory[i].v` found at index `i`\n\t\treturn __binaryLookup(totalSupplyHistory, _blockNum);\n\t}\n\n\t/**\n\t * @dev Reads an entire total token supply history array\n\t *\n\t * @return total token supply history array, a key-value pair array,\n\t *      where key is a block number and value is total token supply at that block\n\t */\n\tfunction entireSupplyHistory() public view returns(KV[] memory) {\n\t\t// return an entire array as memory\n\t\treturn totalSupplyHistory;\n\t}\n\n\t/**\n\t * @dev Returns length of the total token supply history array;\n\t *      useful since reading an entire array just to get its length is expensive (gas cost)\n\t *\n\t * @return total token supply history array\n\t */\n\tfunction totalSupplyHistoryLength() public view returns(uint256) {\n\t\t// read array length and return\n\t\treturn totalSupplyHistory.length;\n\t}\n\n\t/**\n\t * @notice Delegates voting power of the delegator `msg.sender` to the delegate `_to`\n\t *\n\t * @dev Accepts zero value address to delegate voting power to, effectively\n\t *      removing the delegate in that case\n\t *\n\t * @param _to address to delegate voting power to\n\t */\n\tfunction delegate(address _to) public {\n\t\t// verify delegations are enabled\n\t\trequire(isFeatureEnabled(FEATURE_DELEGATIONS), \"delegations are disabled\");\n\t\t// delegate call to `__delegate`\n\t\t__delegate(msg.sender, _to);\n\t}\n\n\t/**\n\t * @dev Powers the meta transaction for `delegate` - `delegateWithAuthorization`\n\t *\n\t * @dev Auxiliary function to delegate delegator's `_from` voting power to the delegate `_to`\n\t * @dev Writes to `votingDelegates` and `votingPowerHistory` mappings\n\t *\n\t * @param _from delegator who delegates his voting power\n\t * @param _to delegate who receives the voting power\n\t */\n\tfunction __delegate(address _from, address _to) private {\n\t\t// read current delegate to be replaced by a new one\n\t\taddress _fromDelegate = votingDelegates[_from];\n\n\t\t// read current voting power (it is equal to token balance)\n\t\tuint256 _value = tokenBalances[_from];\n\n\t\t// reassign voting delegate to `_to`\n\t\tvotingDelegates[_from] = _to;\n\n\t\t// update voting power for `_fromDelegate` and `_to`\n\t\t__moveVotingPower(_from, _fromDelegate, _to, _value);\n\n\t\t// emit an event\n\t\temit DelegateChanged(_from, _fromDelegate, _to);\n\t}\n\n\t/**\n\t * @notice Delegates voting power of the delegator (represented by its signature) to the delegate `_to`\n\t *\n\t * @dev Accepts zero value address to delegate voting power to, effectively\n\t *      removing the delegate in that case\n\t *\n\t * @dev Compliant with EIP-712: Ethereum typed structured data hashing and signing,\n\t *      see https://eips.ethereum.org/EIPS/eip-712\n\t *\n\t * @param _to address to delegate voting power to\n\t * @param _nonce nonce used to construct the signature, and used to validate it;\n\t *      nonce is increased by one after successful signature validation and vote delegation\n\t * @param _exp signature expiration time\n\t * @param v the recovery byte of the signature\n\t * @param r half of the ECDSA signature pair\n\t * @param s half of the ECDSA signature pair\n\t */\n\tfunction delegateWithAuthorization(address _to, bytes32 _nonce, uint256 _exp, uint8 v, bytes32 r, bytes32 s) public {\n\t\t// verify delegations on behalf are enabled\n\t\trequire(isFeatureEnabled(FEATURE_DELEGATIONS_ON_BEHALF), \"delegations on behalf are disabled\");\n\n\t\t// derive signer of the EIP712 Delegation message\n\t\taddress signer = __deriveSigner(abi.encode(DELEGATION_TYPEHASH, _to, _nonce, _exp), v, r, s);\n\n\t\t// perform message integrity and security validations\n\t\trequire(block.timestamp < _exp, \"signature expired\"); // Compound msg\n\n\t\t// use the nonce supplied (verify, mark as used, emit event)\n\t\t__useNonce(signer, _nonce, false);\n\n\t\t// delegate call to `__delegate` - execute the logic required\n\t\t__delegate(signer, _to);\n\t}\n\n\t/**\n\t * @dev Auxiliary function to move voting power `_value`\n\t *      from delegate `_from` to the delegate `_to`\n\t *\n\t * @dev Doesn't have any effect if `_from == _to`, or if `_value == 0`\n\t *\n\t * @param _by an address which executed delegate, mint, burn, or transfer operation\n\t *      which had led to delegate voting power change\n\t * @param _from delegate to move voting power from\n\t * @param _to delegate to move voting power to\n\t * @param _value voting power to move from `_from` to `_to`\n\t */\n\tfunction __moveVotingPower(address _by, address _from, address _to, uint256 _value) private {\n\t\t// if there is no move (`_from == _to`) or there is nothing to move (`_value == 0`)\n\t\tif(_from == _to || _value == 0) {\n\t\t\t// return silently with no action\n\t\t\treturn;\n\t\t}\n\n\t\t// if source address is not zero - decrease its voting power\n\t\tif(_from != address(0)) {\n\t\t\t// get a link to an array of voting power history records for an address specified\n\t\t\tKV[] storage _h = votingPowerHistory[_from];\n\n\t\t\t// update source voting power: decrease by `_value`\n\t\t\t(uint256 _fromVal, uint256 _toVal) = __updateHistory(_h, sub, _value);\n\n\t\t\t// emit an event\n\t\t\temit VotingPowerChanged(_by, _from, _fromVal, _toVal);\n\t\t}\n\n\t\t// if destination address is not zero - increase its voting power\n\t\tif(_to != address(0)) {\n\t\t\t// get a link to an array of voting power history records for an address specified\n\t\t\tKV[] storage _h = votingPowerHistory[_to];\n\n\t\t\t// update destination voting power: increase by `_value`\n\t\t\t(uint256 _fromVal, uint256 _toVal) = __updateHistory(_h, add, _value);\n\n\t\t\t// emit an event\n\t\t\temit VotingPowerChanged(_by, _to, _fromVal, _toVal);\n\t\t}\n\t}\n\n\t/**\n\t * @dev Auxiliary function to append key-value pair to an array,\n\t *      sets the key to the current block number and\n\t *      value as derived\n\t *\n\t * @param _h array of key-value pairs to append to\n\t * @param op a function (add/subtract) to apply\n\t * @param _delta the value for a key-value pair to add/subtract\n\t */\n\tfunction __updateHistory(\n\t\tKV[] storage _h,\n\t\tfunction(uint256,uint256) pure returns(uint256) op,\n\t\tuint256 _delta\n\t) private returns(uint256 _fromVal, uint256 _toVal) {\n\t\t// init the old value - value of the last pair of the array\n\t\t_fromVal = _h.length == 0? 0: _h[_h.length - 1].v;\n\t\t// init the new value - result of the operation on the old value\n\t\t_toVal = op(_fromVal, _delta);\n\n\t\t// if there is an existing voting power value stored for current block\n\t\tif(_h.length != 0 && _h[_h.length - 1].k == block.number) {\n\t\t\t// update voting power which is already stored in the current block\n\t\t\t_h[_h.length - 1].v = uint192(_toVal);\n\t\t}\n\t\t// otherwise - if there is no value stored for current block\n\t\telse {\n\t\t\t// add new element into array representing the value for current block\n\t\t\t_h.push(KV(uint64(block.number), uint192(_toVal)));\n\t\t}\n\t}\n\n\t/**\n\t * @dev Auxiliary function to lookup for a value in a sorted by key (ascending)\n\t *      array of key-value pairs\n\t *\n\t * @dev This function finds a key-value pair element in an array with the closest key\n\t *      to the key of interest (not exceeding that key) and returns the value\n\t *      of the key-value pair element found\n\t *\n\t * @dev An array to search in is a KV[] key-value pair array ordered by key `k`,\n\t *      it is sorted in ascending order (`k` increases as array index increases)\n\t *\n\t * @dev Returns zero for an empty array input regardless of the key input\n\t *\n\t * @param _h an array of key-value pair elements to search in\n\t * @param _k key of interest to look the value for\n\t * @return the value of the key-value pair of the key-value pair element with the closest\n\t *      key to the key of interest (not exceeding that key)\n\t */\n\tfunction __binaryLookup(KV[] storage _h, uint256 _k) private view returns(uint256) {\n\t\t// if an array is empty, there is nothing to lookup in\n\t\tif(_h.length == 0) {\n\t\t\t// by documented agreement, fall back to a zero result\n\t\t\treturn 0;\n\t\t}\n\n\t\t// check last key-value pair key:\n\t\t// if the key is smaller than the key of interest\n\t\tif(_h[_h.length - 1].k <= _k) {\n\t\t\t// we're done - return the value from the last element\n\t\t\treturn _h[_h.length - 1].v;\n\t\t}\n\n\t\t// check first voting power history record block number:\n\t\t// if history was never updated before the block of interest\n\t\tif(_h[0].k > _k) {\n\t\t\t// we're done - voting power at the block num of interest was zero\n\t\t\treturn 0;\n\t\t}\n\n\t\t// left bound of the search interval, originally start of the array\n\t\tuint256 i = 0;\n\n\t\t// right bound of the search interval, originally end of the array\n\t\tuint256 j = _h.length - 1;\n\n\t\t// the iteration process narrows down the bounds by\n\t\t// splitting the interval in a half oce per each iteration\n\t\twhile(j > i) {\n\t\t\t// get an index in the middle of the interval [i, j]\n\t\t\tuint256 k = j - (j - i) / 2;\n\n\t\t\t// read an element to compare it with the value of interest\n\t\t\tKV memory kv = _h[k];\n\n\t\t\t// if we've got a strict equal - we're lucky and done\n\t\t\tif(kv.k == _k) {\n\t\t\t\t// just return the result - pair value at index `k`\n\t\t\t\treturn kv.v;\n\t\t\t}\n\t\t\t// if the value of interest is larger - move left bound to the middle\n\t\t\telse if (kv.k < _k) {\n\t\t\t\t// move left bound `i` to the middle position `k`\n\t\t\t\ti = k;\n\t\t\t}\n\t\t\t// otherwise, when the value of interest is smaller - move right bound to the middle\n\t\t\telse {\n\t\t\t\t// move right bound `j` to the middle position `k - 1`:\n\t\t\t\t// element at position `k` is greater and cannot be the result\n\t\t\t\tj = k - 1;\n\t\t\t}\n\t\t}\n\n\t\t// reaching that point means no exact match found\n\t\t// since we're interested in the element which is not larger than the\n\t\t// element of interest, we return the lower bound `i`\n\t\treturn _h[i].v;\n\t}\n\n\t/**\n\t * @dev Adds a + b\n\t *      Function is used as a parameter for other functions\n\t *\n\t * @param a addition term 1\n\t * @param b addition term 2\n\t * @return a + b\n\t */\n\tfunction add(uint256 a, uint256 b) private pure returns(uint256) {\n\t\t// add `a` to `b` and return\n\t\treturn a + b;\n\t}\n\n\t/**\n\t * @dev Subtracts a - b\n\t *      Function is used as a parameter for other functions\n\t *\n\t * @dev Requires a ≥ b\n\t *\n\t * @param a subtraction term 1\n\t * @param b subtraction term 2, b ≤ a\n\t * @return a - b\n\t */\n\tfunction sub(uint256 a, uint256 b) private pure returns(uint256) {\n\t\t// subtract `b` from `a` and return\n\t\treturn a - b;\n\t}\n\n\t// ===== End: DAO Support (Compound-like voting delegation) =====\n}\n\n/**\n * @title Artificial Liquid Intelligence ERC20 Token (Alethea, ALI)\n *\n * @notice Ethereum mainnet implementation with the fixed supply 10,000,000,000 ALI (non-configurable)\n */\ncontract AliERC20v2 is AliERC20v2Base {\n\t/**\n\t * @dev Deploys the token smart contract,\n\t *      assigns initial token supply to the address specified\n\t *\n\t * @param _initialHolder owner of the initial token supply\n\t */\n\tconstructor(address _initialHolder) AliERC20v2Base(_initialHolder, 10_000_000_000e18) {}\n}\n\n/**\n * @title Artificial Liquid Intelligence ERC20 Token (Alethea, ALI)\n *\n * @notice Non-Ethereum implementation (L2) with no initial supply\n */\ncontract ChildAliERC20v2 is AliERC20v2Base {\n\t/**\n\t * @dev Deploys the token smart contract with no initial supply\n\t */\n\tconstructor() AliERC20v2Base(address(0), 0) {}\n}\n\n"
    },
    "contracts/token/BurnableShortERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./ShortERC721.sol\";\n\n/**\n * @title Burnable Short ERC721\n *\n * @notice Short ERC721 extension to support token burning,\n *      See {ShortERC721}\n */\nabstract contract BurnableShortERC721 is ShortERC721, BurnableERC721 {\n\t/**\n\t * @dev To support burning for enumerable ERC721 we have to be able\n\t *      to quickly remove tokens from `allTokens` array (without iterating it)\n\t *\n\t * @dev Following mapping stores token indexes within `allTokens` array\n\t *\n\t * @dev Maps `Token ID => Token ID Index`\n\t */\n\tmapping(uint256 => uint256) private tokenIndexes;\n\n\t/**\n\t * @dev Constructs/deploys burnable ERC721 instance with the name and symbol specified\n\t *\n\t * @param _name name of the token to be accessible as `name()`\n\t * @param _symbol token symbol to be accessible as `symbol()`\n\t */\n\tconstructor(string memory _name, string memory _symbol) ShortERC721(_name, _symbol) {}\n\n\t/**\n\t * @inheritdoc ERC165\n\t */\n\tfunction supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n\t\t// construct the interface from current and super implementations\n\t\treturn interfaceId == type(MintableERC721).interfaceId || super.supportsInterface(interfaceId);\n\t}\n\n\t// ===== Start: burn support =====\n\n\t/**\n\t * @dev Destroys the token with token ID specified\n\t *\n\t * @dev Requires executor to have `ROLE_TOKEN_DESTROYER` permission\n\t *      or FEATURE_OWN_BURNS/FEATURE_BURNS_ON_BEHALF features to be enabled\n\t *\n\t * @dev Can be disabled by the contract creator forever by disabling\n\t *      FEATURE_OWN_BURNS/FEATURE_BURNS_ON_BEHALF features and then revoking\n\t *      its own roles to burn tokens and to enable burning features\n\t *\n\t * @param _tokenId ID of the token to burn\n\t */\n\tfunction burn(uint256 _tokenId) public override {\n\t\t// read token owner data\n\t\t// verifies token exists under the hood\n\t\taddress _from = ownerOf(_tokenId);\n\n\t\t// check if caller has sufficient permissions to burn tokens\n\t\t// and if not - check for possibility to burn own tokens or to burn on behalf\n\t\tif(!isSenderInRole(ROLE_TOKEN_DESTROYER)) {\n\t\t\t// if `_from` is equal to sender, require own burns feature to be enabled\n\t\t\t// otherwise require burns on behalf feature to be enabled\n\t\t\trequire(_from == msg.sender && isFeatureEnabled(FEATURE_OWN_BURNS)\n\t\t\t     || _from != msg.sender && isFeatureEnabled(FEATURE_BURNS_ON_BEHALF),\n\t\t\t        _from == msg.sender? \"burns are disabled\": \"burns on behalf are disabled\");\n\n\t\t\t// verify sender is either token owner, or approved by the token owner to burn tokens\n\t\t\trequire(_from == msg.sender || msg.sender == getApproved(_tokenId) || isApprovedForAll(_from, msg.sender), \"access denied\");\n\t\t}\n\n\t\t// remove token ownership record (also clears approval),\n\t\t// remove token from both local and global collections\n\t\t__removeToken(_tokenId);\n\n\t\t// delete token URI mapping\n\t\tdelete _tokenURIs[_tokenId];\n\n\t\t// fire ERC721 transfer event\n\t\temit Transfer(_from, address(0), _tokenId);\n\t}\n\n\t// ===== End: burn support =====\n\n\t// ----- Start: auxiliary internal/private functions -----\n\n\t/**\n\t * @inheritdoc ShortERC721\n\t *\n\t * @dev Adds a code to initialize `tokenIndexes` mapping required for burn support\n\t */\n\tfunction __addToken(uint256 _tokenId, address _to) internal virtual override {\n\t\t// write global token index data\n\t\ttokenIndexes[_tokenId] = allTokens.length;\n\n\t\t// execute default parent code\n\t\tsuper.__addToken(_tokenId, _to);\n\t}\n\n\t/**\n\t * @inheritdoc ShortERC721\n\t *\n\t * @dev Adds a code to initialize `tokenIndexes` mapping required for burn support\n\t */\n\tfunction __addTokens(address _to, uint256 _tokenId, uint256 n) internal virtual override {\n\t\t// for each token to be added\n\t\tfor(uint256 i = 0; i < n; i++) {\n\t\t\t// write global token index data\n\t\t\ttokenIndexes[_tokenId + i] = allTokens.length;\n\t\t}\n\n\t\t// execute default parent code\n\t\tsuper.__addTokens(_to, _tokenId, n);\n\t}\n\n\t/**\n\t * @dev Removes token from both local and global collections (enumerations),\n\t *      used internally to burn existing tokens\n\t *\n\t * @dev Unsafe: doesn't check for data structures consistency\n\t *      (token existence, token ownership, etc.)\n\t *\n\t * @dev Must be kept private at all times. Inheriting smart contracts\n\t *      may be interested in overriding this function.\n\t *\n\t * @param _tokenId token ID to remove\n\t */\n\tfunction __removeToken(uint256 _tokenId) internal virtual {\n\t\t// remove token from owner's (local) collection first\n\t\t__removeLocal(_tokenId);\n\n\t\t// token index within the global collection\n\t\tuint256 i = tokenIndexes[_tokenId];\n\n\t\t// delete the token\n\t\tdelete tokens[_tokenId];\n\n\t\t// get an ID of the last token in the collection\n\t\tuint96 lastId = allTokens[allTokens.length - 1];\n\n\t\t// if the token we're to remove from the collection is not the last one,\n\t\t// we need to move last token in the collection into index `i`\n\t\tif(i != allTokens.length - 1) {\n\t\t\t// we put the last token in the collection to the position released\n\n\t\t\t// update last token index to point to proper place in the collection\n\t\t\ttokenIndexes[lastId] = i;\n\n\t\t\t// put it into the position `i` within the collection\n\t\t\tallTokens[i] = lastId;\n\t\t}\n\n\t\t// trim the collection by removing last element\n\t\tallTokens.pop();\n\t}\n\n\t// ----- End: auxiliary internal/private functions -----\n}\n"
    },
    "contracts/token/OpAliERC20v2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// use non-strict version pragma to simplify contract imports in other projects\npragma solidity ^0.8.4;\n\nimport \"../interfaces/bedrock/IOptimismMintableERC20.sol\";\nimport \"./AliERC20v2.sol\";\n\n/**\n * @title Artificial Liquid Intelligence ERC20 Token (with OP Stack bridge support)\n *\n * @notice OP Stack extension contract functions required by the OP Stack StandardBridge\n *\n * @dev In the context of opBNB we call this implementation also an L3 since\n *      it is bridged from the L2 ChildAliERC20v2 which is deployed to BNB chain\n *\n * @notice Read more:\n *      https://community.optimism.io/docs/developers/bridge/standard-bridge/\n *      https://github.com/bnb-chain/opbnb-bridge-tokens\n */\ncontract OpAliERC20v2 is IOptimismMintableERC20, ILegacyMintableERC20, AliERC20v2Base {\n\t/**\n\t * @notice Address of the StandardBridge on this network.\n\t */\n\taddress public immutable BRIDGE;\n\n\t/**\n\t * @notice Address of the corresponding version of this token on the remote chain.\n\t */\n\taddress public immutable REMOTE_TOKEN;\n\n\t/**\n\t * @dev Constructs/deploys ALI instance,\n\t *      assigns initial token supply to the address specified\n\t *\n\t * @param _bridge StandardBridge address\n\t * @param _remoteToken remote (L2) token address\n\t */\n\tconstructor(address _bridge, address _remoteToken) AliERC20v2Base(address(0), 0) {\n\t\t// verify the inputs\n\t\trequire(_bridge != address(0) && _remoteToken != address(0), \"zero address\");\n\n\t\t// set contract's internal state\n\t\tBRIDGE = _bridge;\n\t\tREMOTE_TOKEN = _remoteToken;\n\n\t\t// bridge is assumed to have mint/burn permissions by default\n\t\tupdateRole(_bridge, ROLE_TOKEN_CREATOR | ROLE_TOKEN_DESTROYER);\n\t}\n\n\t/**\n\t * @custom:legacy\n\t * @notice Legacy getter for the bridge. Use BRIDGE going forward.\n\t */\n\tfunction l2Bridge() public view returns (address) {\n\t\treturn BRIDGE;\n\t}\n\n\t/**\n\t * @custom:legacy\n\t * @notice Legacy getter for the remote token. Use REMOTE_TOKEN going forward.\n\t */\n\tfunction l1Token() public view returns (address) {\n\t\treturn REMOTE_TOKEN;\n\t}\n\n\t/**\n\t * @custom:legacy\n\t * @notice Legacy getter for BRIDGE.\n\t */\n\tfunction bridge() public view returns (address) {\n\t\treturn BRIDGE;\n\t}\n\n\t/**\n\t * @custom:legacy\n\t * @notice Legacy getter for REMOTE_TOKEN.\n\t */\n\tfunction remoteToken() public view returns (address) {\n\t\treturn REMOTE_TOKEN;\n\t}\n\n\t/**\n\t * @notice Executed by StandardBridge when token is deposited on the root chain\n\t *\n\t * @dev Executable only by StandardBridge which should be given the minting\n\t *      permission as part of the smart contract deployment process;\n\t *      handles the deposit by minting the required amount for user\n\t *\n\t * @param _to user address for whom deposit is being done\n\t * @param _amount deposit amount\n\t */\n\tfunction mint(address _to, uint256 _amount) public override(AliERC20v2Base, IOptimismMintableERC20, ILegacyMintableERC20) {\n\t\t// delegate to super\n\t\tAliERC20v2Base.mint(_to, _amount);\n\t}\n\n\t/**\n\t * @notice Executed by StandardBridge when withdrawing tokens back to the root chain\n\t *\n\t * @dev Executable only by StandardBridge which should be given the burning\n\t *      permission as part of the smart contract deployment process;\n\t *      handles the withdrawal by burning the required amount from user\n\t *\n\t * @param _from user address for whom withdrawal is being done\n\t * @param _amount withdrawal amount\n\t */\n\tfunction burn(address _from, uint256 _amount) public override(AliERC20v2Base, IOptimismMintableERC20, ILegacyMintableERC20) {\n\t\t// delegate to super\n\t\tAliERC20v2Base.burn(_from, _amount);\n\t}\n\n\t/**\n\t * @inheritdoc ERC165\n\t */\n\tfunction supportsInterface(bytes4 interfaceId) public pure override(AliERC20v2Base, ERC165) returns (bool) {\n\t\t// reconstruct from current interface(s) and super interface(s) (if any)\n\t\treturn super.supportsInterface(interfaceId)\n\t\t    || interfaceId == type(ERC165).interfaceId\n\t\t    || interfaceId == type(ILegacyMintableERC20).interfaceId\n\t\t    || interfaceId == type(IOptimismMintableERC20).interfaceId;\n\t}\n}\n"
    },
    "contracts/token/PersonalityPodERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./RoyalERC721.sol\";\n\n/**\n * @title Personality Pod, a.k.a. AI Personality\n *\n * @notice Personality Pod replaces AI Pod in version 2 release, it doesn't\n *      store any metadata on-chain, all the token related data except URI\n *      (rarity, traits, etc.) is expected to be stored off-chain\n *\n * @notice Terms Personality Pod and AI Personality have identical meaning and\n *      used interchangeably all over the code, documentation, scripts, etc.\n *\n * @dev Personality Pod is a Tiny ERC721, it supports minting and burning,\n *      its token ID space is limited to 32 bits\n */\ncontract PersonalityPodERC721 is RoyalERC721 {\n\t/**\n\t * @inheritdoc TinyERC721\n\t */\n\tuint256 public constant override TOKEN_UID = 0xd9b5d3b66c60255ffa16c57c0f1b2db387997fa02af673da5767f1acb0f345af;\n\n\t/**\n\t * @dev Constructs/deploys AI Personality instance\n\t *      with the name and symbol defined during the deployment\n\t */\n\tconstructor(string memory _name, string memory _symbol) RoyalERC721(_name, _symbol) AccessControl(msg.sender) {}\n}\n"
    },
    "contracts/token/PolygonAliERC20v2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./AliERC20v2.sol\";\n\n/**\n * @title Artificial Liquid Intelligence ERC20 Token (with Polygon bridge support)\n *\n * @notice Polygon extension contract ads the functions required to bridge original\n *      ALI token on Ethereum L1; these are mint and burn functions executed\n *      when the tokens are deposited from from Ethereum L1 into Polygon L2 (mint),\n *      and when the tokens are withdrawn back from Polygon L2 into Ethereum L1 (burn).\n *\n * @notice Read more:\n *      https://docs.polygon.technology/docs/develop/ethereum-polygon/mintable-assets\n */\ncontract PolygonAliERC20v2 is AliERC20v2Base {\n\n\t/**\n\t * @dev Constructs/deploys Polygon ALI instance,\n\t *      assigns initial token supply to the address specified\n\t */\n\tconstructor() AliERC20v2Base(address(0), 0) {}\n\n\t/**\n\t * @notice Executed by ChildChainManager when token is deposited on the root chain\n\t *\n\t * @dev Executable only by ChildChainManager which should be given the minting\n\t *      permission as part of the smart contract deployment process;\n\t *      handles the deposit by minting the required amount for user\n\t *\n\t * @param user user address for whom deposit is being done\n\t * @param depositData abi encoded amount\n\t */\n\tfunction deposit(address user, bytes calldata depositData) external {\n\t\t// extract the amount value to mint from the calldata\n\t\tuint256 amount = abi.decode(depositData, (uint256));\n\n\t\t// delegate to `mint`\n\t\tmint(user, amount);\n\t}\n\n\t/**\n\t * @notice Executed by the tokens owner when they want to withdraw tokens back to the root chain\n\t *\n\t * @dev Burns user's tokens;\n\t *      this transaction will be verified when exiting on the root chain\n\t *\n\t * @param amount amount of tokens to withdraw\n\t */\n\tfunction withdraw(uint256 amount) external {\n\t\t// delegate to the `burn` function\n\t\tburn(msg.sender, amount);\n\t}\n}\n"
    },
    "contracts/token/RoyalERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/EIP2981Spec.sol\";\nimport \"./TinyERC721.sol\";\n\n/**\n * @title Royal ER721\n *\n * @dev Supports EIP-2981 royalties on NFT secondary sales\n *      Supports OpenSea contract metadata royalties\n *      Introduces fake \"owner\" to support OpenSea collections\n */\nabstract contract RoyalERC721 is EIP2981, TinyERC721 {\n\t/**\n\t * @dev OpenSea expects NFTs to be \"Ownable\", that is having an \"owner\",\n\t *      we introduce a fake \"owner\" here with no authority\n\t */\n\taddress public owner;\n\n\t/**\n\t * @notice Address to receive EIP-2981 royalties from secondary sales\n\t *         see https://eips.ethereum.org/EIPS/eip-2981\n\t */\n\taddress public royaltyReceiver = address(0x379e2119f6e0D6088537da82968e2a7ea178dDcF);\n\n\t/**\n\t * @notice Percentage of token sale price to be used for EIP-2981 royalties from secondary sales\n\t *         see https://eips.ethereum.org/EIPS/eip-2981\n\t *\n\t * @dev Has 2 decimal precision. E.g. a value of 500 would result in a 5% royalty fee\n\t */\n\tuint16 public royaltyPercentage = 750; // default OpenSea value\n\n\t/**\n\t * @notice Contract level metadata to define collection name, description, and royalty fees.\n\t *         see https://docs.opensea.io/docs/contract-level-metadata\n\t *\n\t * @dev Should be set by URI manager. By default only includes royalty information\n\t */\n\tstring public contractURI = \"https://gateway.pinata.cloud/ipfs/QmU92w8iKpcaabCoyHtMg7iivWGqW2gW1hgARDtqCmJUWv\";\n\n\t/**\n\t * @notice Royalty manager is responsible for managing the EIP2981 royalty info\n\t *\n\t * @dev Role ROLE_ROYALTY_MANAGER allows updating the royalty information\n\t *      (executing `setRoyaltyInfo` function)\n\t */\n\tuint32 public constant ROLE_ROYALTY_MANAGER = 0x0020_0000;\n\n\t/**\n\t * @notice Owner manager is responsible for setting/updating an \"owner\" field\n\t *\n\t * @dev Role ROLE_OWNER_MANAGER allows updating the \"owner\" field\n\t *      (executing `transferOwnership` function)\n\t */\n\tuint32 public constant ROLE_OWNER_MANAGER = 0x0040_0000;\n\n\t/**\n\t * @dev Fired in setContractURI()\n\t *\n\t * @param _by an address which executed update\n\t * @param _value new contractURI value\n\t */\n\tevent ContractURIUpdated(address indexed _by, string _value);\n\n\t/**\n\t * @dev Fired in setRoyaltyInfo()\n\t *\n\t * @param _by an address which executed update\n\t * @param _receiver new royaltyReceiver value\n\t * @param _percentage new royaltyPercentage value\n\t */\n\tevent RoyaltyInfoUpdated(\n\t\taddress indexed _by,\n\t\taddress indexed _receiver,\n\t\tuint16 _percentage\n\t);\n\n\t/**\n\t * @dev Fired in transferOwnership()\n\t *\n\t * @param _by an address which set the new \"owner\"\n\t * @param _oldVal previous \"owner\" address\n\t * @param _newVal new \"owner\" address\n\t */\n\tevent OwnerUpdated(address indexed _by, address indexed _oldVal, address indexed _newVal);\n\n\t/**\n\t * @dev Fired in transferOwnership() - OpenZeppelin Ownable compliant event\n\t *\n\t * @param previousOwner previous \"owner\" address\n\t * @param newOwner new \"owner\" address\n\t */\n\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\t/**\n\t * @dev Constructs/deploys ERC721 with EIP-2981 instance with the name and symbol specified\n\t *\n\t * @param _name token name (ERC721Metadata)\n\t * @param _symbol token symbol (ERC721Metadata)\n\t */\n\tconstructor(string memory _name, string memory _symbol) TinyERC721(_name, _symbol) {\n\t\t// initialize the \"owner\" as a deployer account\n\t\towner = msg.sender;\n\t}\n\n\t/**\n\t * @dev Restricted access function which updates the contract URI\n\t *\n\t * @dev Requires executor to have ROLE_URI_MANAGER permission\n\t *\n\t * @param _contractURI new contract URI to set\n\t */\n\tfunction setContractURI(string memory _contractURI) public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_URI_MANAGER), \"access denied\");\n\n\t\t// update the contract URI\n\t\tcontractURI = _contractURI;\n\n\t\t// emit an event\n\t\temit ContractURIUpdated(msg.sender, _contractURI);\n\t}\n\n\t/**\n\t * @notice EIP-2981 function to calculate royalties for sales in secondary marketplaces.\n\t *         see https://eips.ethereum.org/EIPS/eip-2981\n\t *\n\t * @inheritdoc EIP2981\n\t */\n\tfunction royaltyInfo(\n\t\tuint256,\n\t\tuint256 _salePrice\n\t) public view override returns (\n\t\taddress receiver,\n\t\tuint256 royaltyAmount\n\t) {\n\t\t// simply calculate the values and return the result\n\t\treturn (royaltyReceiver, _salePrice * royaltyPercentage / 100_00);\n\t}\n\n\t/**\n\t * @dev Restricted access function which updates the royalty info\n\t *\n\t * @dev Requires executor to have ROLE_ROYALTY_MANAGER permission\n\t *\n\t * @param _royaltyReceiver new royalty receiver to set\n\t * @param _royaltyPercentage new royalty percentage to set\n\t */\n\tfunction setRoyaltyInfo(address _royaltyReceiver, uint16 _royaltyPercentage) public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_ROYALTY_MANAGER), \"access denied\");\n\n\t\t// verify royalty percentage is zero if receiver is also zero\n\t\trequire(_royaltyReceiver != address(0) || _royaltyPercentage == 0, \"invalid receiver\");\n\t\t// verify royalty percentage doesn't exceed 100%\n\t\trequire(_royaltyPercentage <= 100_00, \"royalty percentage exceeds 100%\");\n\n\t\t// update the values\n\t\troyaltyReceiver = _royaltyReceiver;\n\t\troyaltyPercentage = _royaltyPercentage;\n\n\t\t// emit an event\n\t\temit RoyaltyInfoUpdated(msg.sender, _royaltyReceiver, _royaltyPercentage);\n\t}\n\n\t/**\n\t * @notice Checks if the address supplied is an \"owner\" of the smart contract\n\t *      Note: an \"owner\" doesn't have any authority on the smart contract and is \"nominal\"\n\t *\n\t * @return true if the caller is the current owner.\n\t */\n\tfunction isOwner(address _addr) public view returns(bool) {\n\t\t// just evaluate and return the result\n\t\treturn _addr == owner;\n\t}\n\n\t/**\n\t * @dev Restricted access function to set smart contract \"owner\"\n\t *      Note: an \"owner\" set doesn't have any authority, and cannot even update \"owner\"\n\t *\n\t * @dev Requires executor to have ROLE_OWNER_MANAGER permission\n\t *\n\t * @param _owner new \"owner\" of the smart contract\n\t */\n\tfunction transferOwnership(address _owner) public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_OWNER_MANAGER), \"access denied\");\n\n\t\t// emit an event first - to log both old and new values\n\t\temit OwnerUpdated(msg.sender, owner, _owner);\n\n\t\t// emit zeppelin ownable-compliant ownership transfer event\n\t\temit OwnershipTransferred(owner, _owner);\n\n\t\t// update \"owner\"\n\t\towner = _owner;\n\t}\n\n\t/**\n\t * @inheritdoc ERC165\n\t */\n\tfunction supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, TinyERC721) returns (bool) {\n\t\t// construct the interface support from EIP-2981 and super interfaces\n\t\treturn interfaceId == type(EIP2981).interfaceId || super.supportsInterface(interfaceId);\n\t}\n}\n"
    },
    "contracts/token/ShortERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ERC721Spec.sol\";\nimport \"../interfaces/ERC721SpecExt.sol\";\nimport \"../lib/AddressUtils.sol\";\nimport \"../lib/StringUtils.sol\";\nimport \"../lib/ECDSA.sol\";\nimport \"../utils/AccessControl.sol\";\n\n/**\n * @title Short ERC721\n *\n * @notice Short ERC721 defines an NFT with short (up to 96 bits) ID space.\n *      ERC721 enumeration support requires additional writes to the storage:\n *      - when transferring a token in order to update the NFT collections of\n *        the previous and next owners,\n *      - when minting/burning a token in order to update global NFT collection\n *\n * @notice Reducing the NFT ID space to 96 bits allows to eliminate the need to have\n *      and to write to one of the additional storage mappings\n *\n * @notice Short NFT ID (up to 96 bits) is concatenated in storage with owner address\n *      (160 bits) resulting in a whole 256 bits slot occupied, and eliminating\n *      the need to store NFT index within owner collection in a separate storage slot.\n *\n * @notice This smart contract is designed to be inherited by concrete implementations,\n *      which are expected to define token metadata, auxiliary functions to access the metadata,\n *      and explicitly define token minting interface, which should be built on top\n *      of current smart contract internal interface\n *\n * @notice Fully ERC721-compatible with all optional interfaces implemented (metadata, enumeration),\n *      see https://eips.ethereum.org/EIPS/eip-721\n *\n * @notice Note: current implementation doesn't support token burning. Burning doesn't come for free\n *      and requires additional mapping maintenance which is written to in both `mint` and `burn` functions.\n *      See {BurnableShortERC721} for burning support\n *\n * @dev Reducing the NFT ID space to 64 bits would allow to optimize batch minting by more tight\n *      packing of the arrays storing NFT IDs (`allTokens` and owners' `collections`)\n *\n * @dev Reducing the NFT ID space to 48 bits would allow to get \"free\" burn support for enumerable ERC721\n *      by eliminating the need to maintain `tokenIndexes` mapping (see {BurnableShortERC721})\n *\n * @dev ERC721: contract has passed adopted OpenZeppelin ERC721 tests\n *        https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/test/token/ERC721/ERC721.behavior.js\n *        https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/test/token/ERC721/extensions/ERC721URIStorage.test.js\n *\n * @dev A note on token URI: there are major differences on how token URI behaves comparing to Zeppelin impl:\n *      1. A token URI can be set for non-existing token for pre-allocation purposes,\n *         still the URI will be deleted once token is burnt\n *      2. If token URI is set, base URI has no affect on the token URI, the two are not concatenated,\n *         base URI is used to construct the token URI only if the latter was not explicitly set\n *\n * @dev Supports EIP-712 powered permits - permit() - approve() with signature.\n *      Supports EIP-712 powered operator permits - permitForAll() - setApprovalForAll() with signature.\n *\n * @dev EIP712 Domain:\n *      name: AliERC721v1\n *      version: not in use, omitted (name already contains version)\n *      chainId: EIP-155 chain id\n *      verifyingContract: deployed contract address\n *      salt: permitNonces[owner], where owner is an address which allows operation on their tokens\n *\n * @dev Permit type:\n *      owner: address\n *      operator: address\n *      tokenId: uint256\n *      nonce: uint256\n *      deadline: uint256\n *\n * @dev Permit typeHash:\n *        keccak256(\"Permit(address owner,address operator,uint256 tokenId,uint256 nonce,uint256 deadline)\")\n *\n * @dev PermitForAll type:\n *      owner: address\n *      operator: address\n *      approved: bool\n *      nonce: uint256\n *      deadline: uint256\n *\n * @dev PermitForAll typeHash:\n *        keccak256(\"PermitForAll(address owner,address operator,bool approved,uint256 nonce,uint256 deadline)\")\n *\n * @dev See https://eips.ethereum.org/EIPS/eip-712\n * @dev See usage examples in tests: erc721_permits.js\n */\nabstract contract ShortERC721 is ERC721Enumerable, ERC721Metadata, WithBaseURI, MintableERC721, AccessControl {\n\t/**\n\t * @dev Smart contract unique identifier, a random number\n\t *\n\t * @dev Should be regenerated each time smart contact source code is changed\n\t *      and changes smart contract itself is to be redeployed\n\t *\n\t * @dev Generated using https://www.random.org/bytes/\n\t * @dev Example value: 0xdbdd2b4ff38a8516da0b8e7ae93288b5e2fed0c92fb051cee90ccf4e4ec9736e\n\t */\n\tfunction TOKEN_UID() external view virtual returns(uint256);\n\n\t/**\n\t * @notice ERC-20 compatible descriptive name for a collection of NFTs in this contract\n\t *\n\t * @inheritdoc ERC721Metadata\n\t */\n\tstring public override name;\n\n\t/**\n\t * @notice ERC-20 compatible abbreviated name for a collection of NFTs in this contract\n\t *\n\t * @inheritdoc ERC721Metadata\n\t */\n\tstring public override symbol;\n\n\t/**\n\t * @notice Current implementation includes a function `decimals` that returns uint8(0)\n\t *      to be more compatible with ERC-20\n\t *\n\t * @dev ERC20 compliant token decimals is equal to zero since ERC721 token is non-fungible\n\t *      and therefore non-divisible\n\t */\n\tuint8 public constant decimals = 0;\n\n\t/**\n\t * @notice Ownership information for all the tokens in existence\n\t *\n\t * @dev Maps `Token ID => Token ID Index | Token Owner Address`, where\n\t *      - Token ID Index denotes Token ID index in the array of all the tokens owned by the owner,\n\t *      - Token ID Index is 96 bits long and is stored in high 96 bits of the mapping value,\n\t *      - `|` denotes bitwise concatenation of the\n\t *        96 bits long Token ID Index and 160 bits long Token Owner Address\n\t * @dev Token Owner Address for a given Token ID is lower 160 bits of the mapping value\n\t */\n\tmapping(uint256 => uint256) internal tokens;\n\n\t/**\n\t * @notice Enumerated collections of the tokens owned by particular owners\n\t *\n\t * @dev We call these collections \"Local\" token collections\n\t *\n\t * @dev Maps `Token Owner Address => Owned Token IDs Array`\n\t *\n\t * @dev Token owner balance is the length of their token collection:\n\t *      `balanceOf(owner) = collections[owner].length`\n\t */\n\tmapping(address => uint96[]) internal collections;\n\n\t/**\n\t * @notice An array of all the tokens in existence\n\t *\n\t * @dev We call this collection \"Global\" token collection\n\t *\n\t * @dev Array with all Token IDs, used for enumeration\n\t *\n\t * @dev Total token supply `tokenSupply` is the length of this collection:\n\t *      `totalSupply() = allTokens.length`\n\t */\n\tuint96[] internal allTokens;\n\n\t/**\n\t * @notice Addresses approved by token owners to transfer their tokens\n\t *\n\t * @dev `Maps Token ID => Approved Address`, where\n\t *      Approved Address is an address allowed transfer ownership for the token\n\t *      defined by Token ID\n\t */\n\tmapping(uint256 => address) internal approvals;\n\n\t/**\n\t * @notice Addresses approved by token owners to transfer all their tokens\n\t *\n\t * @dev Maps `Token Owner Address => Operator Address => Approval State` - true/false (approved/not), where\n\t *      - Token Owner Address is any address which may own tokens or not,\n\t *      - Operator Address is any other address which may own tokens or not,\n\t *      - Approval State is a flag indicating if Operator Address is allowed to\n\t *        transfer tokens owned by Token Owner Address o their behalf\n\t */\n\tmapping(address => mapping(address => bool)) internal approvedOperators;\n\n\t/**\n\t * @dev A record of nonces for signing/validating signatures in EIP-712 based\n\t *      `permit` and `permitForAll` functions\n\t *\n\t * @dev Each time the nonce is used, it is increased by one, meaning reordering\n\t *      of the EIP-712 transactions is not possible\n\t *\n\t * @dev Inspired by EIP-2612 extension for ERC20 token standard\n\t *\n\t * @dev Maps token owner address => token owner nonce\n\t */\n\tmapping(address => uint256) public permitNonces;\n\n\t/**\n\t * @dev Base URI is used to construct ERC721Metadata.tokenURI as\n\t *      `base URI + token ID` if token URI is not set (not present in `_tokenURIs` mapping)\n\t *\n\t * @dev For example, if base URI is https://api.com/token/, then token #1\n\t *      will have an URI https://api.com/token/1\n\t *\n\t * @dev If token URI is set with `setTokenURI()` it will be returned as is via `tokenURI()`\n\t */\n\tstring public override baseURI = \"\";\n\n\t/**\n\t * @dev Optional mapping for token URIs to be returned as is when `tokenURI()`\n\t *      is called; if mapping doesn't exist for token, the URI is constructed\n\t *      as `base URI + token ID`, where plus (+) denotes string concatenation\n\t */\n\tmapping(uint256 => string) internal _tokenURIs;\n\n\t/**\n\t * @notice Enables ERC721 transfers of the tokens\n\t *      (transfer by the token owner himself)\n\t * @dev Feature FEATURE_TRANSFERS must be enabled in order for\n\t *      `transferFrom()` function to succeed when executed by token owner\n\t */\n\tuint32 public constant FEATURE_TRANSFERS = 0x0000_0001;\n\n\t/**\n\t * @notice Enables ERC721 transfers on behalf\n\t *      (transfer by someone else on behalf of token owner)\n\t * @dev Feature FEATURE_TRANSFERS_ON_BEHALF must be enabled in order for\n\t *      `transferFrom()` function to succeed whe executed by approved operator\n\t * @dev Token owner must call `approve()` or `setApprovalForAll()`\n\t *      first to authorize the transfer on behalf\n\t */\n\tuint32 public constant FEATURE_TRANSFERS_ON_BEHALF = 0x0000_0002;\n\n\t/**\n\t * @notice Enables token owners to burn their own tokens\n\t *\n\t * @dev Feature FEATURE_OWN_BURNS must be enabled in order for\n\t *      `burn()` function to succeed when called by token owner\n\t */\n\tuint32 public constant FEATURE_OWN_BURNS = 0x0000_0008;\n\n\t/**\n\t * @notice Enables approved operators to burn tokens on behalf of their owners\n\t *\n\t * @dev Feature FEATURE_BURNS_ON_BEHALF must be enabled in order for\n\t *      `burn()` function to succeed when called by approved operator\n\t */\n\tuint32 public constant FEATURE_BURNS_ON_BEHALF = 0x0000_0010;\n\n\t/**\n\t * @notice Enables approvals on behalf (permits via an EIP712 signature)\n\t * @dev Feature FEATURE_PERMITS must be enabled in order for\n\t *      `permit()` function to succeed\n\t */\n\tuint32 public constant FEATURE_PERMITS = 0x0000_0200;\n\n\t/**\n\t * @notice Enables operator approvals on behalf (permits for all via an EIP712 signature)\n\t * @dev Feature FEATURE_OPERATOR_PERMITS must be enabled in order for\n\t *      `permitForAll()` function to succeed\n\t */\n\tuint32 public constant FEATURE_OPERATOR_PERMITS = 0x0000_0400;\n\n\t/**\n\t * @notice Token creator is responsible for creating (minting)\n\t *      tokens to an arbitrary address\n\t * @dev Role ROLE_TOKEN_CREATOR allows minting tokens\n\t *      (calling `mint` function)\n\t */\n\tuint32 public constant ROLE_TOKEN_CREATOR = 0x0001_0000;\n\n\t/**\n\t * @notice Token destroyer is responsible for destroying (burning)\n\t *      tokens owned by an arbitrary address\n\t * @dev Role ROLE_TOKEN_DESTROYER allows burning tokens\n\t *      (calling `burn` function)\n\t */\n\tuint32 public constant ROLE_TOKEN_DESTROYER = 0x0002_0000;\n\n\t/**\n\t * @notice URI manager is responsible for managing base URI\n\t *      part of the token URI ERC721Metadata interface\n\t *\n\t * @dev Role ROLE_URI_MANAGER allows updating the base URI\n\t *      (executing `setBaseURI` function)\n\t */\n\tuint32 public constant ROLE_URI_MANAGER = 0x0010_0000;\n\n\t/**\n\t * @notice EIP-712 contract's domain typeHash,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\n\t *\n\t * @dev Note: we do not include version into the domain typehash/separator,\n\t *      it is implied version is concatenated to the name field, like \"AliERC721v1\"\n\t */\n\t// keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\")\n\tbytes32 public constant DOMAIN_TYPEHASH = 0x8cad95687ba82c2ce50e74f7b754645e5117c3a5bec8151c0726d5857980a866;\n\n\t/**\n\t * @notice EIP-712 contract's domain separator,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator\n\t *      note: we specify contract version in its name\n\t */\n\tfunction DOMAIN_SEPARATOR() public view returns(bytes32) {\n\t\t// build the EIP-712 contract domain separator, see https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator\n\t\t// note: we specify contract version in its name\n\t\treturn keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(\"AliERC721v1\")), block.chainid, address(this)));\n\t}\n\n\t/**\n\t * @notice EIP-712 permit (EIP-2612) struct typeHash,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\n\t */\n\t// keccak256(\"Permit(address owner,address operator,uint256 tokenId,uint256 nonce,uint256 deadline)\")\n\tbytes32 public constant PERMIT_TYPEHASH = 0xee2282d7affd5a432b221a559e429129347b0c19a3f102179a5fb1859eef3d29;\n\n\t/**\n\t * @notice EIP-712 permitForAll (EIP-2612) struct typeHash,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\n\t */\n\t// keccak256(\"PermitForAll(address owner,address operator,bool approved,uint256 nonce,uint256 deadline)\")\n\tbytes32 public constant PERMIT_FOR_ALL_TYPEHASH = 0x47ab88482c90e4bb94b82a947ae78fa91fb25de1469ab491f4c15b9a0a2677ee;\n\n\t/**\n\t * @dev Fired in setBaseURI()\n\t *\n\t * @param _by an address which executed update\n\t * @param _oldVal old _baseURI value\n\t * @param _newVal new _baseURI value\n\t */\n\tevent BaseURIUpdated(address indexed _by, string _oldVal, string _newVal);\n\n\t/**\n\t * @dev Fired in setTokenURI()\n\t *\n\t * @param _by an address which executed update\n\t * @param _tokenId token ID which URI was updated\n\t * @param _oldVal old _baseURI value\n\t * @param _newVal new _baseURI value\n\t */\n\tevent TokenURIUpdated(address indexed _by, uint256 _tokenId, string _oldVal, string _newVal);\n\n\t/**\n\t * @dev Constructs/deploys ERC721 instance with the name and symbol specified\n\t *\n\t * @param _name name of the token to be accessible as `name()`,\n\t *      ERC-20 compatible descriptive name for a collection of NFTs in this contract\n\t * @param _symbol token symbol to be accessible as `symbol()`,\n\t *      ERC-20 compatible descriptive name for a collection of NFTs in this contract\n\t */\n\tconstructor(string memory _name, string memory _symbol) {\n\t\t// set the name\n\t\tname = _name;\n\n\t\t// set the symbol\n\t\tsymbol = _symbol;\n\t}\n\n\t/**\n\t * @dev Verifies if token is transferable (i.e. can change ownership, allowed to be transferred);\n\t *      The default behaviour is to always allow transfer if token exists\n\t *\n\t * @dev Implementations may modify the default behaviour based on token metadata\n\t *      if required\n\t *\n\t * @param _tokenId ID of the token to check if it's transferable\n\t * @return true if token is transferable, false otherwise\n\t */\n\tfunction isTransferable(uint256 _tokenId) public view virtual returns(bool) {\n\t\t// validate token existence\n\t\trequire(exists(_tokenId), \"token doesn't exist\");\n\n\t\t// generic implementation returns true if token exists\n\t\treturn true;\n\t}\n\n\t/**\n\t * @notice Checks if specified token exists\n\t *\n\t * @dev Returns whether the specified token ID has an ownership\n\t *      information associated with it\n\t *\n\t * @inheritdoc MintableERC721\n\t *\n\t * @param _tokenId ID of the token to query existence for\n\t * @return whether the token exists (true - exists, false - doesn't exist)\n\t */\n\tfunction exists(uint256 _tokenId) public override view returns(bool) {\n\t\t// read ownership information and return a check if it's not zero (set)\n\t\treturn tokens[_tokenId] != 0;\n\t}\n\n\t/**\n\t * @inheritdoc ERC165\n\t */\n\tfunction supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n\t\t// construct the interface support from required and optional ERC721 interfaces\n\t\treturn interfaceId == type(ERC165).interfaceId\n\t\t\t|| interfaceId == type(ERC721).interfaceId\n\t\t\t|| interfaceId == type(ERC721Metadata).interfaceId\n\t\t\t|| interfaceId == type(ERC721Enumerable).interfaceId\n\t\t\t|| interfaceId == type(MintableERC721).interfaceId;\n\t}\n\n\t// ===== Start: ERC721 Metadata =====\n\n\t/**\n\t * @dev Restricted access function which updates base URI used to construct\n\t *      ERC721Metadata.tokenURI\n\t *\n\t * @dev Requires executor to have ROLE_URI_MANAGER permission\n\t *\n\t * @param _baseURI new base URI to set\n\t */\n\tfunction setBaseURI(string memory _baseURI) public virtual {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_URI_MANAGER), \"access denied\");\n\n\t\t// emit an event first - to log both old and new values\n\t\temit BaseURIUpdated(msg.sender, baseURI, _baseURI);\n\n\t\t// and update base URI\n\t\tbaseURI = _baseURI;\n\t}\n\n\t/**\n\t * @dev Returns token URI if it was previously set with `setTokenURI`,\n\t *      otherwise constructs it as base URI + token ID\n\t *\n\t * @inheritdoc ERC721Metadata\n\t */\n\tfunction tokenURI(uint256 _tokenId) public view override returns (string memory) {\n\t\t// verify token exists\n\t\trequire(exists(_tokenId), \"token doesn't exist\");\n\n\t\t// read the token URI for the token specified\n\t\tstring memory _tokenURI = _tokenURIs[_tokenId];\n\n\t\t// if token URI is set\n\t\tif(bytes(_tokenURI).length > 0) {\n\t\t\t// just return it\n\t\t\treturn _tokenURI;\n\t\t}\n\n\t\t// if base URI is not set\n\t\tif(bytes(baseURI).length == 0) {\n\t\t\t// return an empty string\n\t\t\treturn \"\";\n\t\t}\n\n\t\t// otherwise concatenate base URI + token ID\n\t\treturn StringUtils.concat(baseURI, StringUtils.itoa(_tokenId, 10));\n\t}\n\n\t/**\n\t * @dev Sets the token URI for the token defined by its ID\n\t *\n\t * @param _tokenId an ID of the token to set URI for\n\t * @param _tokenURI token URI to set\n\t */\n\tfunction setTokenURI(uint256 _tokenId, string memory _tokenURI) public virtual {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_URI_MANAGER), \"access denied\");\n\n\t\t// we do not verify token existence: we want to be able to\n\t\t// preallocate token URIs before tokens are actually minted\n\n\t\t// emit an event first - to log both old and new values\n\t\temit TokenURIUpdated(msg.sender, _tokenId, _tokenURIs[_tokenId], _tokenURI);\n\n\t\t// and update token URI\n\t\t_tokenURIs[_tokenId] = _tokenURI;\n\t}\n\n\t// ===== End: ERC721 Metadata =====\n\n\t// ===== Start: ERC721, ERC721Enumerable Getters (view functions) =====\n\n\t/**\n\t * @inheritdoc ERC721\n\t */\n\tfunction balanceOf(address _owner) public view override returns (uint256) {\n\t\t// check `_owner` address is set\n\t\trequire(_owner != address(0), \"zero address\");\n\n\t\t// derive owner balance for the their owned tokens collection\n\t\t// as the length of that collection\n\t\treturn collections[_owner].length;\n\t}\n\n\t/**\n\t * @inheritdoc ERC721\n\t */\n\tfunction ownerOf(uint256 _tokenId) public view override returns (address) {\n\t\t// derive ownership information of the token from the ownership mapping\n\t\t// by extracting lower 160 bits of the mapping value as an address\n\t\taddress owner = address(uint160(tokens[_tokenId]));\n\n\t\t// verify owner/token exists\n\t\trequire(owner != address(0), \"token doesn't exist\");\n\n\t\t// return owner address\n\t\treturn owner;\n\t}\n\n\t/**\n\t * @inheritdoc ERC721Enumerable\n\t */\n\tfunction totalSupply() public view override returns (uint256) {\n\t\t// derive total supply value from the array of all existing tokens\n\t\t// as the length of this array\n\t\treturn allTokens.length;\n\t}\n\n\t/**\n\t * @inheritdoc ERC721Enumerable\n\t */\n\tfunction tokenByIndex(uint256 _index) public view override returns (uint256) {\n\t\t// index out of bounds check\n\t\trequire(_index < totalSupply(), \"index out of bounds\");\n\n\t\t// find the token ID requested and return\n\t\treturn allTokens[_index];\n\t}\n\n\t/**\n\t * @inheritdoc ERC721Enumerable\n\t */\n\tfunction tokenOfOwnerByIndex(address _owner, uint256 _index) public view override returns (uint256) {\n\t\t// index out of bounds check\n\t\trequire(_index < balanceOf(_owner), \"index out of bounds\");\n\n\t\t// find the token ID requested and return\n\t\treturn collections[_owner][_index];\n\t}\n\n\t/**\n\t * @inheritdoc ERC721\n\t */\n\tfunction getApproved(uint256 _tokenId) public view override returns (address) {\n\t\t// verify token specified exists\n\t\trequire(exists(_tokenId), \"token doesn't exist\");\n\n\t\t// read the approval value and return\n\t\treturn approvals[_tokenId];\n\t}\n\n\t/**\n\t * @inheritdoc ERC721\n\t */\n\tfunction isApprovedForAll(address _owner, address _operator) public view override returns (bool) {\n\t\t// read the approval state value and return\n\t\treturn approvedOperators[_owner][_operator];\n\t}\n\n\t// ===== End: ERC721, ERC721Enumerable Getters (view functions) =====\n\n\t// ===== Start: ERC721 mutative functions (transfers, approvals) =====\n\n\t/**\n\t * @inheritdoc ERC721\n\t */\n\tfunction safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory _data) public override {\n\t\t// delegate call to unsafe transfer on behalf `transferFrom()`\n\t\ttransferFrom(_from, _to, _tokenId);\n\n\t\t// if receiver `_to` is a smart contract\n\t\tif(AddressUtils.isContract(_to)) {\n\t\t\t// check it supports ERC721 interface - execute onERC721Received()\n\t\t\tbytes4 response = ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data);\n\n\t\t\t// expected response is ERC721TokenReceiver(_to).onERC721Received.selector\n\t\t\t// bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))\n\t\t\trequire(response == ERC721TokenReceiver(_to).onERC721Received.selector, \"invalid onERC721Received response\");\n\t\t}\n\t}\n\n\t/**\n\t * @inheritdoc ERC721\n\t */\n\tfunction safeTransferFrom(address _from, address _to, uint256 _tokenId) public override {\n\t\t// delegate call to overloaded `safeTransferFrom()`, set data to \"\"\n\t\tsafeTransferFrom(_from, _to, _tokenId, \"\");\n\t}\n\n\t/**\n\t * @inheritdoc ERC721\n\t */\n\tfunction transferFrom(address _from, address _to, uint256 _tokenId) public override {\n\t\t// if `_from` is equal to sender, require transfers feature to be enabled\n\t\t// otherwise require transfers on behalf feature to be enabled\n\t\trequire(_from == msg.sender && isFeatureEnabled(FEATURE_TRANSFERS)\n\t\t     || _from != msg.sender && isFeatureEnabled(FEATURE_TRANSFERS_ON_BEHALF),\n\t\t        _from == msg.sender? \"transfers are disabled\": \"transfers on behalf are disabled\");\n\n\t\t// validate destination address is set\n\t\trequire(_to != address(0), \"zero address\");\n\n\t\t// validate token ownership, which also\n\t\t// validates token existence under the hood\n\t\trequire(_from == ownerOf(_tokenId), \"access denied\");\n\n\t\t// verify operator (transaction sender) is either token owner,\n\t\t// or is approved by the token owner to transfer this particular token,\n\t\t// or is approved by the token owner to transfer any of his tokens\n\t\trequire(_from == msg.sender || msg.sender == getApproved(_tokenId) || isApprovedForAll(_from, msg.sender), \"access denied\");\n\n\t\t// transfer is not allowed for a locked token\n\t\trequire(isTransferable(_tokenId), \"locked token\");\n\n\t\t// if required, move token ownership,\n\t\t// update old and new owner's token collections accordingly:\n\t\tif(_from != _to) {\n\t\t\t// remove token from old owner's collection (also clears approval)\n\t\t\t__removeLocal(_tokenId);\n\t\t\t// add token to the new owner's collection\n\t\t\t__addLocal(_tokenId, _to);\n\t\t}\n\t\t// even if no real changes are required, approval needs to be erased\n\t\telse {\n\t\t\t// clear token approval (also emits an Approval event)\n\t\t\t__clearApproval(_from, _tokenId);\n\t\t}\n\n\t\t// fire ERC721 transfer event\n\t\temit Transfer(_from, _to, _tokenId);\n\t}\n\n\t/**\n\t * @inheritdoc ERC721\n\t */\n\tfunction approve(address _approved, uint256 _tokenId) public override {\n\t\t// make an internal approve - delegate to `__approve`\n\t\t__approve(msg.sender, _approved, _tokenId);\n\t}\n\n\t/**\n\t * @dev Powers the meta transaction for `approve` - EIP-712 signed `permit`\n\t *\n\t * @dev Approves address called `_operator` to transfer token `_tokenId`\n\t *      on behalf of the `_owner`\n\t *\n\t * @dev Zero `_operator` address indicates there is no approved address,\n\t *      and effectively removes an approval for the token specified\n\t *\n\t * @dev `_owner` must own token `_tokenId` to grant the permission\n\t * @dev Throws if `_operator` is a self address (`_owner`),\n\t *      or if `_tokenId` doesn't exist\n\t *\n\t * @param _owner owner of the token `_tokenId` to set approval on behalf of\n\t * @param _operator an address approved by the token owner\n\t *      to spend token `_tokenId` on its behalf\n\t * @param _tokenId token ID operator `_approved` is allowed to\n\t *      transfer on behalf of the token owner\n\t */\n\tfunction __approve(address _owner, address _operator, uint256 _tokenId) private {\n\t\t// get token owner address\n\t\taddress owner = ownerOf(_tokenId);\n\n\t\t// approving owner address itself doesn't make sense and is not allowed\n\t\trequire(_operator != owner, \"self approval\");\n\n\t\t// only token owner or/and approved operator can set the approval\n\t\trequire(_owner == owner || isApprovedForAll(owner, _owner), \"access denied\");\n\n\t\t// update the approval\n\t\tapprovals[_tokenId] = _operator;\n\n\t\t// emit an event\n\t\temit Approval(owner, _operator, _tokenId);\n\t}\n\n\t/**\n\t * @inheritdoc ERC721\n\t */\n\tfunction setApprovalForAll(address _operator, bool _approved) public override {\n\t\t// make an internal approve - delegate to `__approveForAll`\n\t\t__approveForAll(msg.sender, _operator, _approved);\n\t}\n\n\t/**\n\t * @dev Powers the meta transaction for `setApprovalForAll` - EIP-712 signed `permitForAll`\n\t *\n\t * @dev Approves address called `_operator` to transfer any tokens\n\t *      on behalf of the `_owner`\n\t *\n\t * @dev `_owner` must not necessarily own any tokens to grant the permission\n\t * @dev Throws if `_operator` is a self address (`_owner`)\n\t *\n\t * @param _owner owner of the tokens to set approval on behalf of\n\t * @param _operator an address to add to the set of authorized operators, i.e.\n\t *      an address approved by the token owner to spend tokens on its behalf\n\t * @param _approved true if the operator is approved, false to revoke approval\n\t */\n\tfunction __approveForAll(address _owner, address _operator, bool _approved) private {\n\t\t// approving tx sender address itself doesn't make sense and is not allowed\n\t\trequire(_operator != _owner, \"self approval\");\n\n\t\t// update the approval\n\t\tapprovedOperators[_owner][_operator] = _approved;\n\n\t\t// emit an event\n\t\temit ApprovalForAll(_owner, _operator, _approved);\n\t}\n\n\t/**\n\t * @dev Clears approval for a given token owned by a given owner,\n\t *      emits an Approval event\n\t *\n\t * @dev Unsafe: doesn't check the validity of inputs (must be kept private),\n\t *      assuming the check is done by the caller\n\t *      - token existence\n\t *      - token ownership\n\t *\n\t * @param _owner token owner to be logged into Approved event as is\n\t * @param _tokenId token ID to erase approval for and to log into Approved event as is\n\t */\n\tfunction __clearApproval(address _owner, uint256 _tokenId) internal {\n\t\t// clear token approval\n\t\tdelete approvals[_tokenId];\n\t\t// emit an ERC721 Approval event:\n\t\t// \"When a Transfer event emits, this also indicates that the approved\n\t\t// address for that NFT (if any) is reset to none.\"\n\t\temit Approval(_owner, address(0), _tokenId);\n\t}\n\n\t// ===== End: ERC721 mutative functions (transfers, approvals) =====\n\n\t// ===== Start: Meta-transactions Support =====\n\n\t/**\n\t * @notice Change or reaffirm the approved address for an NFT on behalf\n\t *\n\t * @dev Executes approve(_operator, _tokenId) on behalf of the token owner\n\t *      who EIP-712 signed the transaction, i.e. as if transaction sender is the EIP712 signer\n\t *\n\t * @dev Sets the `_tokenId` as the allowance of `_operator` over `_owner` token,\n\t *      given `_owner` EIP-712 signed approval\n\t *\n\t * @dev Emits `Approval` event in the same way as `approve` does\n\t *\n\t * @dev Requires:\n\t *     - `_operator` to be non-zero address\n\t *     - `_exp` to be a timestamp in the future\n\t *     - `v`, `r` and `s` to be a valid `secp256k1` signature from `_owner`\n\t *        over the EIP712-formatted function arguments.\n\t *     - the signature to use `_owner` current nonce (see `permitNonces`).\n\t *\n\t * @dev For more information on the signature format, see the\n\t *      https://eips.ethereum.org/EIPS/eip-2612#specification\n\t *\n\t * @param _owner owner of the token to set approval on behalf of,\n\t *      an address which signed the EIP-712 message\n\t * @param _operator new approved NFT controller\n\t * @param _tokenId token ID to approve\n\t * @param _exp signature expiration time (unix timestamp)\n\t * @param v the recovery byte of the signature\n\t * @param r half of the ECDSA signature pair\n\t * @param s half of the ECDSA signature pair\n\t */\n\tfunction permit(address _owner, address _operator, uint256 _tokenId, uint256 _exp, uint8 v, bytes32 r, bytes32 s) public {\n\t\t// verify permits are enabled\n\t\trequire(isFeatureEnabled(FEATURE_PERMITS), \"permits are disabled\");\n\n\t\t// derive signer of the EIP712 Permit message, and\n\t\t// update the nonce for that particular signer to avoid replay attack!!! ----------->>> ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓\n\t\taddress signer = __deriveSigner(abi.encode(PERMIT_TYPEHASH, _owner, _operator, _tokenId, permitNonces[_owner]++, _exp), v, r, s);\n\n\t\t// perform message integrity and security validations\n\t\trequire(signer == _owner, \"invalid signature\");\n\t\trequire(block.timestamp < _exp, \"signature expired\");\n\n\t\t// delegate call to `__approve` - execute the logic required\n\t\t__approve(_owner, _operator, _tokenId);\n\t}\n\n\t/**\n\t * @notice Enable or disable approval for a third party (\"operator\") to manage\n\t *      all of owner's assets - on behalf\n\t *\n\t * @dev Executes setApprovalForAll(_operator, _approved) on behalf of the owner\n\t *      who EIP-712 signed the transaction, i.e. as if transaction sender is the EIP712 signer\n\t *\n\t * @dev Sets the `_operator` as the token operator for `_owner` tokens,\n\t *      given `_owner` EIP-712 signed approval\n\t *\n\t * @dev Emits `ApprovalForAll` event in the same way as `setApprovalForAll` does\n\t *\n\t * @dev Requires:\n\t *     - `_operator` to be non-zero address\n\t *     - `_exp` to be a timestamp in the future\n\t *     - `v`, `r` and `s` to be a valid `secp256k1` signature from `_owner`\n\t *        over the EIP712-formatted function arguments.\n\t *     - the signature to use `_owner` current nonce (see `permitNonces`).\n\t *\n\t * @dev For more information on the signature format, see the\n\t *      https://eips.ethereum.org/EIPS/eip-2612#specification\n\t *\n\t * @param _owner owner of the tokens to set approval on behalf of,\n\t *      an address which signed the EIP-712 message\n\t * @param _operator an address to add to the set of authorized operators, i.e.\n\t *      an address approved by the token owner to spend tokens on its behalf\n\t * @param _approved true if the operator is approved, false to revoke approval\n\t * @param _exp signature expiration time (unix timestamp)\n\t * @param v the recovery byte of the signature\n\t * @param r half of the ECDSA signature pair\n\t * @param s half of the ECDSA signature pair\n\t */\n\tfunction permitForAll(address _owner, address _operator, bool _approved, uint256 _exp, uint8 v, bytes32 r, bytes32 s) public {\n\t\t// verify permits are enabled\n\t\trequire(isFeatureEnabled(FEATURE_OPERATOR_PERMITS), \"operator permits are disabled\");\n\n\t\t// derive signer of the EIP712 PermitForAll message, and\n\t\t// update the nonce for that particular signer to avoid replay attack!!! --------------------->>> ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓\n\t\taddress signer = __deriveSigner(abi.encode(PERMIT_FOR_ALL_TYPEHASH, _owner, _operator, _approved, permitNonces[_owner]++, _exp), v, r, s);\n\n\t\t// perform message integrity and security validations\n\t\trequire(signer == _owner, \"invalid signature\");\n\t\trequire(block.timestamp < _exp, \"signature expired\");\n\n\t\t// delegate call to `__approve` - execute the logic required\n\t\t__approveForAll(_owner, _operator, _approved);\n\t}\n\n\t/**\n\t * @dev Auxiliary function to verify structured EIP712 message signature and derive its signer\n\t *\n\t * @param abiEncodedTypehash abi.encode of the message typehash together with all its parameters\n\t * @param v the recovery byte of the signature\n\t * @param r half of the ECDSA signature pair\n\t * @param s half of the ECDSA signature pair\n\t */\n\tfunction __deriveSigner(bytes memory abiEncodedTypehash, uint8 v, bytes32 r, bytes32 s) private view returns(address) {\n\t\t// build the EIP-712 hashStruct of the message\n\t\tbytes32 hashStruct = keccak256(abiEncodedTypehash);\n\n\t\t// calculate the EIP-712 digest \"\\x19\\x01\" ‖ domainSeparator ‖ hashStruct(message)\n\t\tbytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR(), hashStruct));\n\n\t\t// recover the address which signed the message with v, r, s\n\t\taddress signer = ECDSA.recover(digest, v, r, s);\n\n\t\t// check if the signer address isn't invalid\n\t\t// according to EIP3009 spec, zero address must be rejected when using ecrecover\n\t\trequire(signer != address(0), \"invalid signature\");\n\n\t\t// return the signer address derived from the signature\n\t\treturn signer;\n\t}\n\n\t// ===== End: Meta-transactions Support =====\n\n\t// ===== Start: mint support =====\n\n\t/**\n\t * @dev Creates new token with token ID specified\n\t *      and assigns an ownership `_to` for this token\n\t *\n\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\n\t *      `onERC721Received` on `_to` and throws if the return value is not\n\t *      `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n\t *\n\t * @dev Requires executor to have `ROLE_TOKEN_CREATOR` permission\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId ID of the token to mint\n\t * @param _data additional data with no specified format, sent in call to `_to`\n\t */\n\tfunction safeMint(address _to, uint256 _tokenId, bytes memory _data) public override {\n\t\t// delegate to unsafe mint\n\t\tmint(_to, _tokenId);\n\n\t\t// make it safe: execute `onERC721Received`\n\n\t\t// if receiver `_to` is a smart contract\n\t\tif(AddressUtils.isContract(_to)) {\n\t\t\t// check it supports ERC721 interface - execute onERC721Received()\n\t\t\tbytes4 response = ERC721TokenReceiver(_to).onERC721Received(msg.sender, address(0), _tokenId, _data);\n\n\t\t\t// expected response is ERC721TokenReceiver(_to).onERC721Received.selector\n\t\t\t// bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))\n\t\t\trequire(response == ERC721TokenReceiver(_to).onERC721Received.selector, \"invalid onERC721Received response\");\n\t\t}\n\t}\n\n\t/**\n\t * @dev Creates new token with token ID specified\n\t *      and assigns an ownership `_to` for this token\n\t *\n\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\n\t *      `onERC721Received` on `_to` and throws if the return value is not\n\t *      `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n\t *\n\t * @dev Requires executor to have `ROLE_TOKEN_CREATOR` permission\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId ID of the token to mint\n\t */\n\tfunction safeMint(address _to, uint256 _tokenId) public override {\n\t\t// delegate to `safeMint` with empty data\n\t\tsafeMint(_to, _tokenId, \"\");\n\t}\n\n\t/**\n\t * @dev Creates new tokens starting with token ID specified\n\t *      and assigns an ownership `_to` for these tokens\n\t *\n\t * @dev Token IDs to be minted: [_tokenId, _tokenId + n)\n\t *\n\t * @dev n must be greater or equal 2: `n > 1`\n\t *\n\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\n\t *      `onERC721Received` on `_to` and throws if the return value is not\n\t *      `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n\t *\n\t * @dev Requires executor to have `ROLE_TOKEN_CREATOR` permission\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId ID of the token to mint\n\t * @param n how many tokens to mint, sequentially increasing the _tokenId\n\t * @param _data additional data with no specified format, sent in call to `_to`\n\t */\n\tfunction safeMintBatch(address _to, uint256 _tokenId, uint256 n, bytes memory _data) public override {\n\t\t// delegate to unsafe mint\n\t\tmintBatch(_to, _tokenId, n);\n\n\t\t// make it safe: execute `onERC721Received`\n\n\t\t// if receiver `_to` is a smart contract\n\t\tif(AddressUtils.isContract(_to)) {\n\t\t\t// onERC721Received: for each token minted\n\t\t\tfor(uint256 i = 0; i < n; i++) {\n\t\t\t\t// check it supports ERC721 interface - execute onERC721Received()\n\t\t\t\tbytes4 response = ERC721TokenReceiver(_to).onERC721Received(msg.sender, address(0), _tokenId + i, _data);\n\n\t\t\t\t// expected response is ERC721TokenReceiver(_to).onERC721Received.selector\n\t\t\t\t// bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))\n\t\t\t\trequire(response == ERC721TokenReceiver(_to).onERC721Received.selector, \"invalid onERC721Received response\");\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @dev Creates new tokens starting with token ID specified\n\t *      and assigns an ownership `_to` for these tokens\n\t *\n\t * @dev Token IDs to be minted: [_tokenId, _tokenId + n)\n\t *\n\t * @dev n must be greater or equal 2: `n > 1`\n\t *\n\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\n\t *      `onERC721Received` on `_to` and throws if the return value is not\n\t *      `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n\t *\n\t * @dev Requires executor to have `ROLE_TOKEN_CREATOR` permission\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId ID of the token to mint\n\t * @param n how many tokens to mint, sequentially increasing the _tokenId\n\t */\n\tfunction safeMintBatch(address _to, uint256 _tokenId, uint256 n) public override {\n\t\t// delegate to `safeMint` with empty data\n\t\tsafeMintBatch(_to, _tokenId, n, \"\");\n\t}\n\n\t/**\n\t * @dev Creates new token with token ID specified\n\t *      and assigns an ownership `_to` for this token\n\t *\n\t * @dev Unsafe: doesn't execute `onERC721Received` on the receiver.\n\t *      Prefer the use of `saveMint` instead of `mint`.\n\t *\n\t * @dev Requires executor to have `ROLE_TOKEN_CREATOR` permission\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId ID of the token to mint\n\t */\n\tfunction mint(address _to, uint256 _tokenId) public override {\n\t\t// check if caller has sufficient permissions to mint tokens\n\t\trequire(isSenderInRole(ROLE_TOKEN_CREATOR), \"access denied\");\n\n\t\t// verify the inputs\n\n\t\t// verify the token ID is \"short\" (96 bits long at most)\n\t\trequire(uint96(_tokenId) == _tokenId, \"token ID overflow\");\n\t\t// verify destination address is set\n\t\trequire(_to != address(0), \"zero address\");\n\n\t\t// verify token doesn't yet exist\n\t\trequire(!exists(_tokenId), \"already minted\");\n\n\t\t// create token ownership record,\n\t\t// add token to `allTokens` and new owner's collections\n\t\t// add token to both local and global collections (enumerations)\n\t\t__addToken(_tokenId, _to);\n\n\t\t// fire ERC721 transfer event\n\t\temit Transfer(address(0), _to, _tokenId);\n\t}\n\n\t/**\n\t * @dev Creates new tokens starting with token ID specified\n\t *      and assigns an ownership `_to` for these tokens\n\t *\n\t * @dev Token IDs to be minted: [_tokenId, _tokenId + n)\n\t *\n\t * @dev n must be greater or equal 2: `n > 1`\n\t *\n\t * @dev Unsafe: doesn't execute `onERC721Received` on the receiver.\n\t *      Prefer the use of `saveMintBatch` instead of `mintBatch`.\n\t *\n\t * @dev Requires executor to have `ROLE_TOKEN_CREATOR` permission\n\t *\n\t * @param _to an address to mint tokens to\n\t * @param _tokenId ID of the first token to mint\n\t * @param n how many tokens to mint, sequentially increasing the _tokenId\n\t */\n\tfunction mintBatch(address _to, uint256 _tokenId, uint256 n) public override {\n\t\t// check if caller has sufficient permissions to mint tokens\n\t\trequire(isSenderInRole(ROLE_TOKEN_CREATOR), \"access denied\");\n\n\t\t// verify the inputs\n\n\t\t// verify destination address is set\n\t\trequire(_to != address(0), \"zero address\");\n\t\t// verify n is set properly\n\t\trequire(n > 1, \"n is too small\");\n\t\t// verify the token ID is \"small\" (96 bits long at most)\n\t\trequire(uint96(_tokenId) == _tokenId, \"token ID overflow\");\n\t\trequire(uint96(_tokenId + n - 1) == _tokenId + n - 1, \"n-th token ID overflow\");\n\n\t\t// verification: for each token to be minted\n\t\tfor(uint256 i = 0; i < n; i++) {\n\t\t\t// verify token doesn't yet exist\n\t\t\trequire(!exists(_tokenId + i), \"already minted\");\n\t\t}\n\n\t\t// create token ownership records,\n\t\t// add tokens to `allTokens` and new owner's collections\n\t\t// add tokens to both local and global collections (enumerations)\n\t\t__addTokens(_to, _tokenId, n);\n\n\t\t// events: for each token minted\n\t\tfor(uint256 i = 0; i < n; i++) {\n\t\t\t// fire ERC721 transfer event\n\t\t\temit Transfer(address(0), _to, _tokenId + i);\n\t\t}\n\t}\n\n\t// ===== End: mint support =====\n\n\t// ----- Start: auxiliary internal/private functions -----\n\n\t/**\n\t * @dev Adds token to the new owner's collection (local),\n\t *      used internally to transfer existing tokens, to mint new\n\t *\n\t * @dev Unsafe: doesn't check for data structures consistency\n\t *      (token existence, token ownership, etc.)\n\t *\n\t * @dev Must be kept private at all times. Inheriting smart contracts\n\t *      may be interested in overriding this function.\n\t *\n\t * @param _tokenId token ID to add\n\t * @param _to new owner address to add token to\n\t */\n\tfunction __addLocal(uint256 _tokenId, address _to) internal virtual {\n\t\t// get a reference to the collection where token goes to\n\t\tuint96[] storage destination = collections[_to];\n\n\t\t// update local index and ownership, do not change global index\n\t\ttokens[_tokenId] = destination.length << 160 | uint160(_to);\n\n\t\t// push token into the collection\n\t\tdestination.push(uint96(_tokenId));\n\t}\n\n\t/**\n\t * @dev Add token to both local and global collections (enumerations),\n\t *      used internally to mint new tokens\n\t *\n\t * @dev Unsafe: doesn't check for data structures consistency\n\t *      (token existence, token ownership, etc.)\n\t *\n\t * @dev Must be kept private at all times. Inheriting smart contracts\n\t *      may be interested in overriding this function.\n\t *\n\t * @param _tokenId token ID to add\n\t * @param _to new owner address to add token to\n\t */\n\tfunction __addToken(uint256 _tokenId, address _to) internal virtual {\n\t\t// add token to a local collection first\n\t\t__addLocal(_tokenId, _to);\n\n\t\t// push it into the global `allTokens` collection (enumeration)\n\t\tallTokens.push(uint96(_tokenId));\n\t}\n\n\t/**\n * @dev Add tokens to both local and global collections (enumerations),\n *      used internally to mint new tokens in batches\n *\n * @dev Token IDs to be added: [_tokenId, _tokenId + n)\n *      n is expected to be greater or equal 2, but this is not checked\n *\n * @dev Unsafe: doesn't check for data structures consistency\n *      (token existence, token ownership, etc.)\n *\n * @dev Must be kept private at all times. Inheriting smart contracts\n *      may be interested in overriding this function.\n *\n * @param _to new owner address to add token to\n * @param _tokenId first token ID to add\n * @param n how many tokens to add, sequentially increasing the _tokenId\n */\n\tfunction __addTokens(address _to, uint256 _tokenId, uint256 n) internal virtual {\n\t\t// get a reference to the collection where tokens go to\n\t\tuint96[] storage destination = collections[_to];\n\n\t\t// for each token to be added\n\t\tfor(uint256 i = 0; i < n; i++) {\n\t\t\t// Note: splitting one loop with three doesn't optimize writing into array\n\t\t\t// update token global and local indexes, ownership\n\t\t\ttokens[_tokenId + i] = destination.length + i << 160 | uint160(_to);\n\t\t\t// push token into the local collection\n\t\t\tdestination.push(uint96(_tokenId + i));\n\t\t\t// push it into the global `allTokens` collection (enumeration)\n\t\t\tallTokens.push(uint96(_tokenId + i));\n\t\t}\n\t}\n\n\t/**\n\t * @dev Removes token from owner's local collection,\n\t *      used internally to transfer or burn existing tokens\n\t *\n\t * @dev Unsafe: doesn't check for data structures consistency\n\t *      (token existence, token ownership, etc.)\n\t *\n\t * @dev Must be kept private at all times. Inheriting smart contracts\n\t *      may be interested in overriding this function.\n\t *\n\t * @param _tokenId token ID to remove\n\t */\n\tfunction __removeLocal(uint256 _tokenId) internal virtual {\n\t\t// read token data, containing local index, and owner address\n\t\tuint256 token = tokens[_tokenId];\n\n\t\t// get a reference to the token's owner collection (local)\n\t\tuint96[] storage source = collections[address(uint160(token))];\n\n\t\t// token index within the collection\n\t\tuint256 i = token >> 160;\n\n\t\t// get an ID of the last token in the collection\n\t\tuint96 sourceId = source[source.length - 1];\n\n\t\t// if the token we're to remove from the collection is not the last one,\n\t\t// we need to move last token in the collection into index `i`\n\t\tif(i != source.length - 1) {\n\t\t\t// we put the last token in the collection to the position released\n\n\t\t\t// update last token index to point to proper place in the collection\n\t\t\ttokens[sourceId] = tokens[sourceId]\n\t\t\t\t// | local idx              | ownership information (address)      |\n\t\t\t\t& 0x000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n\t\t\t\t| i << 160;\n\n\t\t\t// put it into the position `i` within the collection\n\t\t\tsource[i] = sourceId;\n\t\t}\n\n\t\t// trim the collection by removing last element\n\t\tsource.pop();\n\n\t\t// clear token approval (also emits an Approval event)\n\t\t__clearApproval(address(uint160(token)), _tokenId);\n\t}\n\n\t// ----- End: auxiliary internal/private functions -----\n}\n"
    },
    "contracts/token/TinyERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ERC721Spec.sol\";\nimport \"../interfaces/ERC721SpecExt.sol\";\nimport \"../lib/AddressUtils.sol\";\nimport \"../lib/ArrayUtils.sol\";\nimport \"../lib/StringUtils.sol\";\nimport \"../lib/ECDSA.sol\";\nimport \"../utils/AccessControl.sol\";\n\n/**\n * @title Tiny ERC721\n *\n * @notice Tiny ERC721 defines an NFT with a very small (up to 32 bits) ID space.\n *      ERC721 enumeration support requires additional writes to the storage:\n *      - when transferring a token in order to update the NFT collections of\n *        the previous and next owners,\n *      - when minting/burning a token in order to update global NFT collection\n *\n * @notice Reducing NFT ID space to 32 bits allows\n *      - to eliminate the need to have and to write to two additional storage mappings\n *        (also achievable with the 48 bits ID space)\n *      - for batch minting optimization by writing 8 tokens instead of 5 at once into\n *        global/local collections\n *\n * @notice This smart contract is designed to be inherited by concrete implementations,\n *      which are expected to define token metadata, auxiliary functions to access the metadata,\n *      and explicitly define token minting interface, which should be built on top\n *      of current smart contract internal interface\n *\n * @notice Fully ERC721-compatible with all optional interfaces implemented (metadata, enumeration),\n *      see https://eips.ethereum.org/EIPS/eip-721\n *\n * @dev ERC721: contract has passed adopted OpenZeppelin ERC721 tests\n *        https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/test/token/ERC721/ERC721.behavior.js\n *        https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/test/token/ERC721/extensions/ERC721URIStorage.test.js\n *\n * @dev A note on token URI: there are major differences on how token URI behaves comparing to Zeppelin impl:\n *      1. A token URI can be set for non-existing token for pre-allocation purposes,\n *         still the URI will be deleted once token is burnt\n *      2. If token URI is set, base URI has no affect on the token URI, the two are not concatenated,\n *         base URI is used to construct the token URI only if the latter was not explicitly set\n *\n * @dev Supports EIP-712 powered permits - permit() - approve() with signature.\n *      Supports EIP-712 powered operator permits - permitForAll() - setApprovalForAll() with signature.\n *\n * @dev EIP712 Domain:\n *      name: AliERC721v1\n *      version: not in use, omitted (name already contains version)\n *      chainId: EIP-155 chain id\n *      verifyingContract: deployed contract address\n *      salt: permitNonces[owner], where owner is an address which allows operation on their tokens\n *\n * @dev Permit type:\n *      owner: address\n *      operator: address\n *      tokenId: uint256\n *      nonce: uint256\n *      deadline: uint256\n *\n * @dev Permit typeHash:\n *        keccak256(\"Permit(address owner,address operator,uint256 tokenId,uint256 nonce,uint256 deadline)\")\n *\n * @dev PermitForAll type:\n *      owner: address\n *      operator: address\n *      approved: bool\n *      nonce: uint256\n *      deadline: uint256\n *\n * @dev PermitForAll typeHash:\n *        keccak256(\"PermitForAll(address owner,address operator,bool approved,uint256 nonce,uint256 deadline)\")\n *\n * @dev See https://eips.ethereum.org/EIPS/eip-712\n * @dev See usage examples in tests: erc721_permits.js\n */\nabstract contract TinyERC721 is ERC721Enumerable, ERC721Metadata, WithBaseURI, MintableERC721, BurnableERC721, AccessControl {\n\t// enable push32 optimization for uint32[]\n\tusing ArrayUtils for uint32[];\n\n\t/**\n\t * @dev Smart contract unique identifier, a random number\n\t *\n\t * @dev Should be regenerated each time smart contact source code is changed\n\t *      and changes smart contract itself is to be redeployed\n\t *\n\t * @dev Generated using https://www.random.org/bytes/\n\t * @dev Example value: 0xdbdd2b4ff38a8516da0b8e7ae93288b5e2fed0c92fb051cee90ccf4e4ec9736e\n\t */\n\tfunction TOKEN_UID() external view virtual returns(uint256);\n\n\t/**\n\t * @notice ERC-20 compatible descriptive name for a collection of NFTs in this contract\n\t *\n\t * @inheritdoc ERC721Metadata\n\t */\n\tstring public override name;\n\n\t/**\n\t * @notice ERC-20 compatible abbreviated name for a collection of NFTs in this contract\n\t *\n\t * @inheritdoc ERC721Metadata\n\t */\n\tstring public override symbol;\n\n\t/**\n\t * @notice Current implementation includes a function `decimals` that returns uint8(0)\n\t *      to be more compatible with ERC-20\n\t *\n\t * @dev ERC20 compliant token decimals is equal to zero since ERC721 token is non-fungible\n\t *      and therefore non-divisible\n\t */\n\tuint8 public constant decimals = 0;\n\n\t/**\n\t * @notice Ownership information for all the tokens in existence\n\t *\n\t * @dev Maps `Token ID => Token ID Global Index | Token ID Local Index | Token Owner Address`, where\n\t *      - Token ID Global Index denotes Token ID index in the array of all the tokens,\n\t *      - Token ID Local Index denotes Token ID index in the array of all the tokens owned by the owner,\n\t *      - Token ID indexes are 32 bits long,\n\t *      - `|` denotes bitwise concatenation of the values\n\t * @dev Token Owner Address for a given Token ID is lower 160 bits of the mapping value\n\t */\n\tmapping(uint256 => uint256) internal tokens;\n\n\t/**\n\t * @notice Enumerated collections of the tokens owned by particular owners\n\t *\n\t * @dev We call these collections \"Local\" token collections\n\t *\n\t * @dev Maps `Token Owner Address => Owned Token IDs Array`\n\t *\n\t * @dev Token owner balance is the length of their token collection:\n\t *      `balanceOf(owner) = collections[owner].length`\n\t */\n\tmapping(address => uint32[]) internal collections;\n\n\t/**\n\t * @notice An array of all the tokens in existence\n\t *\n\t * @dev We call this collection \"Global\" token collection\n\t *\n\t * @dev Array with all Token IDs, used for enumeration\n\t *\n\t * @dev Total token supply `tokenSupply` is the length of this collection:\n\t *      `totalSupply() = allTokens.length`\n\t */\n\tuint32[] internal allTokens;\n\n\t/**\n\t * @notice Addresses approved by token owners to transfer their tokens\n\t *\n\t * @dev `Maps Token ID => Approved Address`, where\n\t *      Approved Address is an address allowed transfer ownership for the token\n\t *      defined by Token ID\n\t */\n\tmapping(uint256 => address) internal approvals;\n\n\t/**\n\t * @notice Addresses approved by token owners to transfer all their tokens\n\t *\n\t * @dev Maps `Token Owner Address => Operator Address => Approval State` - true/false (approved/not), where\n\t *      - Token Owner Address is any address which may own tokens or not,\n\t *      - Operator Address is any other address which may own tokens or not,\n\t *      - Approval State is a flag indicating if Operator Address is allowed to\n\t *        transfer tokens owned by Token Owner Address o their behalf\n\t */\n\tmapping(address => mapping(address => bool)) internal approvedOperators;\n\n\t/**\n\t * @dev A record of nonces for signing/validating signatures in EIP-712 based\n\t *      `permit` and `permitForAll` functions\n\t *\n\t * @dev Each time the nonce is used, it is increased by one, meaning reordering\n\t *      of the EIP-712 transactions is not possible\n\t *\n\t * @dev Inspired by EIP-2612 extension for ERC20 token standard\n\t *\n\t * @dev Maps token owner address => token owner nonce\n\t */\n\tmapping(address => uint256) public permitNonces;\n\n\t/**\n\t * @dev Base URI is used to construct ERC721Metadata.tokenURI as\n\t *      `base URI + token ID` if token URI is not set (not present in `_tokenURIs` mapping)\n\t *\n\t * @dev For example, if base URI is https://api.com/token/, then token #1\n\t *      will have an URI https://api.com/token/1\n\t *\n\t * @dev If token URI is set with `setTokenURI()` it will be returned as is via `tokenURI()`\n\t */\n\tstring public override baseURI = \"\";\n\n\t/**\n\t * @dev Optional mapping for token URIs to be returned as is when `tokenURI()`\n\t *      is called; if mapping doesn't exist for token, the URI is constructed\n\t *      as `base URI + token ID`, where plus (+) denotes string concatenation\n\t */\n\tmapping(uint256 => string) internal _tokenURIs;\n\n\t/**\n\t * @dev 32 bit token ID space is optimal for batch minting in batches of size 8\n\t *      8 * 32 = 256 - single storage slot in global/local collection(s)\n\t */\n\tuint8 public constant BATCH_SIZE_MULTIPLIER = 8;\n\n\t/**\n\t * @notice Enables ERC721 transfers of the tokens\n\t *      (transfer by the token owner himself)\n\t * @dev Feature FEATURE_TRANSFERS must be enabled in order for\n\t *      `transferFrom()` function to succeed when executed by token owner\n\t */\n\tuint32 public constant FEATURE_TRANSFERS = 0x0000_0001;\n\n\t/**\n\t * @notice Enables ERC721 transfers on behalf\n\t *      (transfer by someone else on behalf of token owner)\n\t * @dev Feature FEATURE_TRANSFERS_ON_BEHALF must be enabled in order for\n\t *      `transferFrom()` function to succeed whe executed by approved operator\n\t * @dev Token owner must call `approve()` or `setApprovalForAll()`\n\t *      first to authorize the transfer on behalf\n\t */\n\tuint32 public constant FEATURE_TRANSFERS_ON_BEHALF = 0x0000_0002;\n\n\t/**\n\t * @notice Enables token owners to burn their own tokens\n\t *\n\t * @dev Feature FEATURE_OWN_BURNS must be enabled in order for\n\t *      `burn()` function to succeed when called by token owner\n\t */\n\tuint32 public constant FEATURE_OWN_BURNS = 0x0000_0008;\n\n\t/**\n\t * @notice Enables approved operators to burn tokens on behalf of their owners\n\t *\n\t * @dev Feature FEATURE_BURNS_ON_BEHALF must be enabled in order for\n\t *      `burn()` function to succeed when called by approved operator\n\t */\n\tuint32 public constant FEATURE_BURNS_ON_BEHALF = 0x0000_0010;\n\n\t/**\n\t * @notice Enables approvals on behalf (permits via an EIP712 signature)\n\t * @dev Feature FEATURE_PERMITS must be enabled in order for\n\t *      `permit()` function to succeed\n\t */\n\tuint32 public constant FEATURE_PERMITS = 0x0000_0200;\n\n\t/**\n\t * @notice Enables operator approvals on behalf (permits for all via an EIP712 signature)\n\t * @dev Feature FEATURE_OPERATOR_PERMITS must be enabled in order for\n\t *      `permitForAll()` function to succeed\n\t */\n\tuint32 public constant FEATURE_OPERATOR_PERMITS = 0x0000_0400;\n\n\t/**\n\t * @notice Token creator is responsible for creating (minting)\n\t *      tokens to an arbitrary address\n\t * @dev Role ROLE_TOKEN_CREATOR allows minting tokens\n\t *      (calling `mint` function)\n\t */\n\tuint32 public constant ROLE_TOKEN_CREATOR = 0x0001_0000;\n\n\t/**\n\t * @notice Token destroyer is responsible for destroying (burning)\n\t *      tokens owned by an arbitrary address\n\t * @dev Role ROLE_TOKEN_DESTROYER allows burning tokens\n\t *      (calling `burn` function)\n\t */\n\tuint32 public constant ROLE_TOKEN_DESTROYER = 0x0002_0000;\n\n\t/**\n\t * @notice URI manager is responsible for managing base URI\n\t *      part of the token URI ERC721Metadata interface\n\t *\n\t * @dev Role ROLE_URI_MANAGER allows updating the base URI\n\t *      (executing `setBaseURI` function)\n\t */\n\tuint32 public constant ROLE_URI_MANAGER = 0x0010_0000;\n\n\t/**\n\t * @notice EIP-712 contract's domain typeHash,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\n\t *\n\t * @dev Note: we do not include version into the domain typehash/separator,\n\t *      it is implied version is concatenated to the name field, like \"AliERC721v1\"\n\t */\n\t// keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\")\n\tbytes32 public constant DOMAIN_TYPEHASH = 0x8cad95687ba82c2ce50e74f7b754645e5117c3a5bec8151c0726d5857980a866;\n\n\t/**\n\t * @notice EIP-712 contract's domain separator,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator\n\t *      note: we specify contract version in its name\n\t */\n\tfunction DOMAIN_SEPARATOR() public view returns(bytes32) {\n\t\t// build the EIP-712 contract domain separator, see https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator\n\t\t// note: we specify contract version in its name\n\t\treturn keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(\"AliERC721v1\")), block.chainid, address(this)));\n\t}\n\n\t/**\n\t * @notice EIP-712 permit (EIP-2612) struct typeHash,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\n\t */\n\t// keccak256(\"Permit(address owner,address operator,uint256 tokenId,uint256 nonce,uint256 deadline)\")\n\tbytes32 public constant PERMIT_TYPEHASH = 0xee2282d7affd5a432b221a559e429129347b0c19a3f102179a5fb1859eef3d29;\n\n\t/**\n\t * @notice EIP-712 permitForAll (EIP-2612) struct typeHash,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\n\t */\n\t// keccak256(\"PermitForAll(address owner,address operator,bool approved,uint256 nonce,uint256 deadline)\")\n\tbytes32 public constant PERMIT_FOR_ALL_TYPEHASH = 0x47ab88482c90e4bb94b82a947ae78fa91fb25de1469ab491f4c15b9a0a2677ee;\n\n\t/**\n\t * @dev Fired in setBaseURI()\n\t *\n\t * @param _by an address which executed update\n\t * @param _oldVal old _baseURI value\n\t * @param _newVal new _baseURI value\n\t */\n\tevent BaseURIUpdated(address indexed _by, string _oldVal, string _newVal);\n\n\t/**\n\t * @dev Fired in setTokenURI()\n\t *\n\t * @param _by an address which executed update\n\t * @param _tokenId token ID which URI was updated\n\t * @param _oldVal old _baseURI value\n\t * @param _newVal new _baseURI value\n\t */\n\tevent TokenURIUpdated(address indexed _by, uint256 _tokenId, string _oldVal, string _newVal);\n\n\t/**\n\t * @dev Constructs/deploys ERC721 instance with the name and symbol specified\n\t *\n\t * @param _name name of the token to be accessible as `name()`,\n\t *      ERC-20 compatible descriptive name for a collection of NFTs in this contract\n\t * @param _symbol token symbol to be accessible as `symbol()`,\n\t *      ERC-20 compatible descriptive name for a collection of NFTs in this contract\n\t */\n\tconstructor(string memory _name, string memory _symbol) {\n\t\t// set the name\n\t\tname = _name;\n\n\t\t// set the symbol\n\t\tsymbol = _symbol;\n\t}\n\n\t/**\n\t * @dev Verifies if token is transferable (i.e. can change ownership, allowed to be transferred);\n\t *      The default behaviour is to always allow transfer if token exists\n\t *\n\t * @dev Implementations may modify the default behaviour based on token metadata\n\t *      if required\n\t *\n\t * @param _tokenId ID of the token to check if it's transferable\n\t * @return true if token is transferable, false otherwise\n\t */\n\tfunction isTransferable(uint256 _tokenId) public view virtual returns(bool) {\n\t\t// validate token existence\n\t\trequire(exists(_tokenId), \"token doesn't exist\");\n\n\t\t// generic implementation returns true if token exists\n\t\treturn true;\n\t}\n\n\t/**\n\t * @notice Checks if specified token exists\n\t *\n\t * @dev Returns whether the specified token ID has an ownership\n\t *      information associated with it\n\t *\n\t * @inheritdoc MintableERC721\n\t *\n\t * @param _tokenId ID of the token to query existence for\n\t * @return whether the token exists (true - exists, false - doesn't exist)\n\t */\n\tfunction exists(uint256 _tokenId) public override view returns(bool) {\n\t\t// read ownership information and return a check if it's not zero (set)\n\t\treturn tokens[_tokenId] != 0;\n\t}\n\n\t/**\n\t * @inheritdoc ERC165\n\t */\n\tfunction supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n\t\t// construct the interface support from required and optional ERC721 interfaces\n\t\treturn interfaceId == type(ERC165).interfaceId\n\t\t\t|| interfaceId == type(ERC721).interfaceId\n\t\t\t|| interfaceId == type(ERC721Metadata).interfaceId\n\t\t\t|| interfaceId == type(ERC721Enumerable).interfaceId\n\t\t\t|| interfaceId == type(MintableERC721).interfaceId\n\t\t\t|| interfaceId == type(BurnableERC721).interfaceId;\n\t}\n\n\t// ===== Start: ERC721 Metadata =====\n\n\t/**\n\t * @dev Restricted access function which updates base URI used to construct\n\t *      ERC721Metadata.tokenURI\n\t *\n\t * @dev Requires executor to have ROLE_URI_MANAGER permission\n\t *\n\t * @param _baseURI new base URI to set\n\t */\n\tfunction setBaseURI(string memory _baseURI) public virtual {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_URI_MANAGER), \"access denied\");\n\n\t\t// emit an event first - to log both old and new values\n\t\temit BaseURIUpdated(msg.sender, baseURI, _baseURI);\n\n\t\t// and update base URI\n\t\tbaseURI = _baseURI;\n\t}\n\n\t/**\n\t * @dev Returns token URI if it was previously set with `setTokenURI`,\n\t *      otherwise constructs it as base URI + token ID\n\t *\n\t * @inheritdoc ERC721Metadata\n\t */\n\tfunction tokenURI(uint256 _tokenId) public view override returns (string memory) {\n\t\t// verify token exists\n\t\trequire(exists(_tokenId), \"token doesn't exist\");\n\n\t\t// read the token URI for the token specified\n\t\tstring memory _tokenURI = _tokenURIs[_tokenId];\n\n\t\t// if token URI is set\n\t\tif(bytes(_tokenURI).length > 0) {\n\t\t\t// just return it\n\t\t\treturn _tokenURI;\n\t\t}\n\n\t\t// if base URI is not set\n\t\tif(bytes(baseURI).length == 0) {\n\t\t\t// return an empty string\n\t\t\treturn \"\";\n\t\t}\n\n\t\t// otherwise concatenate base URI + token ID\n\t\treturn StringUtils.concat(baseURI, StringUtils.itoa(_tokenId, 10));\n\t}\n\n\t/**\n\t * @dev Sets the token URI for the token defined by its ID\n\t *\n\t * @param _tokenId an ID of the token to set URI for\n\t * @param _tokenURI token URI to set\n\t */\n\tfunction setTokenURI(uint256 _tokenId, string memory _tokenURI) public virtual {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_URI_MANAGER), \"access denied\");\n\n\t\t// we do not verify token existence: we want to be able to\n\t\t// preallocate token URIs before tokens are actually minted\n\n\t\t// emit an event first - to log both old and new values\n\t\temit TokenURIUpdated(msg.sender, _tokenId, _tokenURIs[_tokenId], _tokenURI);\n\n\t\t// and update token URI\n\t\t_tokenURIs[_tokenId] = _tokenURI;\n\t}\n\n\t// ===== End: ERC721 Metadata =====\n\n\t// ===== Start: ERC721, ERC721Enumerable Getters (view functions) =====\n\n\t/**\n\t * @inheritdoc ERC721\n\t */\n\tfunction balanceOf(address _owner) public view override returns (uint256) {\n\t\t// check `_owner` address is set\n\t\trequire(_owner != address(0), \"zero address\");\n\n\t\t// derive owner balance for the their owned tokens collection\n\t\t// as the length of that collection\n\t\treturn collections[_owner].length;\n\t}\n\n\t/**\n\t * @inheritdoc ERC721\n\t */\n\tfunction ownerOf(uint256 _tokenId) public view override returns (address) {\n\t\t// derive ownership information of the token from the ownership mapping\n\t\t// by extracting lower 160 bits of the mapping value as an address\n\t\taddress owner = address(uint160(tokens[_tokenId]));\n\n\t\t// verify owner/token exists\n\t\trequire(owner != address(0), \"token doesn't exist\");\n\n\t\t// return owner address\n\t\treturn owner;\n\t}\n\n\t/**\n\t * @inheritdoc ERC721Enumerable\n\t */\n\tfunction totalSupply() public view override returns (uint256) {\n\t\t// derive total supply value from the array of all existing tokens\n\t\t// as the length of this array\n\t\treturn allTokens.length;\n\t}\n\n\t/**\n\t * @inheritdoc ERC721Enumerable\n\t */\n\tfunction tokenByIndex(uint256 _index) public view override returns (uint256) {\n\t\t// index out of bounds check\n\t\trequire(_index < totalSupply(), \"index out of bounds\");\n\n\t\t// find the token ID requested and return\n\t\treturn allTokens[_index];\n\t}\n\n\t/**\n\t * @inheritdoc ERC721Enumerable\n\t */\n\tfunction tokenOfOwnerByIndex(address _owner, uint256 _index) public view override returns (uint256) {\n\t\t// index out of bounds check\n\t\trequire(_index < balanceOf(_owner), \"index out of bounds\");\n\n\t\t// find the token ID requested and return\n\t\treturn collections[_owner][_index];\n\t}\n\n\t/**\n\t * @inheritdoc ERC721\n\t */\n\tfunction getApproved(uint256 _tokenId) public view override returns (address) {\n\t\t// verify token specified exists\n\t\trequire(exists(_tokenId), \"token doesn't exist\");\n\n\t\t// read the approval value and return\n\t\treturn approvals[_tokenId];\n\t}\n\n\t/**\n\t * @inheritdoc ERC721\n\t */\n\tfunction isApprovedForAll(address _owner, address _operator) public view override returns (bool) {\n\t\t// read the approval state value and return\n\t\treturn approvedOperators[_owner][_operator];\n\t}\n\n\t// ===== End: ERC721, ERC721Enumerable Getters (view functions) =====\n\n\t// ===== Start: ERC721 mutative functions (transfers, approvals) =====\n\n\t/**\n\t * @inheritdoc ERC721\n\t */\n\tfunction safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory _data) public override {\n\t\t// delegate call to unsafe transfer on behalf `transferFrom()`\n\t\ttransferFrom(_from, _to, _tokenId);\n\n\t\t// if receiver `_to` is a smart contract\n\t\tif(AddressUtils.isContract(_to)) {\n\t\t\t// check it supports ERC721 interface - execute onERC721Received()\n\t\t\tbytes4 response = ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data);\n\n\t\t\t// expected response is ERC721TokenReceiver(_to).onERC721Received.selector\n\t\t\t// bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))\n\t\t\trequire(response == ERC721TokenReceiver(_to).onERC721Received.selector, \"invalid onERC721Received response\");\n\t\t}\n\t}\n\n\t/**\n\t * @inheritdoc ERC721\n\t */\n\tfunction safeTransferFrom(address _from, address _to, uint256 _tokenId) public override {\n\t\t// delegate call to overloaded `safeTransferFrom()`, set data to \"\"\n\t\tsafeTransferFrom(_from, _to, _tokenId, \"\");\n\t}\n\n\t/**\n\t * @inheritdoc ERC721\n\t */\n\tfunction transferFrom(address _from, address _to, uint256 _tokenId) public override {\n\t\t// if `_from` is equal to sender, require transfers feature to be enabled\n\t\t// otherwise require transfers on behalf feature to be enabled\n\t\trequire(_from == msg.sender && isFeatureEnabled(FEATURE_TRANSFERS)\n\t\t     || _from != msg.sender && isFeatureEnabled(FEATURE_TRANSFERS_ON_BEHALF),\n\t\t        _from == msg.sender? \"transfers are disabled\": \"transfers on behalf are disabled\");\n\n\t\t// validate destination address is set\n\t\trequire(_to != address(0), \"zero address\");\n\n\t\t// validate token ownership, which also\n\t\t// validates token existence under the hood\n\t\trequire(_from == ownerOf(_tokenId), \"access denied\");\n\n\t\t// verify operator (transaction sender) is either token owner,\n\t\t// or is approved by the token owner to transfer this particular token,\n\t\t// or is approved by the token owner to transfer any of his tokens\n\t\trequire(_from == msg.sender || msg.sender == getApproved(_tokenId) || isApprovedForAll(_from, msg.sender), \"access denied\");\n\n\t\t// transfer is not allowed for a locked token\n\t\trequire(isTransferable(_tokenId), \"locked token\");\n\n\t\t// if required, move token ownership,\n\t\t// update old and new owner's token collections accordingly:\n\t\tif(_from != _to) {\n\t\t\t// remove token from old owner's collection (also clears approval)\n\t\t\t__removeLocal(_tokenId);\n\t\t\t// add token to the new owner's collection\n\t\t\t__addLocal(_tokenId, _to);\n\t\t}\n\t\t// even if no real changes are required, approval needs to be erased\n\t\telse {\n\t\t\t// clear token approval (also emits an Approval event)\n\t\t\t__clearApproval(_from, _tokenId);\n\t\t}\n\n\t\t// fire ERC721 transfer event\n\t\temit Transfer(_from, _to, _tokenId);\n\t}\n\n\t/**\n\t * @inheritdoc ERC721\n\t */\n\tfunction approve(address _approved, uint256 _tokenId) public override {\n\t\t// make an internal approve - delegate to `__approve`\n\t\t__approve(msg.sender, _approved, _tokenId);\n\t}\n\n\t/**\n\t * @dev Powers the meta transaction for `approve` - EIP-712 signed `permit`\n\t *\n\t * @dev Approves address called `_operator` to transfer token `_tokenId`\n\t *      on behalf of the `_owner`\n\t *\n\t * @dev Zero `_operator` address indicates there is no approved address,\n\t *      and effectively removes an approval for the token specified\n\t *\n\t * @dev `_owner` must own token `_tokenId` to grant the permission\n\t * @dev Throws if `_operator` is a self address (`_owner`),\n\t *      or if `_tokenId` doesn't exist\n\t *\n\t * @param _owner owner of the token `_tokenId` to set approval on behalf of\n\t * @param _operator an address approved by the token owner\n\t *      to spend token `_tokenId` on its behalf\n\t * @param _tokenId token ID operator `_approved` is allowed to\n\t *      transfer on behalf of the token owner\n\t */\n\tfunction __approve(address _owner, address _operator, uint256 _tokenId) private {\n\t\t// get token owner address\n\t\taddress owner = ownerOf(_tokenId);\n\n\t\t// approving owner address itself doesn't make sense and is not allowed\n\t\trequire(_operator != owner, \"self approval\");\n\n\t\t// only token owner or/and approved operator can set the approval\n\t\trequire(_owner == owner || isApprovedForAll(owner, _owner), \"access denied\");\n\n\t\t// update the approval\n\t\tapprovals[_tokenId] = _operator;\n\n\t\t// emit an event\n\t\temit Approval(owner, _operator, _tokenId);\n\t}\n\n\t/**\n\t * @inheritdoc ERC721\n\t */\n\tfunction setApprovalForAll(address _operator, bool _approved) public override {\n\t\t// make an internal approve - delegate to `__approveForAll`\n\t\t__approveForAll(msg.sender, _operator, _approved);\n\t}\n\n\t/**\n\t * @dev Powers the meta transaction for `setApprovalForAll` - EIP-712 signed `permitForAll`\n\t *\n\t * @dev Approves address called `_operator` to transfer any tokens\n\t *      on behalf of the `_owner`\n\t *\n\t * @dev `_owner` must not necessarily own any tokens to grant the permission\n\t * @dev Throws if `_operator` is a self address (`_owner`)\n\t *\n\t * @param _owner owner of the tokens to set approval on behalf of\n\t * @param _operator an address to add to the set of authorized operators, i.e.\n\t *      an address approved by the token owner to spend tokens on its behalf\n\t * @param _approved true if the operator is approved, false to revoke approval\n\t */\n\tfunction __approveForAll(address _owner, address _operator, bool _approved) private {\n\t\t// approving tx sender address itself doesn't make sense and is not allowed\n\t\trequire(_operator != _owner, \"self approval\");\n\n\t\t// update the approval\n\t\tapprovedOperators[_owner][_operator] = _approved;\n\n\t\t// emit an event\n\t\temit ApprovalForAll(_owner, _operator, _approved);\n\t}\n\n\t/**\n\t * @dev Clears approval for a given token owned by a given owner,\n\t *      emits an Approval event\n\t *\n\t * @dev Unsafe: doesn't check the validity of inputs (must be kept private),\n\t *      assuming the check is done by the caller\n\t *      - token existence\n\t *      - token ownership\n\t *\n\t * @param _owner token owner to be logged into Approved event as is\n\t * @param _tokenId token ID to erase approval for and to log into Approved event as is\n\t */\n\tfunction __clearApproval(address _owner, uint256 _tokenId) internal {\n\t\t// clear token approval\n\t\tdelete approvals[_tokenId];\n\t\t// emit an ERC721 Approval event:\n\t\t// \"When a Transfer event emits, this also indicates that the approved\n\t\t// address for that NFT (if any) is reset to none.\"\n\t\temit Approval(_owner, address(0), _tokenId);\n\t}\n\n\t// ===== End: ERC721 mutative functions (transfers, approvals) =====\n\n\t// ===== Start: Meta-transactions Support =====\n\n\t/**\n\t * @notice Change or reaffirm the approved address for an NFT on behalf\n\t *\n\t * @dev Executes approve(_operator, _tokenId) on behalf of the token owner\n\t *      who EIP-712 signed the transaction, i.e. as if transaction sender is the EIP712 signer\n\t *\n\t * @dev Sets the `_tokenId` as the allowance of `_operator` over `_owner` token,\n\t *      given `_owner` EIP-712 signed approval\n\t *\n\t * @dev Emits `Approval` event in the same way as `approve` does\n\t *\n\t * @dev Requires:\n\t *     - `_operator` to be non-zero address\n\t *     - `_exp` to be a timestamp in the future\n\t *     - `v`, `r` and `s` to be a valid `secp256k1` signature from `_owner`\n\t *        over the EIP712-formatted function arguments.\n\t *     - the signature to use `_owner` current nonce (see `permitNonces`).\n\t *\n\t * @dev For more information on the signature format, see the\n\t *      https://eips.ethereum.org/EIPS/eip-2612#specification\n\t *\n\t * @param _owner owner of the token to set approval on behalf of,\n\t *      an address which signed the EIP-712 message\n\t * @param _operator new approved NFT controller\n\t * @param _tokenId token ID to approve\n\t * @param _exp signature expiration time (unix timestamp)\n\t * @param v the recovery byte of the signature\n\t * @param r half of the ECDSA signature pair\n\t * @param s half of the ECDSA signature pair\n\t */\n\tfunction permit(address _owner, address _operator, uint256 _tokenId, uint256 _exp, uint8 v, bytes32 r, bytes32 s) public {\n\t\t// verify permits are enabled\n\t\trequire(isFeatureEnabled(FEATURE_PERMITS), \"permits are disabled\");\n\n\t\t// derive signer of the EIP712 Permit message, and\n\t\t// update the nonce for that particular signer to avoid replay attack!!! ----------->>> ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓\n\t\taddress signer = __deriveSigner(abi.encode(PERMIT_TYPEHASH, _owner, _operator, _tokenId, permitNonces[_owner]++, _exp), v, r, s);\n\n\t\t// perform message integrity and security validations\n\t\trequire(signer == _owner, \"invalid signature\");\n\t\trequire(block.timestamp < _exp, \"signature expired\");\n\n\t\t// delegate call to `__approve` - execute the logic required\n\t\t__approve(_owner, _operator, _tokenId);\n\t}\n\n\t/**\n\t * @notice Enable or disable approval for a third party (\"operator\") to manage\n\t *      all of owner's assets - on behalf\n\t *\n\t * @dev Executes setApprovalForAll(_operator, _approved) on behalf of the owner\n\t *      who EIP-712 signed the transaction, i.e. as if transaction sender is the EIP712 signer\n\t *\n\t * @dev Sets the `_operator` as the token operator for `_owner` tokens,\n\t *      given `_owner` EIP-712 signed approval\n\t *\n\t * @dev Emits `ApprovalForAll` event in the same way as `setApprovalForAll` does\n\t *\n\t * @dev Requires:\n\t *     - `_operator` to be non-zero address\n\t *     - `_exp` to be a timestamp in the future\n\t *     - `v`, `r` and `s` to be a valid `secp256k1` signature from `_owner`\n\t *        over the EIP712-formatted function arguments.\n\t *     - the signature to use `_owner` current nonce (see `permitNonces`).\n\t *\n\t * @dev For more information on the signature format, see the\n\t *      https://eips.ethereum.org/EIPS/eip-2612#specification\n\t *\n\t * @param _owner owner of the tokens to set approval on behalf of,\n\t *      an address which signed the EIP-712 message\n\t * @param _operator an address to add to the set of authorized operators, i.e.\n\t *      an address approved by the token owner to spend tokens on its behalf\n\t * @param _approved true if the operator is approved, false to revoke approval\n\t * @param _exp signature expiration time (unix timestamp)\n\t * @param v the recovery byte of the signature\n\t * @param r half of the ECDSA signature pair\n\t * @param s half of the ECDSA signature pair\n\t */\n\tfunction permitForAll(address _owner, address _operator, bool _approved, uint256 _exp, uint8 v, bytes32 r, bytes32 s) public {\n\t\t// verify permits are enabled\n\t\trequire(isFeatureEnabled(FEATURE_OPERATOR_PERMITS), \"operator permits are disabled\");\n\n\t\t// derive signer of the EIP712 PermitForAll message, and\n\t\t// update the nonce for that particular signer to avoid replay attack!!! --------------------->>> ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓\n\t\taddress signer = __deriveSigner(abi.encode(PERMIT_FOR_ALL_TYPEHASH, _owner, _operator, _approved, permitNonces[_owner]++, _exp), v, r, s);\n\n\t\t// perform message integrity and security validations\n\t\trequire(signer == _owner, \"invalid signature\");\n\t\trequire(block.timestamp < _exp, \"signature expired\");\n\n\t\t// delegate call to `__approve` - execute the logic required\n\t\t__approveForAll(_owner, _operator, _approved);\n\t}\n\n\t/**\n\t * @dev Auxiliary function to verify structured EIP712 message signature and derive its signer\n\t *\n\t * @param abiEncodedTypehash abi.encode of the message typehash together with all its parameters\n\t * @param v the recovery byte of the signature\n\t * @param r half of the ECDSA signature pair\n\t * @param s half of the ECDSA signature pair\n\t */\n\tfunction __deriveSigner(bytes memory abiEncodedTypehash, uint8 v, bytes32 r, bytes32 s) private view returns(address) {\n\t\t// build the EIP-712 hashStruct of the message\n\t\tbytes32 hashStruct = keccak256(abiEncodedTypehash);\n\n\t\t// calculate the EIP-712 digest \"\\x19\\x01\" ‖ domainSeparator ‖ hashStruct(message)\n\t\tbytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR(), hashStruct));\n\n\t\t// recover the address which signed the message with v, r, s\n\t\taddress signer = ECDSA.recover(digest, v, r, s);\n\n\t\t// check if the signer address isn't invalid\n\t\t// according to EIP3009 spec, zero address must be rejected when using ecrecover\n\t\trequire(signer != address(0), \"invalid signature\");\n\n\t\t// return the signer address derived from the signature\n\t\treturn signer;\n\t}\n\n\t// ===== End: Meta-transactions Support =====\n\n\t// ===== Start: mint/burn support =====\n\n\t/**\n\t * @dev Creates new token with token ID specified\n\t *      and assigns an ownership `_to` for this token\n\t *\n\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\n\t *      `onERC721Received` on `_to` and throws if the return value is not\n\t *      `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n\t *\n\t * @dev Requires executor to have `ROLE_TOKEN_CREATOR` permission\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId ID of the token to mint\n\t * @param _data additional data with no specified format, sent in call to `_to`\n\t */\n\tfunction safeMint(address _to, uint256 _tokenId, bytes memory _data) public override {\n\t\t// delegate to unsafe mint\n\t\tmint(_to, _tokenId);\n\n\t\t// make it safe: execute `onERC721Received`\n\n\t\t// if receiver `_to` is a smart contract\n\t\tif(AddressUtils.isContract(_to)) {\n\t\t\t// check it supports ERC721 interface - execute onERC721Received()\n\t\t\tbytes4 response = ERC721TokenReceiver(_to).onERC721Received(msg.sender, address(0), _tokenId, _data);\n\n\t\t\t// expected response is ERC721TokenReceiver(_to).onERC721Received.selector\n\t\t\t// bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))\n\t\t\trequire(response == ERC721TokenReceiver(_to).onERC721Received.selector, \"invalid onERC721Received response\");\n\t\t}\n\t}\n\n\t/**\n\t * @dev Creates new token with token ID specified\n\t *      and assigns an ownership `_to` for this token\n\t *\n\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\n\t *      `onERC721Received` on `_to` and throws if the return value is not\n\t *      `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n\t *\n\t * @dev Requires executor to have `ROLE_TOKEN_CREATOR` permission\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId ID of the token to mint\n\t */\n\tfunction safeMint(address _to, uint256 _tokenId) public override {\n\t\t// delegate to `safeMint` with empty data\n\t\tsafeMint(_to, _tokenId, \"\");\n\t}\n\n\t/**\n\t * @dev Creates new tokens starting with token ID specified\n\t *      and assigns an ownership `_to` for these tokens\n\t *\n\t * @dev Token IDs to be minted: [_tokenId, _tokenId + n)\n\t *\n\t * @dev n must be greater or equal 2: `n > 1`\n\t *\n\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\n\t *      `onERC721Received` on `_to` and throws if the return value is not\n\t *      `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n\t *\n\t * @dev Requires executor to have `ROLE_TOKEN_CREATOR` permission\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId ID of the token to mint\n\t * @param n how many tokens to mint, sequentially increasing the _tokenId\n\t * @param _data additional data with no specified format, sent in call to `_to`\n\t */\n\tfunction safeMintBatch(address _to, uint256 _tokenId, uint256 n, bytes memory _data) public override {\n\t\t// delegate to unsafe mint\n\t\tmintBatch(_to, _tokenId, n);\n\n\t\t// make it safe: execute `onERC721Received`\n\n\t\t// if receiver `_to` is a smart contract\n\t\tif(AddressUtils.isContract(_to)) {\n\t\t\t// onERC721Received: for each token minted\n\t\t\tfor(uint256 i = 0; i < n; i++) {\n\t\t\t\t// check it supports ERC721 interface - execute onERC721Received()\n\t\t\t\tbytes4 response = ERC721TokenReceiver(_to).onERC721Received(msg.sender, address(0), _tokenId + i, _data);\n\n\t\t\t\t// expected response is ERC721TokenReceiver(_to).onERC721Received.selector\n\t\t\t\t// bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))\n\t\t\t\trequire(response == ERC721TokenReceiver(_to).onERC721Received.selector, \"invalid onERC721Received response\");\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @dev Creates new tokens starting with token ID specified\n\t *      and assigns an ownership `_to` for these tokens\n\t *\n\t * @dev Token IDs to be minted: [_tokenId, _tokenId + n)\n\t *\n\t * @dev n must be greater or equal 2: `n > 1`\n\t *\n\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\n\t *      `onERC721Received` on `_to` and throws if the return value is not\n\t *      `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n\t *\n\t * @dev Requires executor to have `ROLE_TOKEN_CREATOR` permission\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId ID of the token to mint\n\t * @param n how many tokens to mint, sequentially increasing the _tokenId\n\t */\n\tfunction safeMintBatch(address _to, uint256 _tokenId, uint256 n) public override {\n\t\t// delegate to `safeMint` with empty data\n\t\tsafeMintBatch(_to, _tokenId, n, \"\");\n\t}\n\n\t/**\n\t * @dev Creates new token with token ID specified\n\t *      and assigns an ownership `_to` for this token\n\t *\n\t * @dev Unsafe: doesn't execute `onERC721Received` on the receiver.\n\t *      Prefer the use of `saveMint` instead of `mint`.\n\t *\n\t * @dev Requires executor to have `ROLE_TOKEN_CREATOR` permission\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId ID of the token to mint\n\t */\n\tfunction mint(address _to, uint256 _tokenId) public override {\n\t\t// check if caller has sufficient permissions to mint tokens\n\t\trequire(isSenderInRole(ROLE_TOKEN_CREATOR), \"access denied\");\n\n\t\t// verify the inputs\n\n\t\t// verify destination address is set\n\t\trequire(_to != address(0), \"zero address\");\n\t\t// verify the token ID is \"tiny\" (32 bits long at most)\n\t\trequire(uint32(_tokenId) == _tokenId, \"token ID overflow\");\n\n\t\t// verify token doesn't yet exist\n\t\trequire(!exists(_tokenId), \"already minted\");\n\n\t\t// create token ownership record,\n\t\t// add token to `allTokens` and new owner's collections\n\t\t// add token to both local and global collections (enumerations)\n\t\t__addToken(_tokenId, _to);\n\n\t\t// fire ERC721 transfer event\n\t\temit Transfer(address(0), _to, _tokenId);\n\t}\n\n\t/**\n\t * @dev Creates new tokens starting with token ID specified\n\t *      and assigns an ownership `_to` for these tokens\n\t *\n\t * @dev Token IDs to be minted: [_tokenId, _tokenId + n)\n\t *\n\t * @dev n must be greater or equal 2: `n > 1`\n\t *\n\t * @dev Unsafe: doesn't execute `onERC721Received` on the receiver.\n\t *      Prefer the use of `saveMintBatch` instead of `mintBatch`.\n\t *\n\t * @dev Requires executor to have `ROLE_TOKEN_CREATOR` permission\n\t *\n\t * @param _to an address to mint tokens to\n\t * @param _tokenId ID of the first token to mint\n\t * @param n how many tokens to mint, sequentially increasing the _tokenId\n\t */\n\tfunction mintBatch(address _to, uint256 _tokenId, uint256 n) public override {\n\t\t// check if caller has sufficient permissions to mint tokens\n\t\trequire(isSenderInRole(ROLE_TOKEN_CREATOR), \"access denied\");\n\n\t\t// verify the inputs\n\n\t\t// verify destination address is set\n\t\trequire(_to != address(0), \"zero address\");\n\t\t// verify n is set properly\n\t\trequire(n > 1, \"n is too small\");\n\t\t// verify the token ID is \"tiny\" (32 bits long at most)\n\t\trequire(uint32(_tokenId) == _tokenId, \"token ID overflow\");\n\t\trequire(uint32(_tokenId + n - 1) == _tokenId + n - 1, \"n-th token ID overflow\");\n\n\t\t// verification: for each token to be minted\n\t\tfor(uint256 i = 0; i < n; i++) {\n\t\t\t// verify token doesn't yet exist\n\t\t\trequire(!exists(_tokenId + i), \"already minted\");\n\t\t}\n\n\t\t// create token ownership records,\n\t\t// add tokens to `allTokens` and new owner's collections\n\t\t// add tokens to both local and global collections (enumerations)\n\t\t__addTokens(_to, _tokenId, n);\n\n\t\t// events: for each token minted\n\t\tfor(uint256 i = 0; i < n; i++) {\n\t\t\t// fire ERC721 transfer event\n\t\t\temit Transfer(address(0), _to, _tokenId + i);\n\t\t}\n\t}\n\n\t/**\n\t * @dev Destroys the token with token ID specified\n\t *\n\t * @dev Requires executor to have `ROLE_TOKEN_DESTROYER` permission\n\t *      or FEATURE_OWN_BURNS/FEATURE_BURNS_ON_BEHALF features to be enabled\n\t *\n\t * @dev Can be disabled by the contract creator forever by disabling\n\t *      FEATURE_OWN_BURNS/FEATURE_BURNS_ON_BEHALF features and then revoking\n\t *      its own roles to burn tokens and to enable burning features\n\t *\n\t * @param _tokenId ID of the token to burn\n\t */\n\tfunction burn(uint256 _tokenId) public override {\n\t\t// read token owner data\n\t\t// verifies token exists under the hood\n\t\taddress _from = ownerOf(_tokenId);\n\n\t\t// check if caller has sufficient permissions to burn tokens\n\t\t// and if not - check for possibility to burn own tokens or to burn on behalf\n\t\tif(!isSenderInRole(ROLE_TOKEN_DESTROYER)) {\n\t\t\t// if `_from` is equal to sender, require own burns feature to be enabled\n\t\t\t// otherwise require burns on behalf feature to be enabled\n\t\t\trequire(_from == msg.sender && isFeatureEnabled(FEATURE_OWN_BURNS)\n\t\t\t     || _from != msg.sender && isFeatureEnabled(FEATURE_BURNS_ON_BEHALF),\n\t\t\t        _from == msg.sender? \"burns are disabled\": \"burns on behalf are disabled\");\n\n\t\t\t// verify sender is either token owner, or approved by the token owner to burn tokens\n\t\t\trequire(_from == msg.sender || msg.sender == getApproved(_tokenId) || isApprovedForAll(_from, msg.sender), \"access denied\");\n\t\t}\n\n\t\t// remove token ownership record (also clears approval),\n\t\t// remove token from both local and global collections\n\t\t__removeToken(_tokenId);\n\n\t\t// delete token URI mapping\n\t\tdelete _tokenURIs[_tokenId];\n\n\t\t// fire ERC721 transfer event\n\t\temit Transfer(_from, address(0), _tokenId);\n\t}\n\n\t// ===== End: mint/burn support =====\n\n\t// ----- Start: auxiliary internal/private functions -----\n\n\t/**\n\t * @dev Adds token to the new owner's collection (local),\n\t *      used internally to transfer existing tokens, to mint new\n\t *\n\t * @dev Unsafe: doesn't check for data structures consistency\n\t *      (token existence, token ownership, etc.)\n\t *\n\t * @dev Must be kept private at all times. Inheriting smart contracts\n\t *      may be interested in overriding this function.\n\t *\n\t * @param _tokenId token ID to add\n\t * @param _to new owner address to add token to\n\t */\n\tfunction __addLocal(uint256 _tokenId, address _to) internal virtual {\n\t\t// get a reference to the collection where token goes to\n\t\tuint32[] storage destination = collections[_to];\n\n\t\t// update local index and ownership, do not change global index\n\t\ttokens[_tokenId] = tokens[_tokenId]\n\t\t\t//  |unused |global | local | ownership information (address)      |\n\t\t\t& 0x00000000FFFFFFFF000000000000000000000000000000000000000000000000\n\t\t\t| uint192(destination.length) << 160 | uint160(_to);\n\n\t\t// push token into the local collection\n\t\tdestination.push(uint32(_tokenId));\n\t}\n\n\t/**\n\t * @dev Add token to both local and global collections (enumerations),\n\t *      used internally to mint new tokens\n\t *\n\t * @dev Unsafe: doesn't check for data structures consistency\n\t *      (token existence, token ownership, etc.)\n\t *\n\t * @dev Must be kept private at all times. Inheriting smart contracts\n\t *      may be interested in overriding this function.\n\t *\n\t * @param _tokenId token ID to add\n\t * @param _to new owner address to add token to\n\t */\n\tfunction __addToken(uint256 _tokenId, address _to) internal virtual {\n\t\t// get a reference to the collection where token goes to\n\t\tuint32[] storage destination = collections[_to];\n\n\t\t// update token global and local indexes, ownership\n\t\ttokens[_tokenId] = uint224(allTokens.length) << 192 | uint192(destination.length) << 160 | uint160(_to);\n\n\t\t// push token into the collection\n\t\tdestination.push(uint32(_tokenId));\n\n\t\t// push it into the global `allTokens` collection (enumeration)\n\t\tallTokens.push(uint32(_tokenId));\n\t}\n\n\t/**\n\t * @dev Add tokens to both local and global collections (enumerations),\n\t *      used internally to mint new tokens in batches\n\t *\n\t * @dev Token IDs to be added: [_tokenId, _tokenId + n)\n\t *      n is expected to be greater or equal 2, but this is not checked\n\t *\n\t * @dev Unsafe: doesn't check for data structures consistency\n\t *      (token existence, token ownership, etc.)\n\t *\n\t * @dev Must be kept private at all times. Inheriting smart contracts\n\t *      may be interested in overriding this function.\n\t *\n\t * @param _to new owner address to add token to\n\t * @param _tokenId first token ID to add\n\t * @param n how many tokens to add, sequentially increasing the _tokenId\n\t */\n\tfunction __addTokens(address _to, uint256 _tokenId, uint256 n) internal virtual {\n\t\t// get a reference to the collection where tokens go to\n\t\tuint32[] storage destination = collections[_to];\n\n\t\t// for each token to be added\n\t\tfor(uint256 i = 0; i < n; i++) {\n\t\t\t// update token global and local indexes, ownership\n\t\t\ttokens[_tokenId + i] = uint224(allTokens.length + i) << 192 | uint192(destination.length + i) << 160 | uint160(_to);\n\t\t}\n\n\t\t// push tokens into the local collection\n\t\tdestination.push32(uint32(_tokenId), uint32(n));\n\t\t// push tokens into the global `allTokens` collection (enumeration)\n\t\tallTokens.push32(uint32(_tokenId), uint32(n));\n\t}\n\n\t/**\n\t * @dev Removes token from owner's local collection,\n\t *      used internally to transfer or burn existing tokens\n\t *\n\t * @dev Unsafe: doesn't check for data structures consistency\n\t *      (token existence, token ownership, etc.)\n\t *\n\t * @dev Must be kept private at all times. Inheriting smart contracts\n\t *      may be interested in overriding this function.\n\t *\n\t * @param _tokenId token ID to remove\n\t */\n\tfunction __removeLocal(uint256 _tokenId) internal virtual {\n\t\t// read token data, containing global and local indexes, owner address\n\t\tuint256 token = tokens[_tokenId];\n\n\t\t// get a reference to the token's owner collection (local)\n\t\tuint32[] storage source = collections[address(uint160(token))];\n\n\t\t// token index within the collection\n\t\tuint32 i = uint32(token >> 160);\n\n\t\t// get an ID of the last token in the collection\n\t\tuint32 sourceId = source[source.length - 1];\n\n\t\t// if the token we're to remove from the collection is not the last one,\n\t\t// we need to move last token in the collection into index `i`\n\t\tif(i != source.length - 1) {\n\t\t\t// we put the last token in the collection to the position released\n\n\t\t\t// update last token local index to point to proper place in the collection\n\t\t\t// preserve global index and ownership info\n\t\t\ttokens[sourceId] = tokens[sourceId]\n\t\t\t\t//  |unused |global | local | ownership information (address)      |\n\t\t\t\t& 0x00000000FFFFFFFF00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n\t\t\t\t| uint192(i) << 160;\n\n\t\t\t// put it into the position `i` within the collection\n\t\t\tsource[i] = sourceId;\n\t\t}\n\n\t\t// trim the collection by removing last element\n\t\tsource.pop();\n\n\t\t// clear token approval (also emits an Approval event)\n\t\t__clearApproval(address(uint160(token)), _tokenId);\n\t}\n\n\t/**\n\t * @dev Removes token from both local and global collections (enumerations),\n\t *      used internally to burn existing tokens\n\t *\n\t * @dev Unsafe: doesn't check for data structures consistency\n\t *      (token existence, token ownership, etc.)\n\t *\n\t * @dev Must be kept private at all times. Inheriting smart contracts\n\t *      may be interested in overriding this function.\n\t *\n\t * @param _tokenId token ID to remove\n\t */\n\tfunction __removeToken(uint256 _tokenId) internal virtual {\n\t\t// remove token from owner's (local) collection first\n\t\t__removeLocal(_tokenId);\n\n\t\t// token index within the global collection\n\t\tuint32 i = uint32(tokens[_tokenId] >> 192);\n\n\t\t// delete the token\n\t\tdelete tokens[_tokenId];\n\n\t\t// get an ID of the last token in the collection\n\t\tuint32 lastId = allTokens[allTokens.length - 1];\n\n\t\t// if the token we're to remove from the collection is not the last one,\n\t\t// we need to move last token in the collection into index `i`\n\t\tif(i != allTokens.length - 1) {\n\t\t\t// we put the last token in the collection to the position released\n\n\t\t\t// update last token global index to point to proper place in the collection\n\t\t\t// preserve local index and ownership info\n\t\t\ttokens[lastId] = tokens[lastId]\n\t\t\t\t//  |unused |global | local | ownership information (address)      |\n\t\t\t\t& 0x0000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n\t\t\t\t| uint224(i) << 192;\n\n\t\t\t// put it into the position `i` within the collection\n\t\t\tallTokens[i] = lastId;\n\t\t}\n\n\t\t// trim the collection by removing last element\n\t\tallTokens.pop();\n\t}\n\n\t// ----- End: auxiliary internal/private functions -----\n}\n"
    },
    "contracts/token/WhitelabelNFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./RoyalERC721.sol\";\n\n/**\n * @title Whitelabel NFT\n *\n * @notice Whitelabel NFT is a non-upgradeable ERC721 standard implementation\n *\n * @dev Whitelabel NFT is a Tiny ERC721, it supports minting and burning,\n *      its token ID space is limited to 32 bits\n *\n * @dev Whitelabel NFT supports EIP-2981 royalties on NFT secondary sales,\n *      and OpenSea royalties\n */\ncontract WhitelabelNFT is RoyalERC721 {\n\t/**\n\t * @inheritdoc TinyERC721\n\t */\n\tuint256 public constant override TOKEN_UID = 0x50c16d79fc64e49cf554b52a1bdf271f1a30a6999329cb1b4642bb24597f282f;\n\n\t/**\n\t * @dev Constructs/deploys Whitelabel NFT instance\n\t *      with the name and symbol defined during the deployment\n\t */\n\tconstructor(string memory _name, string memory _symbol) RoyalERC721(_name, _symbol) AccessControl(msg.sender) {}\n}\n"
    },
    "contracts/utils/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22; // require with message (0.4.22), pure/view modifiers (0.4.16), hardhat (0.4.11)\n\n/**\n * @title Role-based Access Control (RBAC)\n *\n * @notice Access control smart contract provides an API to check\n *      if a specific operation is permitted globally and/or\n *      if a particular user has a permission to execute it.\n *\n * @notice This contract is inherited by other contracts requiring the role-based access control (RBAC)\n *      protection for the restricted access functions\n *\n * @notice It deals with two main entities: features and roles.\n *\n * @notice Features are designed to be used to enable/disable public functions\n *      of the smart contract (used by a wide audience).\n * @notice User roles are designed to control the access to restricted functions\n *      of the smart contract (used by a limited set of maintainers).\n *\n * @notice Terms \"role\", \"permissions\" and \"set of permissions\" have equal meaning\n *      in the documentation text and may be used interchangeably.\n * @notice Terms \"permission\", \"single permission\" implies only one permission bit set.\n *\n * @notice Access manager is a special role which allows to grant/revoke other roles.\n *      Access managers can only grant/revoke permissions which they have themselves.\n *      As an example, access manager with no other roles set can only grant/revoke its own\n *      access manager permission and nothing else.\n *\n * @notice Access manager permission should be treated carefully, as a super admin permission:\n *      Access manager with even no other permission can interfere with another account by\n *      granting own access manager permission to it and effectively creating more powerful\n *      permission set than its own.\n *\n * @dev Both current and OpenZeppelin AccessControl implementations feature a similar API\n *      to check/know \"who is allowed to do this thing\".\n * @dev Zeppelin implementation is more flexible:\n *      - it allows setting unlimited number of roles, while current is limited to 256 different roles\n *      - it allows setting an admin for each role, while current allows having only one global admin\n * @dev Current implementation is more lightweight:\n *      - it uses only 1 bit per role, while Zeppelin uses 256 bits\n *      - it allows setting up to 256 roles at once, in a single transaction, while Zeppelin allows\n *        setting only one role in a single transaction\n *\n * @dev This smart contract is designed to be inherited by other\n *      smart contracts which require access control management capabilities.\n *\n * @dev Access manager permission has a bit 255 set.\n *      This bit must not be used by inheriting contracts for any other permissions/features.\n */\nabstract contract AccessControl {\n\t/**\n\t * @dev Privileged addresses with defined roles/permissions\n\t * @dev In the context of ERC20/ERC721 tokens these can be permissions to\n\t *      allow minting or burning tokens, transferring on behalf and so on\n\t *\n\t * @dev Maps user address to the permissions bitmask (role), where each bit\n\t *      represents a permission\n\t * @dev Bitmask 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n\t *      represents all possible permissions\n\t * @dev 'This' address mapping represents global features of the smart contract\n\t *\n\t * @dev We keep the mapping private to prevent direct writes to it from the inheriting\n\t *      contracts, `getRole()` and `updateRole()` functions should be used instead\n\t */\n\tmapping(address => uint256) internal userRoles; // TODO: restrict to \"private\"\n\n\t/**\n\t * @notice Access manager is responsible for assigning the roles to users,\n\t *      enabling/disabling global features of the smart contract\n\t * @notice Access manager can add, remove and update user roles,\n\t *      remove and update global features\n\t *\n\t * @dev Role ROLE_ACCESS_MANAGER allows modifying user roles and global features\n\t * @dev Role ROLE_ACCESS_MANAGER has single bit at position 255 enabled\n\t */\n\tuint256 public constant ROLE_ACCESS_MANAGER = 0x8000000000000000000000000000000000000000000000000000000000000000;\n\n\t/**\n\t * @dev Bitmask representing all the possible permissions (super admin role)\n\t * @dev Has all the bits are enabled (2^256 - 1 value)\n\t */\n\tuint256 internal constant FULL_PRIVILEGES_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n\t/**\n\t * @dev Fired in updateRole() and updateFeatures()\n\t *\n\t * @param operator address which was granted/revoked permissions\n\t * @param requested permissions requested\n\t * @param assigned permissions effectively set\n\t */\n\tevent RoleUpdated(address indexed operator, uint256 requested, uint256 assigned);\n\n\t/**\n\t * @notice Function modifier making a function defined as public behave as restricted\n\t *      (so that only a pre-configured set of accounts can execute it)\n\t *\n\t * @param role the role transaction executor is required to have;\n\t *      the function throws an \"access denied\" exception if this condition is not met\n\t */\n\tmodifier restrictedTo(uint256 role) {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(role), \"access denied\");\n\n\t\t// execute the rest of the function\n\t\t_;\n\t}\n\n\t/**\n\t * @notice Creates an access control instance, setting the contract owner to have full privileges\n\t *\n\t * @param _owner smart contract owner having full privileges\n\t */\n\tconstructor(address _owner) internal { // visibility modifier is required to be compilable with 0.6.x\n\t\t// grant owner full privileges\n\t\t__setRole(_owner, FULL_PRIVILEGES_MASK, FULL_PRIVILEGES_MASK);\n\t}\n\n\t/**\n\t * @notice Retrieves globally set of features enabled\n\t *\n\t * @dev Effectively reads userRoles role for the contract itself\n\t *\n\t * @return 256-bit bitmask of the features enabled\n\t */\n\tfunction features() public view returns (uint256) {\n\t\t// features are stored in 'this' address mapping of `userRoles`\n\t\treturn getRole(address(this));\n\t}\n\n\t/**\n\t * @notice Updates set of the globally enabled features (`features`),\n\t *      taking into account sender's permissions\n\t *\n\t * @dev Requires transaction sender to have `ROLE_ACCESS_MANAGER` permission\n\t * @dev Function is left for backward compatibility with older versions\n\t *\n\t * @param _mask bitmask representing a set of features to enable/disable\n\t */\n\tfunction updateFeatures(uint256 _mask) public {\n\t\t// delegate call to `updateRole`\n\t\tupdateRole(address(this), _mask);\n\t}\n\n\t/**\n\t * @notice Reads the permissions (role) for a given user from the `userRoles` mapping\n\t *      (privileged addresses with defined roles/permissions)\n\t * @notice In the context of ERC20/ERC721 tokens these can be permissions to\n\t *      allow minting or burning tokens, transferring on behalf and so on\n\t *\n\t * @dev Having a simple getter instead of making the mapping public\n\t *      allows enforcing the encapsulation of the mapping and protects from\n\t *      writing to it directly in the inheriting smart contracts\n\t *\n\t * @param operator address of a user to read permissions for,\n\t *      or self address to read global features of the smart contract\n\t */\n\tfunction getRole(address operator) public view returns(uint256) {\n\t\t// read the value from `userRoles` and return\n\t\treturn userRoles[operator];\n\t}\n\n\t/**\n\t * @notice Updates set of permissions (role) for a given user,\n\t *      taking into account sender's permissions.\n\t *\n\t * @dev Setting role to zero is equivalent to removing an all permissions\n\t * @dev Setting role to `FULL_PRIVILEGES_MASK` is equivalent to\n\t *      copying senders' permissions (role) to the user\n\t * @dev Requires transaction sender to have `ROLE_ACCESS_MANAGER` permission\n\t *\n\t * @param operator address of a user to alter permissions for,\n\t *       or self address to alter global features of the smart contract\n\t * @param role bitmask representing a set of permissions to\n\t *      enable/disable for a user specified\n\t */\n\tfunction updateRole(address operator, uint256 role) public {\n\t\t// caller must have a permission to update user roles\n\t\trequire(isSenderInRole(ROLE_ACCESS_MANAGER), \"access denied\");\n\n\t\t// evaluate the role and reassign it\n\t\t__setRole(operator, role, _evaluateBy(msg.sender, getRole(operator), role));\n\t}\n\n\t/**\n\t * @notice Determines the permission bitmask an operator can set on the\n\t *      target permission set\n\t * @notice Used to calculate the permission bitmask to be set when requested\n\t *     in `updateRole` and `updateFeatures` functions\n\t *\n\t * @dev Calculated based on:\n\t *      1) operator's own permission set read from userRoles[operator]\n\t *      2) target permission set - what is already set on the target\n\t *      3) desired permission set - what do we want set target to\n\t *\n\t * @dev Corner cases:\n\t *      1) Operator is super admin and its permission set is `FULL_PRIVILEGES_MASK`:\n\t *        `desired` bitset is returned regardless of the `target` permission set value\n\t *        (what operator sets is what they get)\n\t *      2) Operator with no permissions (zero bitset):\n\t *        `target` bitset is returned regardless of the `desired` value\n\t *        (operator has no authority and cannot modify anything)\n\t *\n\t * @dev Example:\n\t *      Consider an operator with the permissions bitmask     00001111\n\t *      is about to modify the target permission set          01010101\n\t *      Operator wants to set that permission set to          00110011\n\t *      Based on their role, an operator has the permissions\n\t *      to update only lowest 4 bits on the target, meaning that\n\t *      high 4 bits of the target set in this example is left\n\t *      unchanged and low 4 bits get changed as desired:      01010011\n\t *\n\t * @param operator address of the contract operator which is about to set the permissions\n\t * @param target input set of permissions to operator is going to modify\n\t * @param desired desired set of permissions operator would like to set\n\t * @return resulting set of permissions given operator will set\n\t */\n\tfunction _evaluateBy(address operator, uint256 target, uint256 desired) internal view returns (uint256) {\n\t\t// read operator's permissions\n\t\tuint256 p = getRole(operator);\n\n\t\t// taking into account operator's permissions,\n\t\t// 1) enable the permissions desired on the `target`\n\t\ttarget |= p & desired;\n\t\t// 2) disable the permissions desired on the `target`\n\t\ttarget &= FULL_PRIVILEGES_MASK ^ (p & (FULL_PRIVILEGES_MASK ^ desired));\n\n\t\t// return calculated result\n\t\treturn target;\n\t}\n\n\t/**\n\t * @notice Checks if requested set of features is enabled globally on the contract\n\t *\n\t * @param required set of features to check against\n\t * @return true if all the features requested are enabled, false otherwise\n\t */\n\tfunction isFeatureEnabled(uint256 required) public view returns (bool) {\n\t\t// delegate call to `__hasRole`, passing `features` property\n\t\treturn __hasRole(features(), required);\n\t}\n\n\t/**\n\t * @notice Checks if transaction sender `msg.sender` has all the permissions required\n\t *\n\t * @dev Used in smart contracts only. Off-chain clients should use `isOperatorInRole`.\n\t *\n\t * @param required set of permissions (role) to check against\n\t * @return true if all the permissions requested are enabled, false otherwise\n\t */\n\tfunction isSenderInRole(uint256 required) public view returns (bool) {\n\t\t// delegate call to `isOperatorInRole`, passing transaction sender\n\t\treturn isOperatorInRole(msg.sender, required);\n\t}\n\n\t/**\n\t * @notice Checks if operator has all the permissions (role) required\n\t *\n\t * @param operator address of the user to check role for\n\t * @param required set of permissions (role) to check\n\t * @return true if all the permissions requested are enabled, false otherwise\n\t */\n\tfunction isOperatorInRole(address operator, uint256 required) public view returns (bool) {\n\t\t// delegate call to `__hasRole`, passing operator's permissions (role)\n\t\treturn __hasRole(getRole(operator), required);\n\t}\n\n\t/**\n\t * @dev Sets the `assignedRole` role to the operator, logs both `requestedRole` and `actualRole`\n\t *\n\t * @dev Unsafe:\n\t *      provides direct write access to `userRoles` mapping without any security checks,\n\t *      doesn't verify the executor (msg.sender) permissions,\n\t *      must be kept private at all times\n\t *\n\t * @param operator address of a user to alter permissions for,\n\t *       or self address to alter global features of the smart contract\n\t * @param requestedRole bitmask representing a set of permissions requested\n\t *      to be enabled/disabled for a user specified, used only to be logged into event\n\t * @param assignedRole bitmask representing a set of permissions to\n\t *      enable/disable for a user specified, used to update the mapping and to be logged into event\n\t */\n\tfunction __setRole(address operator, uint256 requestedRole, uint256 assignedRole) private {\n\t\t// assign the role to the operator\n\t\tuserRoles[operator] = assignedRole;\n\n\t\t// fire an event\n\t\temit RoleUpdated(operator, requestedRole, assignedRole);\n\t}\n\n\t/**\n\t * @dev Checks if role `actual` contains all the permissions required `required`\n\t *\n\t * @param actual existent role\n\t * @param required required role\n\t * @return true if actual has required role (all permissions), false otherwise\n\t */\n\tfunction __hasRole(uint256 actual, uint256 required) private pure returns (bool) {\n\t\t// check the bitmask for the role required and return the result\n\t\treturn actual & required == required;\n\t}\n}\n"
    },
    "contracts/utils/InitializableAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.2;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\n/**\n * @title Initializable Role-based Access Control (RBAC) // ERC1967Proxy\n *\n * @notice Access control smart contract provides an API to check\n *      if a specific operation is permitted globally and/or\n *      if a particular user has a permission to execute it.\n *\n * @notice This contract is inherited by other contracts requiring the role-based access control (RBAC)\n *      protection for the restricted access functions\n *\n * @notice It deals with two main entities: features and roles.\n *\n * @notice Features are designed to be used to enable/disable public functions\n *      of the smart contract (used by a wide audience).\n * @notice User roles are designed to control the access to restricted functions\n *      of the smart contract (used by a limited set of maintainers).\n *\n * @notice Terms \"role\", \"permissions\" and \"set of permissions\" have equal meaning\n *      in the documentation text and may be used interchangeably.\n * @notice Terms \"permission\", \"single permission\" implies only one permission bit set.\n *\n * @notice Access manager is a special role which allows to grant/revoke other roles.\n *      Access managers can only grant/revoke permissions which they have themselves.\n *      As an example, access manager with no other roles set can only grant/revoke its own\n *      access manager permission and nothing else.\n *\n * @notice Access manager permission should be treated carefully, as a super admin permission:\n *      Access manager with even no other permission can interfere with another account by\n *      granting own access manager permission to it and effectively creating more powerful\n *      permission set than its own.\n *\n * @dev Both current and OpenZeppelin AccessControl implementations feature a similar API\n *      to check/know \"who is allowed to do this thing\".\n * @dev Zeppelin implementation is more flexible:\n *      - it allows setting unlimited number of roles, while current is limited to 256 different roles\n *      - it allows setting an admin for each role, while current allows having only one global admin\n * @dev Current implementation is more lightweight:\n *      - it uses only 1 bit per role, while Zeppelin uses 256 bits\n *      - it allows setting up to 256 roles at once, in a single transaction, while Zeppelin allows\n *        setting only one role in a single transaction\n *\n * @dev This smart contract is designed to be inherited by other\n *      smart contracts which require access control management capabilities.\n *\n * @dev Access manager permission has a bit 255 set.\n *      This bit must not be used by inheriting contracts for any other permissions/features.\n *\n * @dev This is an initializable version of the RBAC, based on Zeppelin implementation,\n *      it can be used for ERC1967 proxies, as well as for EIP-1167 minimal proxies\n *      see https://docs.openzeppelin.com/contracts/4.x/upgradeable\n *      see https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable\n *      see https://forum.openzeppelin.com/t/uups-proxies-tutorial-solidity-javascript/7786\n *      see https://eips.ethereum.org/EIPS/eip-1167\n *      see https://docs.openzeppelin.com/contracts/4.x/api/proxy#Clones\n */\nabstract contract InitializableAccessControl is Initializable {\n\t/**\n\t * @dev Privileged addresses with defined roles/permissions\n\t * @dev In the context of ERC20/ERC721 tokens these can be permissions to\n\t *      allow minting or burning tokens, transferring on behalf and so on\n\t *\n\t * @dev Maps user address to the permissions bitmask (role), where each bit\n\t *      represents a permission\n\t * @dev Bitmask 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n\t *      represents all possible permissions\n\t * @dev 'This' address mapping represents global features of the smart contract\n\t *\n\t * @dev We keep the mapping private to prevent direct writes to it from the inheriting\n\t *      contracts, `getRole()` and `updateRole()` functions should be used instead\n\t */\n\tmapping(address => uint256) private userRoles;\n\n\t/**\n\t * @dev Empty reserved space in storage. The size of the __gap array is calculated so that\n\t *      the amount of storage used by a contract always adds up to the 50.\n\t *      See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n\t */\n\tuint256[49] private __gap;\n\n\t/**\n\t * @notice Access manager is responsible for assigning the roles to users,\n\t *      enabling/disabling global features of the smart contract\n\t * @notice Access manager can add, remove and update user roles,\n\t *      remove and update global features\n\t *\n\t * @dev Role ROLE_ACCESS_MANAGER allows modifying user roles and global features\n\t * @dev Role ROLE_ACCESS_MANAGER has single bit at position 255 enabled\n\t */\n\tuint256 public constant ROLE_ACCESS_MANAGER = 0x8000000000000000000000000000000000000000000000000000000000000000;\n\n\t/**\n\t * @notice Upgrade manager is responsible for smart contract upgrades,\n\t *      see https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable\n\t *      see https://docs.openzeppelin.com/contracts/4.x/upgradeable\n\t *\n\t * @dev Role ROLE_UPGRADE_MANAGER allows passing the _authorizeUpgrade() check\n\t * @dev Role ROLE_UPGRADE_MANAGER has single bit at position 254 enabled\n\t */\n\tuint256 public constant ROLE_UPGRADE_MANAGER = 0x4000000000000000000000000000000000000000000000000000000000000000;\n\n\t/**\n\t * @dev Bitmask representing all the possible permissions (super admin role)\n\t * @dev Has all the bits are enabled (2^256 - 1 value)\n\t */\n\tuint256 private constant FULL_PRIVILEGES_MASK = type(uint256).max; // before 0.8.0: uint256(-1) overflows to 0xFFFF...\n\n\t/**\n\t * @dev Fired in updateRole() and updateFeatures()\n\t *\n\t * @param operator address which was granted/revoked permissions\n\t * @param requested permissions requested\n\t * @param assigned permissions effectively set\n\t */\n\tevent RoleUpdated(address indexed operator, uint256 requested, uint256 assigned);\n\n\t/**\n\t * @notice Function modifier making a function defined as public behave as restricted\n\t *      (so that only a pre-configured set of accounts can execute it)\n\t *\n\t * @param role the role transaction executor is required to have;\n\t *      the function throws an \"access denied\" exception if this condition is not met\n\t */\n\tmodifier restrictedTo(uint256 role) {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(role), \"access denied\");\n\n\t\t// execute the rest of the function\n\t\t_;\n\t}\n\n\t/**\n\t * @dev Creates/deploys the ACL implementation to be used in a proxy\n\t *\n\t * @dev Note:\n\t *      the implementation is already initialized and\n\t *      `_postConstruct` is not executable on the implementation\n\t *      `_postConstruct` is still available in the context of a proxy\n\t *      and should be executed on the proxy deployment (in the same tx)\n\t */\n\t // constructor() initializer {}\n\n\t/**\n\t * @dev Contract initializer, sets the contract owner to have full privileges\n\t *\n\t * @dev Can be executed only once, reverts when executed second time\n\t *\n\t * @dev IMPORTANT:\n\t *      this function SHOULD be executed during proxy deployment (in the same transaction)\n\t *\n\t * @param _owner smart contract owner having full privileges\n\t */\n\tfunction _postConstruct(address _owner) internal virtual onlyInitializing {\n\t\t// grant owner full privileges\n\t\t__setRole(_owner, FULL_PRIVILEGES_MASK, FULL_PRIVILEGES_MASK);\n\t}\n\n\t/**\n\t * @dev Highest version that has been initialized.\n\t *      Non-zero value means contract was already initialized.\n\t * @dev see {Initializable}, {reinitializer}.\n\t *\n\t * @return highest version that has been initialized\n\t */\n/*\n\tfunction getInitializedVersion() public view returns(uint64) {\n\t\t// delegate to `_getInitializedVersion`\n\t\treturn _getInitializedVersion();\n\t}\n*/\n\n\t/**\n\t * @notice Retrieves globally set of features enabled\n\t *\n\t * @dev Effectively reads userRoles role for the contract itself\n\t *\n\t * @return 256-bit bitmask of the features enabled\n\t */\n\tfunction features() public view returns (uint256) {\n\t\t// features are stored in 'this' address mapping of `userRoles`\n\t\treturn getRole(address(this));\n\t}\n\n\t/**\n\t * @notice Updates set of the globally enabled features (`features`),\n\t *      taking into account sender's permissions\n\t *\n\t * @dev Requires transaction sender to have `ROLE_ACCESS_MANAGER` permission\n\t * @dev Function is left for backward compatibility with older versions\n\t *\n\t * @param _mask bitmask representing a set of features to enable/disable\n\t */\n\tfunction updateFeatures(uint256 _mask) public {\n\t\t// delegate call to `updateRole`\n\t\tupdateRole(address(this), _mask);\n\t}\n\n\t/**\n\t * @notice Reads the permissions (role) for a given user from the `userRoles` mapping\n\t *      (privileged addresses with defined roles/permissions)\n\t * @notice In the context of ERC20/ERC721 tokens these can be permissions to\n\t *      allow minting or burning tokens, transferring on behalf and so on\n\t *\n\t * @dev Having a simple getter instead of making the mapping public\n\t *      allows enforcing the encapsulation of the mapping and protects from\n\t *      writing to it directly in the inheriting smart contracts\n\t *\n\t * @param operator address of a user to read permissions for,\n\t *      or self address to read global features of the smart contract\n\t */\n\tfunction getRole(address operator) public view returns(uint256) {\n\t\t// read the value from `userRoles` and return\n\t\treturn userRoles[operator];\n\t}\n\n\t/**\n\t * @notice Updates set of permissions (role) for a given user,\n\t *      taking into account sender's permissions.\n\t *\n\t * @dev Setting role to zero is equivalent to removing an all permissions\n\t * @dev Setting role to `FULL_PRIVILEGES_MASK` is equivalent to\n\t *      copying senders' permissions (role) to the user\n\t * @dev Requires transaction sender to have `ROLE_ACCESS_MANAGER` permission\n\t *\n\t * @param operator address of a user to alter permissions for,\n\t *       or self address to alter global features of the smart contract\n\t * @param role bitmask representing a set of permissions to\n\t *      enable/disable for a user specified\n\t */\n\tfunction updateRole(address operator, uint256 role) public {\n\t\t// caller must have a permission to update user roles\n\t\trequire(isSenderInRole(ROLE_ACCESS_MANAGER), \"access denied\");\n\n\t\t// evaluate the role and reassign it\n\t\t__setRole(operator, role, _evaluateBy(msg.sender, getRole(operator), role));\n\t}\n\n\t/**\n\t * @notice Determines the permission bitmask an operator can set on the\n\t *      target permission set\n\t * @notice Used to calculate the permission bitmask to be set when requested\n\t *     in `updateRole` and `updateFeatures` functions\n\t *\n\t * @dev Calculated based on:\n\t *      1) operator's own permission set read from userRoles[operator]\n\t *      2) target permission set - what is already set on the target\n\t *      3) desired permission set - what do we want set target to\n\t *\n\t * @dev Corner cases:\n\t *      1) Operator is super admin and its permission set is `FULL_PRIVILEGES_MASK`:\n\t *        `desired` bitset is returned regardless of the `target` permission set value\n\t *        (what operator sets is what they get)\n\t *      2) Operator with no permissions (zero bitset):\n\t *        `target` bitset is returned regardless of the `desired` value\n\t *        (operator has no authority and cannot modify anything)\n\t *\n\t * @dev Example:\n\t *      Consider an operator with the permissions bitmask     00001111\n\t *      is about to modify the target permission set          01010101\n\t *      Operator wants to set that permission set to          00110011\n\t *      Based on their role, an operator has the permissions\n\t *      to update only lowest 4 bits on the target, meaning that\n\t *      high 4 bits of the target set in this example is left\n\t *      unchanged and low 4 bits get changed as desired:      01010011\n\t *\n\t * @param operator address of the contract operator which is about to set the permissions\n\t * @param target input set of permissions to operator is going to modify\n\t * @param desired desired set of permissions operator would like to set\n\t * @return resulting set of permissions given operator will set\n\t */\n\tfunction _evaluateBy(address operator, uint256 target, uint256 desired) internal view returns (uint256) {\n\t\t// read operator's permissions\n\t\tuint256 p = getRole(operator);\n\n\t\t// taking into account operator's permissions,\n\t\t// 1) enable the permissions desired on the `target`\n\t\ttarget |= p & desired;\n\t\t// 2) disable the permissions desired on the `target`\n\t\ttarget &= FULL_PRIVILEGES_MASK ^ (p & (FULL_PRIVILEGES_MASK ^ desired));\n\n\t\t// return calculated result\n\t\treturn target;\n\t}\n\n\t/**\n\t * @notice Checks if requested set of features is enabled globally on the contract\n\t *\n\t * @param required set of features to check against\n\t * @return true if all the features requested are enabled, false otherwise\n\t */\n\tfunction isFeatureEnabled(uint256 required) public view returns (bool) {\n\t\t// delegate call to `__hasRole`, passing `features` property\n\t\treturn __hasRole(features(), required);\n\t}\n\n\t/**\n\t * @notice Checks if transaction sender `msg.sender` has all the permissions required\n\t *\n\t * @dev Used in smart contracts only. Off-chain clients should use `isOperatorInRole`.\n\t *\n\t * @param required set of permissions (role) to check against\n\t * @return true if all the permissions requested are enabled, false otherwise\n\t */\n\tfunction isSenderInRole(uint256 required) public view returns (bool) {\n\t\t// delegate call to `isOperatorInRole`, passing transaction sender\n\t\treturn isOperatorInRole(msg.sender, required);\n\t}\n\n\t/**\n\t * @notice Checks if operator has all the permissions (role) required\n\t *\n\t * @param operator address of the user to check role for\n\t * @param required set of permissions (role) to check\n\t * @return true if all the permissions requested are enabled, false otherwise\n\t */\n\tfunction isOperatorInRole(address operator, uint256 required) public view returns (bool) {\n\t\t// delegate call to `__hasRole`, passing operator's permissions (role)\n\t\treturn __hasRole(getRole(operator), required);\n\t}\n\n\t/**\n\t * @dev Sets the `assignedRole` role to the operator, logs both `requestedRole` and `actualRole`\n\t *\n\t * @dev Unsafe:\n\t *      provides direct write access to `userRoles` mapping without any security checks,\n\t *      doesn't verify the executor (msg.sender) permissions,\n\t *      must be kept private at all times\n\t *\n\t * @param operator address of a user to alter permissions for,\n\t *       or self address to alter global features of the smart contract\n\t * @param requestedRole bitmask representing a set of permissions requested\n\t *      to be enabled/disabled for a user specified, used only to be logged into event\n\t * @param assignedRole bitmask representing a set of permissions to\n\t *      enable/disable for a user specified, used to update the mapping and to be logged into event\n\t */\n\tfunction __setRole(address operator, uint256 requestedRole, uint256 assignedRole) private {\n\t\t// assign the role to the operator\n\t\tuserRoles[operator] = assignedRole;\n\n\t\t// fire an event\n\t\temit RoleUpdated(operator, requestedRole, assignedRole);\n\t}\n\n\t/**\n\t * @dev Checks if role `actual` contains all the permissions required `required`\n\t *\n\t * @param actual existent role\n\t * @param required required role\n\t * @return true if actual has required role (all permissions), false otherwise\n\t */\n\tfunction __hasRole(uint256 actual, uint256 required) private pure returns (bool) {\n\t\t// check the bitmask for the role required and return the result\n\t\treturn actual & required == required;\n\t}\n}\n"
    },
    "contracts/utils/Transfers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @notice Replaces built-in Solidity address.transfer and address.send functions\n *      with the address.call function\n */\nlibrary Transfers {\n\t/// @dev Mimics address.send forwarding 4,900 gas\n\tfunction send(address payable to, uint256 value) internal returns(bool) {\n\t\t(bool success, ) = to.call{gas: 4900, value: value}(\"\");\n\t\treturn success;\n\t}\n\n\t/// @dev Mimics address.transfer forwarding 4,900 gas\n\tfunction transfer(address payable to, uint256 value) internal {\n\t\trequire(send(to, value), \"failed to send ether\");\n\t}\n\n\t/// @dev Alias for `send`\n\tfunction send1(address payable to, uint256 value) internal returns(bool) {\n\t\treturn send(to, value);\n\t}\n\n\t/// @dev Alias for `transfer`\n\tfunction transfer1(address payable to, uint256 value) internal {\n\t\ttransfer(to, value);\n\t}\n}\n"
    },
    "contracts/utils/UpgradeableAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.2;\n\nimport \"./InitializableAccessControl.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\n/**\n * @title Upgradeable Role-based Access Control (RBAC) // ERC1967Proxy\n *\n * @notice Access control smart contract provides an API to check\n *      if a specific operation is permitted globally and/or\n *      if a particular user has a permission to execute it.\n *\n * @notice This contract is inherited by other contracts requiring the role-based access control (RBAC)\n *      protection for the restricted access functions\n *\n * @notice It deals with two main entities: features and roles.\n *\n * @notice Features are designed to be used to enable/disable public functions\n *      of the smart contract (used by a wide audience).\n * @notice User roles are designed to control the access to restricted functions\n *      of the smart contract (used by a limited set of maintainers).\n *\n * @notice Terms \"role\", \"permissions\" and \"set of permissions\" have equal meaning\n *      in the documentation text and may be used interchangeably.\n * @notice Terms \"permission\", \"single permission\" implies only one permission bit set.\n *\n * @notice Access manager is a special role which allows to grant/revoke other roles.\n *      Access managers can only grant/revoke permissions which they have themselves.\n *      As an example, access manager with no other roles set can only grant/revoke its own\n *      access manager permission and nothing else.\n *\n * @notice Access manager permission should be treated carefully, as a super admin permission:\n *      Access manager with even no other permission can interfere with another account by\n *      granting own access manager permission to it and effectively creating more powerful\n *      permission set than its own.\n *\n * @dev Both current and OpenZeppelin AccessControl implementations feature a similar API\n *      to check/know \"who is allowed to do this thing\".\n * @dev Zeppelin implementation is more flexible:\n *      - it allows setting unlimited number of roles, while current is limited to 256 different roles\n *      - it allows setting an admin for each role, while current allows having only one global admin\n * @dev Current implementation is more lightweight:\n *      - it uses only 1 bit per role, while Zeppelin uses 256 bits\n *      - it allows setting up to 256 roles at once, in a single transaction, while Zeppelin allows\n *        setting only one role in a single transaction\n *\n * @dev This smart contract is designed to be inherited by other\n *      smart contracts which require access control management capabilities.\n *\n * @dev Access manager permission has a bit 255 set.\n *      This bit must not be used by inheriting contracts for any other permissions/features.\n *\n * @dev This is an upgradeable version of the ACL, based on Zeppelin implementation for ERC1967,\n *      see https://docs.openzeppelin.com/contracts/4.x/upgradeable\n *      see https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable\n *      see https://forum.openzeppelin.com/t/uups-proxies-tutorial-solidity-javascript/7786\n */\nabstract contract UpgradeableAccessControl is InitializableAccessControl, UUPSUpgradeable {\n\t/**\n\t * @dev Creates/deploys the ACL implementation to be used in a proxy\n\t *\n\t * @dev Note:\n\t *      the implementation is already initialized and\n\t *      `_postConstruct` is not executable on the implementation\n\t *      `_postConstruct` is still available in the context of a proxy\n\t *      and should be executed on the proxy deployment (in the same tx)\n\t */\n\tconstructor() initializer {}\n\n\t/**\n\t * @notice Returns an address of the implementation smart contract,\n\t *      see ERC1967Upgrade._getImplementation()\n\t *\n\t * @return the current implementation address\n\t */\n\tfunction getImplementation() public view virtual returns (address) {\n\t\t// delegate to `ERC1967Upgrade._getImplementation()`\n\t\treturn _getImplementation();\n\t}\n\n\t/**\n\t * @inheritdoc UUPSUpgradeable\n\t */\n\tfunction _authorizeUpgrade(address) internal virtual override {\n\t\t// caller must have a permission to upgrade the contract\n\t\trequire(isSenderInRole(ROLE_UPGRADE_MANAGER), \"access denied\");\n\t}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}