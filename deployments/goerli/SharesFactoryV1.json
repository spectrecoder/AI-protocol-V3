{
  "address": "0x6298417717044c251775A57e742E37328C7F71ba",
  "abi": [
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "previousAdmin",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "newAdmin",
          "type": "address"
        }
      ],
      "name": "AdminChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "beacon",
          "type": "address"
        }
      ],
      "name": "BeaconUpgraded",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "enum SharesFactory.ImplementationType",
          "name": "implementationType",
          "type": "uint8"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "implementationAddress",
          "type": "address"
        }
      ],
      "name": "DistributorImplAddressUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "issuer",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "nonce",
          "type": "uint256"
        }
      ],
      "name": "NonceUsed",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "protocolFeeDestination",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint64",
          "name": "protocolFeePercent",
          "type": "uint64"
        },
        {
          "indexed": false,
          "internalType": "uint64",
          "name": "holdersFeePercent",
          "type": "uint64"
        },
        {
          "indexed": false,
          "internalType": "uint64",
          "name": "subjectFeePercent",
          "type": "uint64"
        }
      ],
      "name": "ProtocolFeeUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "requested",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "assigned",
          "type": "uint256"
        }
      ],
      "name": "RoleUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "creator",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "contract TradeableShares",
          "name": "implementationContract",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "contract HoldersRewardsDistributor",
          "name": "holdersRewardsDistributor",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "enum SharesFactory.ImplementationType",
          "name": "implementationType",
          "type": "uint8"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "tokenAddress",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "tokenId",
              "type": "uint256"
            }
          ],
          "indexed": false,
          "internalType": "struct TradeableShares.SharesSubject",
          "name": "sharesSubject",
          "type": "tuple"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "newDeployment",
          "type": "bool"
        }
      ],
      "name": "SharesContractRegistered",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "enum SharesFactory.ImplementationType",
          "name": "implementationType",
          "type": "uint8"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "implementationAddress",
          "type": "address"
        }
      ],
      "name": "SharesImplAddressUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "sharesOwnerAddress",
          "type": "address"
        }
      ],
      "name": "SharesOwnerAddressUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "implementation",
          "type": "address"
        }
      ],
      "name": "Upgraded",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "FEATURE_ALLOW_EXCLUSIVE_BUY",
      "outputs": [
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "FEATURE_ALLOW_PAUSED_DEPLOYMENTS",
      "outputs": [
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "FEATURE_SHARES_DEPLOYMENT_ENABLED",
      "outputs": [
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "ROLE_ACCESS_MANAGER",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "ROLE_FACTORY_DEPLOYMENT_MANAGER",
      "outputs": [
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "ROLE_HOLDERS_FEE_MANAGER",
      "outputs": [
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "ROLE_PROTOCOL_FEE_MANAGER",
      "outputs": [
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "ROLE_SHARES_REGISTRAR",
      "outputs": [
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "ROLE_SUBJECT_FEE_MANAGER",
      "outputs": [
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "ROLE_UPGRADE_MANAGER",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "enum SharesFactory.ImplementationType",
          "name": "_implementationType",
          "type": "uint8"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "tokenAddress",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "tokenId",
              "type": "uint256"
            }
          ],
          "internalType": "struct TradeableShares.SharesSubject",
          "name": "_sharesSubject",
          "type": "tuple"
        }
      ],
      "name": "deploySharesContract",
      "outputs": [
        {
          "internalType": "contract TradeableShares",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "enum SharesFactory.ImplementationType",
          "name": "_implementationType",
          "type": "uint8"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "tokenAddress",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "tokenId",
              "type": "uint256"
            }
          ],
          "internalType": "struct TradeableShares.SharesSubject",
          "name": "_sharesSubject",
          "type": "tuple"
        },
        {
          "internalType": "uint256",
          "name": "_amount",
          "type": "uint256"
        }
      ],
      "name": "deploySharesContractAndBuy",
      "outputs": [
        {
          "internalType": "contract TradeableShares",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "enum SharesFactory.ImplementationType",
          "name": "_implementationType",
          "type": "uint8"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "tokenAddress",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "tokenId",
              "type": "uint256"
            }
          ],
          "internalType": "struct TradeableShares.SharesSubject",
          "name": "_sharesSubject",
          "type": "tuple"
        }
      ],
      "name": "deploySharesContractPaused",
      "outputs": [
        {
          "internalType": "contract TradeableShares",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract TradeableShares",
          "name": "_sharesContract",
          "type": "address"
        }
      ],
      "name": "determineImplementationType",
      "outputs": [
        {
          "internalType": "enum SharesFactory.ImplementationType",
          "name": "",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "enum SharesFactory.ImplementationType",
              "name": "implementationType",
              "type": "uint8"
            },
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "tokenAddress",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "tokenId",
                  "type": "uint256"
                }
              ],
              "internalType": "struct TradeableShares.SharesSubject",
              "name": "sharesSubject",
              "type": "tuple"
            },
            {
              "internalType": "address",
              "name": "issuer",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "amount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "validFromTimestamp",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "expiresAtTimestamp",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "nonce",
              "type": "uint256"
            }
          ],
          "internalType": "struct SharesFactory.SharesDeploymentRequest",
          "name": "req",
          "type": "tuple"
        },
        {
          "internalType": "bytes",
          "name": "signature",
          "type": "bytes"
        }
      ],
      "name": "executeDeploymentRequest",
      "outputs": [
        {
          "internalType": "contract TradeableShares",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "features",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "enum SharesFactory.ImplementationType",
          "name": "_implementationType",
          "type": "uint8"
        }
      ],
      "name": "getDistributorImplAddress",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getHoldersFeePercent",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "feePercent",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getImplementation",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_issuer",
          "type": "address"
        }
      ],
      "name": "getNonce",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getPaymentToken",
      "outputs": [
        {
          "internalType": "contract ERC1363",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getProtocolFeeDestination",
      "outputs": [
        {
          "internalType": "address",
          "name": "feeDestination",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getProtocolFeePercent",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "feePercent",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "operator",
          "type": "address"
        }
      ],
      "name": "getRole",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "enum SharesFactory.ImplementationType",
          "name": "_implementationType",
          "type": "uint8"
        }
      ],
      "name": "getSharesImplAddress",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getSharesOwnerAddress",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getSubjectFeePercent",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "feePercent",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "required",
          "type": "uint256"
        }
      ],
      "name": "isFeatureEnabled",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "required",
          "type": "uint256"
        }
      ],
      "name": "isOperatorInRole",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "required",
          "type": "uint256"
        }
      ],
      "name": "isSenderInRole",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "tokenAddress",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "tokenId",
              "type": "uint256"
            }
          ],
          "internalType": "struct TradeableShares.SharesSubject",
          "name": "_sharesSubject",
          "type": "tuple"
        }
      ],
      "name": "lookupSharesContract",
      "outputs": [
        {
          "internalType": "contract TradeableShares",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "enum SharesFactory.ImplementationType",
          "name": "_implementationType",
          "type": "uint8"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "tokenAddress",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "tokenId",
              "type": "uint256"
            }
          ],
          "internalType": "struct TradeableShares.SharesSubject",
          "name": "_sharesSubject",
          "type": "tuple"
        },
        {
          "internalType": "address",
          "name": "_issuer",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_amount",
          "type": "uint256"
        }
      ],
      "name": "mintSubjectAndDeployShares",
      "outputs": [
        {
          "internalType": "contract TradeableShares",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "notifySubjectUpdated",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract ERC1363",
          "name": "_paymentToken",
          "type": "address"
        }
      ],
      "name": "postConstruct",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract TradeableShares",
          "name": "_sharesContract",
          "type": "address"
        }
      ],
      "name": "registerSharesContract",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_issuer",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_nonce",
          "type": "uint256"
        }
      ],
      "name": "rewindNonce",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "enum SharesFactory.ImplementationType",
          "name": "_implementationType",
          "type": "uint8"
        },
        {
          "internalType": "address",
          "name": "_implementationAddress",
          "type": "address"
        }
      ],
      "name": "setDistributorImplAddress",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "_feePercent",
          "type": "uint64"
        }
      ],
      "name": "setHoldersFeePercent",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_protocolFeeDestination",
          "type": "address"
        },
        {
          "internalType": "uint64",
          "name": "_protocolFeePercent",
          "type": "uint64"
        },
        {
          "internalType": "uint64",
          "name": "_holdersFeePercent",
          "type": "uint64"
        },
        {
          "internalType": "uint64",
          "name": "_subjectFeePercent",
          "type": "uint64"
        }
      ],
      "name": "setProtocolFee",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_feeDestination",
          "type": "address"
        }
      ],
      "name": "setProtocolFeeDestination",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "_feePercent",
          "type": "uint64"
        }
      ],
      "name": "setProtocolFeePercent",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "enum SharesFactory.ImplementationType",
          "name": "_implementationType",
          "type": "uint8"
        },
        {
          "internalType": "address",
          "name": "_implementationAddress",
          "type": "address"
        }
      ],
      "name": "setSharesImplAddress",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_sharesOwnerAddress",
          "type": "address"
        }
      ],
      "name": "setSharesOwnerAddress",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "_feePercent",
          "type": "uint64"
        }
      ],
      "name": "setSubjectFeePercent",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_mask",
          "type": "uint256"
        }
      ],
      "name": "updateFeatures",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "role",
          "type": "uint256"
        }
      ],
      "name": "updateRole",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newImplementation",
          "type": "address"
        }
      ],
      "name": "upgradeTo",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newImplementation",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "upgradeToAndCall",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    }
  ],
  "transactionHash": "0x3680e8db82ef071b9072872f48f9a13fbe749e263edbf1babeb535ce152afda0",
  "receipt": {
    "to": null,
    "from": "0x5F185Da55f7BBD9217E3b3CeE06b180721FA6d34",
    "contractAddress": "0x6298417717044c251775A57e742E37328C7F71ba",
    "transactionIndex": 9,
    "gasUsed": "3523194",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x01aa9f85f78a390f63b0334534fa8acac97c6efdd897e1d8bd390324832f7804",
    "transactionHash": "0x3680e8db82ef071b9072872f48f9a13fbe749e263edbf1babeb535ce152afda0",
    "logs": [],
    "blockNumber": 10348471,
    "cumulativeGasUsed": "5440551",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "395ad90d11a7c2eb892b5fa1ad354489",
  "metadata": "{\"compiler\":{\"version\":\"0.8.15+commit.e14f2714\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beacon\",\"type\":\"address\"}],\"name\":\"BeaconUpgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"enum SharesFactory.ImplementationType\",\"name\":\"implementationType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"implementationAddress\",\"type\":\"address\"}],\"name\":\"DistributorImplAddressUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"issuer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"NonceUsed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"protocolFeeDestination\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"protocolFeePercent\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"holdersFeePercent\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"subjectFeePercent\",\"type\":\"uint64\"}],\"name\":\"ProtocolFeeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requested\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assigned\",\"type\":\"uint256\"}],\"name\":\"RoleUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract TradeableShares\",\"name\":\"implementationContract\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract HoldersRewardsDistributor\",\"name\":\"holdersRewardsDistributor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum SharesFactory.ImplementationType\",\"name\":\"implementationType\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct TradeableShares.SharesSubject\",\"name\":\"sharesSubject\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"newDeployment\",\"type\":\"bool\"}],\"name\":\"SharesContractRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"enum SharesFactory.ImplementationType\",\"name\":\"implementationType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"implementationAddress\",\"type\":\"address\"}],\"name\":\"SharesImplAddressUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sharesOwnerAddress\",\"type\":\"address\"}],\"name\":\"SharesOwnerAddressUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"FEATURE_ALLOW_EXCLUSIVE_BUY\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FEATURE_ALLOW_PAUSED_DEPLOYMENTS\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FEATURE_SHARES_DEPLOYMENT_ENABLED\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ROLE_ACCESS_MANAGER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ROLE_FACTORY_DEPLOYMENT_MANAGER\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ROLE_HOLDERS_FEE_MANAGER\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ROLE_PROTOCOL_FEE_MANAGER\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ROLE_SHARES_REGISTRAR\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ROLE_SUBJECT_FEE_MANAGER\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ROLE_UPGRADE_MANAGER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum SharesFactory.ImplementationType\",\"name\":\"_implementationType\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"internalType\":\"struct TradeableShares.SharesSubject\",\"name\":\"_sharesSubject\",\"type\":\"tuple\"}],\"name\":\"deploySharesContract\",\"outputs\":[{\"internalType\":\"contract TradeableShares\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum SharesFactory.ImplementationType\",\"name\":\"_implementationType\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"internalType\":\"struct TradeableShares.SharesSubject\",\"name\":\"_sharesSubject\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deploySharesContractAndBuy\",\"outputs\":[{\"internalType\":\"contract TradeableShares\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum SharesFactory.ImplementationType\",\"name\":\"_implementationType\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"internalType\":\"struct TradeableShares.SharesSubject\",\"name\":\"_sharesSubject\",\"type\":\"tuple\"}],\"name\":\"deploySharesContractPaused\",\"outputs\":[{\"internalType\":\"contract TradeableShares\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract TradeableShares\",\"name\":\"_sharesContract\",\"type\":\"address\"}],\"name\":\"determineImplementationType\",\"outputs\":[{\"internalType\":\"enum SharesFactory.ImplementationType\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"enum SharesFactory.ImplementationType\",\"name\":\"implementationType\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"internalType\":\"struct TradeableShares.SharesSubject\",\"name\":\"sharesSubject\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"issuer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"validFromTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiresAtTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"internalType\":\"struct SharesFactory.SharesDeploymentRequest\",\"name\":\"req\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"executeDeploymentRequest\",\"outputs\":[{\"internalType\":\"contract TradeableShares\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"features\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum SharesFactory.ImplementationType\",\"name\":\"_implementationType\",\"type\":\"uint8\"}],\"name\":\"getDistributorImplAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getHoldersFeePercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"feePercent\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_issuer\",\"type\":\"address\"}],\"name\":\"getNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPaymentToken\",\"outputs\":[{\"internalType\":\"contract ERC1363\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getProtocolFeeDestination\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"feeDestination\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getProtocolFeePercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"feePercent\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"getRole\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum SharesFactory.ImplementationType\",\"name\":\"_implementationType\",\"type\":\"uint8\"}],\"name\":\"getSharesImplAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSharesOwnerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSubjectFeePercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"feePercent\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"required\",\"type\":\"uint256\"}],\"name\":\"isFeatureEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"required\",\"type\":\"uint256\"}],\"name\":\"isOperatorInRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"required\",\"type\":\"uint256\"}],\"name\":\"isSenderInRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"internalType\":\"struct TradeableShares.SharesSubject\",\"name\":\"_sharesSubject\",\"type\":\"tuple\"}],\"name\":\"lookupSharesContract\",\"outputs\":[{\"internalType\":\"contract TradeableShares\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum SharesFactory.ImplementationType\",\"name\":\"_implementationType\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"internalType\":\"struct TradeableShares.SharesSubject\",\"name\":\"_sharesSubject\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"_issuer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mintSubjectAndDeployShares\",\"outputs\":[{\"internalType\":\"contract TradeableShares\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"notifySubjectUpdated\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC1363\",\"name\":\"_paymentToken\",\"type\":\"address\"}],\"name\":\"postConstruct\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract TradeableShares\",\"name\":\"_sharesContract\",\"type\":\"address\"}],\"name\":\"registerSharesContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_issuer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"}],\"name\":\"rewindNonce\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum SharesFactory.ImplementationType\",\"name\":\"_implementationType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"_implementationAddress\",\"type\":\"address\"}],\"name\":\"setDistributorImplAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_feePercent\",\"type\":\"uint64\"}],\"name\":\"setHoldersFeePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_protocolFeeDestination\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"_protocolFeePercent\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"_holdersFeePercent\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"_subjectFeePercent\",\"type\":\"uint64\"}],\"name\":\"setProtocolFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeDestination\",\"type\":\"address\"}],\"name\":\"setProtocolFeeDestination\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_feePercent\",\"type\":\"uint64\"}],\"name\":\"setProtocolFeePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum SharesFactory.ImplementationType\",\"name\":\"_implementationType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"_implementationAddress\",\"type\":\"address\"}],\"name\":\"setSharesImplAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sharesOwnerAddress\",\"type\":\"address\"}],\"name\":\"setSharesOwnerAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_feePercent\",\"type\":\"uint64\"}],\"name\":\"setSubjectFeePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_mask\",\"type\":\"uint256\"}],\"name\":\"updateFeatures\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"role\",\"type\":\"uint256\"}],\"name\":\"updateRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"upgradeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"upgradeToAndCall\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Based on the friend.tech FriendtechSharesV1.sol\",\"events\":{\"DistributorImplAddressUpdated(uint8,address)\":{\"details\":\"Fired in `setDistributorImplAddress`\",\"params\":{\"implementationAddress\":\"the address of the already deployed HoldersRewardsDistributor implementation      corresponding to the given implementation type, or zero address\",\"implementationType\":\"HoldersRewardsDistributor implementation type\"}},\"SharesImplAddressUpdated(uint8,address)\":{\"details\":\"Fired in `setSharesImplAddress`\",\"params\":{\"implementationAddress\":\"the address of the already deployed TradeableShares implementation      corresponding to the given implementation type, or zero address\",\"implementationType\":\"TradeableShares implementation type\"}},\"SharesOwnerAddressUpdated(address)\":{\"details\":\"Fired in setSharesOwnerAddress\",\"params\":{\"sharesOwnerAddress\":\"new shares owner address, or zero\"}}},\"kind\":\"dev\",\"methods\":{\"deploySharesContract(uint8,(address,uint256))\":{\"details\":\"Implementation must guarantee only one TradeableShares contract per subject\",\"params\":{\"implementationType\":\"TradeableShares implementation type\",\"sharesSubject\":\"shares subject, owner of the curve\"},\"returns\":{\"_0\":\"deployed TradeableShares contract\"}},\"deploySharesContractAndBuy(uint8,(address,uint256),uint256)\":{\"details\":\"Implementation must guarantee only one TradeableShares contract per subject\",\"params\":{\"amount\":\"how many shares to buy immediately after the deployment\",\"implementationType\":\"TradeableShares implementation type\",\"sharesSubject\":\"shares subject, owner of the curve\"},\"returns\":{\"_0\":\"deployed TradeableShares contract\"}},\"deploySharesContractPaused(uint8,(address,uint256))\":{\"details\":\"Implementation must guarantee only one TradeableShares contract per subject\",\"params\":{\"implementationType\":\"TradeableShares implementation type\",\"sharesSubject\":\"shares subject, owner of the curve\"},\"returns\":{\"_0\":\"deployed TradeableShares contract\"}},\"determineImplementationType(address)\":{\"params\":{\"_sharesContract\":\"deployed TradeableShares instance\"},\"returns\":{\"_0\":\"implementation type of the instance specified\"}},\"executeDeploymentRequest((uint8,(address,uint256),address,uint256,uint256,uint256,uint256),bytes)\":{\"params\":{\"req\":\"the deployment request to fulfill, containing same data as in `mintSubjectAndDeployShares`\",\"signature\":\"the deployment request EIP712 signature issued by the address allowed to execute      the request\"},\"returns\":{\"_0\":\"deployed TradeableShares contract\"}},\"features()\":{\"details\":\"Effectively reads userRoles role for the contract itself\",\"returns\":{\"_0\":\"256-bit bitmask of the features enabled\"}},\"getDistributorImplAddress(uint8)\":{\"details\":\"If the HoldersRewardsDistributor implementation is missing, the TradeableShares contract      can still be deployed, not being attached to the HoldersRewardsDistributor\",\"params\":{\"_implementationType\":\"TradeableShares implementation type\"},\"returns\":{\"_0\":\"the address of the already deployed HoldersRewardsDistributor implementation corresponding      to the given implementation type\"}},\"getHoldersFeePercent()\":{\"details\":\"The value has 18 decimals, 100% is represented as 10^18\",\"returns\":{\"feePercent\":\"shares holders fee percent\"}},\"getImplementation()\":{\"returns\":{\"_0\":\"the current implementation address\"}},\"getNonce(address)\":{\"params\":{\"issuer\":\"the issuer address to get the nonce for\"},\"returns\":{\"_0\":\"current (unused) nonce; incremented by one after      each successful execution of the `executeDeploymentRequest` function\"}},\"getPaymentToken()\":{\"details\":\"Immutable, client applications may cache this value\",\"returns\":{\"_0\":\"ERC1363 payment token contract\"}},\"getProtocolFeeDestination()\":{\"returns\":{\"feeDestination\":\"protocol fee destination, address\"}},\"getProtocolFeePercent()\":{\"details\":\"The value has 18 decimals, 100% is represented as 10^18\",\"returns\":{\"feePercent\":\"protocol fee percent\"}},\"getRole(address)\":{\"details\":\"Having a simple getter instead of making the mapping public      allows enforcing the encapsulation of the mapping and protects from      writing to it directly in the inheriting smart contracts\",\"params\":{\"operator\":\"address of a user to read permissions for,      or self address to read global features of the smart contract\"}},\"getSharesImplAddress(uint8)\":{\"params\":{\"_implementationType\":\"TradeableShares implementation type\"},\"returns\":{\"_0\":\"the address of the already deployed TradeableShares implementation corresponding      to the given implementation type\"}},\"getSharesOwnerAddress()\":{\"details\":\"This should be the MultiSig address, not to EOA and not the      RBAC managed smart contract, so that this address cannot act in a scalable way;      this reduces the risk of misuse, and/or malicious use\",\"returns\":{\"_0\":\"currently active shares owner address, or zero if not set\"}},\"getSubjectFeePercent()\":{\"details\":\"The value has 18 decimals, 100% is represented as 10^18Implementation may return different values for different callers,      for example it can read SharesSubject from the caller TradeableShares contract      and dynamically determine the subject fee\",\"returns\":{\"feePercent\":\"subject fee percent\"}},\"isFeatureEnabled(uint256)\":{\"params\":{\"required\":\"set of features to check against\"},\"returns\":{\"_0\":\"true if all the features requested are enabled, false otherwise\"}},\"isOperatorInRole(address,uint256)\":{\"params\":{\"operator\":\"address of the user to check role for\",\"required\":\"set of permissions (role) to check\"},\"returns\":{\"_0\":\"true if all the permissions requested are enabled, false otherwise\"}},\"isSenderInRole(uint256)\":{\"details\":\"Used in smart contracts only. Off-chain clients should use `isOperatorInRole`.\",\"params\":{\"required\":\"set of permissions (role) to check against\"},\"returns\":{\"_0\":\"true if all the permissions requested are enabled, false otherwise\"}},\"lookupSharesContract((address,uint256))\":{\"params\":{\"sharesSubject\":\"shares subject, owner of the curve\"},\"returns\":{\"_0\":\"deployed TradeableShares contract\"}},\"mintSubjectAndDeployShares(uint8,(address,uint256),address,uint256)\":{\"details\":\"Implementation must guarantee only one TradeableShares contract per subject\",\"params\":{\"amount\":\"how many shares to buy immediately after the deployment\",\"implementationType\":\"TradeableShares implementation type\",\"issuer\":\"an address to mint the NFT defined by the subject if it doesn't exist\",\"sharesSubject\":\"shares subject, owner of the curve\"},\"returns\":{\"_0\":\"deployed TradeableShares contract\"}},\"notifySubjectUpdated()\":{\"details\":\"The factory may throw if the subject is already taken by another contract\"},\"postConstruct(address)\":{\"details\":\"\\\"Constructor replacement\\\" for upgradeable, must be execute immediately after proxy deployment      see https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#initializers\",\"params\":{\"_paymentToken\":\"ERC20 payment token address to bind to, immutable\"}},\"registerSharesContract(address)\":{\"details\":\"Note: this restricted function allows the authorized address to register      the shares contract with the invalid subject\",\"params\":{\"shares\":\"already deployed TradeableShares contract\"}},\"rewindNonce(address,uint256)\":{\"details\":\"Implementation must not allow to decrease the nonce, only increasing (rewinding)      must be possible\",\"params\":{\"issuer\":\"the issuer address to rewind the nonce for\",\"nonce\":\"the nonce value to rewind to\"}},\"setDistributorImplAddress(uint8,address)\":{\"params\":{\"_implementationAddress\":\"address of the already deployed HoldersRewardsDistributor implementation      corresponding to the given implementation type\",\"_implementationType\":\"HoldersRewardsDistributor implementation type\"}},\"setHoldersFeePercent(uint64)\":{\"params\":{\"feePercent\":\"shares holders fee percent to set, examples: 10^18 is 100%, 10^17 is 10%\"}},\"setProtocolFee(address,uint64,uint64,uint64)\":{\"params\":{\"holdersFeePercent\":\"shares holders fee percent to set, examples: 10^18 is 100%, 10^17 is 10%\",\"protocolFeeDestination\":\"protocol fee destination to set\",\"protocolFeePercent\":\"protocol fee percent to set, examples: 10^18 is 100%, 10^17 is 10%\",\"subjectFeePercent\":\"subject fee percent to set, examples: 10^18 is 100%, 10^17 is 10%\"}},\"setProtocolFeeDestination(address)\":{\"details\":\"Implementation must check the consistency of the protocol fee destination and percent      set by this and `setProtocolFeePercent` functions\",\"params\":{\"feeDestination\":\"protocol fee destination to set\"}},\"setProtocolFeePercent(uint64)\":{\"details\":\"Implementation must check the consistency of the protocol fee destination and percent      set by this and `setProtocolFeeDestination` functions\",\"params\":{\"feePercent\":\"protocol fee percent to set, examples: 10^18 is 100%, 10^17 is 10%\"}},\"setSharesImplAddress(uint8,address)\":{\"params\":{\"_implementationAddress\":\"address of the already deployed TradeableShares implementation      corresponding to the given implementation type\",\"_implementationType\":\"TradeableShares implementation type\"}},\"setSharesOwnerAddress(address)\":{\"details\":\"This should be the MultiSig address, not to EOA and not the      RBAC managed smart contract, so that this address cannot act in a scalable way;      this reduces the risk of misuse, and/or malicious useOnce changed/set, the address affects only new TradeableShares deployments\",\"params\":{\"_sharesOwnerAddress\":\"new shares owner address to set, or zero to unset\"}},\"setSubjectFeePercent(uint64)\":{\"params\":{\"feePercent\":\"subject fee percent to set, examples: 10^18 is 100%, 10^17 is 10%\"}},\"updateFeatures(uint256)\":{\"details\":\"Requires transaction sender to have `ROLE_ACCESS_MANAGER` permissionFunction is left for backward compatibility with older versions\",\"params\":{\"_mask\":\"bitmask representing a set of features to enable/disable\"}},\"updateRole(address,uint256)\":{\"details\":\"Setting role to zero is equivalent to removing an all permissionsSetting role to `FULL_PRIVILEGES_MASK` is equivalent to      copying senders' permissions (role) to the userRequires transaction sender to have `ROLE_ACCESS_MANAGER` permission\",\"params\":{\"operator\":\"address of a user to alter permissions for,       or self address to alter global features of the smart contract\",\"role\":\"bitmask representing a set of permissions to      enable/disable for a user specified\"}},\"upgradeTo(address)\":{\"details\":\"Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event.\"},\"upgradeToAndCall(address,bytes)\":{\"details\":\"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event.\"}},\"stateVariables\":{\"FEATURE_ALLOW_EXCLUSIVE_BUY\":{\"details\":\"Feature FEATURE_ALLOW_EXCLUSIVE_BUY enables `deploySharesContractAndBuy` function\"},\"FEATURE_ALLOW_PAUSED_DEPLOYMENTS\":{\"details\":\"Feature FEATURE_ALLOW_PAUSED_DEPLOYMENTS enables `deploySharesContractPaused` function\"},\"FEATURE_SHARES_DEPLOYMENT_ENABLED\":{\"details\":\"Feature FEATURE_SHARES_DEPLOYMENT_ENABLED enables `deploySharesContractPaused`,      `deploySharesContract`, and `deploySharesContractAndBuy` functions\"},\"ROLE_FACTORY_DEPLOYMENT_MANAGER\":{\"details\":\"Role ROLE_SHARES_IMPLEMENTATION_REGISTRAR is required to execute functions:      - `setImplementationAddress`      - `setSharesOwnerAddress`\"},\"ROLE_HOLDERS_FEE_MANAGER\":{\"details\":\"Role ROLE_HOLDERS_FEE_MANAGER is required to execute `setHoldersFeePercent` function\"},\"ROLE_PROTOCOL_FEE_MANAGER\":{\"details\":\"Role ROLE_PROTOCOL_FEE_MANAGER is required to execute      `setProtocolFeeDestination` and `setProtocolFeePercent` functions\"},\"ROLE_SHARES_REGISTRAR\":{\"details\":\"Role ROLE_SHARES_REGISTRAR is required to execute `deploySharesContract`      and `registerSharesContract` functions\"},\"ROLE_SUBJECT_FEE_MANAGER\":{\"details\":\"Role ROLE_SUBJECT_FEE_MANAGER is required to execute `setSubjectFeePercent` function\"},\"distributorsImplementations\":{\"details\":\"HoldersRewardsDistributor implementations mapping storing deployed HoldersRewardsDistributor      address for every supported implementation type, used by the factory to      deploy the HoldersRewardsDistributor contracts EIP-1167 clonesIf available, HoldersRewardsDistributor implementation is attached to the shares contract      during the deployment, allowing it to send shares holders fees to the distributorMaps TradeableShares ImplementationType => HoldersRewardsDistributor deployed implementation address\"},\"holdersFeePercent\":{\"details\":\"Shares holders fee percent with 18 decimals (10^18 = 100%)\"},\"nonces\":{\"details\":\"Keeps track of the used nonces for every possible issuer      Maps address => number of used nonces\"},\"paymentToken\":{\"details\":\"ERC20 payment token address, effectively immutable (cannot be updated)\"},\"protocolFeeDestination\":{\"details\":\"Protocol fee destination is the address receiving the protocol fee\"},\"protocolFeePercent\":{\"details\":\"Protocol fee percent with 18 decimals (10^18 = 100%)\"},\"shares\":{\"details\":\"Deployed shares contracts mapping, keeps track of the deployed contracts subjects      Maps SharesSubject => TradeableShares\"},\"sharesImplementations\":{\"details\":\"TradeableShares implementations mapping storing deployed TradeableShares      address for every supported implementation type, used by the factory to      deploy the TradeableShares contracts EIP-1167 clonesMaps TradeableShares ImplementationType => TradeableShares deployed implementation address\"},\"sharesOwnerAddress\":{\"details\":\"An address receiving the ownership of the deployed TradeableShares contractsThis should be the MultiSig address, not to EOA and not the      RBAC managed smart contract, so that this address cannot act in a scalable way;      this reduces the risk of misuse, and/or malicious use\"},\"subjectFeePercent\":{\"details\":\"Subject fee percent with 18 decimals (10^18 = 100%)\"},\"subjects\":{\"details\":\"Reverse deployed shares contracts mapping, keeps track of the deployed contracts      Maps TradeableShares address => SharesSubject\"}},\"title\":\"Shares Factory V1\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"FEATURE_ALLOW_EXCLUSIVE_BUY()\":{\"notice\":\"Allows the [TradeableShares] curve deployer to exclusively buy      any amount of the initial shares; if disabled the deployer always gets      no more than only one share\"},\"FEATURE_ALLOW_PAUSED_DEPLOYMENTS()\":{\"notice\":\"Allows the [TradeableShares] curve deployer not to buy any shares on deployment;      if disabled the deployer always gets at least one share,      effectively launching the curve and allowing anyone to buy\"},\"FEATURE_SHARES_DEPLOYMENT_ENABLED()\":{\"notice\":\"Enables [TradeableShares] curve deployment functionality\"},\"ROLE_ACCESS_MANAGER()\":{\"notice\":\"Access manager is responsible for assigning the roles to users,      enabling/disabling global features of the smart contractAccess manager can add, remove and update user roles,      remove and update global features\"},\"ROLE_FACTORY_DEPLOYMENT_MANAGER()\":{\"notice\":\"Factory deployment manager      - registers already deployed TradeableShares implementations to be used by the factory        to deploy the TradeableShares contracts EIP-1167 clones      - sets/unsets/updates the shares owner address `sharesOwnerAddress`\"},\"ROLE_HOLDERS_FEE_MANAGER()\":{\"notice\":\"Shares holders fee manager sets shares holders fee percent (holdersFeePercent)\"},\"ROLE_PROTOCOL_FEE_MANAGER()\":{\"notice\":\"Protocol fee manager sets protocol fee destination address (protocolFeeDestination)      and protocol fee percent (protocolFeePercent)\"},\"ROLE_SHARES_REGISTRAR()\":{\"notice\":\"Shares registrar deploys new and registers already deployed TradeableShares instances\"},\"ROLE_SUBJECT_FEE_MANAGER()\":{\"notice\":\"Subject fee manager sets subject fee percent (subjectFeePercent)\"},\"ROLE_UPGRADE_MANAGER()\":{\"notice\":\"Upgrade manager is responsible for smart contract upgrades,      see https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable      see https://docs.openzeppelin.com/contracts/4.x/upgradeable\"},\"deploySharesContract(uint8,(address,uint256))\":{\"notice\":\"Deploys the TradeableShares implementation for the specified subject;      the curve launches immediately, the first share is issued to the subject issuer (NFT owner)Tries minting the NFT defined by the subject if it doesn't exist\"},\"deploySharesContractAndBuy(uint8,(address,uint256),uint256)\":{\"notice\":\"Deploys the TradeableShares implementation for the specified subject;      allows to immediately buy any amount of shares (including zero)Tries minting the NFT defined by the subject if it doesn't exist\"},\"deploySharesContractPaused(uint8,(address,uint256))\":{\"notice\":\"Deploys the TradeableShares implementation for the specified subject;      the curve remains paused, no shares are being bought immediatelyTries minting the NFT defined by the subject if it doesn't exist\"},\"determineImplementationType(address)\":{\"notice\":\"Tries to determine the implementation type of the already deployed TradeableShares contract;      the result should not be considered reliable and can be used only as a hint\"},\"executeDeploymentRequest((uint8,(address,uint256),address,uint256,uint256,uint256,uint256),bytes)\":{\"notice\":\"Executes signed SharesDeploymentRequest; this is identical to executing `mintSubjectAndDeployShares`      on behalf of the signer and allows the transaction to be relayed so that the gas is payed by the      relayer\"},\"features()\":{\"notice\":\"Retrieves globally set of features enabled\"},\"getDistributorImplAddress(uint8)\":{\"notice\":\"Address of the already deployed HoldersRewardsDistributor implementation      to be used by the factory to deploy the HoldersRewardsDistributor contracts EIP-1167 clones\"},\"getHoldersFeePercent()\":{\"notice\":\"Shares holders fee percent is the percentage of the buy/sell transaction volume      sent to the shares holders rewards distributor contract\"},\"getImplementation()\":{\"notice\":\"Returns an address of the implementation smart contract,      see ERC1967Upgrade._getImplementation()\"},\"getNonce(address)\":{\"notice\":\"Gets current (unused) nonce for the given issuer address;      unused nonce is required to build the SharesDeploymentRequest and sign it      nonces increment by one after each use\"},\"getPaymentToken()\":{\"notice\":\"ERC1363 payment token contract which the factory uses to deploy the `ERC20` curve type\"},\"getProtocolFeeDestination()\":{\"notice\":\"Protocol fee destination is the address receiving the protocol fee\"},\"getProtocolFeePercent()\":{\"notice\":\"Protocol fee percent is the percentage of the buy/sell transaction volume      sent to the protocol fee destination\"},\"getRole(address)\":{\"notice\":\"Reads the permissions (role) for a given user from the `userRoles` mapping      (privileged addresses with defined roles/permissions)In the context of ERC20/ERC721 tokens these can be permissions to      allow minting or burning tokens, transferring on behalf and so on\"},\"getSharesImplAddress(uint8)\":{\"notice\":\"Address of the already deployed TradeableShares implementation      to be used by the factory to deploy the TradeableShares contracts EIP-1167 clones\"},\"getSharesOwnerAddress()\":{\"notice\":\"An address receiving the ownership of the deployed TradeableShares contracts\"},\"getSubjectFeePercent()\":{\"notice\":\"Subject fee percent is the percentage of the buy/sell transaction volume      sent to the subject issuer\"},\"isFeatureEnabled(uint256)\":{\"notice\":\"Checks if requested set of features is enabled globally on the contract\"},\"isOperatorInRole(address,uint256)\":{\"notice\":\"Checks if operator has all the permissions (role) required\"},\"isSenderInRole(uint256)\":{\"notice\":\"Checks if transaction sender `msg.sender` has all the permissions required\"},\"lookupSharesContract((address,uint256))\":{\"notice\":\"Gets the already deployed TradeableShares contract\"},\"mintSubjectAndDeployShares(uint8,(address,uint256),address,uint256)\":{\"notice\":\"Deploys the TradeableShares implementation for the specified subject;      allows to immediately buy any amount of shares (including zero)Tries minting the NFT defined by the subject if it doesn't exist\"},\"notifySubjectUpdated()\":{\"notice\":\"Executed only by the previously registered TradeableShares contracts      to notify the factory about the subject change.\"},\"registerSharesContract(address)\":{\"notice\":\"Registers or re-registers the already deployed TradeableShares contract\"},\"rewindNonce(address,uint256)\":{\"notice\":\"Rewinds forward the nonce for the issuer specified, used to      discard one or more signed requests to `executeDeploymentRequest`\"},\"setDistributorImplAddress(uint8,address)\":{\"notice\":\"Sets the address of the already deployed HoldersRewardsDistributor implementation      to be used by the factory to deploy the HoldersRewardsDistributor contracts EIP-1167 clones\"},\"setHoldersFeePercent(uint64)\":{\"notice\":\"Sets the shares holders fee percent\"},\"setProtocolFee(address,uint64,uint64,uint64)\":{\"notice\":\"Sets all the fees at once:      protocolFeeDestination      protocolFeePercent      holdersFeePercent      subjectFeePercent\"},\"setProtocolFeeDestination(address)\":{\"notice\":\"Sets the protocol fee destination\"},\"setProtocolFeePercent(uint64)\":{\"notice\":\"Sets the protocol fee percent\"},\"setSharesImplAddress(uint8,address)\":{\"notice\":\"Sets the address of the already deployed TradeableShares implementation      to be used by the factory to deploy the TradeableShares contracts EIP-1167 clones\"},\"setSharesOwnerAddress(address)\":{\"notice\":\"Sets/unsets/updates the shares owner address `sharesOwnerAddress`, which is      an address receiving the ownership of the deployed TradeableShares contracts\"},\"setSubjectFeePercent(uint64)\":{\"notice\":\"Sets the subject fee percent\"},\"updateFeatures(uint256)\":{\"notice\":\"Updates set of the globally enabled features (`features`),      taking into account sender's permissions\"},\"updateRole(address,uint256)\":{\"notice\":\"Updates set of permissions (role) for a given user,      taking into account sender's permissions.\"}},\"notice\":\"Role-based access control (RBAC) based implementation of the SharesFactory\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/bonding_curves/SharesFactoryV1.sol\":\"SharesFactoryV1\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts-upgradeable/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Upgrade.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../beacon/IBeaconUpgradeable.sol\\\";\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\nimport \\\"../../utils/StorageSlotUpgradeable.sol\\\";\\nimport \\\"../utils/Initializable.sol\\\";\\n\\n/**\\n * @dev This abstract contract provides getters and event emitting update functions for\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\\n *\\n * _Available since v4.1._\\n *\\n * @custom:oz-upgrades-unsafe-allow delegatecall\\n */\\nabstract contract ERC1967UpgradeUpgradeable is Initializable {\\n    function __ERC1967Upgrade_init() internal onlyInitializing {\\n        __ERC1967Upgrade_init_unchained();\\n    }\\n\\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\\n    }\\n    // This is the keccak-256 hash of \\\"eip1967.proxy.rollback\\\" subtracted by 1\\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _getImplementation() internal view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        require(AddressUpgradeable.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeTo(address newImplementation) internal {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCall(\\n        address newImplementation,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        _upgradeTo(newImplementation);\\n        if (data.length > 0 || forceCall) {\\n            _functionDelegateCall(newImplementation, data);\\n        }\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCallSecure(\\n        address newImplementation,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        address oldImplementation = _getImplementation();\\n\\n        // Initial upgrade and setup call\\n        _setImplementation(newImplementation);\\n        if (data.length > 0 || forceCall) {\\n            _functionDelegateCall(newImplementation, data);\\n        }\\n\\n        // Perform rollback test if not already in progress\\n        StorageSlotUpgradeable.BooleanSlot storage rollbackTesting = StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT);\\n        if (!rollbackTesting.value) {\\n            // Trigger rollback using upgradeTo from the new implementation\\n            rollbackTesting.value = true;\\n            _functionDelegateCall(\\n                newImplementation,\\n                abi.encodeWithSignature(\\\"upgradeTo(address)\\\", oldImplementation)\\n            );\\n            rollbackTesting.value = false;\\n            // Check rollback was effective\\n            require(oldImplementation == _getImplementation(), \\\"ERC1967Upgrade: upgrade breaks further upgrades\\\");\\n            // Finally reset to the new implementation and log the upgrade\\n            _upgradeTo(newImplementation);\\n        }\\n    }\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Returns the current admin.\\n     */\\n    function _getAdmin() internal view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin) private {\\n        require(newAdmin != address(0), \\\"ERC1967: new admin is the zero address\\\");\\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {AdminChanged} event.\\n     */\\n    function _changeAdmin(address newAdmin) internal {\\n        emit AdminChanged(_getAdmin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\\n     */\\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\n\\n    /**\\n     * @dev Emitted when the beacon is upgraded.\\n     */\\n    event BeaconUpgraded(address indexed beacon);\\n\\n    /**\\n     * @dev Returns the current beacon.\\n     */\\n    function _getBeacon() internal view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\\n     */\\n    function _setBeacon(address newBeacon) private {\\n        require(AddressUpgradeable.isContract(newBeacon), \\\"ERC1967: new beacon is not a contract\\\");\\n        require(\\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\\n            \\\"ERC1967: beacon implementation is not a contract\\\"\\n        );\\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\\n    }\\n\\n    /**\\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\\n     *\\n     * Emits a {BeaconUpgraded} event.\\n     */\\n    function _upgradeBeaconToAndCall(\\n        address newBeacon,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        _setBeacon(newBeacon);\\n        emit BeaconUpgraded(newBeacon);\\n        if (data.length > 0 || forceCall) {\\n            _functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\\n        }\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function _functionDelegateCall(address target, bytes memory data) private returns (bytes memory) {\\n        require(AddressUpgradeable.isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return AddressUpgradeable.verifyCallResult(success, returndata, \\\"Address: low-level delegate call failed\\\");\\n    }\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0xba3e051005a0b7f77c465dbcfe6366ce6a72e3845028277e1f794e5e8864e017\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/beacon/IBeaconUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeaconUpgradeable {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {BeaconProxy} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\",\"keccak256\":\"0x24b86ac8c005b8c654fbf6ac34a5a4f61580d7273541e83e013e89d66fbf0908\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() initializer {}\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\\n        // contract may have been reentered.\\n        require(_initializing ? _isConstructor() : !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} modifier, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    function _isConstructor() private view returns (bool) {\\n        return !AddressUpgradeable.isContract(address(this));\\n    }\\n}\\n\",\"keccak256\":\"0x68861bcc80cacbd498efde75aab6c74a486cc48262660d326c8d7530d9752097\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/utils/UUPSUpgradeable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC1967/ERC1967UpgradeUpgradeable.sol\\\";\\nimport \\\"./Initializable.sol\\\";\\n\\n/**\\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\\n *\\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\\n * `UUPSUpgradeable` with a custom implementation of upgrades.\\n *\\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\\n *\\n * _Available since v4.1._\\n */\\nabstract contract UUPSUpgradeable is Initializable, ERC1967UpgradeUpgradeable {\\n    function __UUPSUpgradeable_init() internal onlyInitializing {\\n        __ERC1967Upgrade_init_unchained();\\n        __UUPSUpgradeable_init_unchained();\\n    }\\n\\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\\n    }\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\\n    address private immutable __self = address(this);\\n\\n    /**\\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\\n     * fail.\\n     */\\n    modifier onlyProxy() {\\n        require(address(this) != __self, \\\"Function must be called through delegatecall\\\");\\n        require(_getImplementation() == __self, \\\"Function must be called through active proxy\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\\n     *\\n     * Calls {_authorizeUpgrade}.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function upgradeTo(address newImplementation) external virtual onlyProxy {\\n        _authorizeUpgrade(newImplementation);\\n        _upgradeToAndCallSecure(newImplementation, new bytes(0), false);\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\\n     * encoded in `data`.\\n     *\\n     * Calls {_authorizeUpgrade}.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual onlyProxy {\\n        _authorizeUpgrade(newImplementation);\\n        _upgradeToAndCallSecure(newImplementation, data, true);\\n    }\\n\\n    /**\\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\\n     * {upgradeTo} and {upgradeToAndCall}.\\n     *\\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\\n     *\\n     * ```solidity\\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\\n     * ```\\n     */\\n    function _authorizeUpgrade(address newImplementation) internal virtual;\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0xed65883d4af8d00c76ff9f1b7758c5d8ac4ab82da60f9743c74d31b754b06bc0\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x3f0f878c796dfc7feba6d3c4e3e526c14c7deae8b7bfc71088e3f38fab0d77b3\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/StorageSlot.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\\n */\\nlibrary StorageSlotUpgradeable {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x422c3d27d0d5681cea93acbb0dcb175fa5b461b5b7731da7ff77e51f0f0174c7\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary StringsUpgradeable {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\",\"keccak256\":\"0x398d3323c1932a5986bf36be7c57593e121e69d5db5b6574b4ee0d031443de37\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../StringsUpgradeable.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSAUpgradeable {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        } else if (error == RecoverError.InvalidSignatureV) {\\n            revert(\\\"ECDSA: invalid signature 'v' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        // Check the signature length\\n        // - case 65: r,s,v signature (standard)\\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else if (signature.length == 64) {\\n            bytes32 r;\\n            bytes32 vs;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                vs := mload(add(signature, 0x40))\\n            }\\n            return tryRecover(hash, r, vs);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s;\\n        uint8 v;\\n        assembly {\\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            v := add(shr(255, vs), 27)\\n        }\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \\u00f7 2 + 1, and for v in (302): v \\u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n        if (v != 27 && v != 28) {\\n            return (address(0), RecoverError.InvalidSignatureV);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", StringsUpgradeable.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\",\"keccak256\":\"0x1762ac67d230279d7fb183567ce22bbe202054ce08f94224d8794f9d19546d51\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/cryptography/draft-EIP712Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/draft-EIP712.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ECDSAUpgradeable.sol\\\";\\nimport \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\\n *\\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\\n *\\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\\n * ({_hashTypedDataV4}).\\n *\\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\\n * the chain id to protect against replay attacks on an eventual fork of the chain.\\n *\\n * NOTE: This contract implements the version of the encoding known as \\\"v4\\\", as implemented by the JSON RPC method\\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\\n *\\n * _Available since v3.4._\\n */\\nabstract contract EIP712Upgradeable is Initializable {\\n    /* solhint-disable var-name-mixedcase */\\n    bytes32 private _HASHED_NAME;\\n    bytes32 private _HASHED_VERSION;\\n    bytes32 private constant _TYPE_HASH = keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\");\\n\\n    /* solhint-enable var-name-mixedcase */\\n\\n    /**\\n     * @dev Initializes the domain separator and parameter caches.\\n     *\\n     * The meaning of `name` and `version` is specified in\\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\\n     *\\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\\n     * - `version`: the current major version of the signing domain.\\n     *\\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\\n     * contract upgrade].\\n     */\\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\\n        __EIP712_init_unchained(name, version);\\n    }\\n\\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\\n        bytes32 hashedName = keccak256(bytes(name));\\n        bytes32 hashedVersion = keccak256(bytes(version));\\n        _HASHED_NAME = hashedName;\\n        _HASHED_VERSION = hashedVersion;\\n    }\\n\\n    /**\\n     * @dev Returns the domain separator for the current chain.\\n     */\\n    function _domainSeparatorV4() internal view returns (bytes32) {\\n        return _buildDomainSeparator(_TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash());\\n    }\\n\\n    function _buildDomainSeparator(\\n        bytes32 typeHash,\\n        bytes32 nameHash,\\n        bytes32 versionHash\\n    ) private view returns (bytes32) {\\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\\n    }\\n\\n    /**\\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\\n     * function returns the hash of the fully encoded EIP712 message for this domain.\\n     *\\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\\n     *\\n     * ```solidity\\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\\n     *     keccak256(\\\"Mail(address to,string contents)\\\"),\\n     *     mailTo,\\n     *     keccak256(bytes(mailContents))\\n     * )));\\n     * address signer = ECDSA.recover(digest, signature);\\n     * ```\\n     */\\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\\n        return ECDSAUpgradeable.toTypedDataHash(_domainSeparatorV4(), structHash);\\n    }\\n\\n    /**\\n     * @dev The hash of the name parameter for the EIP712 domain.\\n     *\\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\\n     * are a concern.\\n     */\\n    function _EIP712NameHash() internal virtual view returns (bytes32) {\\n        return _HASHED_NAME;\\n    }\\n\\n    /**\\n     * @dev The hash of the version parameter for the EIP712 domain.\\n     *\\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\\n     * are a concern.\\n     */\\n    function _EIP712VersionHash() internal virtual view returns (bytes32) {\\n        return _HASHED_VERSION;\\n    }\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0x92e61d8dd5ba90b513769c06da820e0a8f5d93810a9c6d5207308af345815011\",\"license\":\"MIT\"},\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0x24e0364e503a9bbde94c715d26573a76f14cd2a202d45f96f52134ab806b67b9\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/Clones.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/Clones.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\\n * deploying minimal proxy contracts, also known as \\\"clones\\\".\\n *\\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\\n *\\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\\n * deterministic method.\\n *\\n * _Available since v3.4._\\n */\\nlibrary Clones {\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     */\\n    function clone(address implementation) internal returns (address instance) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            instance := create(0, ptr, 0x37)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create failed\\\");\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            instance := create2(0, ptr, 0x37, salt)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create2 failed\\\");\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\\n            mstore(add(ptr, 0x4c), salt)\\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\\n            predicted := keccak256(add(ptr, 0x37), 0x55)\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(address implementation, bytes32 salt)\\n        internal\\n        view\\n        returns (address predicted)\\n    {\\n        return predictDeterministicAddress(implementation, salt, address(this));\\n    }\\n}\\n\",\"keccak256\":\"0x1cc0efb01cbf008b768fd7b334786a6e358809198bb7e67f1c530af4957c6a21\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xe2e337e6dde9ef6b680e07338c493ebea1b5fd09b43424112868e9cc1706bca7\",\"license\":\"MIT\"},\"contracts/bonding_curves/AbstractShares.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"../utils/InitializableAccessControl.sol\\\";\\nimport \\\"./TradeableShares.sol\\\";\\nimport \\\"./SharesFactory.sol\\\";\\nimport \\\"./SharesSubjectLib.sol\\\";\\nimport \\\"./FriendTechBondingCurve.sol\\\";\\n\\n/**\\n * @title Abstract Shares\\n *\\n * @notice Contains the logic which is currently common for the ETHShares\\n *      and ERC20Shares TradeableShares implementations.\\n *      Once these contracts diverge enough in their logic, this abstract contract\\n *      may cease to exist.\\n *\\n * @dev Based on the friend.tech FriendtechSharesV1.sol\\n */\\nabstract contract AbstractShares is TradeableShares, FriendTechBondingCurve, InitializableAccessControl {\\n\\t/// @dev Shares subject is an NFT; NFT owner receives the subject fee\\n\\tSharesSubject private sharesSubject;\\n\\t/// @dev Protocol fee destination is an address collecting the protocol fee\\n\\taddress private protocolFeeDestination;\\n\\t/// @dev Protocol fee percent, immutable; maximum value: 10^18 (< 2^60)\\n\\tuint64 private /*immutable*/ protocolFeePercent;\\n\\t/// @dev Holders rewards fee destination is a contract collecting the holders fee, immutable\\n\\tHoldersRewardsDistributor private /*immutable*/ holdersFeeDestination;\\n\\t/// @dev Holders rewards fee percent, immutable\\n\\tuint64 private /*immutable*/ holdersFeePercent;\\n\\t/// @dev Subject fee percent, immutable\\n\\tuint64 private /*immutable*/ subjectFeePercent;\\n\\n\\t/// @dev Total shares supply, sum of all the individual balances in `sharesBalances`\\n\\tuint256 internal sharesSupply;\\n\\t/// @dev Individual shares balances: Holder => Balance\\n\\tmapping(address => uint256) internal sharesBalances;\\n\\n\\t/// @dev Cumulative value of all trades, allows to derive cumulative fees paid\\n\\tuint256 private tradeVolume;\\n\\n\\t/**\\n\\t * @dev Fired in `updateSharesSubject`\\n\\t *\\n\\t * @param oldSubject old shares subject\\n\\t * @param newSubject new shares subject\\n\\t * @param factory the factory contract notified about the update\\n\\t */\\n\\tevent SharesSubjectUpdated(SharesSubject oldSubject, SharesSubject newSubject, SharesFactory factory);\\n\\n\\t/**\\n\\t * @dev Fired in `updateProtocolFeeDestination`\\n\\t *\\n\\t * @param oldProtocolFeeDestination old protocol fee destination\\n\\t * @param newProtocolFeeDestination new protocol fee destination\\n\\t */\\n\\tevent ProtocolFeeDestinationUpdated(address oldProtocolFeeDestination, address newProtocolFeeDestination);\\n\\n\\t/**\\n\\t * @dev Fire in `disableHoldersFee` no more than once\\n\\t *      for the entire lifespan of the contract\\n\\t *\\n\\t * @param oldProtocolFeePercent old protocol fee percent\\n\\t * @param newProtocolFeePercent new protocol fee percent, new >= old\\n\\t */\\n\\tevent HoldersFeeDisabled(uint256 oldProtocolFeePercent, uint256 newProtocolFeePercent);\\n\\n\\t/**\\n\\t * @notice Protocol fee destination manager is responsible for updating the address collecting the\\n\\t *      protocol fee destination, that is `protocolFeeDestination`; the manager cannot update the fee percent\\n\\t *\\n\\t * @dev This role should be granted to the MultiSig, not to EOA and not to\\n\\t *      RBAC managed smart contract, so that this functionality is not scalable;\\n\\t *      this reduces the risk of misuse, and/or malicious use\\n\\t *\\n\\t * @dev Role ROLE_PROTOCOL_FEE_MANAGER is required to execute `updateProtocolFeeDestination` function\\n\\t */\\n\\tuint32 public constant ROLE_PROTOCOL_FEE_MANAGER = 0x0001_0000;\\n\\n\\t/**\\n\\t * @notice Holders fee [disable] manager can disable the shares holders fee functionality;\\n\\t *      the manager cannot enable it back\\n\\t *\\n\\t * @dev This role should be granted to the MultiSig, not to EOA and not to\\n\\t *      RBAC managed smart contract, so that this functionality is not scalable;\\n\\t *      this reduces the risk of misuse, and/or malicious use\\n\\t *\\n\\t * @dev Role ROLE_HOLDERS_FEE_MANAGER is required to execute `disableHoldersFee` function\\n\\t */\\n\\tuint32 public constant ROLE_HOLDERS_FEE_MANAGER = 0x0002_0000;\\n\\n\\t/**\\n\\t * @notice Shares subject manager is responsible for updating the \\\"shares subject\\\"\\n\\t *      in case of emergency, for example if underlying NFT was stolen\\n\\t *\\n\\t * @dev This role should be granted to the MultiSig, not to EOA and not to\\n\\t *      RBAC managed smart contract, so that this functionality is not scalable;\\n\\t *      this reduces the risk of misuse, and/or malicious use\\n\\t *\\n\\t * @dev Role ROLE_SHARES_SUBJECT_MANAGER is required to execute `updateSharesSubject` function\\n\\t */\\n\\tuint32 public constant ROLE_SHARES_SUBJECT_MANAGER = 0x0008_0000;\\n\\n\\t/**\\n\\t * @dev \\\"Constructor replacement\\\" for initializable, must be execute during or immediately after deployment\\n\\t *      see https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#initializers\\n\\t *\\n\\t * @param _owner the address receiving all the RBAC permissions on the contract\\n\\t * @param _sharesSubject shares subject, usually defined as NFT (ERC721 contract address + NFT ID)\\n\\t * @param _protocolFeeDestination protocol fee destination, the address protocol fee is sent to\\n\\t * @param _protocolFeePercent protocol fee percent, applied to all the buy and sell operations;\\n\\t *      the fee percent is defined with the 18 decimals, 10^18 corresponds to 100%\\n\\t * @param _holdersFeeDestination shares holders fee destination, the HoldersRewardsDistributor contract\\n\\t *      the shares holders fee is sent to\\n\\t * @param _holdersFeePercent shares holders fee percent, applied to all the buy and sell operations,\\n\\t *      the fee percent is defined with the 18 decimals, 10^18 corresponds to 100%\\n\\t * @param _subjectFeePercent subject fee percent, applied to all the buy and sell operations,\\n\\t *      the fee percent is defined with the 18 decimals, 10^18 corresponds to 100%\\n\\t */\\n\\tfunction _postConstruct(\\n\\t\\taddress _owner,\\n\\t\\tSharesSubject memory _sharesSubject,\\n\\t\\taddress _protocolFeeDestination,\\n\\t\\tuint64 _protocolFeePercent,\\n\\t\\tHoldersRewardsDistributor _holdersFeeDestination,\\n\\t\\tuint64 _holdersFeePercent,\\n\\t\\tuint64 _subjectFeePercent\\n\\t) internal onlyInitializing {\\n\\t\\t// execute parent initializer\\n\\t\\t_postConstruct(_owner);\\n\\t\\t// this initializer is called only from the factory, we do not verify the\\n\\t\\t// validity of the inputs generated by the factory itself\\n\\t\\t// if the factory goes buggy/malicious after the upgrade, all the\\n\\t\\t// shares contracts deployed after should be considered invalid\\n\\t\\tsharesSubject = _sharesSubject;\\n\\t\\tprotocolFeeDestination = _protocolFeeDestination;\\n\\t\\tprotocolFeePercent = _protocolFeePercent;\\n\\t\\tholdersFeeDestination = _holdersFeeDestination;\\n\\t\\tholdersFeePercent = _holdersFeePercent;\\n\\t\\tsubjectFeePercent = _subjectFeePercent;\\n\\t}\\n\\n\\t/**\\n\\t * @inheritdoc TradeableShares\\n\\t */\\n\\tfunction getSharesSubject() public view returns(SharesSubject memory) {\\n\\t\\t// read value from the storage\\n\\t\\treturn sharesSubject;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Updates the shares subject\\n\\t *\\n\\t * @dev This is a restricted access function which should be accessible only from the\\n\\t *      MultiSig wallet controlling the protocol, so that its usage is not scalable\\n\\t *\\n\\t * @param _sharesSubject new subject to set\\n\\t */\\n\\tfunction updateSharesSubject(SharesSubject calldata _sharesSubject) public {\\n\\t\\t// delegate to `updateSharesSubject` with the zero factory\\n\\t\\tupdateSharesSubject(_sharesSubject, SharesFactory(address(0)));\\n\\t}\\n\\n\\t/**\\n\\t * @notice Updates the shares subject and optionally notifies the factory about the update;\\n\\t *      update fails if the factory notification fails\\n\\t *\\n\\t * @dev This is a restricted access function which should be accessible only from the\\n\\t *      MultiSig wallet controlling the protocol, so that its usage is not scalable\\n\\t *\\n\\t * @param _sharesSubject new subject to set\\n\\t * @param _factory shares factory contract to notify about the update, optional\\n\\t *      if set to zero, the notification is not done\\n\\t */\\n\\tfunction updateSharesSubject(SharesSubject calldata _sharesSubject, SharesFactory _factory) public {\\n\\t\\t// verify the access permission\\n\\t\\trequire(isSenderInRole(ROLE_SHARES_SUBJECT_MANAGER), \\\"access denied\\\");\\n\\n\\t\\t// emit an event first - to log both old and new values\\n\\t\\temit SharesSubjectUpdated(sharesSubject, _sharesSubject, _factory);\\n\\n\\t\\t// update contract's state\\n\\t\\tsharesSubject = _sharesSubject;\\n\\n\\t\\t// if factory is set (factory notification requested)\\n\\t\\tif(address(_factory) != address(0)) {\\n\\t\\t\\t// notify factory contract\\n\\t\\t\\t_factory.notifySubjectUpdated();\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * @inheritdoc TradeableShares\\n\\t */\\n\\tfunction getProtocolFeeDestination() public view returns(address) {\\n\\t\\t// read the value from storage\\n\\t\\treturn protocolFeeDestination;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Updates the protocol fee destination address `protocolFeeDestination`\\n\\t *\\n\\t * @dev This is a restricted access function which should be accessible only from the\\n\\t *      MultiSig wallet controlling the protocol, so that its usage is not scalable\\n\\t *\\n\\t * @param _protocolFeeDestination new protocol fee destination address to set\\n\\t */\\n\\tfunction updateProtocolFeeDestination(address _protocolFeeDestination) public {\\n\\t\\t// verify the access permission\\n\\t\\trequire(isSenderInRole(ROLE_PROTOCOL_FEE_MANAGER), \\\"access denied\\\");\\n\\n\\t\\t// emit an event first - to log both old and new values\\n\\t\\temit ProtocolFeeDestinationUpdated(protocolFeeDestination, _protocolFeeDestination);\\n\\n\\t\\t// update contract's state\\n\\t\\tprotocolFeeDestination = _protocolFeeDestination;\\n\\t}\\n\\n\\t/**\\n\\t * @inheritdoc TradeableShares\\n\\t */\\n\\tfunction getProtocolFeePercent() public view returns(uint256) {\\n\\t\\t// read the value from storage (immutable)\\n\\t\\treturn protocolFeePercent;\\n\\t}\\n\\n\\t/**\\n\\t * @inheritdoc TradeableShares\\n\\t */\\n\\tfunction getProtocolFeeInfo() public view returns(address feeDestination, uint256 feePercent) {\\n\\t\\t// read fee destination first\\n\\t\\tfeeDestination = getProtocolFeeDestination();\\n\\t\\t// if it's zero, zero down the fee as well\\n\\t\\tfeePercent = feeDestination == address(0)? 0: getProtocolFeePercent();\\n\\t}\\n\\n\\t/**\\n\\t * @inheritdoc TradeableShares\\n\\t */\\n\\tfunction getHoldersFeeDestination() public view returns(HoldersRewardsDistributor) {\\n\\t\\t// read the value from storage (immutable)\\n\\t\\treturn holdersFeeDestination;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Disables shares holders fee functionality; detaches shares contract from\\n\\t *      the HoldersRewardsDistributor, stops sending fees, stops sending syncs\\n\\t *\\n\\t * @notice Increases the protocol fee by the value of the disabled shares holders fee,\\n\\t *      so that the sum of all the fees remains the same\\n\\t *\\n\\t * @notice Once disabled, the holders fee functionality cannot be enabled back\\n\\t */\\n\\tfunction disableHoldersFee() public {\\n\\t\\t// verify the access permission\\n\\t\\trequire(isSenderInRole(ROLE_HOLDERS_FEE_MANAGER), \\\"access denied\\\");\\n\\n\\t\\t// verify the holders functionality is enabled\\n\\t\\trequire(address(holdersFeeDestination) != address(0) || holdersFeePercent != 0, \\\"not enabled\\\");\\n\\n\\t\\t// emit an event first - to log both old and new values\\n\\t\\temit HoldersFeeDisabled(protocolFeePercent, protocolFeePercent + holdersFeePercent);\\n\\n\\t\\t// shares holders fee goes to the protocol from now on\\n\\t\\tprotocolFeePercent += holdersFeePercent;\\n\\n\\t\\t// zero the shares holders fee\\n\\t\\tholdersFeeDestination = HoldersRewardsDistributor(address(0));\\n\\t\\tholdersFeePercent = 0;\\n\\t}\\n\\n\\t/**\\n\\t * @inheritdoc TradeableShares\\n\\t */\\n\\tfunction getHoldersFeePercent() public view returns(uint256) {\\n\\t\\t// read the value from storage (immutable)\\n\\t\\treturn holdersFeePercent;\\n\\t}\\n\\n\\t/**\\n\\t * @inheritdoc TradeableShares\\n\\t */\\n\\tfunction getHoldersFeeInfo() public view returns(HoldersRewardsDistributor feeDestination, uint256 feePercent) {\\n\\t\\t// read fee destination first\\n\\t\\tfeeDestination = getHoldersFeeDestination();\\n\\t\\t// if it's zero, zero down the fee as well\\n\\t\\tfeePercent = address(feeDestination) == address(0)? 0: getHoldersFeePercent();\\n\\t}\\n\\n\\t/**\\n\\t * @inheritdoc TradeableShares\\n\\t */\\n\\tfunction getSubjectFeeInfo() public view returns(address feeDestination, uint256 feePercent) {\\n\\t\\t// read fee destination first\\n\\t\\tfeeDestination = getSharesIssuer();\\n\\t\\t// if it's zero, zero down the fee as well\\n\\t\\tfeePercent = feeDestination == address(0)? 0: getSubjectFeePercent();\\n\\t}\\n\\n\\t/**\\n\\t * @inheritdoc TradeableShares\\n\\t */\\n\\tfunction getSubjectFeePercent() public view returns(uint256) {\\n\\t\\t// read the value from storage (immutable)\\n\\t\\treturn subjectFeePercent;\\n\\t}\\n\\n\\t/**\\n\\t * @inheritdoc TradeableShares\\n\\t */\\n\\tfunction getSharesIssuer() public view returns(address nftOwner) {\\n\\t\\t// derive the NFT owner defined by the subject\\n\\t\\treturn SharesSubjectLib.getSharesIssuer(sharesSubject);\\n\\t}\\n\\n\\t/**\\n\\t * @inheritdoc TradeableShares\\n\\t */\\n\\tfunction getSharesBalance(address _holder) public view returns(uint256 balance) {\\n\\t\\t// read the value from storage\\n\\t\\treturn sharesBalances[_holder];\\n\\t}\\n\\n\\t/**\\n\\t * @inheritdoc TradeableShares\\n\\t */\\n\\tfunction getSharesSupply() public view returns(uint256 supply) {\\n\\t\\t// read the value from storage\\n\\t\\treturn sharesSupply;\\n\\t}\\n\\n\\t/**\\n\\t * @inheritdoc TradeableShares\\n\\t */\\n\\tfunction getBuyPrice(uint256 _supply, uint256 _amount) public pure returns(uint256) {\\n\\t\\t// this is the original friend tech formula\\n\\t\\treturn getPrice(_supply, _amount);\\n\\t}\\n\\n\\t/**\\n\\t * @inheritdoc TradeableShares\\n\\t */\\n\\tfunction getSellPrice(uint256 _supply, uint256 _amount) public pure returns(uint256) {\\n\\t\\t// this is the original friend tech formula\\n\\t\\treturn getPrice(_supply - _amount, _amount);\\n\\t}\\n\\n\\t/**\\n\\t * @inheritdoc TradeableShares\\n\\t */\\n\\tfunction getBuyPriceAfterFee(\\n\\t\\tuint256 _supply,\\n\\t\\tuint256 _amount,\\n\\t\\tuint256 _protocolFeePercent,\\n\\t\\tuint256 _holdersFeePercent,\\n\\t\\tuint256 _subjectFeePercent\\n\\t) public pure returns(uint256) {\\n\\t\\t// this is the original friend tech formula\\n\\t\\tuint256 price = getBuyPrice(_supply, _amount);\\n\\t\\tuint256 protocolFee = price * _protocolFeePercent / 1 ether;\\n\\t\\tuint256 holdersFee = price * _holdersFeePercent / 1 ether;\\n\\t\\tuint256 subjectFee = price * _subjectFeePercent / 1 ether;\\n\\t\\treturn price + protocolFee + holdersFee + subjectFee;\\n\\t}\\n\\n\\t/**\\n\\t * @inheritdoc TradeableShares\\n\\t */\\n\\tfunction getSellPriceAfterFee(\\n\\t\\tuint256 _supply,\\n\\t\\tuint256 _amount,\\n\\t\\tuint256 _protocolFeePercent,\\n\\t\\tuint256 _holdersFeePercent,\\n\\t\\tuint256 _subjectFeePercent\\n\\t) public pure returns(uint256) {\\n\\t\\t// this is the original friend tech formula\\n\\t\\tuint256 price = getSellPrice(_supply, _amount);\\n\\t\\tuint256 protocolFee = price * _protocolFeePercent / 1 ether;\\n\\t\\tuint256 holdersFee = price * _holdersFeePercent / 1 ether;\\n\\t\\tuint256 subjectFee = price * _subjectFeePercent / 1 ether;\\n\\t\\treturn price - protocolFee - holdersFee - subjectFee;\\n\\t}\\n\\n\\t/**\\n\\t * @inheritdoc TradeableShares\\n\\t */\\n\\tfunction getBuyPrice(uint256 _amount) public view returns(uint256) {\\n\\t\\t// delegate to `getBuyPrice`\\n\\t\\treturn getBuyPrice(getSharesSupply(), _amount);\\n\\t}\\n\\n\\t/**\\n\\t * @inheritdoc TradeableShares\\n\\t */\\n\\tfunction getSellPrice(uint256 _amount) public view returns(uint256) {\\n\\t\\t// delegate to `getSellPrice`\\n\\t\\treturn getSellPrice(getSharesSupply(), _amount);\\n\\t}\\n\\n\\t/**\\n\\t * @inheritdoc TradeableShares\\n\\t */\\n\\tfunction getBuyPriceAfterFee(uint256 _amount) public view returns(uint256) {\\n\\t\\t// read the effective fees values\\n\\t\\t(, uint256 _protocolFeePercent) = getProtocolFeeInfo();\\n\\t\\t(, uint256 _holdersFeePercent) = getHoldersFeeInfo();\\n\\t\\t(, uint256 _subjectFeePercent) = getSubjectFeeInfo();\\n\\n\\t\\t// delegate to `getBuyPriceAfterFee`\\n\\t\\treturn getBuyPriceAfterFee(getSharesSupply(), _amount, _protocolFeePercent, _holdersFeePercent, _subjectFeePercent);\\n\\t}\\n\\n\\t/**\\n\\t * @inheritdoc TradeableShares\\n\\t */\\n\\tfunction getSellPriceAfterFee(uint256 _amount) public view returns(uint256) {\\n\\t\\t// read the effective fees values\\n\\t\\t(, uint256 _protocolFeePercent) = getProtocolFeeInfo();\\n\\t\\t(, uint256 _holdersFeePercent) = getHoldersFeeInfo();\\n\\t\\t(, uint256 _subjectFeePercent) = getSubjectFeeInfo();\\n\\n\\t\\t// delegate to `getSellPriceAfterFee`\\n\\t\\treturn getSellPriceAfterFee(getSharesSupply(), _amount, _protocolFeePercent, _holdersFeePercent, _subjectFeePercent);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Executed internally on every trade (buy/sell) to track the trading volume\\n\\t *\\n\\t * @param value trading operation value, the price of the buy/sell operation without the fees\\n\\t */\\n\\tfunction __increaseTradeVolume(uint256 value) internal {\\n\\t\\t// update the value in the storage\\n\\t\\ttradeVolume += value;\\n\\t}\\n\\n\\t/**\\n\\t * @inheritdoc TradeableShares\\n\\t */\\n\\tfunction getTradeVolume() public view returns(uint256) {\\n\\t\\t// read the value from the storage\\n\\t\\treturn tradeVolume;\\n\\t}\\n}\\n\",\"keccak256\":\"0x0a86cdc032cd74c8930b64b046b175af9ec691c1f465188b73bc1799a532c393\",\"license\":\"MIT\"},\"contracts/bonding_curves/BondingCurve.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/**\\n * @title Bonding Curve\\n *\\n * @notice A friend.tech-like bonding curve definition\\n *\\n * @notice Bonding curve defines the price of the smallest unit of the asset as a function\\n *      of the asset supply\\n */\\ninterface BondingCurve {\\n\\t/**\\n\\t * @notice Bonding curve function definition. The function calculating the price\\n\\t *      of the `amount` of shares given the current total supply `supply`\\n\\t *\\n\\t * @param supply total shares supply\\n\\t * @param amount number of shares to buy/sell\\n\\t * @return the price of the shares (all `amount` amount)\\n\\t */\\n\\tfunction getPrice(uint256 supply, uint256 amount) external pure returns(uint256);\\n}\\n\",\"keccak256\":\"0x5c8602275460cf842e4804ce37f8b847857b32414cd535736857bced13c2cbe2\",\"license\":\"MIT\"},\"contracts/bonding_curves/ERC20Shares.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"../interfaces/ERC1363Spec.sol\\\";\\nimport \\\"./AbstractShares.sol\\\";\\n\\n/**\\n * @title ERC20 Shares\\n *\\n * @notice TradeableShares implementation using ERC20 token as a payment token\\n *\\n * @dev Doesn't have \\\"payable\\\" functions, that is the functions accepting ETH\\n *\\n * @dev Based on the friend.tech FriendtechSharesV1.sol\\n */\\ncontract ERC20Shares is AbstractShares {\\n\\t/// @dev ERC1363 payment token used for payments\\n\\tERC1363 private /*immutable*/ paymentToken;\\n\\n\\t/**\\n\\t * @dev Deploys the ERC20Shares instance and initializes it\\n\\t *\\n\\t * @param _owner the address receiving all the RBAC permissions on the contract\\n\\t * @param _sharesSubject shares subject, usually defined as NFT (ERC721 contract address + NFT ID)\\n\\t * @param _protocolFeeDestination protocol fee destination, the address protocol fee is sent to\\n\\t * @param _protocolFeePercent protocol fee percent, applied to all the buy and sell operations;\\n\\t *      the fee percent is defined with the 18 decimals, 10^18 corresponds to 100%\\n\\t * @param _holdersFeeDestination shares holders fee destination, the HoldersRewardsDistributor contract\\n\\t *      the shares holders fee is sent to\\n\\t * @param _holdersFeePercent shares holders fee percent, applied to all the buy and sell operations,\\n\\t *      the fee percent is defined with the 18 decimals, 10^18 corresponds to 100%\\n\\t * @param _subjectFeePercent subject fee percent, applied to all the buy and sell operations,\\n\\t *      the fee percent is defined with the 18 decimals, 10^18 corresponds to 100%\\n\\t * @param _amount how many shares to buy immediately upon \\\"post-construction\\\", can be zero\\n\\t * @param _beneficiary the address receiving the shares bought immediately (must be set\\n\\t *      if `_amount` is not zero)\\n\\t * @param _paymentToken ERC1363 token used as a payment token instead of ETH\\n\\t */\\n\\tconstructor(\\n\\t\\taddress _owner,\\n\\t\\tSharesSubject memory _sharesSubject,\\n\\t\\taddress _protocolFeeDestination,\\n\\t\\tuint64 _protocolFeePercent,\\n\\t\\tHoldersRewardsDistributor _holdersFeeDestination,\\n\\t\\tuint64 _holdersFeePercent,\\n\\t\\tuint64 _subjectFeePercent,\\n\\t\\tuint256 _amount,\\n\\t\\taddress _beneficiary,\\n\\t\\tERC1363 _paymentToken\\n\\t) initializer {\\n\\t\\t// initialize the deployed instance\\n\\t\\tpostConstruct(\\n\\t\\t\\t_owner,\\n\\t\\t\\t_sharesSubject,\\n\\t\\t\\t_protocolFeeDestination,\\n\\t\\t\\t_protocolFeePercent,\\n\\t\\t\\t_holdersFeeDestination,\\n\\t\\t\\t_holdersFeePercent,\\n\\t\\t\\t_subjectFeePercent,\\n\\t\\t\\t_amount,\\n\\t\\t\\t_beneficiary,\\n\\t\\t\\t_paymentToken\\n\\t\\t);\\n\\t}\\n\\n\\t/**\\n\\t * @dev \\\"Constructor replacement\\\" for initializable, must be execute during or immediately after deployment\\n\\t *      see https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#initializers\\n\\t *\\n\\t * @param _owner the address receiving all the RBAC permissions on the contract\\n\\t * @param _sharesSubject shares subject, usually defined as NFT (ERC721 contract address + NFT ID)\\n\\t * @param _protocolFeeDestination protocol fee destination, the address protocol fee is sent to\\n\\t * @param _protocolFeePercent protocol fee percent, applied to all the buy and sell operations;\\n\\t *      the fee percent is defined with the 18 decimals, 10^18 corresponds to 100%\\n\\t * @param _holdersFeeDestination shares holders fee destination, the HoldersRewardsDistributor contract\\n\\t *      the shares holders fee is sent to\\n\\t * @param _holdersFeePercent shares holders fee percent, applied to all the buy and sell operations,\\n\\t *      the fee percent is defined with the 18 decimals, 10^18 corresponds to 100%\\n\\t * @param _subjectFeePercent subject fee percent, applied to all the buy and sell operations,\\n\\t *      the fee percent is defined with the 18 decimals, 10^18 corresponds to 100%\\n\\t * @param _amount how many shares to buy immediately upon \\\"post-construction\\\", can be zero\\n\\t * @param _beneficiary the address receiving the shares bought immediately (must be set\\n\\t *      if `_amount` is not zero)\\n\\t * @param _paymentToken ERC20 token used as a payment token instead of ETH\\n\\t */\\n\\tfunction postConstruct(\\n\\t\\taddress _owner,\\n\\t\\tSharesSubject memory _sharesSubject,\\n\\t\\taddress _protocolFeeDestination,\\n\\t\\tuint64 _protocolFeePercent,\\n\\t\\tHoldersRewardsDistributor _holdersFeeDestination,\\n\\t\\tuint64 _holdersFeePercent,\\n\\t\\tuint64 _subjectFeePercent,\\n\\t\\tuint256 _amount,\\n\\t\\taddress _beneficiary,\\n\\t\\tERC1363 _paymentToken\\n\\t) public initializer {\\n\\t\\t// execute parent initializer\\n\\t\\t_postConstruct(\\n\\t\\t\\t_owner,\\n\\t\\t\\t_sharesSubject,\\n\\t\\t\\t_protocolFeeDestination,\\n\\t\\t\\t_protocolFeePercent,\\n\\t\\t\\t_holdersFeeDestination,\\n\\t\\t\\t_holdersFeePercent,\\n\\t\\t\\t_subjectFeePercent\\n\\t\\t);\\n\\t\\t// no need to check if payment token is zero since this is designed to be\\n\\t\\t// deployed only from the factory where the ERC20 address in non-modifiable\\n\\t\\t// and is defined on the deployment of the factory\\n\\t\\tpaymentToken = _paymentToken;\\n\\n\\t\\t// buy shares if requested\\n\\t\\tif(_amount != 0) {\\n\\t\\t\\t__buySharesTo(_amount, _beneficiary);\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * @notice ERC1363 payment token getter\\n\\t *\\n\\t * @return ERC1363 payment token, immutable\\n\\t */\\n\\tfunction getPaymentToken() public view returns(ERC1363) {\\n\\t\\t// read from the storage and return\\n\\t\\treturn paymentToken;\\n\\t}\\n\\n\\t/**\\n\\t * @inheritdoc BondingCurve\\n\\t *\\n\\t * @notice Shifts the curve by multiplying the result by 10^5\\n\\t */\\n\\tfunction getPrice(uint256 supply, uint256 amount) public pure override(BondingCurve, FriendTechBondingCurve) returns(uint256) {\\n\\t\\t// shift the curve by 10^5\\n\\t\\treturn 10**5 * super.getPrice(supply, amount);\\n\\t}\\n\\n\\t/**\\n\\t * @inheritdoc TradeableShares\\n\\t */\\n\\tfunction buyShares(uint256 amount) public payable {\\n\\t\\t// delegate to `buySharesTo`\\n\\t\\tbuySharesTo(amount, msg.sender);\\n\\t}\\n\\n\\t/**\\n\\t * @inheritdoc TradeableShares\\n\\t */\\n\\tfunction sellShares(uint256 amount) public {\\n\\t\\t// delegate to `sellSharesTo`\\n\\t\\tsellSharesTo(amount, payable(msg.sender));\\n\\t}\\n\\n\\t/**\\n\\t * @inheritdoc TradeableShares\\n\\t */\\n\\tfunction buySharesTo(uint256 amount, address beneficiary) public payable {\\n\\t\\t// verify the first share is not bought\\n\\t\\trequire(getSharesSupply() > 0 || getSharesIssuer() == msg.sender, \\\"only the issuer can buy the first share\\\");\\n\\n\\t\\t// delegate to unsafe `__buySharesTo`\\n\\t\\t__buySharesTo(amount, beneficiary);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Buys amount of shares for the beneficiary, without checking if the first share was bought\\n\\t *\\n\\t * @param amount amount of the shares to buy\\n\\t * @param beneficiary an address receiving the shares\\n\\t */\\n\\tfunction __buySharesTo(uint256 amount, address beneficiary) private {\\n\\t\\t// ERC20 implementation doesn't expect Ether to be sent\\n\\t\\trequire(msg.value == 0, \\\"only payment in ERC20 token is expected\\\");\\n\\n\\t\\t// cache the supply value\\n\\t\\tuint256 supply = getSharesSupply();\\n\\n\\t\\t// update the balances (note: security checks are below)\\n\\t\\tsharesBalances[beneficiary] += amount;\\n\\t\\tsharesSupply = supply + amount;\\n\\n\\t\\t// determine the price and process the fees\\n\\t\\tuint256 price = getPrice(supply, amount);\\n\\t\\t(, , uint256 protocolFee) = __processProtocolFee(msg.sender, price);\\n\\t\\t(, , uint256 holdersFee) = __processHoldersFeeAndNotify(msg.sender, price, true, amount, beneficiary);\\n\\t\\t(address issuer, , uint256 subjectFee) = __processSubjectFee(msg.sender, price);\\n\\n\\t\\t// do the required ERC20 payment token price transfer\\n\\t\\trequire(\\n\\t\\t\\t// do not try to transfer zero price\\n\\t\\t\\tprice == 0 || paymentToken.transferFrom(msg.sender, address(this), price),\\n\\t\\t\\t\\\"payment failed\\\"\\n\\t\\t);\\n\\n\\t\\t// update the cumulative trade volume\\n\\t\\t__increaseTradeVolume(price);\\n\\n\\t\\t// emit an event\\n\\t\\temit Trade(beneficiary, issuer, true, amount, price, protocolFee, holdersFee, subjectFee, sharesSupply);\\n\\t}\\n\\n\\t/**\\n\\t * @inheritdoc TradeableShares\\n\\t */\\n\\tfunction sellSharesTo(uint256 amount, address payable beneficiary) public {\\n\\t\\t// verify the amount vs total supply\\n\\t\\tuint256 supply = getSharesSupply();\\n\\t\\trequire(supply > amount, \\\"cannot sell the last share\\\");\\n\\n\\t\\t// verify the amount vs seller's balance\\n\\t\\tuint256 balance = getSharesBalance(msg.sender);\\n\\t\\trequire(balance >= amount, \\\"insufficient shares\\\");\\n\\n\\t\\t// update the balances\\n\\t\\tsharesBalances[msg.sender] = balance - amount;\\n\\t\\tsharesSupply = supply - amount;\\n\\n\\t\\t// determine the price and process the fees\\n\\t\\tuint256 price = getPrice(sharesSupply, amount);\\n\\t\\t(, , uint256 protocolFee) = __processProtocolFee(address(this), price);\\n\\t\\t(, , uint256 holdersFee) = __processHoldersFeeAndNotify(address(this), price, false, amount, msg.sender);\\n\\t\\t(address issuer, , uint256 subjectFee) = __processSubjectFee(address(this), price);\\n\\n\\t\\t// price cannot be zero since the last share cannot be sold\\n\\t\\t// if the price transfer fails, we do fail\\n\\t\\t// note: if any of the fees failed to transfer, they are sent to the seller\\n\\t\\trequire(\\n\\t\\t\\tpaymentToken.transfer(beneficiary, price - protocolFee - holdersFee - subjectFee),\\n\\t\\t\\t\\\"payment failed\\\"\\n\\t\\t);\\n\\n\\t\\t// update the cumulative trade volume\\n\\t\\t__increaseTradeVolume(price);\\n\\n\\t\\t// emit an event\\n\\t\\temit Trade(beneficiary, issuer, false, amount, price, protocolFee, holdersFee, subjectFee, sharesSupply);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Calculates the protocol fee and sends it to the protocol fee destination\\n\\t *\\n\\t * @param from the address where the tokens are being sent from, this can be either\\n\\t *      the the shares buyer, or the contract itself (when selling)\\n\\t * @param price already calculated price of the trade\\n\\t */\\n\\tfunction __processProtocolFee(address from, uint256 price) private returns(\\n\\t\\taddress protocolFeeDestination,\\n\\t\\tuint256 protocolFeePercent,\\n\\t\\tuint256 protocolFee\\n\\t) {\\n\\t\\t// read fee information in a consistent way\\n\\t\\t(protocolFeeDestination, protocolFeePercent) = getProtocolFeeInfo();\\n\\n\\t\\t// calculate the fee\\n\\t\\tprotocolFee = price * protocolFeePercent / 1 ether;\\n\\n\\t\\t// do the required ERC20 payment token transfer\\n\\t\\trequire(\\n\\t\\t\\t// do not try to transfer zero protocol fee\\n\\t\\t\\tprotocolFee == 0 || paymentToken.transferFrom(from, protocolFeeDestination, protocolFee),\\n\\t\\t\\t\\\"protocol fee payment failed\\\"\\n\\t\\t);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Calculates the shares holders fee and sends it to the holders fee destination;\\n\\t *      notifies the destination (which is a HoldersRewardsDistributor contract) about\\n\\t *      the trade, submits trader address, and trade amount\\n\\t *\\n\\t * @dev isBuy is true if the shares are bought\\n\\t *      isBuy is false if the shares are sold\\n\\t *\\n\\t * @param from the address where the tokens are being sent from, this can be either\\n\\t *      the the shares buyer, or the contract itself (when selling)\\n\\t * @param price already calculated price of the trade\\n\\t * @param isBuy operation type, [true] buying, [false] selling\\n\\t * @param amount trade amount\\n\\t * @param trader an account which makes a trade, whose shares balance changes by the `amount`\\n\\t */\\n\\tfunction __processHoldersFeeAndNotify(address from, uint256 price, bool isBuy, uint256 amount, address trader) private returns(\\n\\t\\tHoldersRewardsDistributor holdersFeeDestination,\\n\\t\\tuint256 holdersFeePercent,\\n\\t\\tuint256 holdersFee\\n\\t) {\\n\\t\\t// read fee information in a consistent way\\n\\t\\t(holdersFeeDestination, holdersFeePercent) = getHoldersFeeInfo();\\n\\n\\t\\t// calculate the fee\\n\\t\\tholdersFee = price * holdersFeePercent / 1 ether;\\n\\n\\t\\t// do the required ERC1363 payment token transfer and HoldersRewardsDistributor sync\\n\\t\\tif(address(holdersFeeDestination) != address(0) && amount != 0) {\\n\\t\\t\\t// construct the HoldersRewardsDistributor sync message\\n\\t\\t\\tbytes memory syncMessage = abi.encode(trader, isBuy, amount);\\n\\n\\t\\t\\t// send the fee together with the sync message\\n\\t\\t\\tbool success = paymentToken.transferFromAndCall(from, address(holdersFeeDestination), holdersFee, syncMessage);\\n\\n\\t\\t\\t// we require synchronization to succeed, otherwise we can't guarantee data consistency\\n\\t\\t\\t// on the HoldersRewardsDistributor contract's side\\n\\t\\t\\trequire(success, \\\"sync failed\\\");\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * @dev Calculates the subject fee and sends it to the issuer\\n\\t *\\n\\t * @param from the address where the tokens are being sent from, this can be either\\n\\t *      the the shares buyer, or the contract itself (when selling)\\n\\t * @param price already calculated price of the trade\\n\\t */\\n\\tfunction __processSubjectFee(address from, uint256 price) private returns(\\n\\t\\taddress subjectFeeDestination,\\n\\t\\tuint256 subjectFeePercent,\\n\\t\\tuint256 subjectFee\\n\\t) {\\n\\t\\t// read fee information in a consistent way\\n\\t\\t(subjectFeeDestination, subjectFeePercent) = getSubjectFeeInfo();\\n\\n\\t\\t// calculate the fee\\n\\t\\tsubjectFee = price * subjectFeePercent / 1 ether;\\n\\n\\t\\t// do the required ERC20 payment token transfer\\n\\t\\trequire(\\n\\t\\t\\t// do not try to transfer zero subject fee\\n\\t\\t\\tsubjectFee == 0 || paymentToken.transferFrom(from, subjectFeeDestination, subjectFee),\\n\\t\\t\\t\\\"subject fee payment failed\\\"\\n\\t\\t);\\n\\t}\\n}\\n\",\"keccak256\":\"0xc576e29234d2ed5dbd5a5933df545bbfa3c7a8c330e6e71c80ac8f56933912ad\",\"license\":\"MIT\"},\"contracts/bonding_curves/ETHShares.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"../utils/Transfers.sol\\\";\\nimport \\\"./AbstractShares.sol\\\";\\n\\n/**\\n * @title ETH Shares\\n *\\n * @notice TradeableShares implementation using native ETH for payments\\n *\\n * @dev Based on the friend.tech FriendtechSharesV1.sol\\n */\\ncontract ETHShares is AbstractShares {\\n\\t/// @dev Overrides standard send and transfer Solidity functions\\n\\tusing Transfers for address payable;\\n\\n\\t/**\\n\\t * @dev Deploys the ETHShares instance and initializes it\\n\\t *\\n\\t * @param _owner the address receiving all the RBAC permissions on the contract\\n\\t * @param _sharesSubject shares subject, usually defined as NFT (ERC721 contract address + NFT ID)\\n\\t * @param _protocolFeeDestination protocol fee destination, the address protocol fee is sent to\\n\\t * @param _protocolFeePercent protocol fee percent, applied to all the buy and sell operations;\\n\\t *      the fee percent is defined with the 18 decimals, 10^18 corresponds to 100%\\n\\t * @param _holdersFeeDestination shares holders fee destination, the HoldersRewardsDistributor contract\\n\\t *      the shares holders fee is sent to\\n\\t * @param _holdersFeePercent shares holders fee percent, applied to all the buy and sell operations,\\n\\t *      the fee percent is defined with the 18 decimals, 10^18 corresponds to 100%\\n\\t * @param _subjectFeePercent subject fee percent, applied to all the buy and sell operations,\\n\\t *      the fee percent is defined with the 18 decimals, 10^18 corresponds to 100%\\n\\t * @param _amount how many shares to buy immediately upon \\\"post-construction\\\", can be zero\\n\\t * @param _beneficiary the address receiving the shares bought immediately (must be set\\n\\t *      if `_amount` is not zero)\\n\\t */\\n\\tconstructor(\\n\\t\\taddress _owner,\\n\\t\\tSharesSubject memory _sharesSubject,\\n\\t\\taddress _protocolFeeDestination,\\n\\t\\tuint64 _protocolFeePercent,\\n\\t\\tHoldersRewardsDistributor _holdersFeeDestination,\\n\\t\\tuint64 _holdersFeePercent,\\n\\t\\tuint64 _subjectFeePercent,\\n\\t\\tuint256 _amount,\\n\\t\\taddress _beneficiary\\n\\t) payable initializer {\\n\\t\\t// initialize the deployed instance\\n\\t\\tpostConstruct(\\n\\t\\t\\t_owner,\\n\\t\\t\\t_sharesSubject,\\n\\t\\t\\t_protocolFeeDestination,\\n\\t\\t\\t_protocolFeePercent,\\n\\t\\t\\t_holdersFeeDestination,\\n\\t\\t\\t_holdersFeePercent,\\n\\t\\t\\t_subjectFeePercent,\\n\\t\\t\\t_amount,\\n\\t\\t\\t_beneficiary\\n\\t\\t);\\n\\t}\\n\\n\\t/**\\n\\t * @dev \\\"Constructor replacement\\\" for initializable, must be execute during or immediately after deployment\\n\\t *      see https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#initializers\\n\\t *\\n\\t * @param _owner the address receiving all the RBAC permissions on the contract\\n\\t * @param _sharesSubject shares subject, usually defined as NFT (ERC721 contract address + NFT ID)\\n\\t * @param _protocolFeeDestination protocol fee destination, the address protocol fee is sent to\\n\\t * @param _protocolFeePercent protocol fee percent, applied to all the buy and sell operations;\\n\\t *      the fee percent is defined with the 18 decimals, 10^18 corresponds to 100%\\n\\t * @param _holdersFeeDestination shares holders fee destination, the HoldersRewardsDistributor contract\\n\\t *      the shares holders fee is sent to\\n\\t * @param _holdersFeePercent shares holders fee percent, applied to all the buy and sell operations,\\n\\t *      the fee percent is defined with the 18 decimals, 10^18 corresponds to 100%\\n\\t * @param _subjectFeePercent subject fee percent, applied to all the buy and sell operations,\\n\\t *      the fee percent is defined with the 18 decimals, 10^18 corresponds to 100%\\n\\t * @param _amount how many shares to buy immediately upon \\\"post-construction\\\", can be zero\\n\\t * @param _beneficiary the address receiving the shares bought immediately (must be set\\n\\t *      if `_amount` is not zero)\\n\\t */\\n\\tfunction postConstruct(\\n\\t\\taddress _owner,\\n\\t\\tSharesSubject memory _sharesSubject,\\n\\t\\taddress _protocolFeeDestination,\\n\\t\\tuint64 _protocolFeePercent,\\n\\t\\tHoldersRewardsDistributor _holdersFeeDestination,\\n\\t\\tuint64 _holdersFeePercent,\\n\\t\\tuint64 _subjectFeePercent,\\n\\t\\tuint256 _amount,\\n\\t\\taddress _beneficiary\\n\\t) public payable initializer {\\n\\t\\t// execute parent initializer\\n\\t\\t_postConstruct(\\n\\t\\t\\t_owner,\\n\\t\\t\\t_sharesSubject,\\n\\t\\t\\t_protocolFeeDestination,\\n\\t\\t\\t_protocolFeePercent,\\n\\t\\t\\t_holdersFeeDestination,\\n\\t\\t\\t_holdersFeePercent,\\n\\t\\t\\t_subjectFeePercent\\n\\t\\t);\\n\\n\\t\\t// buy shares if requested\\n\\t\\tif(_amount != 0) {\\n\\t\\t\\t__buySharesTo(_amount, _beneficiary);\\n\\t\\t}\\n\\t\\t// otherwise if transaction contains a payment\\n\\t\\telse if(msg.value > 0) {\\n\\t\\t\\t//  don't forget to return it back\\n\\t\\t\\tpayable(msg.sender).transfer1(msg.value);\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * @inheritdoc TradeableShares\\n\\t */\\n\\tfunction buyShares(uint256 amount) public payable {\\n\\t\\t// delegate to `buySharesTo`\\n\\t\\tbuySharesTo(amount, msg.sender);\\n\\t}\\n\\n\\t/**\\n\\t * @inheritdoc TradeableShares\\n\\t */\\n\\tfunction sellShares(uint256 amount) public {\\n\\t\\t// delegate to `sellSharesTo`\\n\\t\\tsellSharesTo(amount, payable(msg.sender));\\n\\t}\\n\\n\\t/**\\n\\t * @inheritdoc TradeableShares\\n\\t */\\n\\tfunction buySharesTo(uint256 amount, address beneficiary) public payable {\\n\\t\\t// verify the first share is not bought\\n\\t\\trequire(getSharesSupply() > 0 || getSharesIssuer() == msg.sender, \\\"only the issuer can buy the first share\\\");\\n\\n\\t\\t// delegate to unsafe `__buySharesTo`\\n\\t\\t__buySharesTo(amount, beneficiary);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Buys amount of shares for the beneficiary, without checking if the first share was bought\\n\\t *\\n\\t * @param amount amount of the shares to buy\\n\\t * @param beneficiary an address receiving the shares\\n\\t */\\n\\tfunction __buySharesTo(uint256 amount, address beneficiary) private {\\n\\t\\t// cache the supply value\\n\\t\\tuint256 supply = getSharesSupply();\\n\\n\\t\\t// update the balances (note: security checks are below)\\n\\t\\tsharesBalances[beneficiary] += amount;\\n\\t\\tsharesSupply = supply + amount;\\n\\n\\t\\t// determine the price and process the fees\\n\\t\\tuint256 price = getPrice(supply, amount);\\n\\t\\t(, , uint256 protocolFee) = __processProtocolFee(price);\\n\\t\\t(, , uint256 holdersFee) = __processHoldersFeeAndNotify(price, true, amount, beneficiary);\\n\\t\\t(address issuer, , uint256 subjectFee) = __processSubjectFee(price);\\n\\n\\t\\t// verify the transaction has enough Ether supplied\\n\\t\\tuint256 value = price + protocolFee + holdersFee + subjectFee;\\n\\t\\trequire(msg.value >= value, \\\"insufficient value supplied\\\");\\n\\n\\t\\t// return the change back to the buyer; here we do fail on error\\n\\t\\t// note: if any of the fees failed to transfer, they are sent to the buyer\\n\\t\\tif(msg.value > value) {\\n\\t\\t\\tpayable(msg.sender).transfer1(msg.value - value);\\n\\t\\t}\\n\\n\\t\\t// update the cumulative trade volume\\n\\t\\t__increaseTradeVolume(price);\\n\\n\\t\\t// emit an event\\n\\t\\temit Trade(beneficiary, issuer, true, amount, price, protocolFee, holdersFee, subjectFee, sharesSupply);\\n\\t}\\n\\n\\t/**\\n\\t * @inheritdoc TradeableShares\\n\\t */\\n\\tfunction sellSharesTo(uint256 amount, address payable beneficiary) public {\\n\\t\\t// verify the amount vs total supply\\n\\t\\tuint256 supply = getSharesSupply();\\n\\t\\trequire(supply > amount, \\\"cannot sell the last share\\\");\\n\\n\\t\\t// verify the amount vs seller's balance\\n\\t\\tuint256 balance = getSharesBalance(msg.sender);\\n\\t\\trequire(balance >= amount, \\\"insufficient shares\\\");\\n\\n\\t\\t// update the balances\\n\\t\\tsharesBalances[msg.sender] = balance - amount;\\n\\t\\tsharesSupply = supply - amount;\\n\\n\\t\\t// determine the price and process the fees\\n\\t\\tuint256 price = getPrice(sharesSupply, amount);\\n\\t\\t(, , uint256 protocolFee) = __processProtocolFee(price);\\n\\t\\t(, , uint256 holdersFee) = __processHoldersFeeAndNotify(price, false, amount, msg.sender);\\n\\t\\t(address issuer, , uint256 subjectFee) = __processSubjectFee(price);\\n\\n\\t\\t// price cannot be zero since the last share cannot be sold\\n\\t\\t// if the price transfer fails, we do fail\\n\\t\\t// note: if any of the fees failed to transfer, they are sent to the seller\\n\\t\\tbeneficiary.transfer1(price - protocolFee - holdersFee - subjectFee);\\n\\n\\t\\t// update the cumulative trade volume\\n\\t\\t__increaseTradeVolume(price);\\n\\n\\t\\t// emit an event\\n\\t\\temit Trade(beneficiary, issuer, false, amount, price, protocolFee, holdersFee, subjectFee, sharesSupply);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Calculates the protocol fee and sends it to the protocol fee destination\\n\\t *\\n\\t * @param price already calculated price of the trade\\n\\t */\\n\\tfunction __processProtocolFee(uint256 price) private returns(\\n\\t\\taddress protocolFeeDestination,\\n\\t\\tuint256 protocolFeePercent,\\n\\t\\tuint256 protocolFee\\n\\t) {\\n\\t\\t// read fee information in a consistent way\\n\\t\\t(protocolFeeDestination, protocolFeePercent) = getProtocolFeeInfo();\\n\\n\\t\\t// calculate the fee\\n\\t\\tprotocolFee = price * protocolFeePercent / 1 ether;\\n\\n\\t\\t// do the required ETH payment transfer\\n\\t\\t// if the fee payment fails - do not throw and update the fee to zero\\n\\t\\tif(protocolFee != 0 && !payable(protocolFeeDestination).send1(protocolFee)) {\\n\\t\\t\\t// protocol fee couldn't be sent or is zero\\n\\t\\t\\tprotocolFee = 0;\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * @dev Calculates the shares holders fee and sends it to the holders fee destination;\\n\\t *      notifies the destination (which is a HoldersRewardsDistributor contract) about\\n\\t *      the trade, submits trader address, and trade amount\\n\\t *\\n\\t * @dev isBuy is true if the shares are bought\\n\\t *      isBuy is false if the shares are sold\\n\\t *\\n\\t * @param price already calculated price of the trade\\n\\t * @param isBuy operation type, [true] buying, [false] selling\\n\\t * @param amount trade amount\\n\\t * @param trader an account which makes a trade, whose shares balance changes by the `amount`\\n\\t */\\n\\tfunction __processHoldersFeeAndNotify(uint256 price, bool isBuy, uint256 amount, address trader) private returns(\\n\\t\\tHoldersRewardsDistributor holdersFeeDestination,\\n\\t\\tuint256 holdersFeePercent,\\n\\t\\tuint256 holdersFee\\n\\t) {\\n\\t\\t// read fee information in a consistent way\\n\\t\\t(holdersFeeDestination, holdersFeePercent) = getHoldersFeeInfo();\\n\\n\\t\\t// calculate the fee\\n\\t\\tholdersFee = price * holdersFeePercent / 1 ether;\\n\\n\\t\\t// do the required ETH payment transfer and HoldersRewardsDistributor sync\\n\\t\\tif(address(holdersFeeDestination) != address(0) && amount != 0) {\\n\\t\\t\\t// construct the HoldersRewardsDistributor sync message\\n\\t\\t\\tbytes memory syncMessage = abi.encode(trader, isBuy, amount);\\n\\n\\t\\t\\t// send the fee together with the sync message\\n\\t\\t\\t// we pass all the gas available since the fee destination address is trusted,\\n\\t\\t\\t// and since if the call fails we also fail the entire transaction\\n\\t\\t\\t(bool success, ) = address(holdersFeeDestination).call{value: holdersFee}(syncMessage);\\n\\n\\t\\t\\t// we require synchronization to succeed, otherwise we can't guarantee data consistency\\n\\t\\t\\t// on the HoldersRewardsDistributor contract's side\\n\\t\\t\\trequire(success, \\\"sync failed\\\");\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * @dev Calculates the subject fee and sends it to the issuer\\n\\t *\\n\\t * @param price already calculated price of the trade\\n\\t */\\n\\tfunction __processSubjectFee(uint256 price) private returns(\\n\\t\\taddress subjectFeeDestination,\\n\\t\\tuint256 subjectFeePercent,\\n\\t\\tuint256 subjectFee\\n\\t) {\\n\\t\\t// read fee information in a consistent way\\n\\t\\t(subjectFeeDestination, subjectFeePercent) = getSubjectFeeInfo();\\n\\n\\t\\t// calculate the fee\\n\\t\\tsubjectFee = price * subjectFeePercent / 1 ether;\\n\\n\\t\\t// do the required ETH payment transfer\\n\\t\\t// if the fee payment fails - do not throw and update the fee to zero\\n\\t\\tif(subjectFee != 0 && !payable(subjectFeeDestination).send1(subjectFee)) {\\n\\t\\t\\t// protocol fee couldn't be sent or is zero\\n\\t\\t\\tsubjectFee = 0;\\n\\t\\t}\\n\\t}\\n}\\n\",\"keccak256\":\"0x4592b676894d49f3d1fadbaefce00c2444b5a50e83457450abd1a6e0473bab6c\",\"license\":\"MIT\"},\"contracts/bonding_curves/FriendTechBondingCurve.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"./BondingCurve.sol\\\";\\n\\n/**\\n * @title FriendTech Bonding Curve\\n *\\n * @notice friend.tech definition of the bonding curve function\\n */\\ncontract FriendTechBondingCurve is BondingCurve {\\n\\t/**\\n\\t * @inheritdoc BondingCurve\\n\\t *\\n\\t * @param s supply, total shares supply\\n\\t * @param a amount, number of shares to buy/sell\\n\\t */\\n\\tfunction getPrice(uint256 s, uint256 a) public pure virtual returns(uint256) {\\n\\t\\t// this is the original friend tech formula with the underflow fix\\n\\t\\t// the fix allows both supply and amount be zero, as well as\\n\\t\\t// it allows supply be zero when the amount is bigger than one\\n\\t\\tuint256 sum1 = s == 0 ? 0 : (s - 1) * s * (2 * (s - 1) + 1) / 6;\\n\\t\\tuint256 sum2 = s == 0 && a <= 1 ? 0 : (s + a - 1) * (s + a) * (2 * (s + a - 1) + 1) / 6;\\n\\t\\tuint256 summation = sum2 - sum1;\\n\\t\\treturn summation * 1 ether / 16000;\\n\\t}\\n}\\n\",\"keccak256\":\"0x32d785248f6ba8c43306dc08c5b287500f468e946133c30b88c4d1b845158353\",\"license\":\"MIT\"},\"contracts/bonding_curves/HoldersRewardsDistributor.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"../interfaces/ERC1363Spec.sol\\\";\\n\\n/**\\n * @title Bonding Curve Holder Reward Distributor\\n *\\n * @notice Holder reward distributor keeps track of every trade event happening in the curve,\\n *      and based on the amount of shares the holder has, alters the holders' reward weight,\\n *      which directly affects the amount of the distributed rewards between the holders\\n *\\n * @notice Holder reward distributor accepts the fees from the curve and distributes these fees\\n *      across shares holders proportionally to their weights\\n *\\n * @dev Apart from the `accept(uint256,address)` function designed to accept the fees from the\\n *      curve contract, the implementation must implement receive(), fallback(), and onTransferReceived()\\n *      functions to accept direct payments in both ETH and/or ERC20 payment token\\n *\\n * @dev receive() and onTransferReceived() with an empty data field must accept the fee in the same way\\n *      as an accept() function would do, but in a passive way (without ERC20 transfer)\\n *\\n * @dev The fallback() and onTransferReceived() with non-empty data field must accept the fee and the trading event;\\n *      trading event encoded in the bytes data field contains the information\\n *      on the trade which resulted in the fee being sent:\\n *\\n *      - address trader - shares holder/trader\\n *      - bool isBuy - true if shares were bought, false if shares were sold\\n *      - uint256 sharesAmount - amount of shares bought or sold\\n *\\n *      the values above are packed as data = abi.encode(trader, isBuy, sharesAmount)\\n *      and can be unpacked as (trader, isBuy, sharesAmount) = abi.decode(data, (address, bool, uint256))\\n *\\n *      if specified, the data field must be parsed by the implementation and its containing data applied;\\n *      standard logic applies, if the data is malformed implementation should throw\\n *\\n */\\ninterface HoldersRewardsDistributor is ERC1363Receiver {\\n\\t/**\\n\\t * @dev Fired in `sharesBought` and `sharesSold`\\n\\t *\\n\\t * @param trader is a buyer or a seller, depending on the operation type\\n\\t * @param isBuy true if the event comes from the `sharesBought` and represents the buy operation,\\n\\t *      false if the event comes from the `sharesSold` and represents the sell operation\\n\\t * @param sharesAmount amount of the shares bought or sold (see `isBuy`)\\n\\t */\\n\\tevent SharesTraded(address indexed trader, bool indexed isBuy, uint256 sharesAmount);\\n\\n\\t/**\\n\\t * @dev Fired when the fee for the distribution is received\\n\\t *\\n\\t * @param feeAmount amount of the fee to distribute between the holders\\n\\t */\\n\\tevent FeeReceived(uint256 feeAmount);\\n\\n\\t/**\\n\\t * @dev Fired in `claimReward`\\n\\t *\\n\\t * @param holder address of the trader (and shares holder) who received the reward\\n\\t * @param rewardAmount amount of the reward sent\\n\\t */\\n\\tevent RewardClaimed(address indexed holder, uint256 rewardAmount);\\n\\n\\t/**\\n\\t * @notice ERC20 payment token distributor is bound to\\n\\t *\\n\\t * @return paymentToken ERC20 payment token address the contract is bound to,\\n\\t *      or zero zero address if it operates with the plain ETH\\n\\t */\\n\\tfunction getPaymentToken() external view returns(address paymentToken);\\n\\n/*\\n\\t*/\\n/**\\n\\t * @notice Notifies the distributor about the trade event\\n\\t *\\n\\t * @dev Trade amount specified affects holder's (buyer's) weight when calculating the reward\\n\\t *\\n\\t * @param buyer shares buyer (becomes shares holder if not yet), a.k.a trader\\n\\t * @param amountBought amount of the shares bought\\n\\t *//*\\n\\n\\tfunction sharesBought(address buyer, uint256 amountBought) external;\\n\\n\\t*/\\n/**\\n\\t * @notice Notifies the distributor about the trade event\\n\\t *\\n\\t * @dev Trade amount specified affects holder's (seller's) weight when calculating the reward\\n\\t *\\n\\t * @param seller shares seller (shares holder), a.k.a trader\\n\\t * @param amountSold amount of the shares sold\\n\\t *//*\\n\\n\\tfunction sharesSold(address seller, uint256 amountSold) external;\\n\\n\\t*/\\n/**\\n\\t * @notice Executed by the fee sender to send the fee; in case of the ERC20 payment,\\n\\t *      this is the ask to take the specified amount of the ERC20 token of the specified type;\\n\\t *      in case of the ETH payment, the amount must be supplied with the transaction itself\\n\\t *\\n\\t * @dev When paying with an ERC20 payment token, sender must approve the contract for\\n\\t *      at least the amount specified before executing this function\\n\\t *\\n\\t * @dev Updates the accumulated reward per share\\n\\t *\\n\\t * @param feeAmount amount of the fee sent,\\n\\t *      in the case of ETH payment must be equal to msg.value\\n\\t *//*\\n\\n\\tfunction accept(uint256 feeAmount) external payable;\\n*/\\n\\n\\t/**\\n\\t * @notice Executed by the holder to claim entire pending reward\\n\\t *\\n\\t * @dev Holder can verify pending reward amount with the `pendingReward` function\\n\\t */\\n\\tfunction claimTheReward() external;\\n\\n\\t/**\\n\\t * @notice Pending (claimable) reward. This is the amount which can be claimed using `claimTheReward`\\n\\t *\\n\\t * @param holder the holder address to query the reward for\\n\\t * @return rewardAmount pending reward amount\\\\\\n\\t */\\n\\tfunction pendingReward(address holder) external view returns(uint256 rewardAmount);\\n}\\n\",\"keccak256\":\"0xc1749ddf31e8338a0e72081b19a792c4496699cd0bfff442f88281a0a32d5699\",\"license\":\"MIT\"},\"contracts/bonding_curves/HoldersRewardsDistributorV1.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"./HoldersRewardsDistributor.sol\\\";\\nimport \\\"../utils/Transfers.sol\\\";\\nimport \\\"../utils/InitializableAccessControl.sol\\\";\\n\\n/**\\n * @title Bonding Curve Holder Reward Distributor\\n *\\n * @notice Holder reward distributor keeps track of every trade event happening in the curve,\\n *      and based on the amount of shares the holder has, alters the holders' reward weight,\\n *      which directly affects the amount of the distributed rewards between the holders\\n *\\n * @notice Holder reward distributor accepts the fees from the curve and distributes these fees\\n *      across shares holders proportionally to their weights\\n *\\n * @dev Apart from the `accept(uint256,address)` function designed to accept the fees from the\\n *      curve contract, the implementation must implement receive(), fallback(), and onTransferReceived()\\n *      functions to accept direct payments in both ETH and/or ERC20 payment token\\n *\\n * @dev receive() and onTransferReceived() with an empty data field must accept the fee in the same way\\n *      as an accept() function would do, but in a passive way (without ERC20 transfer)\\n *\\n * @dev The fallback() and onTransferReceived() with non-empty data field must accept the fee and the trading event;\\n *      trading event encoded in the bytes data field contains the information\\n *      on the trade which resulted in the fee being sent:\\n *\\n *      - address trader - shares holder/trader\\n *      - bool isBuy - true if shares were bought, false if shares were sold\\n *      - uint256 sharesAmount - amount of shares bought or sold\\n *\\n *      the values above are packed as data = abi.encode(trader, isBuy, sharesAmount)\\n *      and can be unpacked as (trader, isBuy, sharesAmount) = abi.decode(data, (address, bool, uint256))\\n *\\n *      if specified, the data field must be parsed by the implementation and its containing data applied;\\n *      standard logic applies, if the data is malformed implementation should throw\\n *\\n */\\ncontract HoldersRewardsDistributorV1 is HoldersRewardsDistributor, InitializableAccessControl {\\n\\t// Info of each user.\\n\\tstruct UserInfo {\\n\\t\\tuint256 shares;\\n\\t\\tuint256 rewardDebt;\\n\\t\\tuint256 claimedAmount;\\n\\t\\tuint256 unclaimedAmount;\\n\\t}\\n\\n\\t// ERC20 payment token address\\n\\taddress private /*immutable*/ paymentToken;\\n\\t/// bonding curve contract address\\n\\taddress public sharesContractAddress;\\n\\t/// accumulated reward per share, times 1e18 (with 18 decimal precision)\\n\\tuint256 public accRewardPerShare;\\n\\t/// total number of share registered\\n\\tuint256 public totalShares;\\n\\t// Info of each user that stakes LP tokens.\\n\\tmapping(address => UserInfo) public userInfo;\\n\\n\\t/**\\n\\t * @dev Deploys the distributor contract\\n\\t *\\n\\t * @param _owner contract, optional (can be zero address), since there are no admin functions\\n\\t * @param _sharesContractAddress TradeableShares contract to bind the distributor to,\\n\\t *      optional (can be zero address), this can be set up later with the\\n\\t *      `initializeSharesContractAddressIfRequired` function\\n\\t * @param _paymentToken ERC1363 payment token to bind to, optional (can be zero address),\\n\\t *      zero address means distributor works with the plain ETH\\n\\t */\\n\\tconstructor(address _owner, address _sharesContractAddress, address _paymentToken) initializer {\\n\\t\\t// initialize the deployed instance\\n\\t\\tpostConstruct(_owner, _sharesContractAddress, _paymentToken);\\n\\t}\\n\\n\\t/**\\n\\t * @dev \\\"Constructor replacement\\\" for initializable, must be execute during or immediately after deployment\\n\\t *      see https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#initializers\\n\\t *\\n\\t * @param _owner contract, optional (can be zero address), since there are no admin functions\\n\\t * @param _sharesContractAddress TradeableShares contract to bind the distributor to,\\n\\t *      optional (can be zero address), this can be set up later with the\\n\\t *      `initializeSharesContractAddressIfRequired` function\\n\\t * @param _paymentToken ERC1363 payment token to bind to, optional (can be zero address),\\n\\t *      zero address means distributor works with the plain ETH\\n\\t */\\n\\tfunction postConstruct(address _owner, address _sharesContractAddress, address _paymentToken) public initializer {\\n\\t\\t// execute parent initializer(s)\\n\\t\\t_postConstruct(_owner);\\n\\n\\t\\tsharesContractAddress = _sharesContractAddress;\\n\\t\\tpaymentToken = _paymentToken;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Sets the TradeableShares contract to bind the distributor to\\n\\t *\\n\\t * @dev TradeableShares contract can be set only once; fails if it is already set\\n\\t * @param _sharesContractAddress TradeableShares contract to bind the distributor to\\n\\t */\\n\\tfunction initializeSharesContractAddressIfRequired(address _sharesContractAddress) public {\\n\\t\\t// check the address is not yet set\\n\\t\\trequire(sharesContractAddress == address(0) && _sharesContractAddress != address(0), \\\"already initialized\\\");\\n\\n\\t\\t// set the TradeableShares contract address\\n\\t\\tsharesContractAddress = _sharesContractAddress;\\n\\t}\\n\\n\\t/**\\n\\t * @inheritdoc HoldersRewardsDistributor\\n\\t */\\n\\tfunction getPaymentToken() public view returns (address) {\\n\\t\\treturn paymentToken;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Executed when TradeableShares contract notifies about shares bought event\\n\\t */\\n\\tfunction __sharesBought(address _buyer, uint256 _amountBought) private {\\n\\t\\tUserInfo storage userDetail = userInfo[_buyer];\\n\\t\\tif(userDetail.shares > 0) {\\n\\t\\t\\t// calculated pending reward if any\\n\\t\\t\\tuint256 pending = ((userDetail.shares * accRewardPerShare) / 1e18) - userDetail.rewardDebt;\\n\\t\\t\\tif(pending > 0) {\\n\\t\\t\\t\\t// update unclaimed amount\\n\\t\\t\\t\\tuserDetail.unclaimedAmount += pending;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// update state variables\\n\\t\\tuserDetail.shares += _amountBought;\\n\\t\\ttotalShares += _amountBought;\\n\\t\\tuserDetail.rewardDebt = (userDetail.shares * accRewardPerShare) / 1e18;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Executed when TradeableShares contract notifies about shares sold event\\n\\t */\\n\\tfunction __sharesSold(address _seller, uint256 _amountSold) private {\\n\\t\\trequire(_amountSold <= userInfo[_seller].shares, \\\"amount must be <= registered amount\\\");\\n\\n\\t\\tUserInfo storage userDetail = userInfo[_seller];\\n\\t\\t// calculated pending reward if any\\n\\t\\tuint256 pending = ((userDetail.shares * accRewardPerShare) / 1e18) - userDetail.rewardDebt;\\n\\t\\tif(pending > 0) {\\n\\t\\t\\t// update unclaimed amount\\n\\t\\t\\tuserDetail.unclaimedAmount += pending;\\n\\t\\t}\\n\\n\\t\\t// update state variables\\n\\t\\tuserDetail.shares = userDetail.shares - _amountSold;\\n\\t\\ttotalShares = totalShares - _amountSold;\\n\\t\\tuserDetail.rewardDebt = (userDetail.shares * accRewardPerShare) / 1e18;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Executed when TradeableShares contract send the fees;\\n\\t * @dev The very first tranche of the fees might be ignored if it is done by the issuer\\n\\t */\\n\\tfunction __accept(uint256 _feeAmount) private {\\n\\t\\t// check the state can accept the changes\\n\\t\\tif(_feeAmount == 0 || totalShares == 0) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// update state variables\\n\\t\\taccRewardPerShare += (_feeAmount * 1e18) / totalShares;\\n\\n\\t\\t// emit an event\\n\\t\\temit FeeReceived(_feeAmount);\\n\\t}\\n\\n\\n\\t/**\\n\\t * @dev Processes the fee, and the sync message\\n\\t *\\n\\t * @dev Takes care about the encoded bytes data containing trader address, trade operation type,\\n\\t *      and amount of the shares bought\\n\\t *\\n\\t * @dev Format: address | bool | uint256\\n\\t */\\n\\tfunction __parseTrade(uint256 _feeAmount, bytes memory data) private {\\n\\t\\tif(totalShares == 0) {\\n\\t\\t\\t__parseFirstTrade(_feeAmount, data);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\t__parseNextTrade(_feeAmount, data);\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * @dev Processes the very first fee, and the sync message\\n\\t */\\n\\tfunction __parseFirstTrade(uint256 _feeAmount, bytes memory data) private {\\n\\t\\t// the very first sync message must not be empty\\n\\t\\trequire(data.length != 0, \\\"sync message expected\\\");\\n\\n\\t\\t// verify message length\\n\\t\\trequire(data.length == 96, \\\"malformed sync message\\\");\\n\\n\\t\\t// decode the sync message\\n\\t\\t(address trader, bool isBuy, uint256 sharesAmount) = abi.decode(data, (address, bool, uint256));\\n\\t\\t// the very first operation can be buy only, and cannot be zero\\n\\t\\trequire(isBuy && sharesAmount >= 1, \\\"invalid state\\\");\\n\\n\\t\\t// init: notify about the first share\\n\\t\\t__sharesBought(trader, 1);\\n\\t\\t// to save the gas execute the rest of the functions only if there is a need\\n\\t\\tif(sharesAmount > 1) {\\n\\t\\t\\t// process the fee\\n\\t\\t\\t__accept(_feeAmount);\\n\\t\\t\\t// notify about the remaining shares\\n\\t\\t\\t__sharesBought(trader, sharesAmount - 1);\\n\\t\\t}\\n\\n\\t\\t// emit an event\\n\\t\\temit SharesTraded(trader, true, sharesAmount);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Processes not the very first fee, and the sync message\\n\\t */\\n\\tfunction __parseNextTrade(uint256 _feeAmount, bytes memory data) private {\\n\\t\\t// process the fee\\n\\t\\t__accept(_feeAmount);\\n\\n\\t\\t// if the sync message is empty, we're done\\n\\t\\tif(data.length == 0) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// verify message length\\n\\t\\trequire(data.length == 96, \\\"malformed sync message\\\");\\n\\n\\t\\t// decode the sync message\\n\\t\\t(address trader, bool isBuy, uint256 sharesAmount) = abi.decode(data, (address, bool, uint256));\\n\\t\\tif(isBuy) {\\n\\t\\t\\t// notify buy\\n\\t\\t\\t__sharesBought(trader, sharesAmount);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\t// notify sell\\n\\t\\t\\t__sharesSold(trader, sharesAmount);\\n\\t\\t}\\n\\n\\t\\t// emit an event\\n\\t\\temit SharesTraded(trader, isBuy, sharesAmount);\\n\\t}\\n\\n\\t/**\\n\\t * @inheritdoc HoldersRewardsDistributor\\n\\t */\\n\\tfunction claimTheReward() public {\\n\\t\\tuint256 claimableAmount = pendingReward(msg.sender);\\n\\t\\trequire(claimableAmount > 0, \\\"Nothing to claim\\\");\\n\\n\\t\\tUserInfo storage userDetail = userInfo[msg.sender];\\n\\t\\t// update state variable\\n\\t\\tuserDetail.unclaimedAmount = 0;\\n\\t\\tuserDetail.claimedAmount += claimableAmount;\\n\\t\\tuserDetail.rewardDebt = (userDetail.shares * accRewardPerShare) / 1e18;\\n\\n\\t\\t// transfer reward\\n\\t\\tif(paymentToken == address(0)) {\\n\\t\\t\\tTransfers.transfer(payable(msg.sender), claimableAmount);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\trequire(ERC20(paymentToken).transfer(msg.sender, claimableAmount));\\n\\t\\t}\\n\\n\\t\\t// emit an event\\n\\t\\temit RewardClaimed(msg.sender, claimableAmount);\\n\\t}\\n\\n\\t/**\\n\\t * @inheritdoc HoldersRewardsDistributor\\n\\t */\\n\\tfunction pendingReward(address holder) public view returns (uint256) {\\n\\t\\t// read user details and calculate how much we own\\n\\t\\tUserInfo memory userDetail = userInfo[holder];\\n\\t\\tuint256 pending = userDetail.unclaimedAmount + userDetail.shares * accRewardPerShare / 1e18 - userDetail.rewardDebt;\\n\\n\\t\\t// get an idea of how much we have on the balance\\n\\t\\tuint256 available = paymentToken == address(0)? address(this).balance: ERC20(paymentToken).balanceOf(address(this));\\n\\n\\t\\t// we allow up to 1 gwei cumulative discrepancy due to rounding errors\\n\\t\\trequire(pending < 1_000_000_000 + available, \\\"discrepancy error\\\");\\n\\n\\t\\t// return the amount we're actually able to return in `claimTheReward`\\n\\t\\treturn pending > available? available: pending;\\n\\t}\\n\\n\\t/**\\n\\t * @inheritdoc ERC1363Receiver\\n\\t *\\n\\t * @notice Anyone can send some additional rewards \\u2013 just use empty `data` for a callback\\n\\t *\\n\\t * @dev Non-empty `data` executes trade updates and therefore is restricted to be sent only\\n\\t *      by `sharesContractAddress`\\n\\t */\\n\\tfunction onTransferReceived(address operator, address, uint256 value, bytes memory data) public returns (bytes4) {\\n\\t\\trequire(msg.sender == paymentToken, \\\"received event from wrong token\\\");\\n\\t\\trequire(operator == sharesContractAddress, \\\"not allowed\\\");\\n\\n\\t\\t__parseTrade(value, data);\\n\\t\\treturn ERC1363Receiver(this).onTransferReceived.selector;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Receive is public. Anyone can send some additional rewards ;)\\n\\t */\\n\\treceive() external payable {\\n\\t\\trequire(paymentToken == address(0), \\\"not allowed\\\");\\n\\t\\t__parseTrade(msg.value, bytes(\\\"\\\"));\\n\\t}\\n\\n\\t/**\\n\\t * @dev Fallback executes trade updates and therefore is restricted to be executed only by `sharesContractAddress`\\n\\t *\\n\\t * @notice If you want do donate some rewards - use `receive()`\\n\\t */\\n\\tfallback() external payable {\\n\\t\\trequire(paymentToken == address(0), \\\"not an ETH reward distributor\\\");\\n\\n\\t\\trequire(msg.sender == sharesContractAddress, \\\"not allowed\\\");\\n\\t\\t__parseTrade(msg.value, msg.data);\\n\\t}\\n}\\n\",\"keccak256\":\"0xe2772adbcfe9126299fb2e9b03710e64b2971fdbf36712d026a59420a31e1f98\",\"license\":\"MIT\"},\"contracts/bonding_curves/SharesFactory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"./TradeableShares.sol\\\";\\n\\n/**\\n * @title Shares Factory\\n *\\n * @notice Creates/deploys TradeableShares contracts\\n *\\n * @notice The factory manages protocol fees of the deployed TradeableShares contract:\\n *      deployed contracts usually follow the protocol fees set on the factory\\n *\\n * @dev Based on the friend.tech FriendtechSharesV1.sol\\n */\\ninterface SharesFactory {\\n\\t/**\\n\\t * @dev Enum of all possible TradeableShares implementations the factory can deploy\\n\\t */\\n\\tenum ImplementationType {\\n\\t\\t/// @dev ETHShares implementation\\n\\t\\tETH,\\n\\t\\t/// @dev ERC20Shares implementation bound to the ERC20 payment token\\n\\t\\tERC20\\n\\t}\\n\\n\\t/**\\n\\t * @dev Shares deployment request is used to enable the TradeableShares\\n\\t *      deployment with meta-transactions\\n\\t * @dev See `executeDeploymentRequest()`\\n\\t */\\n\\tstruct SharesDeploymentRequest {\\n\\t\\t/// @dev TradeableShares implementation type\\n\\t\\tImplementationType implementationType;\\n\\t\\t/// @dev shares subject, owner of the curve\\n\\t\\tTradeableShares.SharesSubject sharesSubject;\\n\\t\\t/// @dev an address to mint the NFT defined by the subject if it doesn't exist\\n\\t\\taddress issuer;\\n\\t\\t/// @dev how many shares to buy immediately after the deployment\\n\\t\\tuint256 amount;\\n\\t\\t/// @dev unix timestamp when the request becomes valid\\n\\t\\tuint256 validFromTimestamp;\\n\\t\\t/// @dev unix timestamp when the request expires (becomes invalid)\\n\\t\\tuint256 expiresAtTimestamp;\\n\\t\\t/// @dev nonce of the request (sequential number, increased by one)\\n\\t\\tuint256 nonce;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Fired in\\n\\t *      `setProtocolFeeDestination`\\n\\t *      `setProtocolFeePercent`\\n\\t *      `setHoldersFeePercent`\\n\\t *      `setSubjectFeePercent`\\n\\t *      `setProtocolFee`\\n\\t *\\n\\t * @param protocolFeeDestination address where the protocol fee is sent\\n\\t * @param protocolFeePercent protocol fee percent, value 10^18 corresponds to 100%\\n\\t * @param holdersFeePercent shares holders fee percent, value 10^18 corresponds to 100%\\n\\t * @param subjectFeePercent subject fee percent, value 10^18 corresponds to 100%\\n\\t */\\n\\tevent ProtocolFeeUpdated(\\n\\t\\taddress protocolFeeDestination,\\n\\t\\tuint64 protocolFeePercent,\\n\\t\\tuint64 holdersFeePercent,\\n\\t\\tuint64 subjectFeePercent\\n\\t);\\n\\n\\t/**\\n\\t * @dev Fired in `deploySharesContract` and `registerSharesContract`\\n\\t *\\n\\t * @param creator shares creator, a.k.a. shares issuer, or current owner\\n\\t * @param implementationContract newly deployed or registered TradeableShares contract\\n\\t * @param holdersRewardsDistributor the shares holders fee destination, HoldersRewardsDistributor contract,\\n\\t *      this can be zero if shares contract is deployed without the shares holders fee distribution\\n\\t * @param implementationType type of the TradeableShares, see ImplementationType\\n\\t * @param sharesSubject current shares subject\\n\\t * @param newDeployment true if the factory deployed this TradeableShares contract,\\n\\t *      false if TradeableShares contract was already deployed and factory just registered it\\n\\t */\\n\\tevent SharesContractRegistered(\\n\\t\\taddress indexed creator,\\n\\t\\tTradeableShares indexed implementationContract,\\n\\t\\tHoldersRewardsDistributor indexed holdersRewardsDistributor,\\n\\t\\tImplementationType implementationType,\\n\\t\\tTradeableShares.SharesSubject sharesSubject,\\n\\t\\tbool newDeployment\\n\\t);\\n\\n\\t/**\\n\\t * @dev Fired in `executeDeploymentRequest` and in `rewind`\\n\\t */\\n\\tevent NonceUsed(address indexed issuer, uint256 nonce);\\n\\n\\t/**\\n\\t * @notice Address of the already deployed TradeableShares implementation\\n\\t *      to be used by the factory to deploy the TradeableShares contracts EIP-1167 clones\\n\\t *\\n\\t * @param _implementationType TradeableShares implementation type\\n\\t * @return the address of the already deployed TradeableShares implementation corresponding\\n\\t *      to the given implementation type\\n\\t */\\n\\tfunction getSharesImplAddress(ImplementationType _implementationType) external view returns(address);\\n\\n\\t/**\\n\\t * @notice Address of the already deployed HoldersRewardsDistributor implementation\\n\\t *      to be used by the factory to deploy the HoldersRewardsDistributor contracts EIP-1167 clones\\n\\t *\\n\\t * @dev If the HoldersRewardsDistributor implementation is missing, the TradeableShares contract\\n\\t *      can still be deployed, not being attached to the HoldersRewardsDistributor\\n\\t *\\n\\t * @param _implementationType TradeableShares implementation type\\n\\t * @return the address of the already deployed HoldersRewardsDistributor implementation corresponding\\n\\t *      to the given implementation type\\n\\t */\\n\\tfunction getDistributorImplAddress(ImplementationType _implementationType) external view returns(address);\\n\\n\\t/**\\n\\t * @notice Protocol fee destination is the address receiving the protocol fee\\n\\t *\\n\\t * @return feeDestination protocol fee destination, address\\n\\t */\\n\\tfunction getProtocolFeeDestination() external view returns(address feeDestination);\\n\\n\\t/**\\n\\t * @notice Protocol fee percent is the percentage of the buy/sell transaction volume\\n\\t *      sent to the protocol fee destination\\n\\t *\\n\\t * @dev The value has 18 decimals, 100% is represented as 10^18\\n\\t *\\n\\t * @return feePercent protocol fee percent\\n\\t */\\n\\tfunction getProtocolFeePercent() external view returns(uint256 feePercent);\\n\\n\\t/**\\n\\t * @notice Shares holders fee percent is the percentage of the buy/sell transaction volume\\n\\t *      sent to the shares holders rewards distributor contract\\n\\t *\\n\\t * @dev The value has 18 decimals, 100% is represented as 10^18\\n\\t *\\n\\t * @return feePercent shares holders fee percent\\n\\t */\\n\\tfunction getHoldersFeePercent() external view returns(uint256 feePercent);\\n\\n\\t/**\\n\\t * @notice Subject fee percent is the percentage of the buy/sell transaction volume\\n\\t *      sent to the subject issuer\\n\\t *\\n\\t * @dev The value has 18 decimals, 100% is represented as 10^18\\n\\t *\\n\\t * @dev Implementation may return different values for different callers,\\n\\t *      for example it can read SharesSubject from the caller TradeableShares contract\\n\\t *      and dynamically determine the subject fee\\n\\t *\\n\\t * @return feePercent subject fee percent\\n\\t */\\n\\tfunction getSubjectFeePercent() external view returns(uint256 feePercent);\\n\\n\\t/**\\n\\t * @notice Sets the protocol fee destination\\n\\t *\\n\\t * @dev Implementation must check the consistency of the protocol fee destination and percent\\n\\t *      set by this and `setProtocolFeePercent` functions\\n\\t *\\n\\t * @param feeDestination protocol fee destination to set\\n\\t */\\n\\tfunction setProtocolFeeDestination(address feeDestination) external;\\n\\n\\t/**\\n\\t * @notice Sets the protocol fee percent\\n\\t *\\n\\t * @dev Implementation must check the consistency of the protocol fee destination and percent\\n\\t *      set by this and `setProtocolFeeDestination` functions\\n\\t *\\n\\t * @param feePercent protocol fee percent to set, examples: 10^18 is 100%, 10^17 is 10%\\n\\t */\\n\\tfunction setProtocolFeePercent(uint64 feePercent) external;\\n\\n\\t/**\\n\\t * @notice Sets the shares holders fee percent\\n\\t *\\n\\t * @param feePercent shares holders fee percent to set, examples: 10^18 is 100%, 10^17 is 10%\\n\\t */\\n\\tfunction setHoldersFeePercent(uint64 feePercent) external;\\n\\n\\t/**\\n\\t * @notice Sets the subject fee percent\\n\\t *\\n\\t * @param feePercent subject fee percent to set, examples: 10^18 is 100%, 10^17 is 10%\\n\\t */\\n\\tfunction setSubjectFeePercent(uint64 feePercent) external;\\n\\n\\t/**\\n\\t * @notice Sets all the fees at once:\\n\\t *      protocolFeeDestination\\n\\t *      protocolFeePercent\\n\\t *      holdersFeePercent\\n\\t *      subjectFeePercent\\n\\t *\\n\\t * @param protocolFeeDestination protocol fee destination to set\\n\\t * @param protocolFeePercent protocol fee percent to set, examples: 10^18 is 100%, 10^17 is 10%\\n\\t * @param holdersFeePercent shares holders fee percent to set, examples: 10^18 is 100%, 10^17 is 10%\\n\\t * @param subjectFeePercent subject fee percent to set, examples: 10^18 is 100%, 10^17 is 10%\\n\\t */\\n\\tfunction setProtocolFee(\\n\\t\\taddress protocolFeeDestination,\\n\\t\\tuint64 protocolFeePercent,\\n\\t\\tuint64 holdersFeePercent,\\n\\t\\tuint64 subjectFeePercent\\n\\t) external;\\n\\n\\t/**\\n\\t * @notice Deploys the TradeableShares implementation for the specified subject;\\n\\t *      the curve remains paused, no shares are being bought immediately\\n\\t *\\n\\t * @notice Tries minting the NFT defined by the subject if it doesn't exist\\n\\t *\\n\\t * @dev Implementation must guarantee only one TradeableShares contract per subject\\n\\t *\\n\\t * @param implementationType TradeableShares implementation type\\n\\t * @param sharesSubject shares subject, owner of the curve\\n\\t * @return deployed TradeableShares contract\\n\\t */\\n\\tfunction deploySharesContractPaused(\\n\\t\\tImplementationType implementationType,\\n\\t\\tTradeableShares.SharesSubject calldata sharesSubject\\n\\t) external returns(TradeableShares);\\n\\n\\t/**\\n\\t * @notice Deploys the TradeableShares implementation for the specified subject;\\n\\t *      the curve launches immediately, the first share is issued to the subject issuer (NFT owner)\\n\\t *\\n\\t * @notice Tries minting the NFT defined by the subject if it doesn't exist\\n\\t *\\n\\t * @dev Implementation must guarantee only one TradeableShares contract per subject\\n\\t *\\n\\t * @param implementationType TradeableShares implementation type\\n\\t * @param sharesSubject shares subject, owner of the curve\\n\\t * @return deployed TradeableShares contract\\n\\t */\\n\\tfunction deploySharesContract(\\n\\t\\tImplementationType implementationType,\\n\\t\\tTradeableShares.SharesSubject calldata sharesSubject\\n\\t) external returns(TradeableShares);\\n\\n\\t/**\\n\\t * @notice Deploys the TradeableShares implementation for the specified subject;\\n\\t *      allows to immediately buy any amount of shares (including zero)\\n\\t *\\n\\t * @notice Tries minting the NFT defined by the subject if it doesn't exist\\n\\t *\\n\\t * @dev Implementation must guarantee only one TradeableShares contract per subject\\n\\t *\\n\\t * @param implementationType TradeableShares implementation type\\n\\t * @param sharesSubject shares subject, owner of the curve\\n\\t * @param amount how many shares to buy immediately after the deployment\\n\\t * @return deployed TradeableShares contract\\n\\t */\\n\\tfunction deploySharesContractAndBuy(\\n\\t\\tImplementationType implementationType,\\n\\t\\tTradeableShares.SharesSubject calldata sharesSubject,\\n\\t\\tuint256 amount\\n\\t) external payable returns(TradeableShares);\\n\\n\\t/**\\n\\t * @notice Deploys the TradeableShares implementation for the specified subject;\\n\\t *      allows to immediately buy any amount of shares (including zero)\\n\\t *\\n\\t * @notice Tries minting the NFT defined by the subject if it doesn't exist\\n\\t *\\n\\t * @dev Implementation must guarantee only one TradeableShares contract per subject\\n\\t *\\n\\t * @param implementationType TradeableShares implementation type\\n\\t * @param sharesSubject shares subject, owner of the curve\\n\\t * @param issuer an address to mint the NFT defined by the subject if it doesn't exist\\n\\t * @param amount how many shares to buy immediately after the deployment\\n\\t * @return deployed TradeableShares contract\\n\\t */\\n\\tfunction mintSubjectAndDeployShares(\\n\\t\\tImplementationType implementationType,\\n\\t\\tTradeableShares.SharesSubject calldata sharesSubject,\\n\\t\\taddress issuer,\\n\\t\\tuint256 amount\\n\\t) external payable returns(TradeableShares);\\n\\n\\t/**\\n\\t * @notice Executes signed SharesDeploymentRequest; this is identical to executing `mintSubjectAndDeployShares`\\n\\t *      on behalf of the signer and allows the transaction to be relayed so that the gas is payed by the\\n\\t *      relayer\\n\\t *\\n\\t * @param req the deployment request to fulfill, containing same data as in `mintSubjectAndDeployShares`\\n\\t * @param signature the deployment request EIP712 signature issued by the address allowed to execute\\n\\t *      the request\\n\\t * @return deployed TradeableShares contract\\n\\t */\\n\\tfunction executeDeploymentRequest(\\n\\t\\tSharesDeploymentRequest calldata req,\\n\\t\\tbytes calldata signature\\n\\t) external payable returns(TradeableShares);\\n\\n\\t/**\\n\\t * @notice Gets current (unused) nonce for the given issuer address;\\n\\t *      unused nonce is required to build the SharesDeploymentRequest and sign it\\n\\t *      nonces increment by one after each use\\n\\t *\\n\\t * @param issuer the issuer address to get the nonce for\\n\\t * @return current (unused) nonce; incremented by one after\\n\\t *      each successful execution of the `executeDeploymentRequest` function\\n\\t */\\n\\tfunction getNonce(address issuer) external view returns(uint256);\\n\\n\\t/**\\n\\t * @notice Rewinds forward the nonce for the issuer specified, used to\\n\\t *      discard one or more signed requests to `executeDeploymentRequest`\\n\\t *\\n\\t * @dev Implementation must not allow to decrease the nonce, only increasing (rewinding)\\n\\t *      must be possible\\n\\t *\\n\\t * @param issuer the issuer address to rewind the nonce for\\n\\t * @param nonce the nonce value to rewind to\\n\\t */\\n\\tfunction rewindNonce(address issuer, uint256 nonce) external;\\n\\n\\t/**\\n\\t * @notice Gets the already deployed TradeableShares contract\\n\\t *\\n\\t * @param sharesSubject shares subject, owner of the curve\\n\\t * @return deployed TradeableShares contract\\n\\t */\\n\\tfunction lookupSharesContract(\\n\\t\\tTradeableShares.SharesSubject calldata sharesSubject\\n\\t) external view returns(TradeableShares);\\n\\n\\t/**\\n\\t * @notice Registers or re-registers the already deployed TradeableShares contract\\n\\t *\\n\\t * @dev Initial registration is usually done manually by authorized address,\\n\\t *      Re-registration is usually done by the shares contract itself\\n\\t *      and implementations must keep the access to this function open for\\n\\t *      the already registered contracts\\n\\t *\\n\\t * @param shares already deployed TradeableShares contract\\n\\t */\\n\\tfunction registerSharesContract(TradeableShares shares) external;\\n\\n\\t/**\\n\\t * @notice Executed only by the previously registered TradeableShares contracts\\n\\t *      to notify the factory about the subject change.\\n\\t *\\n\\t * @dev The factory may throw if the subject is already taken by another contract\\n\\t */\\n\\tfunction notifySubjectUpdated() external;\\n}\\n\\n\",\"keccak256\":\"0xaa4be2c4212a8f755009135c3b4f69fa7de18a03ccc087f44b0b01cfc1c4fe70\",\"license\":\"MIT\"},\"contracts/bonding_curves/SharesFactoryV1.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"../interfaces/ERC721SpecExt.sol\\\";\\nimport \\\"../utils/UpgradeableAccessControl.sol\\\";\\nimport \\\"./TypedStructLib.sol\\\";\\nimport \\\"./SharesFactory.sol\\\";\\nimport \\\"./ETHShares.sol\\\";\\nimport \\\"./ERC20Shares.sol\\\";\\nimport \\\"./HoldersRewardsDistributorV1.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/proxy/Clones.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/cryptography/draft-EIP712Upgradeable.sol\\\";\\n\\n/**\\n * @title Shares Factory V1\\n *\\n * @notice Role-based access control (RBAC) based implementation of the SharesFactory\\n *\\n * @dev Based on the friend.tech FriendtechSharesV1.sol\\n */\\ncontract SharesFactoryV1 is SharesFactory, UpgradeableAccessControl, EIP712Upgradeable {\\n\\t// libraries in use\\n\\tusing ECDSAUpgradeable for bytes32;\\n\\tusing SharesSubjectLib for TradeableShares.SharesSubject;\\n\\tusing TypedStructLib for SharesDeploymentRequest;\\n\\n\\t/**\\n\\t * @dev ERC20 payment token address, effectively immutable (cannot be updated)\\n\\t */\\n\\tERC1363 private /* immutable */ paymentToken;\\n\\n\\t/**\\n\\t * @dev Protocol fee destination is the address receiving the protocol fee\\n\\t */\\n\\taddress private protocolFeeDestination;\\n\\n\\t/**\\n\\t * @dev Protocol fee percent with 18 decimals (10^18 = 100%)\\n\\t */\\n\\tuint64 private protocolFeePercent;\\n\\n\\t/**\\n\\t * @dev Shares holders fee percent with 18 decimals (10^18 = 100%)\\n\\t */\\n\\tuint64 private holdersFeePercent;\\n\\n\\t/**\\n\\t * @dev Subject fee percent with 18 decimals (10^18 = 100%)\\n\\t */\\n\\tuint64 private subjectFeePercent;\\n\\n\\t/**\\n\\t * @dev An address receiving the ownership of the deployed TradeableShares contracts\\n\\t *\\n\\t * @dev This should be the MultiSig address, not to EOA and not the\\n\\t *      RBAC managed smart contract, so that this address cannot act in a scalable way;\\n\\t *      this reduces the risk of misuse, and/or malicious use\\n\\t */\\n\\taddress private sharesOwnerAddress;\\n\\n\\t/**\\n\\t * @dev Deployed shares contracts mapping, keeps track of the deployed contracts subjects\\n\\t *      Maps SharesSubject => TradeableShares\\n\\t */\\n\\tmapping(bytes32 => TradeableShares) private shares;\\n\\n\\t/**\\n\\t * @dev Reverse deployed shares contracts mapping, keeps track of the deployed contracts\\n\\t *      Maps TradeableShares address => SharesSubject\\n\\t */\\n\\tmapping(address => TradeableShares.SharesSubject) private subjects;\\n\\n\\t/**\\n\\t * @dev TradeableShares implementations mapping storing deployed TradeableShares\\n\\t *      address for every supported implementation type, used by the factory to\\n\\t *      deploy the TradeableShares contracts EIP-1167 clones\\n\\t *\\n\\t * @dev Maps TradeableShares ImplementationType => TradeableShares deployed implementation address\\n\\t */\\n\\tmapping(ImplementationType => address) private sharesImplementations;\\n\\n\\t/**\\n\\t * @dev HoldersRewardsDistributor implementations mapping storing deployed HoldersRewardsDistributor\\n\\t *      address for every supported implementation type, used by the factory to\\n\\t *      deploy the HoldersRewardsDistributor contracts EIP-1167 clones\\n\\t *\\n\\t * @dev If available, HoldersRewardsDistributor implementation is attached to the shares contract\\n\\t *      during the deployment, allowing it to send shares holders fees to the distributor\\n\\t *\\n\\t * @dev Maps TradeableShares ImplementationType => HoldersRewardsDistributor deployed implementation address\\n\\t */\\n\\tmapping(ImplementationType => address) private distributorsImplementations;\\n\\n\\t/**\\n\\t * @dev Keeps track of the used nonces for every possible issuer\\n\\t *      Maps address => number of used nonces\\n\\t */\\n\\tmapping(address => uint256) private nonces;\\n\\n\\t/**\\n\\t * @notice Enables [TradeableShares] curve deployment functionality\\n\\t * @dev Feature FEATURE_SHARES_DEPLOYMENT_ENABLED enables `deploySharesContractPaused`,\\n\\t *      `deploySharesContract`, and `deploySharesContractAndBuy` functions\\n\\t */\\n\\tuint32 public constant FEATURE_SHARES_DEPLOYMENT_ENABLED = 0x0000_0001;\\n\\n\\t/**\\n\\t * @notice Allows the [TradeableShares] curve deployer not to buy any shares on deployment;\\n\\t *      if disabled the deployer always gets at least one share,\\n\\t *      effectively launching the curve and allowing anyone to buy\\n\\t *\\n\\t * @dev Feature FEATURE_ALLOW_PAUSED_DEPLOYMENTS enables `deploySharesContractPaused` function\\n\\t */\\n\\tuint32 public constant FEATURE_ALLOW_PAUSED_DEPLOYMENTS = 0x0000_0002;\\n\\n\\t/**\\n\\t * @notice Allows the [TradeableShares] curve deployer to exclusively buy\\n\\t *      any amount of the initial shares; if disabled the deployer always gets\\n\\t *      no more than only one share\\n\\t *\\n\\t * @dev Feature FEATURE_ALLOW_EXCLUSIVE_BUY enables `deploySharesContractAndBuy` function\\n\\t */\\n\\tuint32 public constant FEATURE_ALLOW_EXCLUSIVE_BUY = 0x0000_0004;\\n\\n\\t/**\\n\\t * @notice Protocol fee manager sets protocol fee destination address (protocolFeeDestination)\\n\\t *      and protocol fee percent (protocolFeePercent)\\n\\t *\\n\\t * @dev Role ROLE_PROTOCOL_FEE_MANAGER is required to execute\\n\\t *      `setProtocolFeeDestination` and `setProtocolFeePercent` functions\\n\\t */\\n\\tuint32 public constant ROLE_PROTOCOL_FEE_MANAGER = 0x0001_0000;\\n\\n\\t/**\\n\\t * @notice Shares holders fee manager sets shares holders fee percent (holdersFeePercent)\\n\\t *\\n\\t * @dev Role ROLE_HOLDERS_FEE_MANAGER is required to execute `setHoldersFeePercent` function\\n\\t */\\n\\tuint32 public constant ROLE_HOLDERS_FEE_MANAGER = 0x0002_0000;\\n\\n\\t/**\\n\\t * @notice Subject fee manager sets subject fee percent (subjectFeePercent)\\n\\t *\\n\\t * @dev Role ROLE_SUBJECT_FEE_MANAGER is required to execute `setSubjectFeePercent` function\\n\\t */\\n\\tuint32 public constant ROLE_SUBJECT_FEE_MANAGER = 0x0004_0000;\\n\\n\\t/**\\n\\t * @notice Shares registrar deploys new and registers already deployed TradeableShares instances\\n\\t *\\n\\t * @dev Role ROLE_SHARES_REGISTRAR is required to execute `deploySharesContract`\\n\\t *      and `registerSharesContract` functions\\n\\t */\\n\\tuint32 public constant ROLE_SHARES_REGISTRAR = 0x0008_0000;\\n\\n\\t/**\\n\\t * @notice Factory deployment manager\\n\\t *      - registers already deployed TradeableShares implementations to be used by the factory\\n\\t *        to deploy the TradeableShares contracts EIP-1167 clones\\n\\t *      - sets/unsets/updates the shares owner address `sharesOwnerAddress`\\n\\t *\\n\\t * @dev Role ROLE_SHARES_IMPLEMENTATION_REGISTRAR is required to execute functions:\\n\\t *      - `setImplementationAddress`\\n\\t *      - `setSharesOwnerAddress`\\n\\t */\\n\\tuint32 public constant ROLE_FACTORY_DEPLOYMENT_MANAGER = 0x0010_0000;\\n\\n\\t/**\\n\\t * @dev Fired in setSharesOwnerAddress\\n\\t *\\n\\t * @param sharesOwnerAddress new shares owner address, or zero\\n\\t */\\n\\tevent SharesOwnerAddressUpdated(address indexed sharesOwnerAddress);\\n\\n\\t/**\\n\\t * @dev Fired in `setSharesImplAddress`\\n\\t *\\n\\t * @param implementationType TradeableShares implementation type\\n\\t * @param implementationAddress the address of the already deployed TradeableShares implementation\\n\\t *      corresponding to the given implementation type, or zero address\\n\\t */\\n\\tevent SharesImplAddressUpdated(ImplementationType implementationType, address implementationAddress);\\n\\n\\t/**\\n\\t * @dev Fired in `setDistributorImplAddress`\\n\\t *\\n\\t * @param implementationType HoldersRewardsDistributor implementation type\\n\\t * @param implementationAddress the address of the already deployed HoldersRewardsDistributor implementation\\n\\t *      corresponding to the given implementation type, or zero address\\n\\t */\\n\\tevent DistributorImplAddressUpdated(ImplementationType implementationType, address implementationAddress);\\n\\n\\t/**\\n\\t * @dev \\\"Constructor replacement\\\" for upgradeable, must be execute immediately after proxy deployment\\n\\t *      see https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#initializers\\n\\t *\\n\\t * @param _paymentToken ERC20 payment token address to bind to, immutable\\n\\t */\\n\\tfunction postConstruct(ERC1363 _paymentToken) public initializer {\\n\\t\\t// execute parent initializer(s)\\n\\t\\t__EIP712_init_unchained(\\\"SharesFactory\\\", \\\"1\\\");\\n\\t\\t_postConstruct(msg.sender);\\n\\n\\t\\t// verify token address is set\\n\\t\\trequire(address(_paymentToken) != address(0), \\\"zero address\\\");\\n\\n\\t\\t// set up the immutable ERC20 payment token contract\\n\\t\\tpaymentToken = _paymentToken;\\n\\t}\\n\\n\\t/**\\n\\t * @notice ERC1363 payment token contract which the factory uses to deploy the `ERC20` curve type\\n\\t *\\n\\t * @dev Immutable, client applications may cache this value\\n\\t *\\n\\t * @return ERC1363 payment token contract\\n\\t */\\n\\tfunction getPaymentToken() public view returns(ERC1363) {\\n\\t\\t// return the (effectively) immutable value from the storage\\n\\t\\treturn paymentToken;\\n\\t}\\n\\n\\t/**\\n\\t * @notice An address receiving the ownership of the deployed TradeableShares contracts\\n\\t *\\n\\t * @dev This should be the MultiSig address, not to EOA and not the\\n\\t *      RBAC managed smart contract, so that this address cannot act in a scalable way;\\n\\t *      this reduces the risk of misuse, and/or malicious use\\n\\t *\\n\\t * @return currently active shares owner address, or zero if not set\\n\\t */\\n\\tfunction getSharesOwnerAddress() public view returns(address) {\\n\\t\\t// read it from the storage\\n\\t\\treturn sharesOwnerAddress;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Sets/unsets/updates the shares owner address `sharesOwnerAddress`, which is\\n\\t *      an address receiving the ownership of the deployed TradeableShares contracts\\n\\t *\\n\\t * @dev This should be the MultiSig address, not to EOA and not the\\n\\t *      RBAC managed smart contract, so that this address cannot act in a scalable way;\\n\\t *      this reduces the risk of misuse, and/or malicious use\\n\\t *\\n\\t * @dev Once changed/set, the address affects only new TradeableShares deployments\\n\\t *\\n\\t * @param _sharesOwnerAddress new shares owner address to set, or zero to unset\\n\\t */\\n\\tfunction setSharesOwnerAddress(address _sharesOwnerAddress) public {\\n\\t\\t// verify the access permission\\n\\t\\trequire(isSenderInRole(ROLE_FACTORY_DEPLOYMENT_MANAGER), \\\"access denied\\\");\\n\\n\\t\\t// update the storage (note: this address is allowed to be zero)\\n\\t\\tsharesOwnerAddress = _sharesOwnerAddress;\\n\\n\\t\\t// emit an event\\n\\t\\temit SharesOwnerAddressUpdated(_sharesOwnerAddress);\\n\\t}\\n\\n\\t/**\\n\\t * @inheritdoc SharesFactory\\n\\t */\\n\\tfunction getSharesImplAddress(ImplementationType _implementationType) public view returns(address) {\\n\\t\\t// read the result from storage\\n\\t\\treturn sharesImplementations[_implementationType];\\n\\t}\\n\\n\\t/**\\n\\t * @notice Sets the address of the already deployed TradeableShares implementation\\n\\t *      to be used by the factory to deploy the TradeableShares contracts EIP-1167 clones\\n\\t *\\n\\t * @param _implementationType TradeableShares implementation type\\n\\t * @param _implementationAddress address of the already deployed TradeableShares implementation\\n\\t *      corresponding to the given implementation type\\n\\t */\\n\\tfunction setSharesImplAddress(ImplementationType _implementationType, address _implementationAddress) public {\\n\\t\\t// verify the access permission\\n\\t\\trequire(isSenderInRole(ROLE_FACTORY_DEPLOYMENT_MANAGER), \\\"access denied\\\");\\n\\n\\t\\t// register/update/deregister implementation\\n\\t\\tsharesImplementations[_implementationType] = _implementationAddress;\\n\\n\\t\\t// emit an event\\n\\t\\temit SharesImplAddressUpdated(_implementationType, _implementationAddress);\\n\\t}\\n\\n\\t/**\\n\\t * @inheritdoc SharesFactory\\n\\t */\\n\\tfunction getDistributorImplAddress(ImplementationType _implementationType) public view returns(address) {\\n\\t\\t// read the result from storage\\n\\t\\treturn distributorsImplementations[_implementationType];\\n\\t}\\n\\n\\t/**\\n\\t * @notice Sets the address of the already deployed HoldersRewardsDistributor implementation\\n\\t *      to be used by the factory to deploy the HoldersRewardsDistributor contracts EIP-1167 clones\\n\\t *\\n\\t * @param _implementationType HoldersRewardsDistributor implementation type\\n\\t * @param _implementationAddress address of the already deployed HoldersRewardsDistributor implementation\\n\\t *      corresponding to the given implementation type\\n\\t */\\n\\tfunction setDistributorImplAddress(ImplementationType _implementationType, address _implementationAddress) public {\\n\\t\\t// verify the access permission\\n\\t\\trequire(isSenderInRole(ROLE_FACTORY_DEPLOYMENT_MANAGER), \\\"access denied\\\");\\n\\n\\t\\t// register/update/deregister implementation\\n\\t\\tdistributorsImplementations[_implementationType] = _implementationAddress;\\n\\n\\t\\t// emit an event\\n\\t\\temit DistributorImplAddressUpdated(_implementationType, _implementationAddress);\\n\\t}\\n\\n\\t/**\\n\\t * @inheritdoc SharesFactory\\n\\t */\\n\\tfunction getProtocolFeeDestination() public view returns(address feeDestination) {\\n\\t\\t// read the result from storage\\n\\t\\treturn protocolFeeDestination;\\n\\t}\\n\\n\\t/**\\n\\t * @inheritdoc SharesFactory\\n\\t */\\n\\tfunction getProtocolFeePercent() public view returns(uint256 feePercent) {\\n\\t\\t// read the result from storage\\n\\t\\treturn protocolFeePercent;\\n\\t}\\n\\n\\t/**\\n\\t * @inheritdoc SharesFactory\\n\\t */\\n\\tfunction getHoldersFeePercent() public view returns(uint256 feePercent) {\\n\\t\\t// read the result from storage\\n\\t\\treturn holdersFeePercent;\\n\\t}\\n\\n\\t/**\\n\\t * @inheritdoc SharesFactory\\n\\t */\\n\\tfunction getSubjectFeePercent() public view returns(uint256 feePercent) {\\n\\t\\t// read the result from storage\\n\\t\\treturn subjectFeePercent;\\n\\t}\\n\\n\\t/**\\n\\t * @inheritdoc SharesFactory\\n\\t */\\n\\tfunction setProtocolFeeDestination(address _feeDestination) public {\\n\\t\\t// verify the access permission\\n\\t\\trequire(isSenderInRole(ROLE_PROTOCOL_FEE_MANAGER), \\\"access denied\\\");\\n\\t\\t// verify state change doesn't result into the discrepancy\\n\\t\\trequire(_feeDestination != address(0) || protocolFeePercent == 0, \\\"protocolFeePercent must be set to zero first\\\");\\n\\n\\t\\t// update contract's state\\n\\t\\tprotocolFeeDestination = _feeDestination;\\n\\n\\t\\t// emit an event\\n\\t\\temit ProtocolFeeUpdated(_feeDestination, protocolFeePercent, holdersFeePercent, subjectFeePercent);\\n\\t}\\n\\n\\t/**\\n\\t * @inheritdoc SharesFactory\\n\\t */\\n\\tfunction setProtocolFeePercent(uint64 _feePercent) public {\\n\\t\\t// verify the access permission\\n\\t\\trequire(isSenderInRole(ROLE_PROTOCOL_FEE_MANAGER), \\\"access denied\\\");\\n\\t\\t// verify state change doesn't result into the discrepancy\\n\\t\\trequire(_feePercent == 0 || protocolFeeDestination != address(0), \\\"protocolFeeDestination must be set first\\\");\\n\\t\\t// verify the fee is not mistakenly too small or big (0.00000001%, 30%)\\n\\t\\trequire(_feePercent == 0 || _feePercent > 1000000 && _feePercent < 300000000000000000, \\\"malformed fee percent\\\");\\n\\n\\t\\t// update contract's state\\n\\t\\tprotocolFeePercent = _feePercent;\\n\\n\\t\\t// emit an event\\n\\t\\temit ProtocolFeeUpdated(protocolFeeDestination, _feePercent, holdersFeePercent, subjectFeePercent);\\n\\t}\\n\\n\\t/**\\n\\t * @inheritdoc SharesFactory\\n\\t */\\n\\tfunction setHoldersFeePercent(uint64 _feePercent) public {\\n\\t\\t// verify the access permission\\n\\t\\trequire(isSenderInRole(ROLE_HOLDERS_FEE_MANAGER), \\\"access denied\\\");\\n\\t\\t// verify the fee is not mistakenly too small or big (0.00000001%, 30%)\\n\\t\\trequire(_feePercent == 0 || _feePercent > 1000000 && _feePercent < 300000000000000000, \\\"malformed fee percent\\\");\\n\\n\\t\\t// update contract's state\\n\\t\\tholdersFeePercent = _feePercent;\\n\\n\\t\\t// emit an event\\n\\t\\temit ProtocolFeeUpdated(protocolFeeDestination, protocolFeePercent, _feePercent, subjectFeePercent);\\n\\t}\\n\\n\\t/**\\n\\t * @inheritdoc SharesFactory\\n\\t */\\n\\tfunction setSubjectFeePercent(uint64 _feePercent) public {\\n\\t\\t// verify the access permission\\n\\t\\trequire(isSenderInRole(ROLE_SUBJECT_FEE_MANAGER), \\\"access denied\\\");\\n\\t\\t// verify the fee is not mistakenly too small or big (0.00000001%, 30%)\\n\\t\\trequire(_feePercent == 0 || _feePercent > 1000000 && _feePercent < 300000000000000000, \\\"malformed fee percent\\\");\\n\\n\\t\\t// update contract's state\\n\\t\\tsubjectFeePercent = _feePercent;\\n\\n\\t\\t// emit an event\\n\\t\\temit ProtocolFeeUpdated(protocolFeeDestination, protocolFeePercent, holdersFeePercent, _feePercent);\\n\\t}\\n\\n\\t/**\\n\\t * @inheritdoc SharesFactory\\n\\t */\\n\\tfunction setProtocolFee(\\n\\t\\taddress _protocolFeeDestination,\\n\\t\\tuint64 _protocolFeePercent,\\n\\t\\tuint64 _holdersFeePercent,\\n\\t\\tuint64 _subjectFeePercent\\n\\t) public {\\n\\t\\t// verify the access permission\\n\\t\\trequire(isSenderInRole(ROLE_PROTOCOL_FEE_MANAGER | ROLE_HOLDERS_FEE_MANAGER | ROLE_SUBJECT_FEE_MANAGER), \\\"access denied\\\");\\n\\n\\t\\t// verify state change doesn't result into the discrepancy\\n\\t\\trequire(_protocolFeePercent == 0 || _protocolFeeDestination != address(0), \\\"zero address\\\");\\n\\t\\t// verify the fee is not mistakenly too small or big (0.00000001%, 30%)\\n\\t\\trequire(\\n\\t\\t\\t(_protocolFeePercent == 0 || _protocolFeePercent > 1000000 && _protocolFeePercent < 300000000000000000)\\n\\t\\t\\t&& (_holdersFeePercent == 0 || _holdersFeePercent > 1000000 && _holdersFeePercent < 300000000000000000)\\n\\t\\t\\t&& (_subjectFeePercent == 0 || _subjectFeePercent > 1000000 && _subjectFeePercent < 300000000000000000),\\n\\t\\t\\t\\\"malformed fee percent\\\"\\n\\t\\t);\\n\\n\\t\\t// update contract's state\\n\\t\\tprotocolFeeDestination = _protocolFeeDestination;\\n\\t\\tprotocolFeePercent = _protocolFeePercent;\\n\\t\\tholdersFeePercent = _holdersFeePercent;\\n\\t\\tsubjectFeePercent = _subjectFeePercent;\\n\\n\\t\\t// emit an event\\n\\t\\temit ProtocolFeeUpdated(_protocolFeeDestination, _protocolFeePercent, _holdersFeePercent, _subjectFeePercent);\\n\\t}\\n\\n\\t/**\\n\\t * @inheritdoc SharesFactory\\n\\t */\\n\\tfunction deploySharesContractPaused(\\n\\t\\tImplementationType _implementationType,\\n\\t\\tTradeableShares.SharesSubject calldata _sharesSubject\\n\\t) public returns(TradeableShares) {\\n\\t\\t// delegate to `deploySharesContractAndBuy`\\n\\t\\treturn deploySharesContractAndBuy(_implementationType, _sharesSubject, 0);\\n\\t}\\n\\n\\t/**\\n\\t * @inheritdoc SharesFactory\\n\\t */\\n\\tfunction deploySharesContract(\\n\\t\\tImplementationType _implementationType,\\n\\t\\tTradeableShares.SharesSubject calldata _sharesSubject\\n\\t) public returns(TradeableShares) {\\n\\t\\t// delegate to `deploySharesContractAndBuy`\\n\\t\\treturn deploySharesContractAndBuy(_implementationType, _sharesSubject, 1);\\n\\t}\\n\\n\\t/**\\n\\t * @inheritdoc SharesFactory\\n\\t */\\n\\tfunction deploySharesContractAndBuy(\\n\\t\\tImplementationType _implementationType,\\n\\t\\tTradeableShares.SharesSubject calldata _sharesSubject,\\n\\t\\tuint256 _amount\\n\\t) public payable returns(TradeableShares) {\\n\\t\\t// delegate to `mintSubjectAndDeployShares`\\n\\t\\treturn mintSubjectAndDeployShares(_implementationType, _sharesSubject, msg.sender, _amount);\\n\\t}\\n\\n\\t/**\\n\\t * @inheritdoc SharesFactory\\n\\t */\\n\\tfunction mintSubjectAndDeployShares(\\n\\t\\tImplementationType _implementationType,\\n\\t\\tTradeableShares.SharesSubject calldata _sharesSubject,\\n\\t\\taddress _issuer,\\n\\t\\tuint256 _amount\\n\\t) public payable returns(TradeableShares) {\\n\\t\\t// delegate to unsafe `__mintSubjectAndDeployShares`\\n\\t\\treturn __mintSubjectAndDeployShares(_implementationType, _sharesSubject, _issuer, _amount, msg.sender);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Deploys the TradeableShares implementation for the specified subject;\\n\\t *      allows to immediately buy any amount of shares (including zero)\\n\\t *\\n\\t * @dev Tries minting the NFT defined by the subject if it doesn't exist\\n\\t *\\n\\t * @dev Unsafe, uses the specified `_authorizedBy` to check the access permission, which\\n\\t *      is either msg.sender, or the derived signer (if used in EIP712 meta tx mode)\\n\\t *\\n\\t * @param _implementationType TradeableShares implementation type\\n\\t * @param _sharesSubject shares subject, owner of the curve\\n\\t * @param _issuer an address to mint the NFT defined by the subject if it doesn't exist\\n\\t * @param _amount how many shares to buy immediately after the deployment\\n\\t * @param _authorizedBy must be either msg.sender or EIP712 signer if executed by the relayer\\n\\t * @return deployed TradeableShares contract\\n\\t */\\n\\tfunction __mintSubjectAndDeployShares(\\n\\t\\tImplementationType _implementationType,\\n\\t\\tTradeableShares.SharesSubject calldata _sharesSubject,\\n\\t\\taddress _issuer,\\n\\t\\tuint256 _amount,\\n\\t\\taddress _authorizedBy\\n\\t) private returns(TradeableShares) {\\n\\t\\t// verify deployments are enabled\\n\\t\\trequire(isFeatureEnabled(FEATURE_SHARES_DEPLOYMENT_ENABLED), \\\"shares deployments disabled\\\");\\n\\n\\t\\t// verify paused deployments are enabled\\n\\t\\trequire(\\n\\t\\t\\t// zero amount means paused deployment\\n\\t\\t\\t_amount != 0 || isFeatureEnabled(FEATURE_ALLOW_PAUSED_DEPLOYMENTS)\\n\\t\\t\\t\\t// we do not allow to bypass the feature with meta-tx\\n\\t\\t\\t\\t|| isSenderInRole(ROLE_SHARES_REGISTRAR),\\n\\t\\t\\t\\\"paused deployments disabled\\\"\\n\\t\\t);\\n\\n\\t\\t// verify exclusive buys are enabled (if exclusive buy is requested)\\n\\t\\trequire(\\n\\t\\t\\t_amount <= 1 || isFeatureEnabled(FEATURE_ALLOW_EXCLUSIVE_BUY)\\n\\t\\t\\t\\t// we do not allow to bypass the feature with meta-tx\\n\\t\\t\\t\\t|| isSenderInRole(ROLE_SHARES_REGISTRAR),\\n\\t\\t\\t\\\"exclusive buys disabled\\\"\\n\\t\\t);\\n\\n\\t\\t// determine the issuer\\n\\t\\taddress issuer = _sharesSubject.getSharesIssuer();\\n\\n\\t\\t// verify the access permission:\\n\\t\\t// contract can be deployed either by the shares subject owner, or by the shares registrar\\n\\t\\trequire(\\n\\t\\t\\t// contract can be deployed either by the shares subject owner\\n\\t\\t\\tmsg.sender == issuer\\n\\t\\t\\t// or by the shares registrar (role)\\n\\t\\t\\t|| isOperatorInRole(_authorizedBy, ROLE_SHARES_REGISTRAR)\\n\\t\\t\\t// or by the ERC721 contract owner\\n\\t\\t\\t|| _authorizedBy == _sharesSubject.getCollectionOwner(),\\n\\t\\t\\t\\\"access denied\\\"\\n\\t\\t);\\n\\n\\t\\t// if issuer couldn't determined, we might need to mint the corresponding NFT\\n\\t\\tif(issuer == address(0)) {\\n\\t\\t\\t// ensure the address to mint to is defined\\n\\t\\t\\t// if not - we cannot mint, but the error is in the shares subject in the first place\\n\\t\\t\\trequire(_issuer != address(0), \\\"invalid subject\\\");\\n\\t\\t\\t// try to mint, we expect this function to fail in case of an error\\n\\t\\t\\tMintableERC721(_sharesSubject.tokenAddress).mint(_issuer, _sharesSubject.tokenId);\\n\\t\\t\\t// set the issuer to the address NFT was minted to\\n\\t\\t\\tissuer = _issuer;\\n\\t\\t}\\n\\n\\t\\t// at this point issuer cannot be zero, but it can be different from msg.sender\\n\\t\\t// assert(issuer != address(0));\\n\\n\\t\\t// get shares implementation address for the implementation type specified\\n\\t\\taddress sharesImplAddress = getSharesImplAddress(_implementationType);\\n\\n\\t\\t// verify the implementation address is registered for the implementation type specified\\n\\t\\trequire(sharesImplAddress != address(0), \\\"implementation not registered\\\");\\n\\n\\t\\t// \\\"clone\\\" the impl (deploy a minimalistic EIP-1167 proxy)\\n\\t\\tTradeableShares sharesContract = TradeableShares(Clones.clone(sharesImplAddress));\\n\\n\\t\\t// get holders rewards distributor implementation address for the implementation type specified\\n\\t\\taddress distributorImplAddress = getDistributorImplAddress(_implementationType);\\n\\n\\t\\t// distributorImplAddress can be zero, in this case we will deploy the shares\\n\\t\\t// without the HoldersRewardsDistributor attached to the contract\\n\\t\\tHoldersRewardsDistributor distributorContract = HoldersRewardsDistributor(address(0));\\n\\n\\t\\t// if distributorImplAddress is defined, clone and initialize the HoldersRewardsDistributor\\n\\t\\tif(distributorImplAddress != address(0)) {\\n\\t\\t\\t// \\\"clone\\\" the impl (deploy a minimalistic EIP-1167 proxy)\\n\\t\\t\\tdistributorContract = HoldersRewardsDistributor(Clones.clone(distributorImplAddress));\\n\\n\\t\\t\\t// proxy initialization logic is implementation dependent\\n\\t\\t\\tHoldersRewardsDistributorV1(payable(address(distributorContract))).postConstruct(\\n\\t\\t\\t\\tsharesOwnerAddress,\\n\\t\\t\\t\\taddress(sharesContract),\\n\\t\\t\\t\\t_implementationType == ImplementationType.ETH? address(0): address(paymentToken)\\n\\t\\t\\t);\\n\\t\\t}\\n\\n\\t\\t// initialize TradeableShares EIP-1167 proxy\\n\\t\\t__initSharesContract(sharesContract, distributorContract, _implementationType, _sharesSubject, _amount, issuer);\\n\\n\\t\\t// verify the shares subject is not yet mapped (not in use)\\n\\t\\tbytes32 sharesKey = _sharesSubject.getSharesKey();\\n\\t\\trequire(address(shares[sharesKey]) == address(0), \\\"subject in use\\\");\\n\\n\\t\\t// register the deployed implementation into the mappings\\n\\t\\tshares[sharesKey] = sharesContract;\\n\\t\\tsubjects[address(sharesContract)] = _sharesSubject;\\n\\n\\t\\t// emit an event\\n\\t\\temit SharesContractRegistered(issuer, sharesContract, distributorContract, _implementationType, _sharesSubject, true);\\n\\n\\t\\t// return the result - deployed address\\n\\t\\treturn sharesContract;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Part of the `__mintSubjectAndDeployShares` routine moved into\\n\\t *      a separate routine to fix the \\\"Stack too deep\\\" issue\\n\\t */\\n\\tfunction __initSharesContract(\\n\\t\\tTradeableShares _sharesContract,\\n\\t\\tHoldersRewardsDistributor _distributorContract,\\n\\t\\tImplementationType _implementationType,\\n\\t\\tTradeableShares.SharesSubject calldata _sharesSubject,\\n\\t\\tuint256 _amount,\\n\\t\\taddress _beneficiary\\n\\t) private {\\n\\t\\t// determine the effective shares holders fee percent\\n\\t\\t// this also caches the fee on stack and saves a bit of gas\\n\\t\\tuint64 _holdersFeePercent = address(_distributorContract) == address(0)? 0: holdersFeePercent;\\n\\n\\t\\t// proxy initialization logic is implementation dependent\\n\\t\\t// switch(_implementationType)\\n\\t\\tif(_implementationType == ImplementationType.ETH) {\\n\\t\\t\\t// initialize the Ethereum version by invoking the postConstruct on the proxy\\n\\t\\t\\tETHShares(address(_sharesContract)).postConstruct{value: msg.value}(\\n\\t\\t\\t\\tsharesOwnerAddress,\\n\\t\\t\\t\\t_sharesSubject,\\n\\t\\t\\t\\tprotocolFeeDestination,\\n\\t\\t\\t\\tprotocolFeePercent,\\n\\t\\t\\t\\t_distributorContract,\\n\\t\\t\\t\\t_holdersFeePercent,\\n\\t\\t\\t\\tsubjectFeePercent,\\n\\t\\t\\t\\t_amount,\\n\\t\\t\\t\\t_beneficiary\\n\\t\\t\\t);\\n\\t\\t}\\n\\t\\telse if(_implementationType == ImplementationType.ERC20) {\\n\\t\\t\\t// factory doesn't support sending the change back\\n\\t\\t\\trequire(msg.value == 0, \\\"non-zero value\\\");\\n\\n\\t\\t\\t// if there is a request of the immediate shares buy\\n\\t\\t\\tif(_amount > 1) {\\n\\t\\t\\t\\t// determine how much tokens we need\\n\\t\\t\\t\\tuint256 toPay = _sharesContract.getBuyPriceAfterFee(0, _amount, protocolFeePercent, _holdersFeePercent, subjectFeePercent);\\n\\t\\t\\t\\t// get the tokens required to buy\\n\\t\\t\\t\\trequire(paymentToken.transferFrom(msg.sender, address(this), toPay));\\n\\t\\t\\t\\t// approve the tokens to be spent\\n\\t\\t\\t\\trequire(paymentToken.approve(address(_sharesContract), toPay));\\n\\t\\t\\t}\\n\\n\\t\\t\\t// initialize the ERC20 version with the ERC20 as a payment token by invoking the postConstruct on the proxy\\n\\t\\t\\tERC20Shares(address(_sharesContract)).postConstruct(\\n\\t\\t\\t\\tsharesOwnerAddress,\\n\\t\\t\\t\\t_sharesSubject,\\n\\t\\t\\t\\tprotocolFeeDestination,\\n\\t\\t\\t\\tprotocolFeePercent,\\n\\t\\t\\t\\t_distributorContract,\\n\\t\\t\\t\\t_holdersFeePercent,\\n\\t\\t\\t\\tsubjectFeePercent,\\n\\t\\t\\t\\t_amount,\\n\\t\\t\\t\\t_beneficiary,\\n\\t\\t\\t\\tpaymentToken\\n\\t\\t\\t);\\n\\n\\t\\t\\t// if there was a request of the immediate shares buy\\n\\t\\t\\tif(_amount > 1) {\\n\\t\\t\\t\\t// transfer the remaining tokens (if any) back to the sender\\n\\t\\t\\t\\trequire(paymentToken.transfer(msg.sender, paymentToken.balanceOf(address(this))));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\t// throw if the implementation type is unknown\\n\\t\\t\\t// this must be an unreachable else block because the if-else blocks above\\n\\t\\t\\t// should have been taken care about all possible implementation types\\n\\t\\t\\trevert(\\\"unknown implementation type\\\");\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * @inheritdoc SharesFactory\\n\\t */\\n\\tfunction executeDeploymentRequest(\\n\\t\\tSharesDeploymentRequest calldata req,\\n\\t\\tbytes calldata signature\\n\\t) public payable returns(TradeableShares) {\\n\\t\\t// verify the request validity\\n\\t\\trequire(req.validFromTimestamp <= block.timestamp, \\\"not yet valid\\\");\\n\\t\\trequire(req.expiresAtTimestamp > block.timestamp, \\\"expired\\\");\\n\\n\\t\\t// verify and use nonce\\n\\t\\t__useNonce(req.issuer, req.nonce);\\n\\n\\t\\t// derive the request signer\\n\\t\\t// this also verifies that the signature is valid\\n\\t\\taddress signer = _hashTypedDataV4(req.hashStruct()).recover(signature);\\n\\n\\t\\t// delegate to unsafe `__mintSubjectAndDeployShares`\\n\\t\\treturn __mintSubjectAndDeployShares(req.implementationType, req.sharesSubject, req.issuer, req.amount, signer);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Verifies the nonce is valid and marks it as used\\n\\t *      Throws if nonce is already used or if it is invalid\\n\\t *\\n\\t * @param _issuer the owner of the nonce\\n\\t * @param _nonce the nonce to be used\\n\\t */\\n\\tfunction __useNonce(address _issuer, uint256 _nonce) private {\\n\\t\\t// verify the nonce wasn't yet used and use it\\n\\t\\trequire(nonces[_issuer]++ == _nonce, \\\"invalid nonce\\\");\\n\\n\\t\\t// emit an event\\n\\t\\temit NonceUsed(_issuer, _nonce);\\n\\t}\\n\\n\\t/**\\n\\t * @inheritdoc SharesFactory\\n\\t */\\n\\tfunction getNonce(address _issuer) external view returns(uint256) {\\n\\t\\t// read the nonce from the storage\\n\\t\\treturn nonces[_issuer];\\n\\t}\\n\\n\\t/**\\n\\t * @inheritdoc SharesFactory\\n\\t */\\n\\tfunction rewindNonce(address _issuer, uint256 _nonce) external {\\n\\t\\t// verify the access permission\\n\\t\\trequire(isSenderInRole(ROLE_SHARES_REGISTRAR), \\\"access denied\\\");\\n\\n\\t\\t// make sure nonce is not decreasing\\n\\t\\trequire(nonces[_issuer] < _nonce, \\\"new nonce must be bigger than the current one\\\");\\n\\n\\t\\t// rewind the nonce to the value requested\\n\\t\\tnonces[_issuer] = _nonce;\\n\\n\\t\\t// emit an event\\n\\t\\temit NonceUsed(_issuer, _nonce - 1);\\n\\t}\\n\\n\\t/**\\n\\t * @inheritdoc SharesFactory\\n\\t */\\n\\tfunction lookupSharesContract(\\n\\t\\tTradeableShares.SharesSubject calldata _sharesSubject\\n\\t) public view returns(TradeableShares) {\\n\\t\\treturn shares[_sharesSubject.getSharesKey()];\\n\\t}\\n\\n\\t/**\\n\\t * @inheritdoc SharesFactory\\n\\t *\\n\\t * @dev Note: this restricted function allows the authorized address to register\\n\\t *      the shares contract with the invalid subject\\n\\t */\\n\\tfunction registerSharesContract(TradeableShares _sharesContract) external {\\n\\t\\t// verify the access permission: contract can be registered only by the shares registrar\\n\\t\\trequire(isSenderInRole(ROLE_SHARES_REGISTRAR), \\\"access denied\\\");\\n\\n\\t\\t// delegate to unsafe `__registerSharesContract`\\n\\t\\t__registerSharesContract(_sharesContract);\\n\\t}\\n\\n\\t/**\\n\\t * @inheritdoc SharesFactory\\n\\t */\\n\\tfunction notifySubjectUpdated() external {\\n\\t\\t// read the registered subject (this can be zero if not registered)\\n\\t\\tTradeableShares.SharesSubject memory registeredSubject = subjects[msg.sender];\\n\\n\\t\\t// ensure the subject is registered (we know the caller, we already registered it)\\n\\t\\trequire(!registeredSubject.isZero(), \\\"not registered\\\");\\n\\t\\t// we do not allow binding to non-existent NFTs (consistency with `__mintSubjectAndDeployShares`)\\n\\t\\trequire(TradeableShares(msg.sender).getSharesSubject().getSharesIssuer() != address(0), \\\"invalid subject\\\");\\n\\n\\t\\t// delegate to unsafe `__registerSharesContract`\\n\\t\\t__registerSharesContract(TradeableShares(msg.sender));\\n\\t}\\n\\n\\t/**\\n\\t * @dev Registers the TradeableShares contract;\\n\\t *      unsafe, doesn't verify the access permissions, must be kept private at all times\\n\\t *\\n\\t * @param _sharesContract TradeableShares contract to register\\n\\t */\\n\\tfunction __registerSharesContract(TradeableShares _sharesContract) private {\\n\\t\\t// determine current shares subject\\n\\t\\tTradeableShares.SharesSubject memory sharesSubject = _sharesContract.getSharesSubject();\\n\\t\\t// this contract may had already been registered under the different subject\\n\\t\\tTradeableShares.SharesSubject memory registeredSubject = subjects[address(_sharesContract)];\\n\\n\\t\\t// if it was already registered and subject didn't change there is nothing to do\\n\\t\\tif(sharesSubject.equals(registeredSubject)) {\\n\\t\\t\\t// exit from the function silently\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// verify the shares subject is not yet mapped (not in use)\\n\\t\\tbytes32 sharesKey = sharesSubject.getSharesKey();\\n\\t\\trequire(address(shares[sharesKey]) == address(0), \\\"subject in use\\\");\\n\\n\\t\\t// cleanup previously registered subject mapping if any\\n\\t\\tdelete shares[registeredSubject.getSharesKey()];\\n\\n\\t\\t// register the deployed implementation into the mappings\\n\\t\\tshares[sharesKey] = _sharesContract;\\n\\t\\tsubjects[address(_sharesContract)] = sharesSubject;\\n\\n\\t\\t// emit an event\\n\\t\\temit SharesContractRegistered(\\n\\t\\t\\t_sharesContract.getSharesIssuer(),\\n\\t\\t\\t_sharesContract,\\n\\t\\t\\t_sharesContract.getHoldersFeeDestination(),\\n\\t\\t\\tdetermineImplementationType(_sharesContract),\\n\\t\\t\\t_sharesContract.getSharesSubject(),\\n\\t\\t\\tfalse\\n\\t\\t);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Tries to determine the implementation type of the already deployed TradeableShares contract;\\n\\t *      the result should not be considered reliable and can be used only as a hint\\n\\t *\\n\\t * @param _sharesContract deployed TradeableShares instance\\n\\t * @return implementation type of the instance specified\\n\\t */\\n\\tfunction determineImplementationType(TradeableShares _sharesContract) public view returns(ImplementationType) {\\n\\t\\t// determine the implementation type\\n\\t\\tImplementationType implementationType;\\n\\n\\t\\t// try to treat the implementation as ERC20\\n\\t\\ttry ERC20Shares(address(_sharesContract)).getPaymentToken() returns (ERC1363 token) {\\n\\t\\t\\t// for the ERC20Shares impl we support only ERC20 token known to factory\\n\\t\\t\\trequire(token == paymentToken, \\\"unknown ERC20 implementation type\\\");\\n\\n\\t\\t\\t// implementation type is successfully determined as ERC20\\n\\t\\t\\timplementationType = ImplementationType.ERC20;\\n\\t\\t}\\n\\t\\tcatch {\\n\\t\\t\\t// fallback to ETH\\n\\t\\t\\timplementationType = ImplementationType.ETH;\\n\\t\\t}\\n\\n\\t\\t// return the result\\n\\t\\treturn implementationType;\\n\\t}\\n}\\n\",\"keccak256\":\"0x2c7803df57d9166eae8bd73d575342891eeff3c85a86c93568f75a26f22b8940\",\"license\":\"MIT\"},\"contracts/bonding_curves/SharesSubjectLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"../interfaces/ERC721Spec.sol\\\";\\nimport \\\"../interfaces/ERC721SpecExt.sol\\\";\\nimport \\\"./TradeableShares.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n/**\\n * @title Shares Subject Library\\n *\\n * @notice Auxiliary functions to work with SharesSubject struct\\n */\\nlibrary SharesSubjectLib {\\n\\t/**\\n\\t * @notice Determines current owner of the shares subject, which is a corresponding NFT owner\\n\\t *\\n\\t * @dev This function returns zero address if NFT doesn't exist, or even if NFT contract doesn't exist\\n\\t *\\n\\t * @param sharesSubject shares subject, owner of the curve\\n\\t * @return address of the issuer, underlying NFT owner; or zero address\\n\\t */\\n\\tfunction getSharesIssuer(TradeableShares.SharesSubject memory sharesSubject) internal view returns(address) {\\n\\t\\t// we have to check if the address is callable, otherwise staticall would throw\\n\\t\\tif(isCallable(sharesSubject.tokenAddress)) {\\n\\t\\t\\t// try to avoid an exception / failed call in the ownerOf function by checking NFT existence first\\n\\t\\t\\t// this is required *only* to avoid \\\"partially failed\\\" transaction display on etherscan\\n\\t\\t\\t{\\n\\t\\t\\t\\t// we use staticcall instead of ABI function call to guaranty immutable call\\n\\t\\t\\t\\t(bool success, bytes memory data) = sharesSubject.tokenAddress.staticcall{gas: 4900}(\\n\\t\\t\\t\\t\\t// MintableERC721 interface: function exists(uint256) external view returns(bool)\\n\\t\\t\\t\\t\\tabi.encodeWithSelector(MintableERC721.exists.selector, sharesSubject.tokenId)\\n\\t\\t\\t\\t);\\n\\t\\t\\t\\t// only if the call was successful\\n\\t\\t\\t\\tif(success) {\\n\\t\\t\\t\\t\\t// try to decode the result as a bool,\\n\\t\\t\\t\\t\\t// and if we know for sure token doesn't exist,\\n\\t\\t\\t\\t\\tif(!abi.decode(data, (bool))) {\\n\\t\\t\\t\\t\\t\\t// just return zero address as a default result in case of any error\\n\\t\\t\\t\\t\\t\\treturn address(0);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// try to get the ERC721 owner of the underlying NFT\\n\\t\\t\\t{\\n\\t\\t\\t\\t// we use staticcall instead of ABI function call to guaranty immutable call\\n\\t\\t\\t\\t(bool success, bytes memory data) = sharesSubject.tokenAddress.staticcall{gas: 4900}(\\n\\t\\t\\t\\t\\t// ERC721 interface: function ownerOf(uint256) external view returns(address)\\n\\t\\t\\t\\t\\tabi.encodeWithSelector(ERC721.ownerOf.selector, sharesSubject.tokenId)\\n\\t\\t\\t\\t);\\n\\t\\t\\t\\t// only if the call was successful\\n\\t\\t\\t\\tif(success) {\\n\\t\\t\\t\\t\\t// try to decode the result as an address and return\\n\\t\\t\\t\\t\\treturn abi.decode(data, (address));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// return the default zero address value in case of any errors\\n\\t\\treturn address(0);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Determines the owner of the shares subject's underlying NFT collection\\n\\t *\\n\\t * @dev This function returns zero address if the underlying ERC721 contract is not OZ ownable\\n\\t *      (doesn't have `owner()` function), doesn't exist, or if any other error occurs\\n\\t *\\n\\t * @param sharesSubject shares subject, owner of the curve\\n\\t * @return address of the NFT collection owner (OZ ownable); or zero address\\n\\t */\\n\\tfunction getCollectionOwner(TradeableShares.SharesSubject memory sharesSubject) internal view returns(address) {\\n\\t\\t// we have to check if the address is callable, otherwise staticall would throw\\n\\t\\tif(isCallable(sharesSubject.tokenAddress)) {\\n\\t\\t\\t// try to derive the owner via the OZ Ownable interface owner()\\n\\t\\t\\t// we use staticcall instead of ABI function call to guaranty immutable call\\n\\t\\t\\t(bool success, bytes memory data) = sharesSubject.tokenAddress.staticcall{gas: 4900}(\\n\\t\\t\\t\\t// OZ Ownable interface: function owner() external view returns(address)\\n\\t\\t\\t\\tabi.encodeWithSelector(Ownable.owner.selector)\\n\\t\\t\\t);\\n\\n\\t\\t\\t// only if the call was successful\\n\\t\\t\\tif(success) {\\n\\t\\t\\t\\t// try to decode the result as an address and return\\n\\t\\t\\t\\treturn abi.decode(data, (address));\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// return the default zero address value in case of any errors\\n\\t\\treturn address(0);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Calculates the keccak256 bytes32 key for the shares subject to be used in the mappings\\n\\t *\\n\\t * @param sharesSubject shares subject, owner of the curve\\n\\t * @return keccak256 of the shares subject\\n\\t */\\n\\tfunction getSharesKey(TradeableShares.SharesSubject memory sharesSubject) internal pure returns(bytes32) {\\n\\t\\t// calculate the keccak256 from the concatenated internals of the SharesSubject struct\\n\\t\\treturn keccak256(abi.encode(sharesSubject.tokenAddress, sharesSubject.tokenId));\\n\\t}\\n\\n\\t/**\\n\\t * @notice Checks if two subjects - subject 1 and subject 2 - are equal\\n\\t *      Returns false if any of the subjects is not initialized (have zero ERC721 address)\\n\\t *\\n\\t * @param sharesSubject1 subject 1\\n\\t * @param sharesSubject2 subject 2\\n\\t * @return true if subject 1 and subject 2 are equal\\n\\t */\\n\\tfunction equals(\\n\\t\\tTradeableShares.SharesSubject memory sharesSubject1,\\n\\t\\tTradeableShares.SharesSubject memory sharesSubject2\\n\\t) internal pure returns(bool) {\\n\\t\\treturn sharesSubject1.tokenAddress != address(0)\\n\\t\\t\\t&& sharesSubject1.tokenAddress == sharesSubject2.tokenAddress\\n\\t\\t\\t&& sharesSubject1.tokenId == sharesSubject2.tokenId;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Verifies if the shares subject contains a value; this function is useful\\n\\t *      to check if the value in storage (mapping) was initialized\\n\\t *\\n\\t * @param sharesSubject the shares subject to check\\n\\t * @return true if the subject has a value, false otherwise (zero value)\\n\\t */\\n\\tfunction isZero(TradeableShares.SharesSubject memory sharesSubject) internal pure returns(bool) {\\n\\t\\treturn sharesSubject.tokenAddress == address(0) && sharesSubject.tokenId == 0;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Checks if account can be called (is callable, already deployed contract)\\n\\t *\\n\\t * @dev Verifies if the bytecode on the specified address is present\\n\\t *\\n\\t * @param account an address to check\\n\\t * @return true if address denotes already deployed callable contract\\n\\t */\\n\\tfunction isCallable(address account) internal view returns(bool) {\\n\\t\\t// This method relies on extcodesize, which returns 0 for contracts in\\n\\t\\t// construction, since the code is only stored at the end of the\\n\\t\\t// constructor execution.\\n\\n\\t\\tuint256 size;\\n\\t\\tassembly {\\n\\t\\t\\tsize := extcodesize(account)\\n\\t\\t}\\n\\t\\treturn size > 0;\\n\\t}\\n}\\n\",\"keccak256\":\"0x98a257a6e47d79774accc47a12ac2b2b070410c9962a4fa0ea188be652138a56\",\"license\":\"MIT\"},\"contracts/bonding_curves/TradeableShares.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"./BondingCurve.sol\\\";\\nimport \\\"./HoldersRewardsDistributor.sol\\\";\\n\\n/**\\n * @title Tradeable Shares\\n *\\n * @notice Tradeable shares is a non-transferable, but buyable/sellable fungible token-like asset,\\n *      which is sold/bought solely by the shares contract at the predefined by\\n *      the bonding curve function price\\n *\\n * @notice The shares is bound to its \\\"subject\\\" \\u2013 an NFT; the NFT owner gets the subject fee\\n *      emerging in every buy/sell operation\\n *\\n * @dev Based on the friend.tech FriendtechSharesV1.sol\\n */\\ninterface TradeableShares is BondingCurve {\\n\\t/**\\n\\t * @notice Shares subject is an NFT defined by its ERC721 contract address and NFT ID\\n\\t *       Note: this is different from the original FriendTech implementation where\\n\\t *       shares subject is always equal to the issuer address\\n\\t */\\n\\tstruct SharesSubject {\\n\\t\\t/// @dev ERC721 contract address\\n\\t\\taddress tokenAddress;\\n\\n\\t\\t/// @dev NFT ID\\n\\t\\tuint256 tokenId;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Fired in `buyShares` and `sellShares` functions, this event logs\\n\\t *      the entire trading activity happening on the curve\\n\\t *\\n\\t * @dev Trader, that is the buyer or seller, depending on the operation type is the transaction sender\\n\\t *\\n\\t * @param beneficiary the address which receives shares or funds, usually this is the trader itself\\n\\t * @param issuer subject issuer, usually an owner of the NFT defined by the subject\\n\\t * @param isBuy true if the event comes from the `buyShares` and represents the buy operation,\\n\\t *      false if the event comes from the `sellShares` and represents the sell operation\\n\\t * @param sharesAmount amount of the shares bought or sold (see `isBuy`)\\n\\t * @param paidAmount amount of ETH spent or gained by the buyer or seller;\\n\\t *      this is implementation dependent and can represent an amount of ERC20 payment token\\n\\t * @param protocolFeeAmount amount of fees paid to the protocol\\n\\t * @param holdersFeeAmount amount of fees paid to the shares holders\\n\\t * @param subjectFeeAmount amount of fees paid to the subject (issuer)\\n\\t * @param supply total shares supply after the operation\\n\\t */\\n\\tevent Trade(\\n\\t\\taddress indexed beneficiary,\\n\\t\\taddress indexed issuer,\\n\\t\\tbool indexed isBuy,\\n\\t\\tuint256 sharesAmount,\\n\\t\\tuint256 paidAmount,\\n\\t\\tuint256 protocolFeeAmount,\\n\\t\\tuint256 holdersFeeAmount,\\n\\t\\tuint256 subjectFeeAmount,\\n\\t\\tuint256 supply\\n\\t);\\n\\n\\t/**\\n\\t * @notice Shares subject, usually defined as NFT (ERC721 contract address + NFT ID)\\n\\t *\\n\\t * @dev Immutable, client applications may cache this value\\n\\t *\\n\\t * @return Shares subject as a SharesSubject struct, this is an NFT if all currently known implementations\\n\\t */\\n\\tfunction getSharesSubject() external view returns(SharesSubject calldata);\\n\\n\\t/**\\n\\t * @notice Protocol fee destination, the address protocol fee is sent to\\n\\t *\\n\\t * @dev Mutable, can be changed by the protocol fee manager\\n\\t *\\n\\t * @return the address where the protocol fee is sent to\\n\\t */\\n\\tfunction getProtocolFeeDestination() external view returns(address);\\n\\n\\t/**\\n\\t * @notice Protocol fee percent, applied to all the buy and sell operations;\\n\\t *      the fee percent is defined with the 18 decimals, 10^18 corresponds to 100%\\n\\t *\\n\\t * @notice Protocol fee is sent to the protocol fee destination (see `getProtocolFeeDestination`)\\n\\t *\\n\\t * @dev Immutable, client applications may cache this value\\n\\t *\\n\\t * @return protocol fee percent with the 18 decimals (10^18 is 100%)\\n\\t */\\n\\tfunction getProtocolFeePercent() external view returns(uint256);\\n\\n\\t/**\\n\\t * @notice Protocol fee destination and protocol fee percent as a tuple;\\n\\t *      the fee percent is defined with the 18 decimals, 10^18 corresponds to 100%\\n\\t *\\n\\t * @dev Implementation must always return zero fee percent if fee destination is zero address\\n\\t *\\n\\t * @return feeDestination protocol fee destination\\n\\t * @return feePercent protocol fee percent, zero if protocol fee destination is zero\\n\\t */\\n\\tfunction getProtocolFeeInfo() external view returns(address feeDestination, uint256 feePercent);\\n\\n\\t/**\\n\\t * @notice Shares holders reward distributor contract attached to the shares contract\\n\\t *      in order to receive its portion of the fees to be distributed among the shares holders\\n\\t *\\n\\t * @dev Immutable, client applications may cache this value; holders fee destination is not\\n\\t *      an arbitrary address capable of receiving ETH or ERC20, but a HoldersRewardsDistributor\\n\\t *      smart contract, which not only receives the fees but also receives updated on the\\n\\t *      trading activity in the shares contract\\n\\t *\\n\\t * @return the contract where the holders fee is sent to\\n\\t */\\n\\tfunction getHoldersFeeDestination() external view returns(HoldersRewardsDistributor);\\n\\n\\t/**\\n\\t * @notice Shares holders fee percent, applied to all the buy and sell operations;\\n\\t *      the fee percent is defined with the 18 decimals, 10^18 corresponds to 100%\\n\\t *\\n\\t * @notice Shares holders fee is sent to the holders fee destination (see `getHoldersFeeDestination`)\\n\\t *\\n\\t * @dev Immutable, client applications may cache this value\\n\\t *\\n\\t * @return shares holders fee percent with the 18 decimals (10^18 is 100%)\\n\\t */\\n\\tfunction getHoldersFeePercent() external view returns(uint256);\\n\\n\\t/**\\n\\t * @notice Shares holders fee destination and shares holders fee percent as a tuple;\\n\\t *      the fee percent is defined with the 18 decimals, 10^18 corresponds to 100%\\n\\t *\\n\\t * @dev Implementation must always return zero fee percent if fee destination is zero\\n\\t *\\n\\t * @return feeDestination shares holders fee destination\\n\\t * @return feePercent shares holders fee percent, zero if holders fee destination is zero\\n\\t */\\n\\tfunction getHoldersFeeInfo() external view returns(HoldersRewardsDistributor feeDestination, uint256 feePercent);\\n\\n\\t/**\\n\\t * @notice Subject fee destination and subject fee percent as a tuple;\\n\\t *      subject fee destination is shares issuer address;\\n\\t *      the fee percent is defined with the 18 decimals, 10^18 corresponds to 100%;\\n\\t *\\n\\t * @dev Implementation must always return zero fee percent if fee destination is zero address\\n\\t *\\n\\t * @return feeDestination protocol fee destination\\n\\t * @return feePercent protocol fee percent, zero if subject fee destination is zero\\n\\t */\\n\\tfunction getSubjectFeeInfo() external view returns(address feeDestination, uint256 feePercent);\\n\\n\\t/**\\n\\t * @notice Subject fee percent, applied to all the buy and sell operations,\\n\\t *      the fee percent is defined with the 18 decimals, 10^18 corresponds to 100%\\n\\t *\\n\\t * @notice Subject fee is sent to the subject fee issuer (see `getSharesIssuer`)\\n\\t *\\n\\t * @dev Immutable, client applications may cache this value\\n\\t *\\n\\t * @return subject fee percent with the 18 decimals (10^18 is 100%)\\n\\t */\\n\\tfunction getSubjectFeePercent() external view returns(uint256);\\n\\n\\t/**\\n\\t * @notice Shares issuer, the receiver of the shares fees\\n\\t *\\n\\t * @dev Mutable, changes (potentially frequently and unpredictably) when the NFT owner changes;\\n\\t *      subject to the front-run attacks, off-chain client applications must not rely on this address\\n\\t *      in anyway\\n\\t *\\n\\t * @return nftOwner subject issuer, the owner of the NFT\\n\\t */\\n\\tfunction getSharesIssuer() external view returns(address nftOwner);\\n\\n\\t/**\\n\\t * @notice Shares balance of the given holder; this function is similar to ERC20.balanceOf()\\n\\t *\\n\\t * @param holder the address to check the balance for\\n\\t *\\n\\t * @return balance number of shares the holder has\\n\\t */\\n\\tfunction getSharesBalance(address holder) external view returns(uint256 balance);\\n\\n\\t/**\\n\\t * @notice Total amount of the shares in existence, the sum of all individual shares balances;\\n\\t *      this function is similar to ERC20.totalSupply()\\n\\t *\\n\\t * @return supply total shares supply\\n\\t */\\n\\tfunction getSharesSupply() external view returns(uint256 supply);\\n\\n\\t/**\\n\\t * @notice The price of the `amount` of shares to buy calculated based on\\n\\t *      the specified total shares supply\\n\\t *\\n\\t * @param supply total shares supply\\n\\t * @param amount number of shares to buy\\n\\t * @return the price of the shares to buy\\n\\t */\\n\\tfunction getBuyPrice(uint256 supply, uint256 amount) external pure returns(uint256);\\n\\n\\t/**\\n\\t * @notice The price of the `amount` of shares to sell calculated based on\\n\\t *      the specified total shares supply\\n\\t *\\n\\t * @param supply total shares supply\\n\\t * @param amount number of shares to sell\\n\\t * @return the price of the shares to sell\\n\\t */\\n\\tfunction getSellPrice(uint256 supply, uint256 amount) external pure returns(uint256);\\n\\n\\t/**\\n\\t * @notice The price of the `amount` of shares to buy, including all fees;\\n\\t *      calculated based on the specified total shares supply and fees percentages\\n\\t *\\n\\t * @param supply total shares supply\\n\\t * @param amount number of shares to buy\\n\\t * @param protocolFeePercent protocol fee percent\\n\\t * @param holdersFeePercent shares holders fee percent\\n\\t * @param subjectFeePercent protocol fee percent\\n\\t * @return the price of the shares to buy\\n\\t */\\n\\tfunction getBuyPriceAfterFee(\\n\\t\\tuint256 supply,\\n\\t\\tuint256 amount,\\n\\t\\tuint256 protocolFeePercent,\\n\\t\\tuint256 holdersFeePercent,\\n\\t\\tuint256 subjectFeePercent\\n\\t) external pure returns(uint256);\\n\\n\\t/**\\n\\t * @notice The price of the `amount` of shares to sell, including all fees;\\n\\t *      calculated based on the specified total shares supply and fees percentages\\n\\t *\\n\\t * @param supply total shares supply\\n\\t * @param amount number of shares to sell\\n\\t * @param protocolFeePercent protocol fee percent\\n\\t * @param holdersFeePercent shares holders fee percent\\n\\t * @param subjectFeePercent protocol fee percent\\n\\t * @return the price of the shares to sell\\n\\t */\\n\\tfunction getSellPriceAfterFee(\\n\\t\\tuint256 supply,\\n\\t\\tuint256 amount,\\n\\t\\tuint256 protocolFeePercent,\\n\\t\\tuint256 holdersFeePercent,\\n\\t\\tuint256 subjectFeePercent\\n\\t) external pure returns(uint256);\\n\\n\\t/**\\n\\t * @notice Current price of the `amount` of shares to buy; calculated based on\\n\\t *      the current total shares supply\\n\\t *\\n\\t * @param amount number of shares to buy\\n\\t * @return the price of the shares to buy\\n\\t */\\n\\tfunction getBuyPrice(uint256 amount) external view returns(uint256);\\n\\n\\t/**\\n\\t * @notice Current price of the `amount` of shares to sell; calculated based on\\n\\t *      the current total shares supply\\n\\t *\\n\\t * @param amount number of shares to sell\\n\\t * @return the price of the shares to sell\\n\\t */\\n\\tfunction getSellPrice(uint256 amount) external view returns(uint256);\\n\\n\\t/**\\n\\t * @notice Current price of the `amount` of shares to buy, including all fees;\\n\\t *      calculated based on the current total shares supply and fees percentages\\n\\t *\\n\\t * @param amount number of shares to buy\\n\\t * @return the price of the shares to buy\\n\\t */\\n\\tfunction getBuyPriceAfterFee(uint256 amount) external view returns(uint256);\\n\\n\\t/**\\n\\t * @notice Current price of the `amount` of shares to sell, including all fees;\\n\\t *      calculated based on the current total shares supply and fees percentages\\n\\t *\\n\\t * @param amount number of shares to sell\\n\\t * @return the price of the shares to sell\\n\\t */\\n\\tfunction getSellPriceAfterFee(uint256 amount) external view returns(uint256);\\n\\n\\t/**\\n\\t * @notice Buy `amount` of shares. Sender has to supply `getBuyPriceAfterFee(amount)` ETH.\\n\\t *      First share can be bought only by current subject issuer.\\n\\t *\\n\\t * @dev Depending on the implementation, ERC20 token payment may be required instead of ETH.\\n\\t *      In such a case, implementation must through if ETH is sent, effectively overriding\\n\\t *      the function definition as non-payable\\n\\t *\\n\\t * @param amount amount of the shares to buy\\n\\t */\\n\\tfunction buyShares(uint256 amount) external payable;\\n\\n\\t/**\\n\\t * @notice Buy `amount` of shares in the favor of the address specified (beneficiary).\\n\\t *      Sender has to supply `getBuyPriceAfterFee(amount)` ETH.\\n\\t *      First share can be bought only by current subject issuer.\\n\\t *\\n\\t * @dev Depending on the implementation, ERC20 token payment may be required instead of ETH.\\n\\t *      In such a case, implementation must through if ETH is sent, effectively overriding\\n\\t *      the function definition as non-payable\\n\\t *\\n\\t * @param amount amount of the shares to buy\\n\\t * @param beneficiary an address receiving the shares\\n\\t */\\n\\tfunction buySharesTo(uint256 amount, address beneficiary) external payable;\\n\\n\\t/**\\n\\t * @notice Sell `amount` of shares. Sender gets `getSellPriceAfterFee(amount)` of ETH.\\n\\t *      Last share cannot be sold.\\n\\t *\\n\\t * @dev Depending on the implementation, ERC20 token may be payed instead of ETH.\\n\\t *\\n\\t * @param amount amount of the shares to sell\\n\\t */\\n\\tfunction sellShares(uint256 amount) external;\\n\\n\\t/**\\n\\t * @notice Sell `amount` of shares in the favor of the address specified (beneficiary).\\n\\t *      The beneficiary gets `getSellPriceAfterFee(amount)` of ETH.\\n\\t *      Last share cannot be sold.\\n\\t *\\n\\t * @dev Depending on the implementation, ERC20 token may be payed instead of ETH.\\n\\t *\\n\\t * @param amount amount of the shares to sell\\n\\t * @param beneficiary an address receiving the funds from the sale\\n\\t */\\n\\tfunction sellSharesTo(uint256 amount, address payable beneficiary) external;\\n\\n\\t/**\\n\\t * @notice Cumulative value of all trades; allows to derive cumulative fees paid\\n\\t *\\n\\t * @dev This value cannot decrease over time; it can increase or remain constant\\n\\t *      if no trades are happening\\n\\t *\\n\\t * @return Sum of the modulo of all trading operations\\n\\t */\\n\\tfunction getTradeVolume() external view returns(uint256);\\n}\\n\",\"keccak256\":\"0x0f8402decde54a46b1722b836f72bac480e03e37ac86613ca9b93b9997a980c2\",\"license\":\"MIT\"},\"contracts/bonding_curves/TypedStructLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"./SharesFactory.sol\\\";\\n\\n/**\\n * @title EIP712 Typed Struct Library\\n *\\n * @notice Calculates EIP712 typed structured data typeHash and hashStruct\\n */\\nlibrary TypedStructLib {\\n\\t/**\\n\\t * @notice SharesDeploymentRequest typeHash\\n\\t */\\n\\tfunction hashType(SharesFactory.SharesDeploymentRequest calldata) internal pure returns(bytes32) {\\n\\t\\t// hashType(SharesDeploymentRequest) = keccak256(\\\"SharesDeploymentRequest(ImplementationType implementationType,TradeableShares.SharesSubject sharesSubject,address issuer,uint256 amount,uint256 validFromTimestamp,uint256 expiresAtTimestamp,uint256 nonce)\\\")\\n\\t\\treturn 0x7acc9d8c19a06f50ae6d92c5e1206302e8aeac9f7f8bf014389ca2a4354650fd;\\n\\t}\\n\\n\\t/**\\n\\t * @notice SharesSubject typeHash\\n\\t */\\n\\tfunction hashType(TradeableShares.SharesSubject calldata) internal pure returns(bytes32) {\\n\\t\\t// hashType(SharesSubject) = keccak256(\\\"SharesSubject(address tokenAddress,uint256 tokenId)\\\")\\n\\t\\treturn 0x685dd8e2693cf377e50b3e95f06b61dff4c1705fa19df1071074d64f4e1469eb;\\n\\t}\\n\\n\\t/**\\n\\t * @notice SharesDeploymentRequest hashStruct\\n\\t */\\n\\tfunction hashStruct(SharesFactory.SharesDeploymentRequest calldata request) internal pure returns(bytes32) {\\n\\t\\treturn keccak256(abi.encode(\\n\\t\\t\\thashType(request),\\n\\t\\t\\trequest.implementationType,\\n\\t\\t\\thashStruct(request.sharesSubject),\\n\\t\\t\\trequest.issuer,\\n\\t\\t\\trequest.amount,\\n\\t\\t\\trequest.validFromTimestamp,\\n\\t\\t\\trequest.expiresAtTimestamp,\\n\\t\\t\\trequest.nonce\\n\\t\\t));\\n\\t}\\n\\n\\t/**\\n\\t * @notice SharesSubject hashStruct\\n\\t */\\n\\tfunction hashStruct(TradeableShares.SharesSubject calldata sharesSubject) internal pure returns(bytes32) {\\n\\t\\treturn keccak256(abi.encode(\\n\\t\\t\\thashType(sharesSubject),\\n\\t\\t\\tsharesSubject.tokenAddress,\\n\\t\\t\\tsharesSubject.tokenId\\n\\t\\t));\\n\\t}\\n\\n}\\n\",\"keccak256\":\"0x03678123c881966bf24d36fd36e10eb966aa93a0692b5bd0348b957c02913704\",\"license\":\"MIT\"},\"contracts/interfaces/ERC1363Spec.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"./ERC20Spec.sol\\\";\\nimport \\\"./ERC165Spec.sol\\\";\\n\\n/**\\n * @title ERC1363 Interface\\n *\\n * @dev Interface defining a ERC1363 Payable Token contract.\\n *      Implementing contracts MUST implement the ERC1363 interface as well as the ERC20 and ERC165 interfaces.\\n */\\ninterface ERC1363 is ERC20, ERC165  {\\n\\t/*\\n\\t * Note: the ERC-165 identifier for this interface is 0xb0202a11.\\n\\t * 0xb0202a11 ===\\n\\t *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\\n\\t *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\\n\\t *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\\n\\t *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\\n\\t *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\\n\\t *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\\n\\t */\\n\\n\\t/**\\n\\t * @notice Transfer tokens from `msg.sender` to another address and then call `onTransferReceived` on receiver\\n\\t * @param to address The address which you want to transfer to\\n\\t * @param value uint256 The amount of tokens to be transferred\\n\\t * @return true unless throwing\\n\\t */\\n\\tfunction transferAndCall(address to, uint256 value) external returns (bool);\\n\\n\\t/**\\n\\t * @notice Transfer tokens from `msg.sender` to another address and then call `onTransferReceived` on receiver\\n\\t * @param to address The address which you want to transfer to\\n\\t * @param value uint256 The amount of tokens to be transferred\\n\\t * @param data bytes Additional data with no specified format, sent in call to `to`\\n\\t * @return true unless throwing\\n\\t */\\n\\tfunction transferAndCall(address to, uint256 value, bytes memory data) external returns (bool);\\n\\n\\t/**\\n\\t * @notice Transfer tokens from one address to another and then call `onTransferReceived` on receiver\\n\\t * @param from address The address which you want to send tokens from\\n\\t * @param to address The address which you want to transfer to\\n\\t * @param value uint256 The amount of tokens to be transferred\\n\\t * @return true unless throwing\\n\\t */\\n\\tfunction transferFromAndCall(address from, address to, uint256 value) external returns (bool);\\n\\n\\n\\t/**\\n\\t * @notice Transfer tokens from one address to another and then call `onTransferReceived` on receiver\\n\\t * @param from address The address which you want to send tokens from\\n\\t * @param to address The address which you want to transfer to\\n\\t * @param value uint256 The amount of tokens to be transferred\\n\\t * @param data bytes Additional data with no specified format, sent in call to `to`\\n\\t * @return true unless throwing\\n\\t */\\n\\tfunction transferFromAndCall(address from, address to, uint256 value, bytes memory data) external returns (bool);\\n\\n\\t/**\\n\\t * @notice Approve the passed address to spend the specified amount of tokens on behalf of msg.sender\\n\\t * and then call `onApprovalReceived` on spender.\\n\\t * @param spender address The address which will spend the funds\\n\\t * @param value uint256 The amount of tokens to be spent\\n\\t */\\n\\tfunction approveAndCall(address spender, uint256 value) external returns (bool);\\n\\n\\t/**\\n\\t * @notice Approve the passed address to spend the specified amount of tokens on behalf of msg.sender\\n\\t * and then call `onApprovalReceived` on spender.\\n\\t * @param spender address The address which will spend the funds\\n\\t * @param value uint256 The amount of tokens to be spent\\n\\t * @param data bytes Additional data with no specified format, sent in call to `spender`\\n\\t */\\n\\tfunction approveAndCall(address spender, uint256 value, bytes memory data) external returns (bool);\\n}\\n\\n/**\\n * @title ERC1363Receiver Interface\\n *\\n * @dev Interface for any contract that wants to support `transferAndCall` or `transferFromAndCall`\\n *      from ERC1363 token contracts.\\n */\\ninterface ERC1363Receiver {\\n\\t/*\\n\\t * Note: the ERC-165 identifier for this interface is 0x88a7ca5c.\\n\\t * 0x88a7ca5c === bytes4(keccak256(\\\"onTransferReceived(address,address,uint256,bytes)\\\"))\\n\\t */\\n\\n\\t/**\\n\\t * @notice Handle the receipt of ERC1363 tokens\\n\\t *\\n\\t * @dev Any ERC1363 smart contract calls this function on the recipient\\n\\t *      after a `transfer` or a `transferFrom`. This function MAY throw to revert and reject the\\n\\t *      transfer. Return of other than the magic value MUST result in the\\n\\t *      transaction being reverted.\\n\\t *      Note: the token contract address is always the message sender.\\n\\t *\\n\\t * @param operator address The address which called `transferAndCall` or `transferFromAndCall` function\\n\\t * @param from address The address which are token transferred from\\n\\t * @param value uint256 The amount of tokens transferred\\n\\t * @param data bytes Additional data with no specified format\\n\\t * @return `bytes4(keccak256(\\\"onTransferReceived(address,address,uint256,bytes)\\\"))`\\n\\t *      unless throwing\\n\\t */\\n\\tfunction onTransferReceived(address operator, address from, uint256 value, bytes memory data) external returns (bytes4);\\n}\\n\\n/**\\n * @title ERC1363Spender Interface\\n *\\n * @dev Interface for any contract that wants to support `approveAndCall`\\n *      from ERC1363 token contracts.\\n */\\ninterface ERC1363Spender {\\n\\t/*\\n\\t * Note: the ERC-165 identifier for this interface is 0x7b04a2d0.\\n\\t * 0x7b04a2d0 === bytes4(keccak256(\\\"onApprovalReceived(address,uint256,bytes)\\\"))\\n\\t */\\n\\n\\t/**\\n\\t * @notice Handle the approval of ERC1363 tokens\\n\\t *\\n\\t * @dev Any ERC1363 smart contract calls this function on the recipient\\n\\t *      after an `approve`. This function MAY throw to revert and reject the\\n\\t *      approval. Return of other than the magic value MUST result in the\\n\\t *      transaction being reverted.\\n\\t *      Note: the token contract address is always the message sender.\\n\\t *\\n\\t * @param owner address The address which called `approveAndCall` function\\n\\t * @param value uint256 The amount of tokens to be spent\\n\\t * @param data bytes Additional data with no specified format\\n\\t * @return `bytes4(keccak256(\\\"onApprovalReceived(address,uint256,bytes)\\\"))`\\n\\t *      unless throwing\\n\\t */\\n\\tfunction onApprovalReceived(address owner, uint256 value, bytes memory data) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0x5a9800736f8d59f69ddeb59babcc71ec0ba439150ea1ecac1f4c30d8e4a98d5e\",\"license\":\"MIT\"},\"contracts/interfaces/ERC165Spec.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/**\\n * @title ERC-165 Standard Interface Detection\\n *\\n * @dev Interface of the ERC165 standard, as defined in the\\n *       https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * @dev Implementers can declare support of contract interfaces,\\n *      which can then be queried by others.\\n *\\n * @author Christian Reitwie\\u00dfner, Nick Johnson, Fabian Vogelsteller, Jordi Baylina, Konrad Feldmeier, William Entriken\\n */\\ninterface ERC165 {\\n\\t/**\\n\\t * @notice Query if a contract implements an interface\\n\\t *\\n\\t * @dev Interface identification is specified in ERC-165.\\n\\t *      This function uses less than 30,000 gas.\\n\\t *\\n\\t * @param interfaceID The interface identifier, as specified in ERC-165\\n\\t * @return `true` if the contract implements `interfaceID` and\\n\\t *      `interfaceID` is not 0xffffffff, `false` otherwise\\n\\t */\\n\\tfunction supportsInterface(bytes4 interfaceID) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x9b8e0a0ee2ddff1014108266f62a95dab3f76f08deba2e6177ec2ed251128f9d\",\"license\":\"MIT\"},\"contracts/interfaces/ERC20Spec.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/**\\n * @title EIP-20: ERC-20 Token Standard\\n *\\n * @notice The ERC-20 (Ethereum Request for Comments 20), proposed by Fabian Vogelsteller in November 2015,\\n *      is a Token Standard that implements an API for tokens within Smart Contracts.\\n *\\n * @notice It provides functionalities like to transfer tokens from one account to another,\\n *      to get the current token balance of an account and also the total supply of the token available on the network.\\n *      Besides these it also has some other functionalities like to approve that an amount of\\n *      token from an account can be spent by a third party account.\\n *\\n * @notice If a Smart Contract implements the following methods and events it can be called an ERC-20 Token\\n *      Contract and, once deployed, it will be responsible to keep track of the created tokens on Ethereum.\\n *\\n * @notice See https://ethereum.org/en/developers/docs/standards/tokens/erc-20/\\n * @notice See https://eips.ethereum.org/EIPS/eip-20\\n */\\ninterface ERC20 {\\n\\t/**\\n\\t * @dev Fired in transfer(), transferFrom() to indicate that token transfer happened\\n\\t *\\n\\t * @param from an address tokens were consumed from\\n\\t * @param to an address tokens were sent to\\n\\t * @param value number of tokens transferred\\n\\t */\\n\\tevent Transfer(address indexed from, address indexed to, uint256 value);\\n\\n\\t/**\\n\\t * @dev Fired in approve() to indicate an approval event happened\\n\\t *\\n\\t * @param owner an address which granted a permission to transfer\\n\\t *      tokens on its behalf\\n\\t * @param spender an address which received a permission to transfer\\n\\t *      tokens on behalf of the owner `_owner`\\n\\t * @param value amount of tokens granted to transfer on behalf\\n\\t */\\n\\tevent Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n\\t/**\\n\\t * @return name of the token (ex.: USD Coin)\\n\\t */\\n\\t// OPTIONAL - This method can be used to improve usability,\\n\\t// but interfaces and other contracts MUST NOT expect these values to be present.\\n\\t// function name() external view returns (string memory);\\n\\n\\t/**\\n\\t * @return symbol of the token (ex.: USDC)\\n\\t */\\n\\t// OPTIONAL - This method can be used to improve usability,\\n\\t// but interfaces and other contracts MUST NOT expect these values to be present.\\n\\t// function symbol() external view returns (string memory);\\n\\n\\t/**\\n\\t * @dev Returns the number of decimals used to get its user representation.\\n\\t *      For example, if `decimals` equals `2`, a balance of `505` tokens should\\n\\t *      be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n\\t *\\n\\t * @dev Tokens usually opt for a value of 18, imitating the relationship between\\n\\t *      Ether and Wei. This is the value {ERC20} uses, unless this function is\\n\\t *      overridden;\\n\\t *\\n\\t * @dev NOTE: This information is only used for _display_ purposes: it in\\n\\t *      no way affects any of the arithmetic of the contract, including\\n\\t *      {IERC20-balanceOf} and {IERC20-transfer}.\\n\\t *\\n\\t * @return token decimals\\n\\t */\\n\\t// OPTIONAL - This method can be used to improve usability,\\n\\t// but interfaces and other contracts MUST NOT expect these values to be present.\\n\\t// function decimals() external view returns (uint8);\\n\\n\\t/**\\n\\t * @return the amount of tokens in existence\\n\\t */\\n\\tfunction totalSupply() external view returns (uint256);\\n\\n\\t/**\\n\\t * @notice Gets the balance of a particular address\\n\\t *\\n\\t * @param _owner the address to query the the balance for\\n\\t * @return balance an amount of tokens owned by the address specified\\n\\t */\\n\\tfunction balanceOf(address _owner) external view returns (uint256 balance);\\n\\n\\t/**\\n\\t * @notice Transfers some tokens to an external address or a smart contract\\n\\t *\\n\\t * @dev Called by token owner (an address which has a\\n\\t *      positive token balance tracked by this smart contract)\\n\\t * @dev Throws on any error like\\n\\t *      * insufficient token balance or\\n\\t *      * incorrect `_to` address:\\n\\t *          * zero address or\\n\\t *          * self address or\\n\\t *          * smart contract which doesn't support ERC20\\n\\t *\\n\\t * @param _to an address to transfer tokens to,\\n\\t *      must be either an external address or a smart contract,\\n\\t *      compliant with the ERC20 standard\\n\\t * @param _value amount of tokens to be transferred,, zero\\n\\t *      value is allowed\\n\\t * @return success true on success, throws otherwise\\n\\t */\\n\\tfunction transfer(address _to, uint256 _value) external returns (bool success);\\n\\n\\t/**\\n\\t * @notice Transfers some tokens on behalf of address `_from' (token owner)\\n\\t *      to some other address `_to`\\n\\t *\\n\\t * @dev Called by token owner on his own or approved address,\\n\\t *      an address approved earlier by token owner to\\n\\t *      transfer some amount of tokens on its behalf\\n\\t * @dev Throws on any error like\\n\\t *      * insufficient token balance or\\n\\t *      * incorrect `_to` address:\\n\\t *          * zero address or\\n\\t *          * same as `_from` address (self transfer)\\n\\t *          * smart contract which doesn't support ERC20\\n\\t *\\n\\t * @param _from token owner which approved caller (transaction sender)\\n\\t *      to transfer `_value` of tokens on its behalf\\n\\t * @param _to an address to transfer tokens to,\\n\\t *      must be either an external address or a smart contract,\\n\\t *      compliant with the ERC20 standard\\n\\t * @param _value amount of tokens to be transferred,, zero\\n\\t *      value is allowed\\n\\t * @return success true on success, throws otherwise\\n\\t */\\n\\tfunction transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\\n\\n\\t/**\\n\\t * @notice Approves address called `_spender` to transfer some amount\\n\\t *      of tokens on behalf of the owner (transaction sender)\\n\\t *\\n\\t * @dev Transaction sender must not necessarily own any tokens to grant the permission\\n\\t *\\n\\t * @param _spender an address approved by the caller (token owner)\\n\\t *      to spend some tokens on its behalf\\n\\t * @param _value an amount of tokens spender `_spender` is allowed to\\n\\t *      transfer on behalf of the token owner\\n\\t * @return success true on success, throws otherwise\\n\\t */\\n\\tfunction approve(address _spender, uint256 _value) external returns (bool success);\\n\\n\\t/**\\n\\t * @notice Returns the amount which _spender is still allowed to withdraw from _owner.\\n\\t *\\n\\t * @dev A function to check an amount of tokens owner approved\\n\\t *      to transfer on its behalf by some other address called \\\"spender\\\"\\n\\t *\\n\\t * @param _owner an address which approves transferring some tokens on its behalf\\n\\t * @param _spender an address approved to transfer some tokens on behalf\\n\\t * @return remaining an amount of tokens approved address `_spender` can transfer on behalf\\n\\t *      of token owner `_owner`\\n\\t */\\n\\tfunction allowance(address _owner, address _spender) external view returns (uint256 remaining);\\n}\\n\\n/**\\n * @title Mintable/burnable ERC20 Extension\\n *\\n * @notice Adds mint/burn functions to ERC20 interface, these functions\\n *      are usually present in ERC20 implementations, but these become\\n *      a must for the bridged tokens in L2 since the bridge on L2\\n *      needs to have a way to mint tokens deposited from L1 to L2\\n *      and to burn tokens to be withdrawn from L2 to L1\\n */\\ninterface MintableBurnableERC20 is ERC20 {\\n\\t/**\\n\\t * @dev Mints (creates) some tokens to address specified\\n\\t * @dev The value specified is treated as is without taking\\n\\t *      into account what `decimals` value is\\n\\t *\\n\\t * @param _to an address to mint tokens to\\n\\t * @param _value an amount of tokens to mint (create)\\n\\t */\\n\\tfunction mint(address _to, uint256 _value) external;\\n\\n\\t/**\\n\\t * @dev Burns (destroys) some tokens from the address specified\\n\\t *\\n\\t * @dev The value specified is treated as is without taking\\n\\t *      into account what `decimals` value is\\n\\t *\\n\\t * @param _from an address to burn some tokens from\\n\\t * @param _value an amount of tokens to burn (destroy)\\n\\t */\\n\\tfunction burn(address _from, uint256 _value) external;\\n}\\n\",\"keccak256\":\"0xb07fc5b34a9814eac569e73cb23d352e0547b5736e09c9e50234bc23344144e1\",\"license\":\"MIT\"},\"contracts/interfaces/ERC721Spec.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"./ERC165Spec.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard\\n *\\n * @notice See https://eips.ethereum.org/EIPS/eip-721\\n *\\n * @dev Solidity issue #3412: The ERC721 interfaces include explicit mutability guarantees for each function.\\n *      Mutability guarantees are, in order weak to strong: payable, implicit nonpayable, view, and pure.\\n *      Implementation MUST meet the mutability guarantee in this interface and MAY meet a stronger guarantee.\\n *      For example, a payable function in this interface may be implemented as nonpayable\\n *      (no state mutability specified) in implementing contract.\\n *      It is expected a later Solidity release will allow stricter contract to inherit from this interface,\\n *      but current workaround is that we edit this interface to add stricter mutability before inheriting:\\n *      we have removed all \\\"payable\\\" modifiers.\\n *\\n * @dev The ERC-165 identifier for this interface is 0x80ac58cd.\\n *\\n * @author William Entriken, Dieter Shirley, Jacob Evans, Nastassia Sachs\\n */\\ninterface ERC721 is ERC165 {\\n\\t/// @dev This emits when ownership of any NFT changes by any mechanism.\\n\\t///  This event emits when NFTs are created (`from` == 0) and destroyed\\n\\t///  (`to` == 0). Exception: during contract creation, any number of NFTs\\n\\t///  may be created and assigned without emitting Transfer. At the time of\\n\\t///  any transfer, the approved address for that NFT (if any) is reset to none.\\n\\tevent Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\\n\\n\\t/// @dev This emits when the approved address for an NFT is changed or\\n\\t///  reaffirmed. The zero address indicates there is no approved address.\\n\\t///  When a Transfer event emits, this also indicates that the approved\\n\\t///  address for that NFT (if any) is reset to none.\\n\\tevent Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\\n\\n\\t/// @dev This emits when an operator is enabled or disabled for an owner.\\n\\t///  The operator can manage all NFTs of the owner.\\n\\tevent ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\\n\\n\\t/// @notice Count all NFTs assigned to an owner\\n\\t/// @dev NFTs assigned to the zero address are considered invalid, and this\\n\\t///  function throws for queries about the zero address.\\n\\t/// @param _owner An address for whom to query the balance\\n\\t/// @return The number of NFTs owned by `_owner`, possibly zero\\n\\tfunction balanceOf(address _owner) external view returns (uint256);\\n\\n\\t/// @notice Find the owner of an NFT\\n\\t/// @dev NFTs assigned to zero address are considered invalid, and queries\\n\\t///  about them do throw.\\n\\t/// @param _tokenId The identifier for an NFT\\n\\t/// @return The address of the owner of the NFT\\n\\tfunction ownerOf(uint256 _tokenId) external view returns (address);\\n\\n\\t/// @notice Transfers the ownership of an NFT from one address to another address\\n\\t/// @dev Throws unless `msg.sender` is the current owner, an authorized\\n\\t///  operator, or the approved address for this NFT. Throws if `_from` is\\n\\t///  not the current owner. Throws if `_to` is the zero address. Throws if\\n\\t///  `_tokenId` is not a valid NFT. When transfer is complete, this function\\n\\t///  checks if `_to` is a smart contract (code size > 0). If so, it calls\\n\\t///  `onERC721Received` on `_to` and throws if the return value is not\\n\\t///  `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`.\\n\\t/// @param _from The current owner of the NFT\\n\\t/// @param _to The new owner\\n\\t/// @param _tokenId The NFT to transfer\\n\\t/// @param _data Additional data with no specified format, sent in call to `_to`\\n\\tfunction safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external /*payable*/;\\n\\n\\t/// @notice Transfers the ownership of an NFT from one address to another address\\n\\t/// @dev This works identically to the other function with an extra data parameter,\\n\\t///  except this function just sets data to \\\"\\\".\\n\\t/// @param _from The current owner of the NFT\\n\\t/// @param _to The new owner\\n\\t/// @param _tokenId The NFT to transfer\\n\\tfunction safeTransferFrom(address _from, address _to, uint256 _tokenId) external /*payable*/;\\n\\n\\t/// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\\n\\t///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\\n\\t///  THEY MAY BE PERMANENTLY LOST\\n\\t/// @dev Throws unless `msg.sender` is the current owner, an authorized\\n\\t///  operator, or the approved address for this NFT. Throws if `_from` is\\n\\t///  not the current owner. Throws if `_to` is the zero address. Throws if\\n\\t///  `_tokenId` is not a valid NFT.\\n\\t/// @param _from The current owner of the NFT\\n\\t/// @param _to The new owner\\n\\t/// @param _tokenId The NFT to transfer\\n\\tfunction transferFrom(address _from, address _to, uint256 _tokenId) external /*payable*/;\\n\\n\\t/// @notice Change or reaffirm the approved address for an NFT\\n\\t/// @dev The zero address indicates there is no approved address.\\n\\t///  Throws unless `msg.sender` is the current NFT owner, or an authorized\\n\\t///  operator of the current owner.\\n\\t/// @param _approved The new approved NFT controller\\n\\t/// @param _tokenId The NFT to approve\\n\\tfunction approve(address _approved, uint256 _tokenId) external /*payable*/;\\n\\n\\t/// @notice Enable or disable approval for a third party (\\\"operator\\\") to manage\\n\\t///  all of `msg.sender`'s assets\\n\\t/// @dev Emits the ApprovalForAll event. The contract MUST allow\\n\\t///  multiple operators per owner.\\n\\t/// @param _operator Address to add to the set of authorized operators\\n\\t/// @param _approved True if the operator is approved, false to revoke approval\\n\\tfunction setApprovalForAll(address _operator, bool _approved) external;\\n\\n\\t/// @notice Get the approved address for a single NFT\\n\\t/// @dev Throws if `_tokenId` is not a valid NFT.\\n\\t/// @param _tokenId The NFT to find the approved address for\\n\\t/// @return The approved address for this NFT, or the zero address if there is none\\n\\tfunction getApproved(uint256 _tokenId) external view returns (address);\\n\\n\\t/// @notice Query if an address is an authorized operator for another address\\n\\t/// @param _owner The address that owns the NFTs\\n\\t/// @param _operator The address that acts on behalf of the owner\\n\\t/// @return True if `_operator` is an approved operator for `_owner`, false otherwise\\n\\tfunction isApprovedForAll(address _owner, address _operator) external view returns (bool);\\n}\\n\\n/// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.\\ninterface ERC721TokenReceiver {\\n\\t/// @notice Handle the receipt of an NFT\\n\\t/// @dev The ERC721 smart contract calls this function on the recipient\\n\\t///  after a `transfer`. This function MAY throw to revert and reject the\\n\\t///  transfer. Return of other than the magic value MUST result in the\\n\\t///  transaction being reverted.\\n\\t///  Note: the contract address is always the message sender.\\n\\t/// @param _operator The address which called `safeTransferFrom` function\\n\\t/// @param _from The address which previously owned the token\\n\\t/// @param _tokenId The NFT identifier which is being transferred\\n\\t/// @param _data Additional data with no specified format\\n\\t/// @return `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`\\n\\t///  unless throwing\\n\\tfunction onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4);\\n}\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n *\\n * @notice See https://eips.ethereum.org/EIPS/eip-721\\n *\\n * @dev The ERC-165 identifier for this interface is 0x5b5e139f.\\n *\\n * @author William Entriken, Dieter Shirley, Jacob Evans, Nastassia Sachs\\n */\\ninterface ERC721Metadata is ERC721 {\\n\\t/// @notice A descriptive name for a collection of NFTs in this contract\\n\\tfunction name() external view returns (string memory _name);\\n\\n\\t/// @notice An abbreviated name for NFTs in this contract\\n\\tfunction symbol() external view returns (string memory _symbol);\\n\\n\\t/// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\\n\\t/// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\\n\\t///  3986. The URI may point to a JSON file that conforms to the \\\"ERC721\\n\\t///  Metadata JSON Schema\\\".\\n\\tfunction tokenURI(uint256 _tokenId) external view returns (string memory);\\n}\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n *\\n * @notice See https://eips.ethereum.org/EIPS/eip-721\\n *\\n * @dev The ERC-165 identifier for this interface is 0x780e9d63.\\n *\\n * @author William Entriken, Dieter Shirley, Jacob Evans, Nastassia Sachs\\n */\\ninterface ERC721Enumerable is ERC721 {\\n\\t/// @notice Count NFTs tracked by this contract\\n\\t/// @return A count of valid NFTs tracked by this contract, where each one of\\n\\t///  them has an assigned and queryable owner not equal to the zero address\\n\\tfunction totalSupply() external view returns (uint256);\\n\\n\\t/// @notice Enumerate valid NFTs\\n\\t/// @dev Throws if `_index` >= `totalSupply()`.\\n\\t/// @param _index A counter less than `totalSupply()`\\n\\t/// @return The token identifier for the `_index`th NFT,\\n\\t///  (sort order not specified)\\n\\tfunction tokenByIndex(uint256 _index) external view returns (uint256);\\n\\n\\t/// @notice Enumerate NFTs assigned to an owner\\n\\t/// @dev Throws if `_index` >= `balanceOf(_owner)` or if\\n\\t///  `_owner` is the zero address, representing invalid NFTs.\\n\\t/// @param _owner An address where we are interested in NFTs owned by them\\n\\t/// @param _index A counter less than `balanceOf(_owner)`\\n\\t/// @return The token identifier for the `_index`th NFT assigned to `_owner`,\\n\\t///   (sort order not specified)\\n\\tfunction tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xe57d29caebdb7151575f0644ba5c5865fcc498e87f255aae97523871893f56c2\",\"license\":\"MIT\"},\"contracts/interfaces/ERC721SpecExt.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/**\\n * @title Mintable ERC721\\n *\\n * @notice Defines mint capabilities for Alethea ERC721 tokens.\\n *      This interface should be treated as a definition of what mintable means for ERC721\\n *\\n * @author Basil Gorin\\n */\\ninterface MintableERC721 {\\n\\t/**\\n\\t * @notice Checks if specified token exists\\n\\t *\\n\\t * @dev Returns whether the specified token ID has an ownership\\n\\t *      information associated with it\\n\\t *\\n\\t * @param _tokenId ID of the token to query existence for\\n\\t * @return whether the token exists (true - exists, false - doesn't exist)\\n\\t */\\n\\tfunction exists(uint256 _tokenId) external view returns(bool);\\n\\n\\t/**\\n\\t * @dev Creates new token with token ID specified\\n\\t *      and assigns an ownership `_to` for this token\\n\\t *\\n\\t * @dev Unsafe: doesn't execute `onERC721Received` on the receiver.\\n\\t *      Prefer the use of `safeMint` instead of `mint`.\\n\\t *\\n\\t * @dev Should have a restricted access handled by the implementation\\n\\t *\\n\\t * @param _to an address to mint token to\\n\\t * @param _tokenId ID of the token to mint\\n\\t */\\n\\tfunction mint(address _to, uint256 _tokenId) external;\\n\\n\\t/**\\n\\t * @dev Creates new tokens starting with token ID specified\\n\\t *      and assigns an ownership `_to` for these tokens\\n\\t *\\n\\t * @dev Token IDs to be minted: [_tokenId, _tokenId + n)\\n\\t *\\n\\t * @dev n must be greater or equal 2: `n > 1`\\n\\t *\\n\\t * @dev Unsafe: doesn't execute `onERC721Received` on the receiver.\\n\\t *      Prefer the use of `safeMintBatch` instead of `mintBatch`.\\n\\t *\\n\\t * @dev Should have a restricted access handled by the implementation\\n\\t *\\n\\t * @param _to an address to mint tokens to\\n\\t * @param _tokenId ID of the first token to mint\\n\\t * @param n how many tokens to mint, sequentially increasing the _tokenId\\n\\t */\\n\\tfunction mintBatch(address _to, uint256 _tokenId, uint256 n) external;\\n\\n\\t/**\\n\\t * @dev Creates new token with token ID specified\\n\\t *      and assigns an ownership `_to` for this token\\n\\t *\\n\\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\\n\\t *      `onERC721Received` on `_to` and throws if the return value is not\\n\\t *      `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`.\\n\\t *\\n\\t * @dev Should have a restricted access handled by the implementation\\n\\t *\\n\\t * @param _to an address to mint token to\\n\\t * @param _tokenId ID of the token to mint\\n\\t */\\n\\tfunction safeMint(address _to, uint256 _tokenId) external;\\n\\n\\t/**\\n\\t * @dev Creates new token with token ID specified\\n\\t *      and assigns an ownership `_to` for this token\\n\\t *\\n\\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\\n\\t *      `onERC721Received` on `_to` and throws if the return value is not\\n\\t *      `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`.\\n\\t *\\n\\t * @dev Should have a restricted access handled by the implementation\\n\\t *\\n\\t * @param _to an address to mint token to\\n\\t * @param _tokenId ID of the token to mint\\n\\t * @param _data additional data with no specified format, sent in call to `_to`\\n\\t */\\n\\tfunction safeMint(address _to, uint256 _tokenId, bytes memory _data) external;\\n\\n\\t/**\\n\\t * @dev Creates new tokens starting with token ID specified\\n\\t *      and assigns an ownership `_to` for these tokens\\n\\t *\\n\\t * @dev Token IDs to be minted: [_tokenId, _tokenId + n)\\n\\t *\\n\\t * @dev n must be greater or equal 2: `n > 1`\\n\\t *\\n\\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\\n\\t *      `onERC721Received` on `_to` and throws if the return value is not\\n\\t *      `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`.\\n\\t *\\n\\t * @dev Should have a restricted access handled by the implementation\\n\\t *\\n\\t * @param _to an address to mint token to\\n\\t * @param _tokenId ID of the token to mint\\n\\t * @param n how many tokens to mint, sequentially increasing the _tokenId\\n\\t */\\n\\tfunction safeMintBatch(address _to, uint256 _tokenId, uint256 n) external;\\n\\n\\t/**\\n\\t * @dev Creates new tokens starting with token ID specified\\n\\t *      and assigns an ownership `_to` for these tokens\\n\\t *\\n\\t * @dev Token IDs to be minted: [_tokenId, _tokenId + n)\\n\\t *\\n\\t * @dev n must be greater or equal 2: `n > 1`\\n\\t *\\n\\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\\n\\t *      `onERC721Received` on `_to` and throws if the return value is not\\n\\t *      `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`.\\n\\t *\\n\\t * @dev Should have a restricted access handled by the implementation\\n\\t *\\n\\t * @param _to an address to mint token to\\n\\t * @param _tokenId ID of the token to mint\\n\\t * @param n how many tokens to mint, sequentially increasing the _tokenId\\n\\t * @param _data additional data with no specified format, sent in call to `_to`\\n\\t */\\n\\tfunction safeMintBatch(address _to, uint256 _tokenId, uint256 n, bytes memory _data) external;\\n}\\n\\n/**\\n * @title Alethea Burnable ERC721\\n *\\n * @notice Defines burn capabilities for Alethea ERC721 tokens.\\n *      This interface should be treated as a definition of what burnable means for ERC721\\n *\\n * @author Basil Gorin\\n */\\ninterface BurnableERC721 {\\n\\t/**\\n\\t * @notice Destroys the token with token ID specified\\n\\t *\\n\\t * @dev Should be accessible publicly by token owners.\\n\\t *      May have a restricted access handled by the implementation\\n\\t *\\n\\t * @param _tokenId ID of the token to burn\\n\\t */\\n\\tfunction burn(uint256 _tokenId) external;\\n}\\n\\n/**\\n * @title With Base URI\\n *\\n * @notice A marker interface for the contracts having the baseURI() function\\n *      or public string variable named baseURI\\n *      NFT implementations like TinyERC721, or ShortERC721 are example of such smart contracts\\n *\\n * @author Basil Gorin\\n */\\ninterface WithBaseURI {\\n\\t/**\\n\\t * @dev Usually used in NFT implementations to construct ERC721Metadata.tokenURI as\\n\\t *      `base URI + token ID` if token URI is not set (not present in `_tokenURIs` mapping)\\n\\t *\\n\\t * @dev For example, if base URI is https://api.com/token/, then token #1\\n\\t *      will have an URI https://api.com/token/1\\n\\t */\\n\\tfunction baseURI() external view returns(string memory);\\n}\\n\",\"keccak256\":\"0x76bb7f54420c208fbe8a1a0792ebe54dfd5ce06b90e571ab5c20acab610d3d05\",\"license\":\"MIT\"},\"contracts/utils/InitializableAccessControl.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.2;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @title Initializable Role-based Access Control (RBAC) // ERC1967Proxy\\n *\\n * @notice Access control smart contract provides an API to check\\n *      if a specific operation is permitted globally and/or\\n *      if a particular user has a permission to execute it.\\n *\\n * @notice This contract is inherited by other contracts requiring the role-based access control (RBAC)\\n *      protection for the restricted access functions\\n *\\n * @notice It deals with two main entities: features and roles.\\n *\\n * @notice Features are designed to be used to enable/disable public functions\\n *      of the smart contract (used by a wide audience).\\n * @notice User roles are designed to control the access to restricted functions\\n *      of the smart contract (used by a limited set of maintainers).\\n *\\n * @notice Terms \\\"role\\\", \\\"permissions\\\" and \\\"set of permissions\\\" have equal meaning\\n *      in the documentation text and may be used interchangeably.\\n * @notice Terms \\\"permission\\\", \\\"single permission\\\" implies only one permission bit set.\\n *\\n * @notice Access manager is a special role which allows to grant/revoke other roles.\\n *      Access managers can only grant/revoke permissions which they have themselves.\\n *      As an example, access manager with no other roles set can only grant/revoke its own\\n *      access manager permission and nothing else.\\n *\\n * @notice Access manager permission should be treated carefully, as a super admin permission:\\n *      Access manager with even no other permission can interfere with another account by\\n *      granting own access manager permission to it and effectively creating more powerful\\n *      permission set than its own.\\n *\\n * @dev Both current and OpenZeppelin AccessControl implementations feature a similar API\\n *      to check/know \\\"who is allowed to do this thing\\\".\\n * @dev Zeppelin implementation is more flexible:\\n *      - it allows setting unlimited number of roles, while current is limited to 256 different roles\\n *      - it allows setting an admin for each role, while current allows having only one global admin\\n * @dev Current implementation is more lightweight:\\n *      - it uses only 1 bit per role, while Zeppelin uses 256 bits\\n *      - it allows setting up to 256 roles at once, in a single transaction, while Zeppelin allows\\n *        setting only one role in a single transaction\\n *\\n * @dev This smart contract is designed to be inherited by other\\n *      smart contracts which require access control management capabilities.\\n *\\n * @dev Access manager permission has a bit 255 set.\\n *      This bit must not be used by inheriting contracts for any other permissions/features.\\n *\\n * @dev This is an initializable version of the RBAC, based on Zeppelin implementation,\\n *      it can be used for ERC1967 proxies, as well as for EIP-1167 minimal proxies\\n *      see https://docs.openzeppelin.com/contracts/4.x/upgradeable\\n *      see https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable\\n *      see https://forum.openzeppelin.com/t/uups-proxies-tutorial-solidity-javascript/7786\\n *      see https://eips.ethereum.org/EIPS/eip-1167\\n *      see https://docs.openzeppelin.com/contracts/4.x/api/proxy#Clones\\n *\\n * @author Basil Gorin\\n */\\nabstract contract InitializableAccessControl is Initializable {\\n\\t/**\\n\\t * @dev Privileged addresses with defined roles/permissions\\n\\t * @dev In the context of ERC20/ERC721 tokens these can be permissions to\\n\\t *      allow minting or burning tokens, transferring on behalf and so on\\n\\t *\\n\\t * @dev Maps user address to the permissions bitmask (role), where each bit\\n\\t *      represents a permission\\n\\t * @dev Bitmask 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\\n\\t *      represents all possible permissions\\n\\t * @dev 'This' address mapping represents global features of the smart contract\\n\\t *\\n\\t * @dev We keep the mapping private to prevent direct writes to it from the inheriting\\n\\t *      contracts, `getRole()` and `updateRole()` functions should be used instead\\n\\t */\\n\\tmapping(address => uint256) private userRoles;\\n\\n\\t/**\\n\\t * @dev Empty reserved space in storage. The size of the __gap array is calculated so that\\n\\t *      the amount of storage used by a contract always adds up to the 50.\\n\\t *      See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n\\t */\\n\\tuint256[49] private __gap;\\n\\n\\t/**\\n\\t * @notice Access manager is responsible for assigning the roles to users,\\n\\t *      enabling/disabling global features of the smart contract\\n\\t * @notice Access manager can add, remove and update user roles,\\n\\t *      remove and update global features\\n\\t *\\n\\t * @dev Role ROLE_ACCESS_MANAGER allows modifying user roles and global features\\n\\t * @dev Role ROLE_ACCESS_MANAGER has single bit at position 255 enabled\\n\\t */\\n\\tuint256 public constant ROLE_ACCESS_MANAGER = 0x8000000000000000000000000000000000000000000000000000000000000000;\\n\\n\\t/**\\n\\t * @notice Upgrade manager is responsible for smart contract upgrades,\\n\\t *      see https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable\\n\\t *      see https://docs.openzeppelin.com/contracts/4.x/upgradeable\\n\\t *\\n\\t * @dev Role ROLE_UPGRADE_MANAGER allows passing the _authorizeUpgrade() check\\n\\t * @dev Role ROLE_UPGRADE_MANAGER has single bit at position 254 enabled\\n\\t */\\n\\tuint256 public constant ROLE_UPGRADE_MANAGER = 0x4000000000000000000000000000000000000000000000000000000000000000;\\n\\n\\t/**\\n\\t * @dev Bitmask representing all the possible permissions (super admin role)\\n\\t * @dev Has all the bits are enabled (2^256 - 1 value)\\n\\t */\\n\\tuint256 private constant FULL_PRIVILEGES_MASK = type(uint256).max; // before 0.8.0: uint256(-1) overflows to 0xFFFF...\\n\\n\\t/**\\n\\t * @dev Fired in updateRole() and updateFeatures()\\n\\t *\\n\\t * @param operator address which was granted/revoked permissions\\n\\t * @param requested permissions requested\\n\\t * @param assigned permissions effectively set\\n\\t */\\n\\tevent RoleUpdated(address indexed operator, uint256 requested, uint256 assigned);\\n\\n\\t/**\\n\\t * @notice Function modifier making a function defined as public behave as restricted\\n\\t *      (so that only a pre-configured set of accounts can execute it)\\n\\t *\\n\\t * @param role the role transaction executor is required to have;\\n\\t *      the function throws an \\\"access denied\\\" exception if this condition is not met\\n\\t */\\n\\tmodifier restrictedTo(uint256 role) {\\n\\t\\t// verify the access permission\\n\\t\\trequire(isSenderInRole(role), \\\"access denied\\\");\\n\\n\\t\\t// execute the rest of the function\\n\\t\\t_;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Creates/deploys the ACL implementation to be used in a proxy\\n\\t *\\n\\t * @dev Note:\\n\\t *      the implementation is already initialized and\\n\\t *      `_postConstruct` is not executable on the implementation\\n\\t *      `_postConstruct` is still available in the context of a proxy\\n\\t *      and should be executed on the proxy deployment (in the same tx)\\n\\t */\\n\\t // constructor() initializer {}\\n\\n\\t/**\\n\\t * @dev Contract initializer, sets the contract owner to have full privileges\\n\\t *\\n\\t * @dev Can be executed only once, reverts when executed second time\\n\\t *\\n\\t * @dev IMPORTANT:\\n\\t *      this function SHOULD be executed during proxy deployment (in the same transaction)\\n\\t *\\n\\t * @param _owner smart contract owner having full privileges\\n\\t */\\n\\tfunction _postConstruct(address _owner) internal virtual onlyInitializing {\\n\\t\\t// grant owner full privileges\\n\\t\\t__setRole(_owner, FULL_PRIVILEGES_MASK, FULL_PRIVILEGES_MASK);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Highest version that has been initialized.\\n\\t *      Non-zero value means contract was already initialized.\\n\\t * @dev see {Initializable}, {reinitializer}.\\n\\t *\\n\\t * @return highest version that has been initialized\\n\\t */\\n/*\\n\\tfunction getInitializedVersion() public view returns(uint64) {\\n\\t\\t// delegate to `_getInitializedVersion`\\n\\t\\treturn _getInitializedVersion();\\n\\t}\\n*/\\n\\n\\t/**\\n\\t * @notice Retrieves globally set of features enabled\\n\\t *\\n\\t * @dev Effectively reads userRoles role for the contract itself\\n\\t *\\n\\t * @return 256-bit bitmask of the features enabled\\n\\t */\\n\\tfunction features() public view returns (uint256) {\\n\\t\\t// features are stored in 'this' address mapping of `userRoles`\\n\\t\\treturn getRole(address(this));\\n\\t}\\n\\n\\t/**\\n\\t * @notice Updates set of the globally enabled features (`features`),\\n\\t *      taking into account sender's permissions\\n\\t *\\n\\t * @dev Requires transaction sender to have `ROLE_ACCESS_MANAGER` permission\\n\\t * @dev Function is left for backward compatibility with older versions\\n\\t *\\n\\t * @param _mask bitmask representing a set of features to enable/disable\\n\\t */\\n\\tfunction updateFeatures(uint256 _mask) public {\\n\\t\\t// delegate call to `updateRole`\\n\\t\\tupdateRole(address(this), _mask);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Reads the permissions (role) for a given user from the `userRoles` mapping\\n\\t *      (privileged addresses with defined roles/permissions)\\n\\t * @notice In the context of ERC20/ERC721 tokens these can be permissions to\\n\\t *      allow minting or burning tokens, transferring on behalf and so on\\n\\t *\\n\\t * @dev Having a simple getter instead of making the mapping public\\n\\t *      allows enforcing the encapsulation of the mapping and protects from\\n\\t *      writing to it directly in the inheriting smart contracts\\n\\t *\\n\\t * @param operator address of a user to read permissions for,\\n\\t *      or self address to read global features of the smart contract\\n\\t */\\n\\tfunction getRole(address operator) public view returns(uint256) {\\n\\t\\t// read the value from `userRoles` and return\\n\\t\\treturn userRoles[operator];\\n\\t}\\n\\n\\t/**\\n\\t * @notice Updates set of permissions (role) for a given user,\\n\\t *      taking into account sender's permissions.\\n\\t *\\n\\t * @dev Setting role to zero is equivalent to removing an all permissions\\n\\t * @dev Setting role to `FULL_PRIVILEGES_MASK` is equivalent to\\n\\t *      copying senders' permissions (role) to the user\\n\\t * @dev Requires transaction sender to have `ROLE_ACCESS_MANAGER` permission\\n\\t *\\n\\t * @param operator address of a user to alter permissions for,\\n\\t *       or self address to alter global features of the smart contract\\n\\t * @param role bitmask representing a set of permissions to\\n\\t *      enable/disable for a user specified\\n\\t */\\n\\tfunction updateRole(address operator, uint256 role) public {\\n\\t\\t// caller must have a permission to update user roles\\n\\t\\trequire(isSenderInRole(ROLE_ACCESS_MANAGER), \\\"access denied\\\");\\n\\n\\t\\t// evaluate the role and reassign it\\n\\t\\t__setRole(operator, role, _evaluateBy(msg.sender, getRole(operator), role));\\n\\t}\\n\\n\\t/**\\n\\t * @notice Determines the permission bitmask an operator can set on the\\n\\t *      target permission set\\n\\t * @notice Used to calculate the permission bitmask to be set when requested\\n\\t *     in `updateRole` and `updateFeatures` functions\\n\\t *\\n\\t * @dev Calculated based on:\\n\\t *      1) operator's own permission set read from userRoles[operator]\\n\\t *      2) target permission set - what is already set on the target\\n\\t *      3) desired permission set - what do we want set target to\\n\\t *\\n\\t * @dev Corner cases:\\n\\t *      1) Operator is super admin and its permission set is `FULL_PRIVILEGES_MASK`:\\n\\t *        `desired` bitset is returned regardless of the `target` permission set value\\n\\t *        (what operator sets is what they get)\\n\\t *      2) Operator with no permissions (zero bitset):\\n\\t *        `target` bitset is returned regardless of the `desired` value\\n\\t *        (operator has no authority and cannot modify anything)\\n\\t *\\n\\t * @dev Example:\\n\\t *      Consider an operator with the permissions bitmask     00001111\\n\\t *      is about to modify the target permission set          01010101\\n\\t *      Operator wants to set that permission set to          00110011\\n\\t *      Based on their role, an operator has the permissions\\n\\t *      to update only lowest 4 bits on the target, meaning that\\n\\t *      high 4 bits of the target set in this example is left\\n\\t *      unchanged and low 4 bits get changed as desired:      01010011\\n\\t *\\n\\t * @param operator address of the contract operator which is about to set the permissions\\n\\t * @param target input set of permissions to operator is going to modify\\n\\t * @param desired desired set of permissions operator would like to set\\n\\t * @return resulting set of permissions given operator will set\\n\\t */\\n\\tfunction _evaluateBy(address operator, uint256 target, uint256 desired) internal view returns (uint256) {\\n\\t\\t// read operator's permissions\\n\\t\\tuint256 p = getRole(operator);\\n\\n\\t\\t// taking into account operator's permissions,\\n\\t\\t// 1) enable the permissions desired on the `target`\\n\\t\\ttarget |= p & desired;\\n\\t\\t// 2) disable the permissions desired on the `target`\\n\\t\\ttarget &= FULL_PRIVILEGES_MASK ^ (p & (FULL_PRIVILEGES_MASK ^ desired));\\n\\n\\t\\t// return calculated result\\n\\t\\treturn target;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Checks if requested set of features is enabled globally on the contract\\n\\t *\\n\\t * @param required set of features to check against\\n\\t * @return true if all the features requested are enabled, false otherwise\\n\\t */\\n\\tfunction isFeatureEnabled(uint256 required) public view returns (bool) {\\n\\t\\t// delegate call to `__hasRole`, passing `features` property\\n\\t\\treturn __hasRole(features(), required);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Checks if transaction sender `msg.sender` has all the permissions required\\n\\t *\\n\\t * @dev Used in smart contracts only. Off-chain clients should use `isOperatorInRole`.\\n\\t *\\n\\t * @param required set of permissions (role) to check against\\n\\t * @return true if all the permissions requested are enabled, false otherwise\\n\\t */\\n\\tfunction isSenderInRole(uint256 required) public view returns (bool) {\\n\\t\\t// delegate call to `isOperatorInRole`, passing transaction sender\\n\\t\\treturn isOperatorInRole(msg.sender, required);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Checks if operator has all the permissions (role) required\\n\\t *\\n\\t * @param operator address of the user to check role for\\n\\t * @param required set of permissions (role) to check\\n\\t * @return true if all the permissions requested are enabled, false otherwise\\n\\t */\\n\\tfunction isOperatorInRole(address operator, uint256 required) public view returns (bool) {\\n\\t\\t// delegate call to `__hasRole`, passing operator's permissions (role)\\n\\t\\treturn __hasRole(getRole(operator), required);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Sets the `assignedRole` role to the operator, logs both `requestedRole` and `actualRole`\\n\\t *\\n\\t * @dev Unsafe:\\n\\t *      provides direct write access to `userRoles` mapping without any security checks,\\n\\t *      doesn't verify the executor (msg.sender) permissions,\\n\\t *      must be kept private at all times\\n\\t *\\n\\t * @param operator address of a user to alter permissions for,\\n\\t *       or self address to alter global features of the smart contract\\n\\t * @param requestedRole bitmask representing a set of permissions requested\\n\\t *      to be enabled/disabled for a user specified, used only to be logged into event\\n\\t * @param assignedRole bitmask representing a set of permissions to\\n\\t *      enable/disable for a user specified, used to update the mapping and to be logged into event\\n\\t */\\n\\tfunction __setRole(address operator, uint256 requestedRole, uint256 assignedRole) private {\\n\\t\\t// assign the role to the operator\\n\\t\\tuserRoles[operator] = assignedRole;\\n\\n\\t\\t// fire an event\\n\\t\\temit RoleUpdated(operator, requestedRole, assignedRole);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Checks if role `actual` contains all the permissions required `required`\\n\\t *\\n\\t * @param actual existent role\\n\\t * @param required required role\\n\\t * @return true if actual has required role (all permissions), false otherwise\\n\\t */\\n\\tfunction __hasRole(uint256 actual, uint256 required) private pure returns (bool) {\\n\\t\\t// check the bitmask for the role required and return the result\\n\\t\\treturn actual & required == required;\\n\\t}\\n}\\n\",\"keccak256\":\"0x4401ac10646baffe69521c6e6ae82ab76c2fbdfbe1c39bc0fb6028996a298284\",\"license\":\"MIT\"},\"contracts/utils/Transfers.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/**\\n * @notice Replaces built-in Solidity address.transfer and address.send functions\\n *      with the address.call function\\n */\\nlibrary Transfers {\\n\\t/// @dev Mimics address.send forwarding 4,900 gas\\n\\tfunction send(address payable to, uint256 value) internal returns(bool) {\\n\\t\\t(bool success, ) = to.call{gas: 4900, value: value}(\\\"\\\");\\n\\t\\treturn success;\\n\\t}\\n\\n\\t/// @dev Mimics address.transfer forwarding 4,900 gas\\n\\tfunction transfer(address payable to, uint256 value) internal {\\n\\t\\trequire(send(to, value), \\\"failed to send ether\\\");\\n\\t}\\n\\n\\t/// @dev Alias for `send`\\n\\tfunction send1(address payable to, uint256 value) internal returns(bool) {\\n\\t\\treturn send(to, value);\\n\\t}\\n\\n\\t/// @dev Alias for `transfer`\\n\\tfunction transfer1(address payable to, uint256 value) internal {\\n\\t\\ttransfer(to, value);\\n\\t}\\n}\\n\",\"keccak256\":\"0xc0f5a4f1c527b8bdbedf63c3342657e0ddf3a03b0f80c6117adb51f208cc9cbe\",\"license\":\"MIT\"},\"contracts/utils/UpgradeableAccessControl.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.2;\\n\\nimport \\\"./InitializableAccessControl.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\\\";\\n\\n/**\\n * @title Upgradeable Role-based Access Control (RBAC) // ERC1967Proxy\\n *\\n * @notice Access control smart contract provides an API to check\\n *      if a specific operation is permitted globally and/or\\n *      if a particular user has a permission to execute it.\\n *\\n * @notice This contract is inherited by other contracts requiring the role-based access control (RBAC)\\n *      protection for the restricted access functions\\n *\\n * @notice It deals with two main entities: features and roles.\\n *\\n * @notice Features are designed to be used to enable/disable public functions\\n *      of the smart contract (used by a wide audience).\\n * @notice User roles are designed to control the access to restricted functions\\n *      of the smart contract (used by a limited set of maintainers).\\n *\\n * @notice Terms \\\"role\\\", \\\"permissions\\\" and \\\"set of permissions\\\" have equal meaning\\n *      in the documentation text and may be used interchangeably.\\n * @notice Terms \\\"permission\\\", \\\"single permission\\\" implies only one permission bit set.\\n *\\n * @notice Access manager is a special role which allows to grant/revoke other roles.\\n *      Access managers can only grant/revoke permissions which they have themselves.\\n *      As an example, access manager with no other roles set can only grant/revoke its own\\n *      access manager permission and nothing else.\\n *\\n * @notice Access manager permission should be treated carefully, as a super admin permission:\\n *      Access manager with even no other permission can interfere with another account by\\n *      granting own access manager permission to it and effectively creating more powerful\\n *      permission set than its own.\\n *\\n * @dev Both current and OpenZeppelin AccessControl implementations feature a similar API\\n *      to check/know \\\"who is allowed to do this thing\\\".\\n * @dev Zeppelin implementation is more flexible:\\n *      - it allows setting unlimited number of roles, while current is limited to 256 different roles\\n *      - it allows setting an admin for each role, while current allows having only one global admin\\n * @dev Current implementation is more lightweight:\\n *      - it uses only 1 bit per role, while Zeppelin uses 256 bits\\n *      - it allows setting up to 256 roles at once, in a single transaction, while Zeppelin allows\\n *        setting only one role in a single transaction\\n *\\n * @dev This smart contract is designed to be inherited by other\\n *      smart contracts which require access control management capabilities.\\n *\\n * @dev Access manager permission has a bit 255 set.\\n *      This bit must not be used by inheriting contracts for any other permissions/features.\\n *\\n * @dev This is an upgradeable version of the ACL, based on Zeppelin implementation for ERC1967,\\n *      see https://docs.openzeppelin.com/contracts/4.x/upgradeable\\n *      see https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable\\n *      see https://forum.openzeppelin.com/t/uups-proxies-tutorial-solidity-javascript/7786\\n *\\n * @author Basil Gorin\\n */\\nabstract contract UpgradeableAccessControl is InitializableAccessControl, UUPSUpgradeable {\\n\\t/**\\n\\t * @dev Creates/deploys the ACL implementation to be used in a proxy\\n\\t *\\n\\t * @dev Note:\\n\\t *      the implementation is already initialized and\\n\\t *      `_postConstruct` is not executable on the implementation\\n\\t *      `_postConstruct` is still available in the context of a proxy\\n\\t *      and should be executed on the proxy deployment (in the same tx)\\n\\t */\\n\\tconstructor() initializer {}\\n\\n\\t/**\\n\\t * @notice Returns an address of the implementation smart contract,\\n\\t *      see ERC1967Upgrade._getImplementation()\\n\\t *\\n\\t * @return the current implementation address\\n\\t */\\n\\tfunction getImplementation() public view virtual returns (address) {\\n\\t\\t// delegate to `ERC1967Upgrade._getImplementation()`\\n\\t\\treturn _getImplementation();\\n\\t}\\n\\n\\t/**\\n\\t * @inheritdoc UUPSUpgradeable\\n\\t */\\n\\tfunction _authorizeUpgrade(address) internal virtual override {\\n\\t\\t// caller must have a permission to upgrade the contract\\n\\t\\trequire(isSenderInRole(ROLE_UPGRADE_MANAGER), \\\"access denied\\\");\\n\\t}\\n}\\n\",\"keccak256\":\"0x6108509c98214452c4eadf7aa322e09ed3a53c97298dca0935c9d8cc9ac9f846\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60a0604052306080523480156200001557600080fd5b50600054610100900460ff16620000335760005460ff16156200003d565b6200003d620000e2565b620000a55760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201526d191e481a5b9a5d1a585b1a5e995960921b606482015260840160405180910390fd5b600054610100900460ff16158015620000c8576000805461ffff19166101011790555b8015620000db576000805461ff00191690555b5062000106565b6000620000fa306200010060201b620019bc1760201c565b15905090565b3b151590565b608051613e4c6200013760003960008181610ca201528181610ce201528181610e4d0152610e8d0152613e4c6000f3fe6080604052600436106102935760003560e01c80637d4912151161015a578063ae682e2e116100c1578063d3a63eb31161007a578063d3a63eb3146107bd578063d41c3a65146107dd578063d5bb7f67146107fb578063e3bf4c151461081b578063f0254a071461083b578063fcc2c0781461085b57600080fd5b8063ae682e2e1461071f578063b1c6ffcf14610737578063c2fec9fb1461074e578063c688d69314610763578063cd3f29e914610783578063d216d77b146107a857600080fd5b80639e59e2f2116101135780639e59e2f214610674578063a10786b014610692578063a248a831146106b2578063aaf10f42146106d2578063ae5b102e146106e7578063ae60bda41461070757600080fd5b80637d491215146105cc5780637fcb7b42146105df57806381f8a0df146105f65780638db462fc1461061657806391e9c79c146106345780639e35e6a51461065457600080fd5b806340472069116101fe5780635639b19f116101b75780635639b19f1461050357806358ab4e90146105305780636c5d611314610547578063725f36261461056757806372e926a4146105975780637b80be6b146105b757600080fd5b8063404720691461043e57806343fc12001461045557806344276733146104755780634f1ef286146104ab57806351033545146104be57806353b73799146104de57600080fd5b80632b521416116102505780632b521416146103695780632d0335ab146103955780632e53c12a146103cb57806331576ad5146103eb5780633505da541461040b5780633659cfe61461041e57600080fd5b80630fb25c75146102985780631263aa2b146102c757806325f335c5146102e95780632639b8d1146103145780632651ecc8146103325780632b30a5d714610349575b600080fd5b3480156102a457600080fd5b506102ad600281565b60405163ffffffff90911681526020015b60405180910390f35b3480156102d357600080fd5b506102e76102e23660046134a4565b61087b565b005b6102fc6102f73660046134fb565b6109f5565b6040516001600160a01b0390911681526020016102be565b34801561032057600080fd5b5060ce546001600160a01b03166102fc565b34801561033e57600080fd5b506102ad6208000081565b34801561035557600080fd5b506102fc610364366004613549565b610a0d565b34801561037557600080fd5b50306000908152600160205260409020545b6040519081526020016102be565b3480156103a157600080fd5b506103876103b036600461357d565b6001600160a01b0316600090815260d3602052604090205490565b3480156103d757600080fd5b506102e76103e63660046134a4565b610a29565b3480156103f757600080fd5b506102e761040636600461357d565b610b15565b6102fc61041936600461359a565b610c80565b34801561042a57600080fd5b506102e761043936600461357d565b610c98565b34801561044a57600080fd5b506102ad6210000081565b34801561046157600080fd5b506102e76104703660046134a4565b610d60565b34801561048157600080fd5b5061038761049036600461357d565b6001600160a01b031660009081526001602052604090205490565b6102e76104b9366004613645565b610e43565b3480156104ca57600080fd5b506102e76104d93660046136ec565b610ef8565b3480156104ea57600080fd5b5060cd54600160401b90046001600160401b0316610387565b34801561050f57600080fd5b5061052361051e36600461357d565b6110eb565b6040516102be919061377a565b34801561053c57600080fd5b506102ad6202000081565b34801561055357600080fd5b506102e7610562366004613788565b6111c5565b34801561057357600080fd5b506105876105823660046137bf565b611284565b60405190151581526020016102be565b3480156105a357600080fd5b506102fc6105b23660046137d8565b6112a0565b3480156105c357600080fd5b506102e76112e9565b6102fc6105da3660046137f3565b611425565b3480156105eb57600080fd5b506102ad6204000081565b34801561060257600080fd5b506102e761061136600461357d565b61154b565b34801561062257600080fd5b5060cc546001600160a01b03166102fc565b34801561064057600080fd5b506102fc61064f36600461387f565b6115bd565b34801561066057600080fd5b506102e761066f36600461389b565b6115d9565b34801561068057600080fd5b5060cd546001600160401b0316610387565b34801561069e57600080fd5b506102e76106ad36600461357d565b6116db565b3480156106be57600080fd5b506102fc6106cd3660046137d8565b6117eb565b3480156106de57600080fd5b506102fc611803565b3480156106f357600080fd5b506102e761070236600461389b565b61180d565b34801561071357600080fd5b50610387600160fe1b81565b34801561072b57600080fd5b50610387600160ff1b81565b34801561074357600080fd5b506102ad6201000081565b34801561075a57600080fd5b506102ad600181565b34801561076f57600080fd5b5061058761077e36600461389b565b611892565b34801561078f57600080fd5b5060cc54600160a01b90046001600160401b0316610387565b3480156107b457600080fd5b506102ad600481565b3480156107c957600080fd5b506102e76107d836600461357d565b6118b4565b3480156107e957600080fd5b5060cb546001600160a01b03166102fc565b34801561080757600080fd5b506102e76108163660046137bf565b6118e5565b34801561082757600080fd5b506102e7610836366004613788565b6118ef565b34801561084757600080fd5b506102fc610856366004613549565b6119a2565b34801561086757600080fd5b506105876108763660046137bf565b6119b0565b610887620100006119b0565b6108ac5760405162461bcd60e51b81526004016108a3906138c7565b60405180910390fd5b6001600160401b03811615806108cc575060cc546001600160a01b031615155b6109295760405162461bcd60e51b815260206004820152602860248201527f70726f746f636f6c46656544657374696e6174696f6e206d7573742062652073604482015267195d08199a5c9cdd60c21b60648201526084016108a3565b6001600160401b03811615806109655750620f4240816001600160401b03161180156109655750670429d069189e0000816001600160401b0316105b6109815760405162461bcd60e51b81526004016108a3906138ee565b60cc80546001600160401b03808416600160a01b0267ffffffffffffffff60a01b198316811790935560cd54604051600080516020613dd0833981519152946109ea946001600160a01b0391821691161792869280821692600160401b9091049091169061391d565b60405180910390a150565b6000610a0485858585336119c2565b95945050505050565b6000610a1b83836000610c80565b90505b92915050565b905090565b610a35620400006119b0565b610a515760405162461bcd60e51b81526004016108a3906138c7565b6001600160401b0381161580610a8d5750620f4240816001600160401b0316118015610a8d5750670429d069189e0000816001600160401b0316105b610aa95760405162461bcd60e51b81526004016108a3906138ee565b60cd80546001600160401b03808416600160401b026fffffffffffffffff0000000000000000198316811790935560cc54604051600080516020613dd0833981519152946109ea946001600160a01b03841694600160a01b90940484169391821691161790869061391d565b600054610100900460ff16610b305760005460ff1615610b34565b303b155b610b975760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201526d191e481a5b9a5d1a585b1a5e995960921b60648201526084016108a3565b600054610100900460ff16158015610bb9576000805461ffff19166101011790555b610c016040518060400160405280600d81526020016c536861726573466163746f727960981b815250604051806040016040528060018152602001603160f81b815250611ec1565b610c0a33611f02565b6001600160a01b038216610c4f5760405162461bcd60e51b815260206004820152600c60248201526b7a65726f206164647265737360a01b60448201526064016108a3565b60cb80546001600160a01b0319166001600160a01b0384161790558015610c7c576000805461ff00191690555b5050565b6000610c8e848433856109f5565b90505b9392505050565b6001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000163003610ce05760405162461bcd60e51b81526004016108a39061394f565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316610d12611f36565b6001600160a01b031614610d385760405162461bcd60e51b81526004016108a39061399b565b610d4181611f64565b60408051600080825260208201909252610d5d91839190611f8d565b50565b610d6c620200006119b0565b610d885760405162461bcd60e51b81526004016108a3906138c7565b6001600160401b0381161580610dc45750620f4240816001600160401b0316118015610dc45750670429d069189e0000816001600160401b0316105b610de05760405162461bcd60e51b81526004016108a3906138ee565b60cd805467ffffffffffffffff19166001600160401b03838116919091179182905560cc54604051600080516020613dd0833981519152936109ea936001600160a01b03841693600160a01b90048116928792600160401b90049091169061391d565b6001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000163003610e8b5760405162461bcd60e51b81526004016108a39061394f565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316610ebd611f36565b6001600160a01b031614610ee35760405162461bcd60e51b81526004016108a39061399b565b610eec82611f64565b610c7c82826001611f8d565b610f04620700006119b0565b610f205760405162461bcd60e51b81526004016108a3906138c7565b6001600160401b0383161580610f3e57506001600160a01b03841615155b610f795760405162461bcd60e51b815260206004820152600c60248201526b7a65726f206164647265737360a01b60448201526064016108a3565b6001600160401b0383161580610fb55750620f4240836001600160401b0316118015610fb55750670429d069189e0000836001600160401b0316105b8015610ff857506001600160401b0382161580610ff85750620f4240826001600160401b0316118015610ff85750670429d069189e0000826001600160401b0316105b801561103b57506001600160401b038116158061103b5750620f4240816001600160401b031611801561103b5750670429d069189e0000816001600160401b0316105b6110575760405162461bcd60e51b81526004016108a3906138ee565b60cc80546001600160401b03808616600160a01b026001600160e01b03199092166001600160a01b038816179190911790915560cd8054838316600160401b026fffffffffffffffffffffffffffffffff1990911692851692909217919091179055604051600080516020613dd0833981519152906110dd90869086908690869061391d565b60405180910390a150505050565b600080826001600160a01b031663d41c3a656040518163ffffffff1660e01b8152600401602060405180830381865afa925050508015611148575060408051601f3d908101601f19168201909252611145918101906139e7565b60015b61115457506000610a1e565b60cb546001600160a01b038281169116146111bb5760405162461bcd60e51b815260206004820152602160248201527f756e6b6e6f776e20455243323020696d706c656d656e746174696f6e207479706044820152606560f81b60648201526084016108a3565b5060019392505050565b6111d1621000006119b0565b6111ed5760405162461bcd60e51b81526004016108a3906138c7565b8060d1600084600181111561120457611204613742565b600181111561121557611215613742565b815260200190815260200160002060006101000a8154816001600160a01b0302191690836001600160a01b031602179055507f39d0c1f5555d16e32fcbf213430b2c212bf7d37ad5d7586156a134764d8ad29a8282604051611278929190613a04565b60405180910390a15050565b30600090815260016020526040812054610a1e905b8316831490565b600060d160008360018111156112b8576112b8613742565b60018111156112c9576112c9613742565b81526020810191909152604001600020546001600160a01b031692915050565b33600090815260d06020908152604091829020825180840190935280546001600160a01b031683526001015490820152611322816120d8565b156113605760405162461bcd60e51b815260206004820152600e60248201526d1b9bdd081c9959da5cdd195c995960921b60448201526064016108a3565b60006001600160a01b03166113d4336001600160a01b03166306ae0df96040518163ffffffff1660e01b81526004016040805180830381865afa1580156113ab573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113cf9190613a2a565b6120f7565b6001600160a01b03160361141c5760405162461bcd60e51b815260206004820152600f60248201526e1a5b9d985b1a59081cdd589a9958dd608a1b60448201526064016108a3565b610d5d336122c7565b6000428460a00135111561146b5760405162461bcd60e51b815260206004820152600d60248201526c1b9bdd081e595d081d985b1a59609a1b60448201526064016108a3565b428460c00135116114a85760405162461bcd60e51b8152602060048201526007602482015266195e1c1a5c995960ca1b60448201526064016108a3565b6114c56114bb608086016060870161357d565b8560e001356125d5565b600061151a84848080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250611514925061150f9150899050612679565b61270d565b9061275b565b9050610a0461152c60208701876137d8565b602087016115406080890160608a0161357d565b8860800135856119c2565b611557621000006119b0565b6115735760405162461bcd60e51b81526004016108a3906138c7565b60ce80546001600160a01b0319166001600160a01b0383169081179091556040517fafc0287a7a675aa38b3d1bc19df5c1a06cad878a807597d53611ec734ddb9f6190600090a250565b600060cf816112c96115d436869003860186613a64565b61277f565b6115e5620800006119b0565b6116015760405162461bcd60e51b81526004016108a3906138c7565b6001600160a01b038216600090815260d36020526040902054811161167e5760405162461bcd60e51b815260206004820152602d60248201527f6e6577206e6f6e6365206d75737420626520626967676572207468616e20746860448201526c652063757272656e74206f6e6560981b60648201526084016108a3565b6001600160a01b038216600081815260d3602052604090208290557f2af71f10069c28afc67c3752e87e0e4616a97948d33c8f404a856c0c334b3e016116c5600184613ab4565b6040519081526020015b60405180910390a25050565b6116e7620100006119b0565b6117035760405162461bcd60e51b81526004016108a3906138c7565b6001600160a01b03811615158061172a575060cc54600160a01b90046001600160401b0316155b61178b5760405162461bcd60e51b815260206004820152602c60248201527f70726f746f636f6c46656550657263656e74206d75737420626520736574207460448201526b1bc81e995c9bc8199a5c9cdd60a21b60648201526084016108a3565b60cc80546001600160a01b0383166001600160a01b0319909116179081905560cd54604051600080516020613dd0833981519152926109ea9285926001600160401b03600160a01b90930483169282811692600160401b9004169061391d565b600060d260008360018111156112b8576112b8613742565b6000610a24611f36565b61181a600160ff1b6119b0565b6118365760405162461bcd60e51b81526004016108a3906138c7565b610c7c828261188d3361185e876001600160a01b031660009081526001602052604090205490565b6001600160a01b0391909116600090815260016020526040902054600019808818821618908716919091171690565b6127ac565b6001600160a01b038216600090815260016020526040812054610a1b90611299565b6118c0620800006119b0565b6118dc5760405162461bcd60e51b81526004016108a3906138c7565b610d5d816122c7565b610d5d308261180d565b6118fb621000006119b0565b6119175760405162461bcd60e51b81526004016108a3906138c7565b8060d2600084600181111561192e5761192e613742565b600181111561193f5761193f613742565b815260200190815260200160002060006101000a8154816001600160a01b0302191690836001600160a01b031602179055507f6a09ac969b496d91039b79a4515de0a5694f234e77a6293f278e24f9ae6391018282604051611278929190613a04565b6000610a1b83836001610c80565b6000610a1e3383611892565b3b151590565b60006119ce6001611284565b611a1a5760405162461bcd60e51b815260206004820152601b60248201527f736861726573206465706c6f796d656e74732064697361626c6564000000000060448201526064016108a3565b82151580611a2d5750611a2d6002611284565b80611a3f5750611a3f620800006119b0565b611a8b5760405162461bcd60e51b815260206004820152601b60248201527f706175736564206465706c6f796d656e74732064697361626c6564000000000060448201526064016108a3565b600183111580611aa05750611aa06004611284565b80611ab25750611ab2620800006119b0565b611afe5760405162461bcd60e51b815260206004820152601760248201527f6578636c757369766520627579732064697361626c656400000000000000000060448201526064016108a3565b6000611b126113cf36889003880188613a64565b9050336001600160a01b0382161480611b335750611b338362080000611892565b80611b655750611b50611b4b36889003880188613a64565b612806565b6001600160a01b0316836001600160a01b0316145b611b815760405162461bcd60e51b81526004016108a3906138c7565b6001600160a01b038116611c4f576001600160a01b038516611bd75760405162461bcd60e51b815260206004820152600f60248201526e1a5b9d985b1a59081cdd589a9958dd608a1b60448201526064016108a3565b611be4602087018761357d565b6040516340c10f1960e01b81526001600160a01b0387811660048301526020890135602483015291909116906340c10f1990604401600060405180830381600087803b158015611c3357600080fd5b505af1158015611c47573d6000803e3d6000fd5b505050508490505b6000611c5a886112a0565b90506001600160a01b038116611cb25760405162461bcd60e51b815260206004820152601d60248201527f696d706c656d656e746174696f6e206e6f74207265676973746572656400000060448201526064016108a3565b6000611cbd8261285b565b90506000611cca8a6117eb565b905060006001600160a01b03821615611d9757611ce68261285b565b60ce549091506001600160a01b038083169163e023fd4291168560008f6001811115611d1457611d14613742565b14611d2a5760cb546001600160a01b0316611d2d565b60005b60405160e085901b6001600160e01b03191681526001600160a01b03938416600482015291831660248301529091166044820152606401600060405180830381600087803b158015611d7e57600080fd5b505af1158015611d92573d6000803e3d6000fd5b505050505b611da583828d8d8c8a6128f8565b6000611db96115d4368d90038d018d613a64565b600081815260cf60205260409020549091506001600160a01b031615611e125760405162461bcd60e51b815260206004820152600e60248201526d7375626a65637420696e2075736560901b60448201526064016108a3565b600081815260cf6020908152604080832080546001600160a01b0319166001600160a01b038916908117909155835260d090915290208b90611e548282613acb565b905050816001600160a01b0316846001600160a01b0316876001600160a01b03167f66c1d025001886ee359d6bdd456661ed32d9a2126425aec9bebc400c2368c2678f8f6001604051611ea993929190613b22565b60405180910390a450919a9950505050505050505050565b600054610100900460ff16611ee85760405162461bcd60e51b81526004016108a390613b4d565b815160209283012081519190920120609791909155609855565b600054610100900460ff16611f295760405162461bcd60e51b81526004016108a390613b4d565b610d5d81600019806127ac565b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc546001600160a01b031690565b611f71600160fe1b6119b0565b610d5d5760405162461bcd60e51b81526004016108a3906138c7565b6000611f97611f36565b9050611fa284612e36565b600083511180611faf5750815b15611fc057611fbe8484612edb565b505b7f4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143805460ff166120d157805460ff191660011781556040516001600160a01b038316602482015261203f90869060440160408051601f198184030181529190526020810180516001600160e01b0316631b2ce7f360e11b179052612edb565b50805460ff19168155612050611f36565b6001600160a01b0316826001600160a01b0316146120c85760405162461bcd60e51b815260206004820152602f60248201527f45524331393637557067726164653a207570677261646520627265616b73206660448201526e75727468657220757067726164657360881b60648201526084016108a3565b6120d185612fbd565b5050505050565b80516000906001600160a01b0316158015610a1e575050602001511590565b80516000903b156122bf5760008083600001516001600160a01b0316611324634f558e7960e01b866020015160405160240161213591815260200190565b60408051601f198184030181529181526020820180516001600160e01b03166001600160e01b03199094169390931790925290516121739190613bc8565b6000604051808303818686fa925050503d80600081146121af576040519150601f19603f3d011682016040523d82523d6000602084013e6121b4565b606091505b509150915081156121e157808060200190518101906121d39190613be4565b6121e1575060009392505050565b505060008083600001516001600160a01b0316611324636352211e60e01b866020015160405160240161221691815260200190565b60408051601f198184030181529181526020820180516001600160e01b03166001600160e01b03199094169390931790925290516122549190613bc8565b6000604051808303818686fa925050503d8060008114612290576040519150601f19603f3d011682016040523d82523d6000602084013e612295565b606091505b509150915081156122bc57808060200190518101906122b491906139e7565b949350505050565b50505b506000919050565b6000816001600160a01b03166306ae0df96040518163ffffffff1660e01b81526004016040805180830381865afa158015612306573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061232a9190613a2a565b6001600160a01b03808416600090815260d06020908152604091829020825180840190935280549093168252600190920154918101919091529091506123708282612ffd565b1561237a57505050565b60006123858361277f565b600081815260cf60205260409020549091506001600160a01b0316156123de5760405162461bcd60e51b815260206004820152600e60248201526d7375626a65637420696e2075736560901b60448201526064016108a3565b60cf60006123eb8461277f565b81526020808201929092526040908101600090812080546001600160a01b031990811690915584825260cf845282822080546001600160a01b038a8116918416821790925580845260d086529284902088518154921691909216178155868401516001919091015581516337e36f8360e01b8152915190926337e36f8392600480820193918290030181865afa158015612489573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906124ad91906139e7565b6001600160a01b0316846001600160a01b0316856001600160a01b0316637573af8e6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156124fe573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061252291906139e7565b6001600160a01b03167f66c1d025001886ee359d6bdd456661ed32d9a2126425aec9bebc400c2368c267612555886110eb565b886001600160a01b03166306ae0df96040518163ffffffff1660e01b81526004016040805180830381865afa158015612592573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906125b69190613a2a565b60006040516125c793929190613c06565b60405180910390a450505050565b6001600160a01b038216600090815260d360205260408120805483929091906125fd83613c3f565b919050551461263e5760405162461bcd60e51b815260206004820152600d60248201526c696e76616c6964206e6f6e636560981b60448201526064016108a3565b816001600160a01b03167f2af71f10069c28afc67c3752e87e0e4616a97948d33c8f404a856c0c334b3e01826040516116cf91815260200190565b60007f7acc9d8c19a06f50ae6d92c5e1206302e8aeac9f7f8bf014389ca2a4354650fd6126a960208401846137d8565b6126b58460200161303c565b6126c5608086016060870161357d565b85608001358660a001358760c001358860e001356040516020016126f0989796959493929190613c58565b604051602081830303815290604052805190602001209050919050565b6000610a1e61271a613099565b8360405161190160f01b6020820152602281018390526042810182905260009060620160405160208183030381529060405280519060200120905092915050565b600080600061276a8585613114565b9150915061277781613182565b509392505050565b8051602080830151604080516001600160a01b0390941692840192909252908201526000906060016126f0565b6001600160a01b03831660008181526001602090815260409182902084905581518581529081018490527fe9be537308880e0f56b7d7cfd7abf85f14c4934486d138f848b92a0cbaf659b4910160405180910390a2505050565b80516000903b156122bf57815160408051600481526024810182526020810180516001600160e01b0316638da5cb5b60e01b179052905160009283926001600160a01b03909116916113249161225491613bc8565b6000604051733d602d80600a3d3981f3363d3d373d3d3d363d7360601b81528260601b60148201526e5af43d82803e903d91602b57fd5bf360881b60288201526037816000f09150506001600160a01b0381166128f35760405162461bcd60e51b8152602060048201526016602482015275115490cc4c4d8dce8818dc99585d194819985a5b195960521b60448201526064016108a3565b919050565b60006001600160a01b0386161561291a5760cd546001600160401b031661291d565b60005b9050600085600181111561293357612933613742565b03612a0057866001600160a01b031663cfdc8b023460ce60009054906101000a90046001600160a01b03168760cc60009054906101000a90046001600160a01b031660cc60149054906101000a90046001600160401b03168c8860cd60089054906101000a90046001600160401b03168c8c6040518b63ffffffff1660e01b81526004016129c999989796959493929190613ca7565b6000604051808303818588803b1580156129e257600080fd5b505af11580156129f6573d6000803e3d6000fd5b5050505050612e2d565b6001856001811115612a1457612a14613742565b03612de5573415612a585760405162461bcd60e51b815260206004820152600e60248201526d6e6f6e2d7a65726f2076616c756560901b60448201526064016108a3565b6001831115612c105760cc5460cd54604051630648932d60e21b815260006004820181905260248201879052600160a01b9093046001600160401b0390811660448301528481166064830152600160401b90920490911660848201526001600160a01b038916906319224cb49060a401602060405180830381865afa158015612ae5573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612b099190613d12565b60cb546040516323b872dd60e01b8152336004820152306024820152604481018390529192506001600160a01b0316906323b872dd906064016020604051808303816000875af1158015612b61573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612b859190613be4565b612b8e57600080fd5b60cb5460405163095ea7b360e01b81526001600160a01b038a81166004830152602482018490529091169063095ea7b3906044016020604051808303816000875af1158015612be1573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612c059190613be4565b612c0e57600080fd5b505b866001600160a01b0316639ccb89e260ce60009054906101000a90046001600160a01b03168660cc60009054906101000a90046001600160a01b031660cc60149054906101000a90046001600160401b03168b8760cd60089054906101000a90046001600160401b03168b8b60cb60009054906101000a90046001600160a01b03166040518b63ffffffff1660e01b8152600401612cb79a99989796959493929190613d2b565b600060405180830381600087803b158015612cd157600080fd5b505af1158015612ce5573d6000803e3d6000fd5b505050506001831115612de05760cb546040516370a0823160e01b81523060048201526001600160a01b039091169063a9059cbb90339083906370a0823190602401602060405180830381865afa158015612d44573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612d689190613d12565b6040516001600160e01b031960e085901b1681526001600160a01b03909216600483015260248201526044016020604051808303816000875af1158015612db3573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612dd79190613be4565b612de057600080fd5b612e2d565b60405162461bcd60e51b815260206004820152601b60248201527f756e6b6e6f776e20696d706c656d656e746174696f6e2074797065000000000060448201526064016108a3565b50505050505050565b803b612e9a5760405162461bcd60e51b815260206004820152602d60248201527f455243313936373a206e657720696d706c656d656e746174696f6e206973206e60448201526c1bdd08184818dbdb9d1c9858dd609a1b60648201526084016108a3565b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc80546001600160a01b0319166001600160a01b0392909216919091179055565b6060823b612f3a5760405162461bcd60e51b815260206004820152602660248201527f416464726573733a2064656c65676174652063616c6c20746f206e6f6e2d636f6044820152651b9d1c9858dd60d21b60648201526084016108a3565b600080846001600160a01b031684604051612f559190613bc8565b600060405180830381855af49150503d8060008114612f90576040519150601f19603f3d011682016040523d82523d6000602084013e612f95565b606091505b5091509150610a048282604051806060016040528060278152602001613df060279139613338565b612fc681612e36565b6040516001600160a01b038216907fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b90600090a250565b81516000906001600160a01b0316158015906130275750815183516001600160a01b039081169116145b8015610a1b5750506020908101519101511490565b60007f685dd8e2693cf377e50b3e95f06b61dff4c1705fa19df1071074d64f4e1469eb61306c602084018461357d565b604080516020818101949094526001600160a01b03909216908201529083013560608201526080016126f0565b6000610a247f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f6130c860975490565b6098546040805160208101859052908101839052606081018290524660808201523060a082015260009060c0016040516020818303038152906040528051906020012090509392505050565b600080825160410361314a5760208301516040840151606085015160001a61313e87828585613371565b9450945050505061317b565b8251604003613173576020830151604084015161316886838361345e565b93509350505061317b565b506000905060025b9250929050565b600081600481111561319657613196613742565b0361319e5750565b60018160048111156131b2576131b2613742565b036131ff5760405162461bcd60e51b815260206004820152601860248201527f45434453413a20696e76616c6964207369676e6174757265000000000000000060448201526064016108a3565b600281600481111561321357613213613742565b036132605760405162461bcd60e51b815260206004820152601f60248201527f45434453413a20696e76616c6964207369676e6174757265206c656e6774680060448201526064016108a3565b600381600481111561327457613274613742565b036132cc5760405162461bcd60e51b815260206004820152602260248201527f45434453413a20696e76616c6964207369676e6174757265202773272076616c604482015261756560f01b60648201526084016108a3565b60048160048111156132e0576132e0613742565b03610d5d5760405162461bcd60e51b815260206004820152602260248201527f45434453413a20696e76616c6964207369676e6174757265202776272076616c604482015261756560f01b60648201526084016108a3565b60608315613347575081610c91565b8251156133575782518084602001fd5b8160405162461bcd60e51b81526004016108a39190613d9c565b6000807f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a08311156133a85750600090506003613455565b8460ff16601b141580156133c057508460ff16601c14155b156133d15750600090506004613455565b6040805160008082526020820180845289905260ff881692820192909252606081018690526080810185905260019060a0016020604051602081039080840390855afa158015613425573d6000803e3d6000fd5b5050604051601f1901519150506001600160a01b03811661344e57600060019250925050613455565b9150600090505b94509492505050565b6000806001600160ff1b03831660ff84901c601b0161347f87828885613371565b935093505050935093915050565b80356001600160401b03811681146128f357600080fd5b6000602082840312156134b657600080fd5b610a1b8261348d565b8035600281106128f357600080fd5b6000604082840312156134e057600080fd5b50919050565b6001600160a01b0381168114610d5d57600080fd5b60008060008060a0858703121561351157600080fd5b61351a856134bf565b935061352986602087016134ce565b92506060850135613539816134e6565b9396929550929360800135925050565b6000806060838503121561355c57600080fd5b613565836134bf565b915061357484602085016134ce565b90509250929050565b60006020828403121561358f57600080fd5b8135610c91816134e6565b6000806000608084860312156135af57600080fd5b6135b8846134bf565b92506135c785602086016134ce565b9150606084013590509250925092565b634e487b7160e01b600052604160045260246000fd5b604080519081016001600160401b038111828210171561360f5761360f6135d7565b60405290565b604051601f8201601f191681016001600160401b038111828210171561363d5761363d6135d7565b604052919050565b6000806040838503121561365857600080fd5b8235613663816134e6565b91506020838101356001600160401b038082111561368057600080fd5b818601915086601f83011261369457600080fd5b8135818111156136a6576136a66135d7565b6136b8601f8201601f19168501613615565b915080825287848285010111156136ce57600080fd5b80848401858401376000848284010152508093505050509250929050565b6000806000806080858703121561370257600080fd5b843561370d816134e6565b935061371b6020860161348d565b92506137296040860161348d565b91506137376060860161348d565b905092959194509250565b634e487b7160e01b600052602160045260246000fd5b6002811061377657634e487b7160e01b600052602160045260246000fd5b9052565b60208101610a1e8284613758565b6000806040838503121561379b57600080fd5b6137a4836134bf565b915060208301356137b4816134e6565b809150509250929050565b6000602082840312156137d157600080fd5b5035919050565b6000602082840312156137ea57600080fd5b610a1b826134bf565b600080600083850361012081121561380a57600080fd5b6101008082121561381a57600080fd5b85945084013590506001600160401b038082111561383757600080fd5b818601915086601f83011261384b57600080fd5b81358181111561385a57600080fd5b87602082850101111561386c57600080fd5b6020830194508093505050509250925092565b60006040828403121561389157600080fd5b610a1b83836134ce565b600080604083850312156138ae57600080fd5b82356138b9816134e6565b946020939093013593505050565b6020808252600d908201526c1858d8d95cdcc819195b9a5959609a1b604082015260600190565b6020808252601590820152741b585b199bdc9b595908199959481c195c98d95b9d605a1b604082015260600190565b6001600160a01b039490941684526001600160401b039283166020850152908216604084015216606082015260800190565b6020808252602c908201527f46756e6374696f6e206d7573742062652063616c6c6564207468726f7567682060408201526b19195b1959d85d1958d85b1b60a21b606082015260800190565b6020808252602c908201527f46756e6374696f6e206d7573742062652063616c6c6564207468726f7567682060408201526b6163746976652070726f787960a01b606082015260800190565b6000602082840312156139f957600080fd5b8151610c91816134e6565b60408101613a128285613758565b6001600160a01b039290921660209190910152919050565b600060408284031215613a3c57600080fd5b613a446135ed565b8251613a4f816134e6565b81526020928301519281019290925250919050565b600060408284031215613a7657600080fd5b613a7e6135ed565b8235613a89816134e6565b81526020928301359281019290925250919050565b634e487b7160e01b600052601160045260246000fd5b600082821015613ac657613ac6613a9e565b500390565b8135613ad6816134e6565b81546001600160a01b0319166001600160a01b03919091161781556020919091013560019190910155565b8035613b0c816134e6565b6001600160a01b03168252602090810135910152565b60808101613b308286613758565b613b3d6020830185613b01565b8215156060830152949350505050565b6020808252602b908201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960408201526a6e697469616c697a696e6760a81b606082015260800190565b60005b83811015613bb3578181015183820152602001613b9b565b83811115613bc2576000848401525b50505050565b60008251613bda818460208701613b98565b9190910192915050565b600060208284031215613bf657600080fd5b81518015158114610c9157600080fd5b60808101613c148286613758565b83516001600160a01b0316602083810191909152909301516040820152901515606090910152919050565b600060018201613c5157613c51613a9e565b5060010190565b8881526101008101613c6d602083018a613758565b60408201979097526001600160a01b03959095166060860152608085019390935260a084019190915260c083015260e09091015292915050565b6001600160a01b038a81168252610140820190613cc7602084018c613b01565b98891660608301526001600160401b03978816608083015295881660a082015293861660c08501529190941660e0830152610100820193909352919092166101209091015292915050565b600060208284031215613d2457600080fd5b5051919050565b6001600160a01b038b81168252610160820190613d4b602084018d613b01565b998a1660608301526001600160401b03988916608083015296891660a082015294871660c08601529290951660e0840152610100830152928416610120820152919092166101409091015292915050565b6020815260008251806020840152613dbb816040850160208701613b98565b601f01601f1916919091016040019291505056fe7cc25b0a5b4d04c15a8cdc1e104f221f1263a55074d6c1c053fc6b1c7734efbe416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c206661696c6564a2646970667358221220237f29e94a9c1fe244976aadbfec66c4fcc09481e2df39212810f87e987d58fd64736f6c634300080f0033",
  "deployedBytecode": "0x6080604052600436106102935760003560e01c80637d4912151161015a578063ae682e2e116100c1578063d3a63eb31161007a578063d3a63eb3146107bd578063d41c3a65146107dd578063d5bb7f67146107fb578063e3bf4c151461081b578063f0254a071461083b578063fcc2c0781461085b57600080fd5b8063ae682e2e1461071f578063b1c6ffcf14610737578063c2fec9fb1461074e578063c688d69314610763578063cd3f29e914610783578063d216d77b146107a857600080fd5b80639e59e2f2116101135780639e59e2f214610674578063a10786b014610692578063a248a831146106b2578063aaf10f42146106d2578063ae5b102e146106e7578063ae60bda41461070757600080fd5b80637d491215146105cc5780637fcb7b42146105df57806381f8a0df146105f65780638db462fc1461061657806391e9c79c146106345780639e35e6a51461065457600080fd5b806340472069116101fe5780635639b19f116101b75780635639b19f1461050357806358ab4e90146105305780636c5d611314610547578063725f36261461056757806372e926a4146105975780637b80be6b146105b757600080fd5b8063404720691461043e57806343fc12001461045557806344276733146104755780634f1ef286146104ab57806351033545146104be57806353b73799146104de57600080fd5b80632b521416116102505780632b521416146103695780632d0335ab146103955780632e53c12a146103cb57806331576ad5146103eb5780633505da541461040b5780633659cfe61461041e57600080fd5b80630fb25c75146102985780631263aa2b146102c757806325f335c5146102e95780632639b8d1146103145780632651ecc8146103325780632b30a5d714610349575b600080fd5b3480156102a457600080fd5b506102ad600281565b60405163ffffffff90911681526020015b60405180910390f35b3480156102d357600080fd5b506102e76102e23660046134a4565b61087b565b005b6102fc6102f73660046134fb565b6109f5565b6040516001600160a01b0390911681526020016102be565b34801561032057600080fd5b5060ce546001600160a01b03166102fc565b34801561033e57600080fd5b506102ad6208000081565b34801561035557600080fd5b506102fc610364366004613549565b610a0d565b34801561037557600080fd5b50306000908152600160205260409020545b6040519081526020016102be565b3480156103a157600080fd5b506103876103b036600461357d565b6001600160a01b0316600090815260d3602052604090205490565b3480156103d757600080fd5b506102e76103e63660046134a4565b610a29565b3480156103f757600080fd5b506102e761040636600461357d565b610b15565b6102fc61041936600461359a565b610c80565b34801561042a57600080fd5b506102e761043936600461357d565b610c98565b34801561044a57600080fd5b506102ad6210000081565b34801561046157600080fd5b506102e76104703660046134a4565b610d60565b34801561048157600080fd5b5061038761049036600461357d565b6001600160a01b031660009081526001602052604090205490565b6102e76104b9366004613645565b610e43565b3480156104ca57600080fd5b506102e76104d93660046136ec565b610ef8565b3480156104ea57600080fd5b5060cd54600160401b90046001600160401b0316610387565b34801561050f57600080fd5b5061052361051e36600461357d565b6110eb565b6040516102be919061377a565b34801561053c57600080fd5b506102ad6202000081565b34801561055357600080fd5b506102e7610562366004613788565b6111c5565b34801561057357600080fd5b506105876105823660046137bf565b611284565b60405190151581526020016102be565b3480156105a357600080fd5b506102fc6105b23660046137d8565b6112a0565b3480156105c357600080fd5b506102e76112e9565b6102fc6105da3660046137f3565b611425565b3480156105eb57600080fd5b506102ad6204000081565b34801561060257600080fd5b506102e761061136600461357d565b61154b565b34801561062257600080fd5b5060cc546001600160a01b03166102fc565b34801561064057600080fd5b506102fc61064f36600461387f565b6115bd565b34801561066057600080fd5b506102e761066f36600461389b565b6115d9565b34801561068057600080fd5b5060cd546001600160401b0316610387565b34801561069e57600080fd5b506102e76106ad36600461357d565b6116db565b3480156106be57600080fd5b506102fc6106cd3660046137d8565b6117eb565b3480156106de57600080fd5b506102fc611803565b3480156106f357600080fd5b506102e761070236600461389b565b61180d565b34801561071357600080fd5b50610387600160fe1b81565b34801561072b57600080fd5b50610387600160ff1b81565b34801561074357600080fd5b506102ad6201000081565b34801561075a57600080fd5b506102ad600181565b34801561076f57600080fd5b5061058761077e36600461389b565b611892565b34801561078f57600080fd5b5060cc54600160a01b90046001600160401b0316610387565b3480156107b457600080fd5b506102ad600481565b3480156107c957600080fd5b506102e76107d836600461357d565b6118b4565b3480156107e957600080fd5b5060cb546001600160a01b03166102fc565b34801561080757600080fd5b506102e76108163660046137bf565b6118e5565b34801561082757600080fd5b506102e7610836366004613788565b6118ef565b34801561084757600080fd5b506102fc610856366004613549565b6119a2565b34801561086757600080fd5b506105876108763660046137bf565b6119b0565b610887620100006119b0565b6108ac5760405162461bcd60e51b81526004016108a3906138c7565b60405180910390fd5b6001600160401b03811615806108cc575060cc546001600160a01b031615155b6109295760405162461bcd60e51b815260206004820152602860248201527f70726f746f636f6c46656544657374696e6174696f6e206d7573742062652073604482015267195d08199a5c9cdd60c21b60648201526084016108a3565b6001600160401b03811615806109655750620f4240816001600160401b03161180156109655750670429d069189e0000816001600160401b0316105b6109815760405162461bcd60e51b81526004016108a3906138ee565b60cc80546001600160401b03808416600160a01b0267ffffffffffffffff60a01b198316811790935560cd54604051600080516020613dd0833981519152946109ea946001600160a01b0391821691161792869280821692600160401b9091049091169061391d565b60405180910390a150565b6000610a0485858585336119c2565b95945050505050565b6000610a1b83836000610c80565b90505b92915050565b905090565b610a35620400006119b0565b610a515760405162461bcd60e51b81526004016108a3906138c7565b6001600160401b0381161580610a8d5750620f4240816001600160401b0316118015610a8d5750670429d069189e0000816001600160401b0316105b610aa95760405162461bcd60e51b81526004016108a3906138ee565b60cd80546001600160401b03808416600160401b026fffffffffffffffff0000000000000000198316811790935560cc54604051600080516020613dd0833981519152946109ea946001600160a01b03841694600160a01b90940484169391821691161790869061391d565b600054610100900460ff16610b305760005460ff1615610b34565b303b155b610b975760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201526d191e481a5b9a5d1a585b1a5e995960921b60648201526084016108a3565b600054610100900460ff16158015610bb9576000805461ffff19166101011790555b610c016040518060400160405280600d81526020016c536861726573466163746f727960981b815250604051806040016040528060018152602001603160f81b815250611ec1565b610c0a33611f02565b6001600160a01b038216610c4f5760405162461bcd60e51b815260206004820152600c60248201526b7a65726f206164647265737360a01b60448201526064016108a3565b60cb80546001600160a01b0319166001600160a01b0384161790558015610c7c576000805461ff00191690555b5050565b6000610c8e848433856109f5565b90505b9392505050565b6001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000163003610ce05760405162461bcd60e51b81526004016108a39061394f565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316610d12611f36565b6001600160a01b031614610d385760405162461bcd60e51b81526004016108a39061399b565b610d4181611f64565b60408051600080825260208201909252610d5d91839190611f8d565b50565b610d6c620200006119b0565b610d885760405162461bcd60e51b81526004016108a3906138c7565b6001600160401b0381161580610dc45750620f4240816001600160401b0316118015610dc45750670429d069189e0000816001600160401b0316105b610de05760405162461bcd60e51b81526004016108a3906138ee565b60cd805467ffffffffffffffff19166001600160401b03838116919091179182905560cc54604051600080516020613dd0833981519152936109ea936001600160a01b03841693600160a01b90048116928792600160401b90049091169061391d565b6001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000163003610e8b5760405162461bcd60e51b81526004016108a39061394f565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316610ebd611f36565b6001600160a01b031614610ee35760405162461bcd60e51b81526004016108a39061399b565b610eec82611f64565b610c7c82826001611f8d565b610f04620700006119b0565b610f205760405162461bcd60e51b81526004016108a3906138c7565b6001600160401b0383161580610f3e57506001600160a01b03841615155b610f795760405162461bcd60e51b815260206004820152600c60248201526b7a65726f206164647265737360a01b60448201526064016108a3565b6001600160401b0383161580610fb55750620f4240836001600160401b0316118015610fb55750670429d069189e0000836001600160401b0316105b8015610ff857506001600160401b0382161580610ff85750620f4240826001600160401b0316118015610ff85750670429d069189e0000826001600160401b0316105b801561103b57506001600160401b038116158061103b5750620f4240816001600160401b031611801561103b5750670429d069189e0000816001600160401b0316105b6110575760405162461bcd60e51b81526004016108a3906138ee565b60cc80546001600160401b03808616600160a01b026001600160e01b03199092166001600160a01b038816179190911790915560cd8054838316600160401b026fffffffffffffffffffffffffffffffff1990911692851692909217919091179055604051600080516020613dd0833981519152906110dd90869086908690869061391d565b60405180910390a150505050565b600080826001600160a01b031663d41c3a656040518163ffffffff1660e01b8152600401602060405180830381865afa925050508015611148575060408051601f3d908101601f19168201909252611145918101906139e7565b60015b61115457506000610a1e565b60cb546001600160a01b038281169116146111bb5760405162461bcd60e51b815260206004820152602160248201527f756e6b6e6f776e20455243323020696d706c656d656e746174696f6e207479706044820152606560f81b60648201526084016108a3565b5060019392505050565b6111d1621000006119b0565b6111ed5760405162461bcd60e51b81526004016108a3906138c7565b8060d1600084600181111561120457611204613742565b600181111561121557611215613742565b815260200190815260200160002060006101000a8154816001600160a01b0302191690836001600160a01b031602179055507f39d0c1f5555d16e32fcbf213430b2c212bf7d37ad5d7586156a134764d8ad29a8282604051611278929190613a04565b60405180910390a15050565b30600090815260016020526040812054610a1e905b8316831490565b600060d160008360018111156112b8576112b8613742565b60018111156112c9576112c9613742565b81526020810191909152604001600020546001600160a01b031692915050565b33600090815260d06020908152604091829020825180840190935280546001600160a01b031683526001015490820152611322816120d8565b156113605760405162461bcd60e51b815260206004820152600e60248201526d1b9bdd081c9959da5cdd195c995960921b60448201526064016108a3565b60006001600160a01b03166113d4336001600160a01b03166306ae0df96040518163ffffffff1660e01b81526004016040805180830381865afa1580156113ab573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113cf9190613a2a565b6120f7565b6001600160a01b03160361141c5760405162461bcd60e51b815260206004820152600f60248201526e1a5b9d985b1a59081cdd589a9958dd608a1b60448201526064016108a3565b610d5d336122c7565b6000428460a00135111561146b5760405162461bcd60e51b815260206004820152600d60248201526c1b9bdd081e595d081d985b1a59609a1b60448201526064016108a3565b428460c00135116114a85760405162461bcd60e51b8152602060048201526007602482015266195e1c1a5c995960ca1b60448201526064016108a3565b6114c56114bb608086016060870161357d565b8560e001356125d5565b600061151a84848080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250611514925061150f9150899050612679565b61270d565b9061275b565b9050610a0461152c60208701876137d8565b602087016115406080890160608a0161357d565b8860800135856119c2565b611557621000006119b0565b6115735760405162461bcd60e51b81526004016108a3906138c7565b60ce80546001600160a01b0319166001600160a01b0383169081179091556040517fafc0287a7a675aa38b3d1bc19df5c1a06cad878a807597d53611ec734ddb9f6190600090a250565b600060cf816112c96115d436869003860186613a64565b61277f565b6115e5620800006119b0565b6116015760405162461bcd60e51b81526004016108a3906138c7565b6001600160a01b038216600090815260d36020526040902054811161167e5760405162461bcd60e51b815260206004820152602d60248201527f6e6577206e6f6e6365206d75737420626520626967676572207468616e20746860448201526c652063757272656e74206f6e6560981b60648201526084016108a3565b6001600160a01b038216600081815260d3602052604090208290557f2af71f10069c28afc67c3752e87e0e4616a97948d33c8f404a856c0c334b3e016116c5600184613ab4565b6040519081526020015b60405180910390a25050565b6116e7620100006119b0565b6117035760405162461bcd60e51b81526004016108a3906138c7565b6001600160a01b03811615158061172a575060cc54600160a01b90046001600160401b0316155b61178b5760405162461bcd60e51b815260206004820152602c60248201527f70726f746f636f6c46656550657263656e74206d75737420626520736574207460448201526b1bc81e995c9bc8199a5c9cdd60a21b60648201526084016108a3565b60cc80546001600160a01b0383166001600160a01b0319909116179081905560cd54604051600080516020613dd0833981519152926109ea9285926001600160401b03600160a01b90930483169282811692600160401b9004169061391d565b600060d260008360018111156112b8576112b8613742565b6000610a24611f36565b61181a600160ff1b6119b0565b6118365760405162461bcd60e51b81526004016108a3906138c7565b610c7c828261188d3361185e876001600160a01b031660009081526001602052604090205490565b6001600160a01b0391909116600090815260016020526040902054600019808818821618908716919091171690565b6127ac565b6001600160a01b038216600090815260016020526040812054610a1b90611299565b6118c0620800006119b0565b6118dc5760405162461bcd60e51b81526004016108a3906138c7565b610d5d816122c7565b610d5d308261180d565b6118fb621000006119b0565b6119175760405162461bcd60e51b81526004016108a3906138c7565b8060d2600084600181111561192e5761192e613742565b600181111561193f5761193f613742565b815260200190815260200160002060006101000a8154816001600160a01b0302191690836001600160a01b031602179055507f6a09ac969b496d91039b79a4515de0a5694f234e77a6293f278e24f9ae6391018282604051611278929190613a04565b6000610a1b83836001610c80565b6000610a1e3383611892565b3b151590565b60006119ce6001611284565b611a1a5760405162461bcd60e51b815260206004820152601b60248201527f736861726573206465706c6f796d656e74732064697361626c6564000000000060448201526064016108a3565b82151580611a2d5750611a2d6002611284565b80611a3f5750611a3f620800006119b0565b611a8b5760405162461bcd60e51b815260206004820152601b60248201527f706175736564206465706c6f796d656e74732064697361626c6564000000000060448201526064016108a3565b600183111580611aa05750611aa06004611284565b80611ab25750611ab2620800006119b0565b611afe5760405162461bcd60e51b815260206004820152601760248201527f6578636c757369766520627579732064697361626c656400000000000000000060448201526064016108a3565b6000611b126113cf36889003880188613a64565b9050336001600160a01b0382161480611b335750611b338362080000611892565b80611b655750611b50611b4b36889003880188613a64565b612806565b6001600160a01b0316836001600160a01b0316145b611b815760405162461bcd60e51b81526004016108a3906138c7565b6001600160a01b038116611c4f576001600160a01b038516611bd75760405162461bcd60e51b815260206004820152600f60248201526e1a5b9d985b1a59081cdd589a9958dd608a1b60448201526064016108a3565b611be4602087018761357d565b6040516340c10f1960e01b81526001600160a01b0387811660048301526020890135602483015291909116906340c10f1990604401600060405180830381600087803b158015611c3357600080fd5b505af1158015611c47573d6000803e3d6000fd5b505050508490505b6000611c5a886112a0565b90506001600160a01b038116611cb25760405162461bcd60e51b815260206004820152601d60248201527f696d706c656d656e746174696f6e206e6f74207265676973746572656400000060448201526064016108a3565b6000611cbd8261285b565b90506000611cca8a6117eb565b905060006001600160a01b03821615611d9757611ce68261285b565b60ce549091506001600160a01b038083169163e023fd4291168560008f6001811115611d1457611d14613742565b14611d2a5760cb546001600160a01b0316611d2d565b60005b60405160e085901b6001600160e01b03191681526001600160a01b03938416600482015291831660248301529091166044820152606401600060405180830381600087803b158015611d7e57600080fd5b505af1158015611d92573d6000803e3d6000fd5b505050505b611da583828d8d8c8a6128f8565b6000611db96115d4368d90038d018d613a64565b600081815260cf60205260409020549091506001600160a01b031615611e125760405162461bcd60e51b815260206004820152600e60248201526d7375626a65637420696e2075736560901b60448201526064016108a3565b600081815260cf6020908152604080832080546001600160a01b0319166001600160a01b038916908117909155835260d090915290208b90611e548282613acb565b905050816001600160a01b0316846001600160a01b0316876001600160a01b03167f66c1d025001886ee359d6bdd456661ed32d9a2126425aec9bebc400c2368c2678f8f6001604051611ea993929190613b22565b60405180910390a450919a9950505050505050505050565b600054610100900460ff16611ee85760405162461bcd60e51b81526004016108a390613b4d565b815160209283012081519190920120609791909155609855565b600054610100900460ff16611f295760405162461bcd60e51b81526004016108a390613b4d565b610d5d81600019806127ac565b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc546001600160a01b031690565b611f71600160fe1b6119b0565b610d5d5760405162461bcd60e51b81526004016108a3906138c7565b6000611f97611f36565b9050611fa284612e36565b600083511180611faf5750815b15611fc057611fbe8484612edb565b505b7f4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143805460ff166120d157805460ff191660011781556040516001600160a01b038316602482015261203f90869060440160408051601f198184030181529190526020810180516001600160e01b0316631b2ce7f360e11b179052612edb565b50805460ff19168155612050611f36565b6001600160a01b0316826001600160a01b0316146120c85760405162461bcd60e51b815260206004820152602f60248201527f45524331393637557067726164653a207570677261646520627265616b73206660448201526e75727468657220757067726164657360881b60648201526084016108a3565b6120d185612fbd565b5050505050565b80516000906001600160a01b0316158015610a1e575050602001511590565b80516000903b156122bf5760008083600001516001600160a01b0316611324634f558e7960e01b866020015160405160240161213591815260200190565b60408051601f198184030181529181526020820180516001600160e01b03166001600160e01b03199094169390931790925290516121739190613bc8565b6000604051808303818686fa925050503d80600081146121af576040519150601f19603f3d011682016040523d82523d6000602084013e6121b4565b606091505b509150915081156121e157808060200190518101906121d39190613be4565b6121e1575060009392505050565b505060008083600001516001600160a01b0316611324636352211e60e01b866020015160405160240161221691815260200190565b60408051601f198184030181529181526020820180516001600160e01b03166001600160e01b03199094169390931790925290516122549190613bc8565b6000604051808303818686fa925050503d8060008114612290576040519150601f19603f3d011682016040523d82523d6000602084013e612295565b606091505b509150915081156122bc57808060200190518101906122b491906139e7565b949350505050565b50505b506000919050565b6000816001600160a01b03166306ae0df96040518163ffffffff1660e01b81526004016040805180830381865afa158015612306573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061232a9190613a2a565b6001600160a01b03808416600090815260d06020908152604091829020825180840190935280549093168252600190920154918101919091529091506123708282612ffd565b1561237a57505050565b60006123858361277f565b600081815260cf60205260409020549091506001600160a01b0316156123de5760405162461bcd60e51b815260206004820152600e60248201526d7375626a65637420696e2075736560901b60448201526064016108a3565b60cf60006123eb8461277f565b81526020808201929092526040908101600090812080546001600160a01b031990811690915584825260cf845282822080546001600160a01b038a8116918416821790925580845260d086529284902088518154921691909216178155868401516001919091015581516337e36f8360e01b8152915190926337e36f8392600480820193918290030181865afa158015612489573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906124ad91906139e7565b6001600160a01b0316846001600160a01b0316856001600160a01b0316637573af8e6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156124fe573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061252291906139e7565b6001600160a01b03167f66c1d025001886ee359d6bdd456661ed32d9a2126425aec9bebc400c2368c267612555886110eb565b886001600160a01b03166306ae0df96040518163ffffffff1660e01b81526004016040805180830381865afa158015612592573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906125b69190613a2a565b60006040516125c793929190613c06565b60405180910390a450505050565b6001600160a01b038216600090815260d360205260408120805483929091906125fd83613c3f565b919050551461263e5760405162461bcd60e51b815260206004820152600d60248201526c696e76616c6964206e6f6e636560981b60448201526064016108a3565b816001600160a01b03167f2af71f10069c28afc67c3752e87e0e4616a97948d33c8f404a856c0c334b3e01826040516116cf91815260200190565b60007f7acc9d8c19a06f50ae6d92c5e1206302e8aeac9f7f8bf014389ca2a4354650fd6126a960208401846137d8565b6126b58460200161303c565b6126c5608086016060870161357d565b85608001358660a001358760c001358860e001356040516020016126f0989796959493929190613c58565b604051602081830303815290604052805190602001209050919050565b6000610a1e61271a613099565b8360405161190160f01b6020820152602281018390526042810182905260009060620160405160208183030381529060405280519060200120905092915050565b600080600061276a8585613114565b9150915061277781613182565b509392505050565b8051602080830151604080516001600160a01b0390941692840192909252908201526000906060016126f0565b6001600160a01b03831660008181526001602090815260409182902084905581518581529081018490527fe9be537308880e0f56b7d7cfd7abf85f14c4934486d138f848b92a0cbaf659b4910160405180910390a2505050565b80516000903b156122bf57815160408051600481526024810182526020810180516001600160e01b0316638da5cb5b60e01b179052905160009283926001600160a01b03909116916113249161225491613bc8565b6000604051733d602d80600a3d3981f3363d3d373d3d3d363d7360601b81528260601b60148201526e5af43d82803e903d91602b57fd5bf360881b60288201526037816000f09150506001600160a01b0381166128f35760405162461bcd60e51b8152602060048201526016602482015275115490cc4c4d8dce8818dc99585d194819985a5b195960521b60448201526064016108a3565b919050565b60006001600160a01b0386161561291a5760cd546001600160401b031661291d565b60005b9050600085600181111561293357612933613742565b03612a0057866001600160a01b031663cfdc8b023460ce60009054906101000a90046001600160a01b03168760cc60009054906101000a90046001600160a01b031660cc60149054906101000a90046001600160401b03168c8860cd60089054906101000a90046001600160401b03168c8c6040518b63ffffffff1660e01b81526004016129c999989796959493929190613ca7565b6000604051808303818588803b1580156129e257600080fd5b505af11580156129f6573d6000803e3d6000fd5b5050505050612e2d565b6001856001811115612a1457612a14613742565b03612de5573415612a585760405162461bcd60e51b815260206004820152600e60248201526d6e6f6e2d7a65726f2076616c756560901b60448201526064016108a3565b6001831115612c105760cc5460cd54604051630648932d60e21b815260006004820181905260248201879052600160a01b9093046001600160401b0390811660448301528481166064830152600160401b90920490911660848201526001600160a01b038916906319224cb49060a401602060405180830381865afa158015612ae5573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612b099190613d12565b60cb546040516323b872dd60e01b8152336004820152306024820152604481018390529192506001600160a01b0316906323b872dd906064016020604051808303816000875af1158015612b61573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612b859190613be4565b612b8e57600080fd5b60cb5460405163095ea7b360e01b81526001600160a01b038a81166004830152602482018490529091169063095ea7b3906044016020604051808303816000875af1158015612be1573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612c059190613be4565b612c0e57600080fd5b505b866001600160a01b0316639ccb89e260ce60009054906101000a90046001600160a01b03168660cc60009054906101000a90046001600160a01b031660cc60149054906101000a90046001600160401b03168b8760cd60089054906101000a90046001600160401b03168b8b60cb60009054906101000a90046001600160a01b03166040518b63ffffffff1660e01b8152600401612cb79a99989796959493929190613d2b565b600060405180830381600087803b158015612cd157600080fd5b505af1158015612ce5573d6000803e3d6000fd5b505050506001831115612de05760cb546040516370a0823160e01b81523060048201526001600160a01b039091169063a9059cbb90339083906370a0823190602401602060405180830381865afa158015612d44573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612d689190613d12565b6040516001600160e01b031960e085901b1681526001600160a01b03909216600483015260248201526044016020604051808303816000875af1158015612db3573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612dd79190613be4565b612de057600080fd5b612e2d565b60405162461bcd60e51b815260206004820152601b60248201527f756e6b6e6f776e20696d706c656d656e746174696f6e2074797065000000000060448201526064016108a3565b50505050505050565b803b612e9a5760405162461bcd60e51b815260206004820152602d60248201527f455243313936373a206e657720696d706c656d656e746174696f6e206973206e60448201526c1bdd08184818dbdb9d1c9858dd609a1b60648201526084016108a3565b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc80546001600160a01b0319166001600160a01b0392909216919091179055565b6060823b612f3a5760405162461bcd60e51b815260206004820152602660248201527f416464726573733a2064656c65676174652063616c6c20746f206e6f6e2d636f6044820152651b9d1c9858dd60d21b60648201526084016108a3565b600080846001600160a01b031684604051612f559190613bc8565b600060405180830381855af49150503d8060008114612f90576040519150601f19603f3d011682016040523d82523d6000602084013e612f95565b606091505b5091509150610a048282604051806060016040528060278152602001613df060279139613338565b612fc681612e36565b6040516001600160a01b038216907fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b90600090a250565b81516000906001600160a01b0316158015906130275750815183516001600160a01b039081169116145b8015610a1b5750506020908101519101511490565b60007f685dd8e2693cf377e50b3e95f06b61dff4c1705fa19df1071074d64f4e1469eb61306c602084018461357d565b604080516020818101949094526001600160a01b03909216908201529083013560608201526080016126f0565b6000610a247f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f6130c860975490565b6098546040805160208101859052908101839052606081018290524660808201523060a082015260009060c0016040516020818303038152906040528051906020012090509392505050565b600080825160410361314a5760208301516040840151606085015160001a61313e87828585613371565b9450945050505061317b565b8251604003613173576020830151604084015161316886838361345e565b93509350505061317b565b506000905060025b9250929050565b600081600481111561319657613196613742565b0361319e5750565b60018160048111156131b2576131b2613742565b036131ff5760405162461bcd60e51b815260206004820152601860248201527f45434453413a20696e76616c6964207369676e6174757265000000000000000060448201526064016108a3565b600281600481111561321357613213613742565b036132605760405162461bcd60e51b815260206004820152601f60248201527f45434453413a20696e76616c6964207369676e6174757265206c656e6774680060448201526064016108a3565b600381600481111561327457613274613742565b036132cc5760405162461bcd60e51b815260206004820152602260248201527f45434453413a20696e76616c6964207369676e6174757265202773272076616c604482015261756560f01b60648201526084016108a3565b60048160048111156132e0576132e0613742565b03610d5d5760405162461bcd60e51b815260206004820152602260248201527f45434453413a20696e76616c6964207369676e6174757265202776272076616c604482015261756560f01b60648201526084016108a3565b60608315613347575081610c91565b8251156133575782518084602001fd5b8160405162461bcd60e51b81526004016108a39190613d9c565b6000807f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a08311156133a85750600090506003613455565b8460ff16601b141580156133c057508460ff16601c14155b156133d15750600090506004613455565b6040805160008082526020820180845289905260ff881692820192909252606081018690526080810185905260019060a0016020604051602081039080840390855afa158015613425573d6000803e3d6000fd5b5050604051601f1901519150506001600160a01b03811661344e57600060019250925050613455565b9150600090505b94509492505050565b6000806001600160ff1b03831660ff84901c601b0161347f87828885613371565b935093505050935093915050565b80356001600160401b03811681146128f357600080fd5b6000602082840312156134b657600080fd5b610a1b8261348d565b8035600281106128f357600080fd5b6000604082840312156134e057600080fd5b50919050565b6001600160a01b0381168114610d5d57600080fd5b60008060008060a0858703121561351157600080fd5b61351a856134bf565b935061352986602087016134ce565b92506060850135613539816134e6565b9396929550929360800135925050565b6000806060838503121561355c57600080fd5b613565836134bf565b915061357484602085016134ce565b90509250929050565b60006020828403121561358f57600080fd5b8135610c91816134e6565b6000806000608084860312156135af57600080fd5b6135b8846134bf565b92506135c785602086016134ce565b9150606084013590509250925092565b634e487b7160e01b600052604160045260246000fd5b604080519081016001600160401b038111828210171561360f5761360f6135d7565b60405290565b604051601f8201601f191681016001600160401b038111828210171561363d5761363d6135d7565b604052919050565b6000806040838503121561365857600080fd5b8235613663816134e6565b91506020838101356001600160401b038082111561368057600080fd5b818601915086601f83011261369457600080fd5b8135818111156136a6576136a66135d7565b6136b8601f8201601f19168501613615565b915080825287848285010111156136ce57600080fd5b80848401858401376000848284010152508093505050509250929050565b6000806000806080858703121561370257600080fd5b843561370d816134e6565b935061371b6020860161348d565b92506137296040860161348d565b91506137376060860161348d565b905092959194509250565b634e487b7160e01b600052602160045260246000fd5b6002811061377657634e487b7160e01b600052602160045260246000fd5b9052565b60208101610a1e8284613758565b6000806040838503121561379b57600080fd5b6137a4836134bf565b915060208301356137b4816134e6565b809150509250929050565b6000602082840312156137d157600080fd5b5035919050565b6000602082840312156137ea57600080fd5b610a1b826134bf565b600080600083850361012081121561380a57600080fd5b6101008082121561381a57600080fd5b85945084013590506001600160401b038082111561383757600080fd5b818601915086601f83011261384b57600080fd5b81358181111561385a57600080fd5b87602082850101111561386c57600080fd5b6020830194508093505050509250925092565b60006040828403121561389157600080fd5b610a1b83836134ce565b600080604083850312156138ae57600080fd5b82356138b9816134e6565b946020939093013593505050565b6020808252600d908201526c1858d8d95cdcc819195b9a5959609a1b604082015260600190565b6020808252601590820152741b585b199bdc9b595908199959481c195c98d95b9d605a1b604082015260600190565b6001600160a01b039490941684526001600160401b039283166020850152908216604084015216606082015260800190565b6020808252602c908201527f46756e6374696f6e206d7573742062652063616c6c6564207468726f7567682060408201526b19195b1959d85d1958d85b1b60a21b606082015260800190565b6020808252602c908201527f46756e6374696f6e206d7573742062652063616c6c6564207468726f7567682060408201526b6163746976652070726f787960a01b606082015260800190565b6000602082840312156139f957600080fd5b8151610c91816134e6565b60408101613a128285613758565b6001600160a01b039290921660209190910152919050565b600060408284031215613a3c57600080fd5b613a446135ed565b8251613a4f816134e6565b81526020928301519281019290925250919050565b600060408284031215613a7657600080fd5b613a7e6135ed565b8235613a89816134e6565b81526020928301359281019290925250919050565b634e487b7160e01b600052601160045260246000fd5b600082821015613ac657613ac6613a9e565b500390565b8135613ad6816134e6565b81546001600160a01b0319166001600160a01b03919091161781556020919091013560019190910155565b8035613b0c816134e6565b6001600160a01b03168252602090810135910152565b60808101613b308286613758565b613b3d6020830185613b01565b8215156060830152949350505050565b6020808252602b908201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960408201526a6e697469616c697a696e6760a81b606082015260800190565b60005b83811015613bb3578181015183820152602001613b9b565b83811115613bc2576000848401525b50505050565b60008251613bda818460208701613b98565b9190910192915050565b600060208284031215613bf657600080fd5b81518015158114610c9157600080fd5b60808101613c148286613758565b83516001600160a01b0316602083810191909152909301516040820152901515606090910152919050565b600060018201613c5157613c51613a9e565b5060010190565b8881526101008101613c6d602083018a613758565b60408201979097526001600160a01b03959095166060860152608085019390935260a084019190915260c083015260e09091015292915050565b6001600160a01b038a81168252610140820190613cc7602084018c613b01565b98891660608301526001600160401b03978816608083015295881660a082015293861660c08501529190941660e0830152610100820193909352919092166101209091015292915050565b600060208284031215613d2457600080fd5b5051919050565b6001600160a01b038b81168252610160820190613d4b602084018d613b01565b998a1660608301526001600160401b03988916608083015296891660a082015294871660c08601529290951660e0840152610100830152928416610120820152919092166101409091015292915050565b6020815260008251806020840152613dbb816040850160208701613b98565b601f01601f1916919091016040019291505056fe7cc25b0a5b4d04c15a8cdc1e104f221f1263a55074d6c1c053fc6b1c7734efbe416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c206661696c6564a2646970667358221220237f29e94a9c1fe244976aadbfec66c4fcc09481e2df39212810f87e987d58fd64736f6c634300080f0033",
  "devdoc": {
    "details": "Based on the friend.tech FriendtechSharesV1.sol",
    "events": {
      "DistributorImplAddressUpdated(uint8,address)": {
        "details": "Fired in `setDistributorImplAddress`",
        "params": {
          "implementationAddress": "the address of the already deployed HoldersRewardsDistributor implementation      corresponding to the given implementation type, or zero address",
          "implementationType": "HoldersRewardsDistributor implementation type"
        }
      },
      "SharesImplAddressUpdated(uint8,address)": {
        "details": "Fired in `setSharesImplAddress`",
        "params": {
          "implementationAddress": "the address of the already deployed TradeableShares implementation      corresponding to the given implementation type, or zero address",
          "implementationType": "TradeableShares implementation type"
        }
      },
      "SharesOwnerAddressUpdated(address)": {
        "details": "Fired in setSharesOwnerAddress",
        "params": {
          "sharesOwnerAddress": "new shares owner address, or zero"
        }
      }
    },
    "kind": "dev",
    "methods": {
      "deploySharesContract(uint8,(address,uint256))": {
        "details": "Implementation must guarantee only one TradeableShares contract per subject",
        "params": {
          "implementationType": "TradeableShares implementation type",
          "sharesSubject": "shares subject, owner of the curve"
        },
        "returns": {
          "_0": "deployed TradeableShares contract"
        }
      },
      "deploySharesContractAndBuy(uint8,(address,uint256),uint256)": {
        "details": "Implementation must guarantee only one TradeableShares contract per subject",
        "params": {
          "amount": "how many shares to buy immediately after the deployment",
          "implementationType": "TradeableShares implementation type",
          "sharesSubject": "shares subject, owner of the curve"
        },
        "returns": {
          "_0": "deployed TradeableShares contract"
        }
      },
      "deploySharesContractPaused(uint8,(address,uint256))": {
        "details": "Implementation must guarantee only one TradeableShares contract per subject",
        "params": {
          "implementationType": "TradeableShares implementation type",
          "sharesSubject": "shares subject, owner of the curve"
        },
        "returns": {
          "_0": "deployed TradeableShares contract"
        }
      },
      "determineImplementationType(address)": {
        "params": {
          "_sharesContract": "deployed TradeableShares instance"
        },
        "returns": {
          "_0": "implementation type of the instance specified"
        }
      },
      "executeDeploymentRequest((uint8,(address,uint256),address,uint256,uint256,uint256,uint256),bytes)": {
        "params": {
          "req": "the deployment request to fulfill, containing same data as in `mintSubjectAndDeployShares`",
          "signature": "the deployment request EIP712 signature issued by the address allowed to execute      the request"
        },
        "returns": {
          "_0": "deployed TradeableShares contract"
        }
      },
      "features()": {
        "details": "Effectively reads userRoles role for the contract itself",
        "returns": {
          "_0": "256-bit bitmask of the features enabled"
        }
      },
      "getDistributorImplAddress(uint8)": {
        "details": "If the HoldersRewardsDistributor implementation is missing, the TradeableShares contract      can still be deployed, not being attached to the HoldersRewardsDistributor",
        "params": {
          "_implementationType": "TradeableShares implementation type"
        },
        "returns": {
          "_0": "the address of the already deployed HoldersRewardsDistributor implementation corresponding      to the given implementation type"
        }
      },
      "getHoldersFeePercent()": {
        "details": "The value has 18 decimals, 100% is represented as 10^18",
        "returns": {
          "feePercent": "shares holders fee percent"
        }
      },
      "getImplementation()": {
        "returns": {
          "_0": "the current implementation address"
        }
      },
      "getNonce(address)": {
        "params": {
          "issuer": "the issuer address to get the nonce for"
        },
        "returns": {
          "_0": "current (unused) nonce; incremented by one after      each successful execution of the `executeDeploymentRequest` function"
        }
      },
      "getPaymentToken()": {
        "details": "Immutable, client applications may cache this value",
        "returns": {
          "_0": "ERC1363 payment token contract"
        }
      },
      "getProtocolFeeDestination()": {
        "returns": {
          "feeDestination": "protocol fee destination, address"
        }
      },
      "getProtocolFeePercent()": {
        "details": "The value has 18 decimals, 100% is represented as 10^18",
        "returns": {
          "feePercent": "protocol fee percent"
        }
      },
      "getRole(address)": {
        "details": "Having a simple getter instead of making the mapping public      allows enforcing the encapsulation of the mapping and protects from      writing to it directly in the inheriting smart contracts",
        "params": {
          "operator": "address of a user to read permissions for,      or self address to read global features of the smart contract"
        }
      },
      "getSharesImplAddress(uint8)": {
        "params": {
          "_implementationType": "TradeableShares implementation type"
        },
        "returns": {
          "_0": "the address of the already deployed TradeableShares implementation corresponding      to the given implementation type"
        }
      },
      "getSharesOwnerAddress()": {
        "details": "This should be the MultiSig address, not to EOA and not the      RBAC managed smart contract, so that this address cannot act in a scalable way;      this reduces the risk of misuse, and/or malicious use",
        "returns": {
          "_0": "currently active shares owner address, or zero if not set"
        }
      },
      "getSubjectFeePercent()": {
        "details": "The value has 18 decimals, 100% is represented as 10^18Implementation may return different values for different callers,      for example it can read SharesSubject from the caller TradeableShares contract      and dynamically determine the subject fee",
        "returns": {
          "feePercent": "subject fee percent"
        }
      },
      "isFeatureEnabled(uint256)": {
        "params": {
          "required": "set of features to check against"
        },
        "returns": {
          "_0": "true if all the features requested are enabled, false otherwise"
        }
      },
      "isOperatorInRole(address,uint256)": {
        "params": {
          "operator": "address of the user to check role for",
          "required": "set of permissions (role) to check"
        },
        "returns": {
          "_0": "true if all the permissions requested are enabled, false otherwise"
        }
      },
      "isSenderInRole(uint256)": {
        "details": "Used in smart contracts only. Off-chain clients should use `isOperatorInRole`.",
        "params": {
          "required": "set of permissions (role) to check against"
        },
        "returns": {
          "_0": "true if all the permissions requested are enabled, false otherwise"
        }
      },
      "lookupSharesContract((address,uint256))": {
        "params": {
          "sharesSubject": "shares subject, owner of the curve"
        },
        "returns": {
          "_0": "deployed TradeableShares contract"
        }
      },
      "mintSubjectAndDeployShares(uint8,(address,uint256),address,uint256)": {
        "details": "Implementation must guarantee only one TradeableShares contract per subject",
        "params": {
          "amount": "how many shares to buy immediately after the deployment",
          "implementationType": "TradeableShares implementation type",
          "issuer": "an address to mint the NFT defined by the subject if it doesn't exist",
          "sharesSubject": "shares subject, owner of the curve"
        },
        "returns": {
          "_0": "deployed TradeableShares contract"
        }
      },
      "notifySubjectUpdated()": {
        "details": "The factory may throw if the subject is already taken by another contract"
      },
      "postConstruct(address)": {
        "details": "\"Constructor replacement\" for upgradeable, must be execute immediately after proxy deployment      see https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#initializers",
        "params": {
          "_paymentToken": "ERC20 payment token address to bind to, immutable"
        }
      },
      "registerSharesContract(address)": {
        "details": "Note: this restricted function allows the authorized address to register      the shares contract with the invalid subject",
        "params": {
          "shares": "already deployed TradeableShares contract"
        }
      },
      "rewindNonce(address,uint256)": {
        "details": "Implementation must not allow to decrease the nonce, only increasing (rewinding)      must be possible",
        "params": {
          "issuer": "the issuer address to rewind the nonce for",
          "nonce": "the nonce value to rewind to"
        }
      },
      "setDistributorImplAddress(uint8,address)": {
        "params": {
          "_implementationAddress": "address of the already deployed HoldersRewardsDistributor implementation      corresponding to the given implementation type",
          "_implementationType": "HoldersRewardsDistributor implementation type"
        }
      },
      "setHoldersFeePercent(uint64)": {
        "params": {
          "feePercent": "shares holders fee percent to set, examples: 10^18 is 100%, 10^17 is 10%"
        }
      },
      "setProtocolFee(address,uint64,uint64,uint64)": {
        "params": {
          "holdersFeePercent": "shares holders fee percent to set, examples: 10^18 is 100%, 10^17 is 10%",
          "protocolFeeDestination": "protocol fee destination to set",
          "protocolFeePercent": "protocol fee percent to set, examples: 10^18 is 100%, 10^17 is 10%",
          "subjectFeePercent": "subject fee percent to set, examples: 10^18 is 100%, 10^17 is 10%"
        }
      },
      "setProtocolFeeDestination(address)": {
        "details": "Implementation must check the consistency of the protocol fee destination and percent      set by this and `setProtocolFeePercent` functions",
        "params": {
          "feeDestination": "protocol fee destination to set"
        }
      },
      "setProtocolFeePercent(uint64)": {
        "details": "Implementation must check the consistency of the protocol fee destination and percent      set by this and `setProtocolFeeDestination` functions",
        "params": {
          "feePercent": "protocol fee percent to set, examples: 10^18 is 100%, 10^17 is 10%"
        }
      },
      "setSharesImplAddress(uint8,address)": {
        "params": {
          "_implementationAddress": "address of the already deployed TradeableShares implementation      corresponding to the given implementation type",
          "_implementationType": "TradeableShares implementation type"
        }
      },
      "setSharesOwnerAddress(address)": {
        "details": "This should be the MultiSig address, not to EOA and not the      RBAC managed smart contract, so that this address cannot act in a scalable way;      this reduces the risk of misuse, and/or malicious useOnce changed/set, the address affects only new TradeableShares deployments",
        "params": {
          "_sharesOwnerAddress": "new shares owner address to set, or zero to unset"
        }
      },
      "setSubjectFeePercent(uint64)": {
        "params": {
          "feePercent": "subject fee percent to set, examples: 10^18 is 100%, 10^17 is 10%"
        }
      },
      "updateFeatures(uint256)": {
        "details": "Requires transaction sender to have `ROLE_ACCESS_MANAGER` permissionFunction is left for backward compatibility with older versions",
        "params": {
          "_mask": "bitmask representing a set of features to enable/disable"
        }
      },
      "updateRole(address,uint256)": {
        "details": "Setting role to zero is equivalent to removing an all permissionsSetting role to `FULL_PRIVILEGES_MASK` is equivalent to      copying senders' permissions (role) to the userRequires transaction sender to have `ROLE_ACCESS_MANAGER` permission",
        "params": {
          "operator": "address of a user to alter permissions for,       or self address to alter global features of the smart contract",
          "role": "bitmask representing a set of permissions to      enable/disable for a user specified"
        }
      },
      "upgradeTo(address)": {
        "details": "Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."
      },
      "upgradeToAndCall(address,bytes)": {
        "details": "Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."
      }
    },
    "stateVariables": {
      "FEATURE_ALLOW_EXCLUSIVE_BUY": {
        "details": "Feature FEATURE_ALLOW_EXCLUSIVE_BUY enables `deploySharesContractAndBuy` function"
      },
      "FEATURE_ALLOW_PAUSED_DEPLOYMENTS": {
        "details": "Feature FEATURE_ALLOW_PAUSED_DEPLOYMENTS enables `deploySharesContractPaused` function"
      },
      "FEATURE_SHARES_DEPLOYMENT_ENABLED": {
        "details": "Feature FEATURE_SHARES_DEPLOYMENT_ENABLED enables `deploySharesContractPaused`,      `deploySharesContract`, and `deploySharesContractAndBuy` functions"
      },
      "ROLE_FACTORY_DEPLOYMENT_MANAGER": {
        "details": "Role ROLE_SHARES_IMPLEMENTATION_REGISTRAR is required to execute functions:      - `setImplementationAddress`      - `setSharesOwnerAddress`"
      },
      "ROLE_HOLDERS_FEE_MANAGER": {
        "details": "Role ROLE_HOLDERS_FEE_MANAGER is required to execute `setHoldersFeePercent` function"
      },
      "ROLE_PROTOCOL_FEE_MANAGER": {
        "details": "Role ROLE_PROTOCOL_FEE_MANAGER is required to execute      `setProtocolFeeDestination` and `setProtocolFeePercent` functions"
      },
      "ROLE_SHARES_REGISTRAR": {
        "details": "Role ROLE_SHARES_REGISTRAR is required to execute `deploySharesContract`      and `registerSharesContract` functions"
      },
      "ROLE_SUBJECT_FEE_MANAGER": {
        "details": "Role ROLE_SUBJECT_FEE_MANAGER is required to execute `setSubjectFeePercent` function"
      },
      "distributorsImplementations": {
        "details": "HoldersRewardsDistributor implementations mapping storing deployed HoldersRewardsDistributor      address for every supported implementation type, used by the factory to      deploy the HoldersRewardsDistributor contracts EIP-1167 clonesIf available, HoldersRewardsDistributor implementation is attached to the shares contract      during the deployment, allowing it to send shares holders fees to the distributorMaps TradeableShares ImplementationType => HoldersRewardsDistributor deployed implementation address"
      },
      "holdersFeePercent": {
        "details": "Shares holders fee percent with 18 decimals (10^18 = 100%)"
      },
      "nonces": {
        "details": "Keeps track of the used nonces for every possible issuer      Maps address => number of used nonces"
      },
      "paymentToken": {
        "details": "ERC20 payment token address, effectively immutable (cannot be updated)"
      },
      "protocolFeeDestination": {
        "details": "Protocol fee destination is the address receiving the protocol fee"
      },
      "protocolFeePercent": {
        "details": "Protocol fee percent with 18 decimals (10^18 = 100%)"
      },
      "shares": {
        "details": "Deployed shares contracts mapping, keeps track of the deployed contracts subjects      Maps SharesSubject => TradeableShares"
      },
      "sharesImplementations": {
        "details": "TradeableShares implementations mapping storing deployed TradeableShares      address for every supported implementation type, used by the factory to      deploy the TradeableShares contracts EIP-1167 clonesMaps TradeableShares ImplementationType => TradeableShares deployed implementation address"
      },
      "sharesOwnerAddress": {
        "details": "An address receiving the ownership of the deployed TradeableShares contractsThis should be the MultiSig address, not to EOA and not the      RBAC managed smart contract, so that this address cannot act in a scalable way;      this reduces the risk of misuse, and/or malicious use"
      },
      "subjectFeePercent": {
        "details": "Subject fee percent with 18 decimals (10^18 = 100%)"
      },
      "subjects": {
        "details": "Reverse deployed shares contracts mapping, keeps track of the deployed contracts      Maps TradeableShares address => SharesSubject"
      }
    },
    "title": "Shares Factory V1",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "FEATURE_ALLOW_EXCLUSIVE_BUY()": {
        "notice": "Allows the [TradeableShares] curve deployer to exclusively buy      any amount of the initial shares; if disabled the deployer always gets      no more than only one share"
      },
      "FEATURE_ALLOW_PAUSED_DEPLOYMENTS()": {
        "notice": "Allows the [TradeableShares] curve deployer not to buy any shares on deployment;      if disabled the deployer always gets at least one share,      effectively launching the curve and allowing anyone to buy"
      },
      "FEATURE_SHARES_DEPLOYMENT_ENABLED()": {
        "notice": "Enables [TradeableShares] curve deployment functionality"
      },
      "ROLE_ACCESS_MANAGER()": {
        "notice": "Access manager is responsible for assigning the roles to users,      enabling/disabling global features of the smart contractAccess manager can add, remove and update user roles,      remove and update global features"
      },
      "ROLE_FACTORY_DEPLOYMENT_MANAGER()": {
        "notice": "Factory deployment manager      - registers already deployed TradeableShares implementations to be used by the factory        to deploy the TradeableShares contracts EIP-1167 clones      - sets/unsets/updates the shares owner address `sharesOwnerAddress`"
      },
      "ROLE_HOLDERS_FEE_MANAGER()": {
        "notice": "Shares holders fee manager sets shares holders fee percent (holdersFeePercent)"
      },
      "ROLE_PROTOCOL_FEE_MANAGER()": {
        "notice": "Protocol fee manager sets protocol fee destination address (protocolFeeDestination)      and protocol fee percent (protocolFeePercent)"
      },
      "ROLE_SHARES_REGISTRAR()": {
        "notice": "Shares registrar deploys new and registers already deployed TradeableShares instances"
      },
      "ROLE_SUBJECT_FEE_MANAGER()": {
        "notice": "Subject fee manager sets subject fee percent (subjectFeePercent)"
      },
      "ROLE_UPGRADE_MANAGER()": {
        "notice": "Upgrade manager is responsible for smart contract upgrades,      see https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable      see https://docs.openzeppelin.com/contracts/4.x/upgradeable"
      },
      "deploySharesContract(uint8,(address,uint256))": {
        "notice": "Deploys the TradeableShares implementation for the specified subject;      the curve launches immediately, the first share is issued to the subject issuer (NFT owner)Tries minting the NFT defined by the subject if it doesn't exist"
      },
      "deploySharesContractAndBuy(uint8,(address,uint256),uint256)": {
        "notice": "Deploys the TradeableShares implementation for the specified subject;      allows to immediately buy any amount of shares (including zero)Tries minting the NFT defined by the subject if it doesn't exist"
      },
      "deploySharesContractPaused(uint8,(address,uint256))": {
        "notice": "Deploys the TradeableShares implementation for the specified subject;      the curve remains paused, no shares are being bought immediatelyTries minting the NFT defined by the subject if it doesn't exist"
      },
      "determineImplementationType(address)": {
        "notice": "Tries to determine the implementation type of the already deployed TradeableShares contract;      the result should not be considered reliable and can be used only as a hint"
      },
      "executeDeploymentRequest((uint8,(address,uint256),address,uint256,uint256,uint256,uint256),bytes)": {
        "notice": "Executes signed SharesDeploymentRequest; this is identical to executing `mintSubjectAndDeployShares`      on behalf of the signer and allows the transaction to be relayed so that the gas is payed by the      relayer"
      },
      "features()": {
        "notice": "Retrieves globally set of features enabled"
      },
      "getDistributorImplAddress(uint8)": {
        "notice": "Address of the already deployed HoldersRewardsDistributor implementation      to be used by the factory to deploy the HoldersRewardsDistributor contracts EIP-1167 clones"
      },
      "getHoldersFeePercent()": {
        "notice": "Shares holders fee percent is the percentage of the buy/sell transaction volume      sent to the shares holders rewards distributor contract"
      },
      "getImplementation()": {
        "notice": "Returns an address of the implementation smart contract,      see ERC1967Upgrade._getImplementation()"
      },
      "getNonce(address)": {
        "notice": "Gets current (unused) nonce for the given issuer address;      unused nonce is required to build the SharesDeploymentRequest and sign it      nonces increment by one after each use"
      },
      "getPaymentToken()": {
        "notice": "ERC1363 payment token contract which the factory uses to deploy the `ERC20` curve type"
      },
      "getProtocolFeeDestination()": {
        "notice": "Protocol fee destination is the address receiving the protocol fee"
      },
      "getProtocolFeePercent()": {
        "notice": "Protocol fee percent is the percentage of the buy/sell transaction volume      sent to the protocol fee destination"
      },
      "getRole(address)": {
        "notice": "Reads the permissions (role) for a given user from the `userRoles` mapping      (privileged addresses with defined roles/permissions)In the context of ERC20/ERC721 tokens these can be permissions to      allow minting or burning tokens, transferring on behalf and so on"
      },
      "getSharesImplAddress(uint8)": {
        "notice": "Address of the already deployed TradeableShares implementation      to be used by the factory to deploy the TradeableShares contracts EIP-1167 clones"
      },
      "getSharesOwnerAddress()": {
        "notice": "An address receiving the ownership of the deployed TradeableShares contracts"
      },
      "getSubjectFeePercent()": {
        "notice": "Subject fee percent is the percentage of the buy/sell transaction volume      sent to the subject issuer"
      },
      "isFeatureEnabled(uint256)": {
        "notice": "Checks if requested set of features is enabled globally on the contract"
      },
      "isOperatorInRole(address,uint256)": {
        "notice": "Checks if operator has all the permissions (role) required"
      },
      "isSenderInRole(uint256)": {
        "notice": "Checks if transaction sender `msg.sender` has all the permissions required"
      },
      "lookupSharesContract((address,uint256))": {
        "notice": "Gets the already deployed TradeableShares contract"
      },
      "mintSubjectAndDeployShares(uint8,(address,uint256),address,uint256)": {
        "notice": "Deploys the TradeableShares implementation for the specified subject;      allows to immediately buy any amount of shares (including zero)Tries minting the NFT defined by the subject if it doesn't exist"
      },
      "notifySubjectUpdated()": {
        "notice": "Executed only by the previously registered TradeableShares contracts      to notify the factory about the subject change."
      },
      "registerSharesContract(address)": {
        "notice": "Registers or re-registers the already deployed TradeableShares contract"
      },
      "rewindNonce(address,uint256)": {
        "notice": "Rewinds forward the nonce for the issuer specified, used to      discard one or more signed requests to `executeDeploymentRequest`"
      },
      "setDistributorImplAddress(uint8,address)": {
        "notice": "Sets the address of the already deployed HoldersRewardsDistributor implementation      to be used by the factory to deploy the HoldersRewardsDistributor contracts EIP-1167 clones"
      },
      "setHoldersFeePercent(uint64)": {
        "notice": "Sets the shares holders fee percent"
      },
      "setProtocolFee(address,uint64,uint64,uint64)": {
        "notice": "Sets all the fees at once:      protocolFeeDestination      protocolFeePercent      holdersFeePercent      subjectFeePercent"
      },
      "setProtocolFeeDestination(address)": {
        "notice": "Sets the protocol fee destination"
      },
      "setProtocolFeePercent(uint64)": {
        "notice": "Sets the protocol fee percent"
      },
      "setSharesImplAddress(uint8,address)": {
        "notice": "Sets the address of the already deployed TradeableShares implementation      to be used by the factory to deploy the TradeableShares contracts EIP-1167 clones"
      },
      "setSharesOwnerAddress(address)": {
        "notice": "Sets/unsets/updates the shares owner address `sharesOwnerAddress`, which is      an address receiving the ownership of the deployed TradeableShares contracts"
      },
      "setSubjectFeePercent(uint64)": {
        "notice": "Sets the subject fee percent"
      },
      "updateFeatures(uint256)": {
        "notice": "Updates set of the globally enabled features (`features`),      taking into account sender's permissions"
      },
      "updateRole(address,uint256)": {
        "notice": "Updates set of permissions (role) for a given user,      taking into account sender's permissions."
      }
    },
    "notice": "Role-based access control (RBAC) based implementation of the SharesFactory",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 414,
        "contract": "contracts/bonding_curves/SharesFactoryV1.sol:SharesFactoryV1",
        "label": "_initialized",
        "offset": 0,
        "slot": "0",
        "type": "t_bool"
      },
      {
        "astId": 417,
        "contract": "contracts/bonding_curves/SharesFactoryV1.sol:SharesFactoryV1",
        "label": "_initializing",
        "offset": 1,
        "slot": "0",
        "type": "t_bool"
      },
      {
        "astId": 7378,
        "contract": "contracts/bonding_curves/SharesFactoryV1.sol:SharesFactoryV1",
        "label": "userRoles",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_address,t_uint256)"
      },
      {
        "astId": 7383,
        "contract": "contracts/bonding_curves/SharesFactoryV1.sol:SharesFactoryV1",
        "label": "__gap",
        "offset": 0,
        "slot": "2",
        "type": "t_array(t_uint256)49_storage"
      },
      {
        "astId": 396,
        "contract": "contracts/bonding_curves/SharesFactoryV1.sol:SharesFactoryV1",
        "label": "__gap",
        "offset": 0,
        "slot": "51",
        "type": "t_array(t_uint256)50_storage"
      },
      {
        "astId": 591,
        "contract": "contracts/bonding_curves/SharesFactoryV1.sol:SharesFactoryV1",
        "label": "__gap",
        "offset": 0,
        "slot": "101",
        "type": "t_array(t_uint256)50_storage"
      },
      {
        "astId": 1499,
        "contract": "contracts/bonding_curves/SharesFactoryV1.sol:SharesFactoryV1",
        "label": "_HASHED_NAME",
        "offset": 0,
        "slot": "151",
        "type": "t_bytes32"
      },
      {
        "astId": 1501,
        "contract": "contracts/bonding_curves/SharesFactoryV1.sol:SharesFactoryV1",
        "label": "_HASHED_VERSION",
        "offset": 0,
        "slot": "152",
        "type": "t_bytes32"
      },
      {
        "astId": 1638,
        "contract": "contracts/bonding_curves/SharesFactoryV1.sol:SharesFactoryV1",
        "label": "__gap",
        "offset": 0,
        "slot": "153",
        "type": "t_array(t_uint256)50_storage"
      },
      {
        "astId": 4864,
        "contract": "contracts/bonding_curves/SharesFactoryV1.sol:SharesFactoryV1",
        "label": "paymentToken",
        "offset": 0,
        "slot": "203",
        "type": "t_contract(ERC1363)6957"
      },
      {
        "astId": 4867,
        "contract": "contracts/bonding_curves/SharesFactoryV1.sol:SharesFactoryV1",
        "label": "protocolFeeDestination",
        "offset": 0,
        "slot": "204",
        "type": "t_address"
      },
      {
        "astId": 4870,
        "contract": "contracts/bonding_curves/SharesFactoryV1.sol:SharesFactoryV1",
        "label": "protocolFeePercent",
        "offset": 20,
        "slot": "204",
        "type": "t_uint64"
      },
      {
        "astId": 4873,
        "contract": "contracts/bonding_curves/SharesFactoryV1.sol:SharesFactoryV1",
        "label": "holdersFeePercent",
        "offset": 0,
        "slot": "205",
        "type": "t_uint64"
      },
      {
        "astId": 4876,
        "contract": "contracts/bonding_curves/SharesFactoryV1.sol:SharesFactoryV1",
        "label": "subjectFeePercent",
        "offset": 8,
        "slot": "205",
        "type": "t_uint64"
      },
      {
        "astId": 4879,
        "contract": "contracts/bonding_curves/SharesFactoryV1.sol:SharesFactoryV1",
        "label": "sharesOwnerAddress",
        "offset": 0,
        "slot": "206",
        "type": "t_address"
      },
      {
        "astId": 4885,
        "contract": "contracts/bonding_curves/SharesFactoryV1.sol:SharesFactoryV1",
        "label": "shares",
        "offset": 0,
        "slot": "207",
        "type": "t_mapping(t_bytes32,t_contract(TradeableShares)6790)"
      },
      {
        "astId": 4891,
        "contract": "contracts/bonding_curves/SharesFactoryV1.sol:SharesFactoryV1",
        "label": "subjects",
        "offset": 0,
        "slot": "208",
        "type": "t_mapping(t_address,t_struct(SharesSubject)6567_storage)"
      },
      {
        "astId": 4897,
        "contract": "contracts/bonding_curves/SharesFactoryV1.sol:SharesFactoryV1",
        "label": "sharesImplementations",
        "offset": 0,
        "slot": "209",
        "type": "t_mapping(t_enum(ImplementationType)4584,t_address)"
      },
      {
        "astId": 4903,
        "contract": "contracts/bonding_curves/SharesFactoryV1.sol:SharesFactoryV1",
        "label": "distributorsImplementations",
        "offset": 0,
        "slot": "210",
        "type": "t_mapping(t_enum(ImplementationType)4584,t_address)"
      },
      {
        "astId": 4908,
        "contract": "contracts/bonding_curves/SharesFactoryV1.sol:SharesFactoryV1",
        "label": "nonces",
        "offset": 0,
        "slot": "211",
        "type": "t_mapping(t_address,t_uint256)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_uint256)49_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[49]",
        "numberOfBytes": "1568"
      },
      "t_array(t_uint256)50_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[50]",
        "numberOfBytes": "1600"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_contract(ERC1363)6957": {
        "encoding": "inplace",
        "label": "contract ERC1363",
        "numberOfBytes": "20"
      },
      "t_contract(TradeableShares)6790": {
        "encoding": "inplace",
        "label": "contract TradeableShares",
        "numberOfBytes": "20"
      },
      "t_enum(ImplementationType)4584": {
        "encoding": "inplace",
        "label": "enum SharesFactory.ImplementationType",
        "numberOfBytes": "1"
      },
      "t_mapping(t_address,t_struct(SharesSubject)6567_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => struct TradeableShares.SharesSubject)",
        "numberOfBytes": "32",
        "value": "t_struct(SharesSubject)6567_storage"
      },
      "t_mapping(t_address,t_uint256)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_bytes32,t_contract(TradeableShares)6790)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => contract TradeableShares)",
        "numberOfBytes": "32",
        "value": "t_contract(TradeableShares)6790"
      },
      "t_mapping(t_enum(ImplementationType)4584,t_address)": {
        "encoding": "mapping",
        "key": "t_enum(ImplementationType)4584",
        "label": "mapping(enum SharesFactory.ImplementationType => address)",
        "numberOfBytes": "32",
        "value": "t_address"
      },
      "t_struct(SharesSubject)6567_storage": {
        "encoding": "inplace",
        "label": "struct TradeableShares.SharesSubject",
        "members": [
          {
            "astId": 6563,
            "contract": "contracts/bonding_curves/SharesFactoryV1.sol:SharesFactoryV1",
            "label": "tokenAddress",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 6566,
            "contract": "contracts/bonding_curves/SharesFactoryV1.sol:SharesFactoryV1",
            "label": "tokenId",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint64": {
        "encoding": "inplace",
        "label": "uint64",
        "numberOfBytes": "8"
      }
    }
  }
}