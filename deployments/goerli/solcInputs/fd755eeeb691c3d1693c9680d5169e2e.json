{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-upgradeable/proxy/beacon/IBeaconUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeaconUpgradeable {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeaconUpgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/StorageSlotUpgradeable.sol\";\nimport \"../utils/Initializable.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967UpgradeUpgradeable is Initializable {\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n        __ERC1967Upgrade_init_unchained();\n    }\n\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            _functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallSecure(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        address oldImplementation = _getImplementation();\n\n        // Initial upgrade and setup call\n        _setImplementation(newImplementation);\n        if (data.length > 0 || forceCall) {\n            _functionDelegateCall(newImplementation, data);\n        }\n\n        // Perform rollback test if not already in progress\n        StorageSlotUpgradeable.BooleanSlot storage rollbackTesting = StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT);\n        if (!rollbackTesting.value) {\n            // Trigger rollback using upgradeTo from the new implementation\n            rollbackTesting.value = true;\n            _functionDelegateCall(\n                newImplementation,\n                abi.encodeWithSignature(\"upgradeTo(address)\", oldImplementation)\n            );\n            rollbackTesting.value = false;\n            // Check rollback was effective\n            require(oldImplementation == _getImplementation(), \"ERC1967Upgrade: upgrade breaks further upgrades\");\n            // Finally reset to the new implementation and log the upgrade\n            _upgradeTo(newImplementation);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            _functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function _functionDelegateCall(address target, bytes memory data) private returns (bytes memory) {\n        require(AddressUpgradeable.isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return AddressUpgradeable.verifyCallResult(success, returndata, \"Address: low-level delegate call failed\");\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() initializer {}\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\n        // contract may have been reentered.\n        require(_initializing ? _isConstructor() : !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} modifier, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/utils/UUPSUpgradeable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1967/ERC1967UpgradeUpgradeable.sol\";\nimport \"./Initializable.sol\";\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n *\n * _Available since v4.1._\n */\nabstract contract UUPSUpgradeable is Initializable, ERC1967UpgradeUpgradeable {\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n        __ERC1967Upgrade_init_unchained();\n        __UUPSUpgradeable_init_unchained();\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n    address private immutable __self = address(this);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        require(address(this) != __self, \"Function must be called through delegatecall\");\n        require(_getImplementation() == __self, \"Function must be called through active proxy\");\n        _;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeTo(address newImplementation) external virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallSecure(newImplementation, new bytes(0), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallSecure(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeTo} and {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/cryptography/draft-EIP712Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/draft-EIP712.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSAUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712Upgradeable is Initializable {\n    /* solhint-disable var-name-mixedcase */\n    bytes32 private _HASHED_NAME;\n    bytes32 private _HASHED_VERSION;\n    bytes32 private constant _TYPE_HASH = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator(_TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash());\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSAUpgradeable.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev The hash of the name parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712NameHash() internal virtual view returns (bytes32) {\n        return _HASHED_NAME;\n    }\n\n    /**\n     * @dev The hash of the version parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712VersionHash() internal virtual view returns (bytes32) {\n        return _HASHED_VERSION;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../StringsUpgradeable.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSAUpgradeable {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s;\n        uint8 v;\n        assembly {\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            v := add(shr(255, vs), 27)\n        }\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", StringsUpgradeable.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlotUpgradeable {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/Clones.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle Trees proofs.\n *\n * The proofs can be generated using the JavaScript library\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\n *\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merklee tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     *\n     * _Available since v4.4._\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n            if (computedHash <= proofElement) {\n                // Hash(current computed hash + current element of the proof)\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\n            } else {\n                // Hash(current element of the proof + current computed hash)\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\n            }\n        }\n        return computedHash;\n    }\n}\n"
    },
    "contracts/bonding_curves/AbstractShares.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../utils/InitializableAccessControl.sol\";\nimport \"./TradeableShares.sol\";\nimport \"./SharesFactory.sol\";\nimport \"./SharesSubjectLib.sol\";\nimport \"./FriendTechBondingCurve.sol\";\n\n/**\n * @title Abstract Shares\n *\n * @notice Contains the logic which is currently common for the ETHShares\n *      and ERC20Shares TradeableShares implementations.\n *      Once these contracts diverge enough in their logic, this abstract contract\n *      may cease to exist.\n *\n * @dev Based on the friend.tech FriendtechSharesV1.sol\n */\nabstract contract AbstractShares is TradeableShares, FriendTechBondingCurve, InitializableAccessControl {\n\t/// @dev Shares subject is an NFT; NFT owner receives the subject fee\n\tSharesSubject private sharesSubject;\n\t/// @dev Protocol fee destination is an address collecting the protocol fee\n\taddress private protocolFeeDestination;\n\t/// @dev Protocol fee percent, immutable; maximum value: 10^18 (< 2^60)\n\tuint64 private /*immutable*/ protocolFeePercent;\n\t/// @dev Holders rewards fee destination is a contract collecting the holders fee, immutable\n\tHoldersRewardsDistributor private /*immutable*/ holdersFeeDestination;\n\t/// @dev Holders rewards fee percent, immutable\n\tuint64 private /*immutable*/ holdersFeePercent;\n\t/// @dev Subject fee percent, immutable\n\tuint64 private /*immutable*/ subjectFeePercent;\n\n\t/// @dev Total shares supply, sum of all the individual balances in `sharesBalances`\n\tuint256 internal sharesSupply;\n\t/// @dev Individual shares balances: Holder => Balance\n\tmapping(address => uint256) internal sharesBalances;\n\n\t/// @dev Cumulative value of all trades, allows to derive cumulative fees paid\n\tuint256 private tradeVolume;\n\n\t/**\n\t * @dev Fired in `updateSharesSubject`\n\t *\n\t * @param oldSubject old shares subject\n\t * @param newSubject new shares subject\n\t * @param factory the factory contract notified about the update\n\t */\n\tevent SharesSubjectUpdated(SharesSubject oldSubject, SharesSubject newSubject, SharesFactory factory);\n\n\t/**\n\t * @dev Fired in `updateProtocolFeeDestination`\n\t *\n\t * @param oldProtocolFeeDestination old protocol fee destination\n\t * @param newProtocolFeeDestination new protocol fee destination\n\t */\n\tevent ProtocolFeeDestinationUpdated(address oldProtocolFeeDestination, address newProtocolFeeDestination);\n\n\t/**\n\t * @dev Fire in `disableHoldersFee` no more than once\n\t *      for the entire lifespan of the contract\n\t *\n\t * @param oldProtocolFeePercent old protocol fee percent\n\t * @param newProtocolFeePercent new protocol fee percent, new >= old\n\t */\n\tevent HoldersFeeDisabled(uint256 oldProtocolFeePercent, uint256 newProtocolFeePercent);\n\n\t/**\n\t * @notice Protocol fee destination manager is responsible for updating the address collecting the\n\t *      protocol fee destination, that is `protocolFeeDestination`; the manager cannot update the fee percent\n\t *\n\t * @dev This role should be granted to the MultiSig, not to EOA and not to\n\t *      RBAC managed smart contract, so that this functionality is not scalable;\n\t *      this reduces the risk of misuse, and/or malicious use\n\t *\n\t * @dev Role ROLE_PROTOCOL_FEE_MANAGER is required to execute `updateProtocolFeeDestination` function\n\t */\n\tuint32 public constant ROLE_PROTOCOL_FEE_MANAGER = 0x0001_0000;\n\n\t/**\n\t * @notice Holders fee [disable] manager can disable the shares holders fee functionality;\n\t *      the manager cannot enable it back\n\t *\n\t * @dev This role should be granted to the MultiSig, not to EOA and not to\n\t *      RBAC managed smart contract, so that this functionality is not scalable;\n\t *      this reduces the risk of misuse, and/or malicious use\n\t *\n\t * @dev Role ROLE_HOLDERS_FEE_MANAGER is required to execute `disableHoldersFee` function\n\t */\n\tuint32 public constant ROLE_HOLDERS_FEE_MANAGER = 0x0002_0000;\n\n\t/**\n\t * @notice Shares subject manager is responsible for updating the \"shares subject\"\n\t *      in case of emergency, for example if underlying NFT was stolen\n\t *\n\t * @dev This role should be granted to the MultiSig, not to EOA and not to\n\t *      RBAC managed smart contract, so that this functionality is not scalable;\n\t *      this reduces the risk of misuse, and/or malicious use\n\t *\n\t * @dev Role ROLE_SHARES_SUBJECT_MANAGER is required to execute `updateSharesSubject` function\n\t */\n\tuint32 public constant ROLE_SHARES_SUBJECT_MANAGER = 0x0008_0000;\n\n\t/**\n\t * @dev \"Constructor replacement\" for initializable, must be execute during or immediately after deployment\n\t *      see https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#initializers\n\t *\n\t * @param _owner the address receiving all the RBAC permissions on the contract\n\t * @param _sharesSubject shares subject, usually defined as NFT (ERC721 contract address + NFT ID)\n\t * @param _protocolFeeDestination protocol fee destination, the address protocol fee is sent to\n\t * @param _protocolFeePercent protocol fee percent, applied to all the buy and sell operations;\n\t *      the fee percent is defined with the 18 decimals, 10^18 corresponds to 100%\n\t * @param _holdersFeeDestination shares holders fee destination, the HoldersRewardsDistributor contract\n\t *      the shares holders fee is sent to\n\t * @param _holdersFeePercent shares holders fee percent, applied to all the buy and sell operations,\n\t *      the fee percent is defined with the 18 decimals, 10^18 corresponds to 100%\n\t * @param _subjectFeePercent subject fee percent, applied to all the buy and sell operations,\n\t *      the fee percent is defined with the 18 decimals, 10^18 corresponds to 100%\n\t */\n\tfunction _postConstruct(\n\t\taddress _owner,\n\t\tSharesSubject memory _sharesSubject,\n\t\taddress _protocolFeeDestination,\n\t\tuint64 _protocolFeePercent,\n\t\tHoldersRewardsDistributor _holdersFeeDestination,\n\t\tuint64 _holdersFeePercent,\n\t\tuint64 _subjectFeePercent\n\t) internal onlyInitializing {\n\t\t// execute parent initializer\n\t\t_postConstruct(_owner);\n\t\t// this initializer is called only from the factory, we do not verify the\n\t\t// validity of the inputs generated by the factory itself\n\t\t// if the factory goes buggy/malicious after the upgrade, all the\n\t\t// shares contracts deployed after should be considered invalid\n\t\tsharesSubject = _sharesSubject;\n\t\tprotocolFeeDestination = _protocolFeeDestination;\n\t\tprotocolFeePercent = _protocolFeePercent;\n\t\tholdersFeeDestination = _holdersFeeDestination;\n\t\tholdersFeePercent = _holdersFeePercent;\n\t\tsubjectFeePercent = _subjectFeePercent;\n\t}\n\n\t/**\n\t * @inheritdoc TradeableShares\n\t */\n\tfunction getSharesSubject() public view returns(SharesSubject memory) {\n\t\t// read value from the storage\n\t\treturn sharesSubject;\n\t}\n\n\t/**\n\t * @notice Updates the shares subject\n\t *\n\t * @dev This is a restricted access function which should be accessible only from the\n\t *      MultiSig wallet controlling the protocol, so that its usage is not scalable\n\t *\n\t * @param _sharesSubject new subject to set\n\t */\n\tfunction updateSharesSubject(SharesSubject calldata _sharesSubject) public {\n\t\t// delegate to `updateSharesSubject` with the zero factory\n\t\tupdateSharesSubject(_sharesSubject, SharesFactory(address(0)));\n\t}\n\n\t/**\n\t * @notice Updates the shares subject and optionally notifies the factory about the update;\n\t *      update fails if the factory notification fails\n\t *\n\t * @dev This is a restricted access function which should be accessible only from the\n\t *      MultiSig wallet controlling the protocol, so that its usage is not scalable\n\t *\n\t * @param _sharesSubject new subject to set\n\t * @param _factory shares factory contract to notify about the update, optional\n\t *      if set to zero, the notification is not done\n\t */\n\tfunction updateSharesSubject(SharesSubject calldata _sharesSubject, SharesFactory _factory) public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_SHARES_SUBJECT_MANAGER), \"access denied\");\n\n\t\t// emit an event first - to log both old and new values\n\t\temit SharesSubjectUpdated(sharesSubject, _sharesSubject, _factory);\n\n\t\t// update contract's state\n\t\tsharesSubject = _sharesSubject;\n\n\t\t// if factory is set (factory notification requested)\n\t\tif(address(_factory) != address(0)) {\n\t\t\t// notify factory contract\n\t\t\t_factory.notifySubjectUpdated();\n\t\t}\n\t}\n\n\t/**\n\t * @inheritdoc TradeableShares\n\t */\n\tfunction getProtocolFeeDestination() public view returns(address) {\n\t\t// read the value from storage\n\t\treturn protocolFeeDestination;\n\t}\n\n\t/**\n\t * @notice Updates the protocol fee destination address `protocolFeeDestination`\n\t *\n\t * @dev This is a restricted access function which should be accessible only from the\n\t *      MultiSig wallet controlling the protocol, so that its usage is not scalable\n\t *\n\t * @param _protocolFeeDestination new protocol fee destination address to set\n\t */\n\tfunction updateProtocolFeeDestination(address _protocolFeeDestination) public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_PROTOCOL_FEE_MANAGER), \"access denied\");\n\n\t\t// emit an event first - to log both old and new values\n\t\temit ProtocolFeeDestinationUpdated(protocolFeeDestination, _protocolFeeDestination);\n\n\t\t// update contract's state\n\t\tprotocolFeeDestination = _protocolFeeDestination;\n\t}\n\n\t/**\n\t * @inheritdoc TradeableShares\n\t */\n\tfunction getProtocolFeePercent() public view returns(uint256) {\n\t\t// read the value from storage (immutable)\n\t\treturn protocolFeePercent;\n\t}\n\n\t/**\n\t * @inheritdoc TradeableShares\n\t */\n\tfunction getProtocolFeeInfo() public view returns(address feeDestination, uint256 feePercent) {\n\t\t// read fee destination first\n\t\tfeeDestination = getProtocolFeeDestination();\n\t\t// if it's zero, zero down the fee as well\n\t\tfeePercent = feeDestination == address(0)? 0: getProtocolFeePercent();\n\t}\n\n\t/**\n\t * @inheritdoc TradeableShares\n\t */\n\tfunction getHoldersFeeDestination() public view returns(HoldersRewardsDistributor) {\n\t\t// read the value from storage (immutable)\n\t\treturn holdersFeeDestination;\n\t}\n\n\t/**\n\t * @notice Disables shares holders fee functionality; detaches shares contract from\n\t *      the HoldersRewardsDistributor, stops sending fees, stops sending syncs\n\t *\n\t * @notice Increases the protocol fee by the value of the disabled shares holders fee,\n\t *      so that the sum of all the fees remains the same\n\t *\n\t * @notice Once disabled, the holders fee functionality cannot be enabled back\n\t */\n\tfunction disableHoldersFee() public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_HOLDERS_FEE_MANAGER), \"access denied\");\n\n\t\t// verify the holders functionality is enabled\n\t\trequire(address(holdersFeeDestination) != address(0) || holdersFeePercent != 0, \"not enabled\");\n\n\t\t// emit an event first - to log both old and new values\n\t\temit HoldersFeeDisabled(protocolFeePercent, protocolFeePercent + holdersFeePercent);\n\n\t\t// shares holders fee goes to the protocol from now on\n\t\tprotocolFeePercent += holdersFeePercent;\n\n\t\t// zero the shares holders fee\n\t\tholdersFeeDestination = HoldersRewardsDistributor(address(0));\n\t\tholdersFeePercent = 0;\n\t}\n\n\t/**\n\t * @inheritdoc TradeableShares\n\t */\n\tfunction getHoldersFeePercent() public view returns(uint256) {\n\t\t// read the value from storage (immutable)\n\t\treturn holdersFeePercent;\n\t}\n\n\t/**\n\t * @inheritdoc TradeableShares\n\t */\n\tfunction getHoldersFeeInfo() public view returns(HoldersRewardsDistributor feeDestination, uint256 feePercent) {\n\t\t// read fee destination first\n\t\tfeeDestination = getHoldersFeeDestination();\n\t\t// if it's zero, zero down the fee as well\n\t\tfeePercent = address(feeDestination) == address(0)? 0: getHoldersFeePercent();\n\t}\n\n\t/**\n\t * @inheritdoc TradeableShares\n\t */\n\tfunction getSubjectFeeInfo() public view returns(address feeDestination, uint256 feePercent) {\n\t\t// read fee destination first\n\t\tfeeDestination = getSharesIssuer();\n\t\t// if it's zero, zero down the fee as well\n\t\tfeePercent = feeDestination == address(0)? 0: getSubjectFeePercent();\n\t}\n\n\t/**\n\t * @inheritdoc TradeableShares\n\t */\n\tfunction getSubjectFeePercent() public view returns(uint256) {\n\t\t// read the value from storage (immutable)\n\t\treturn subjectFeePercent;\n\t}\n\n\t/**\n\t * @inheritdoc TradeableShares\n\t */\n\tfunction getSharesIssuer() public view returns(address nftOwner) {\n\t\t// derive the NFT owner defined by the subject\n\t\treturn SharesSubjectLib.getSharesIssuer(sharesSubject);\n\t}\n\n\t/**\n\t * @inheritdoc TradeableShares\n\t */\n\tfunction getSharesBalance(address _holder) public view returns(uint256 balance) {\n\t\t// read the value from storage\n\t\treturn sharesBalances[_holder];\n\t}\n\n\t/**\n\t * @inheritdoc TradeableShares\n\t */\n\tfunction getSharesSupply() public view returns(uint256 supply) {\n\t\t// read the value from storage\n\t\treturn sharesSupply;\n\t}\n\n\t/**\n\t * @inheritdoc TradeableShares\n\t */\n\tfunction getBuyPrice(uint256 _supply, uint256 _amount) public pure returns(uint256) {\n\t\t// this is the original friend tech formula\n\t\treturn getPrice(_supply, _amount);\n\t}\n\n\t/**\n\t * @inheritdoc TradeableShares\n\t */\n\tfunction getSellPrice(uint256 _supply, uint256 _amount) public pure returns(uint256) {\n\t\t// this is the original friend tech formula\n\t\treturn getPrice(_supply - _amount, _amount);\n\t}\n\n\t/**\n\t * @inheritdoc TradeableShares\n\t */\n\tfunction getBuyPriceAfterFee(\n\t\tuint256 _supply,\n\t\tuint256 _amount,\n\t\tuint256 _protocolFeePercent,\n\t\tuint256 _holdersFeePercent,\n\t\tuint256 _subjectFeePercent\n\t) public pure returns(uint256) {\n\t\t// this is the original friend tech formula\n\t\tuint256 price = getBuyPrice(_supply, _amount);\n\t\tuint256 protocolFee = price * _protocolFeePercent / 1 ether;\n\t\tuint256 holdersFee = price * _holdersFeePercent / 1 ether;\n\t\tuint256 subjectFee = price * _subjectFeePercent / 1 ether;\n\t\treturn price + protocolFee + holdersFee + subjectFee;\n\t}\n\n\t/**\n\t * @inheritdoc TradeableShares\n\t */\n\tfunction getSellPriceAfterFee(\n\t\tuint256 _supply,\n\t\tuint256 _amount,\n\t\tuint256 _protocolFeePercent,\n\t\tuint256 _holdersFeePercent,\n\t\tuint256 _subjectFeePercent\n\t) public pure returns(uint256) {\n\t\t// this is the original friend tech formula\n\t\tuint256 price = getSellPrice(_supply, _amount);\n\t\tuint256 protocolFee = price * _protocolFeePercent / 1 ether;\n\t\tuint256 holdersFee = price * _holdersFeePercent / 1 ether;\n\t\tuint256 subjectFee = price * _subjectFeePercent / 1 ether;\n\t\treturn price - protocolFee - holdersFee - subjectFee;\n\t}\n\n\t/**\n\t * @inheritdoc TradeableShares\n\t */\n\tfunction getBuyPrice(uint256 _amount) public view returns(uint256) {\n\t\t// delegate to `getBuyPrice`\n\t\treturn getBuyPrice(getSharesSupply(), _amount);\n\t}\n\n\t/**\n\t * @inheritdoc TradeableShares\n\t */\n\tfunction getSellPrice(uint256 _amount) public view returns(uint256) {\n\t\t// delegate to `getSellPrice`\n\t\treturn getSellPrice(getSharesSupply(), _amount);\n\t}\n\n\t/**\n\t * @inheritdoc TradeableShares\n\t */\n\tfunction getBuyPriceAfterFee(uint256 _amount) public view returns(uint256) {\n\t\t// read the effective fees values\n\t\t(, uint256 _protocolFeePercent) = getProtocolFeeInfo();\n\t\t(, uint256 _holdersFeePercent) = getHoldersFeeInfo();\n\t\t(, uint256 _subjectFeePercent) = getSubjectFeeInfo();\n\n\t\t// delegate to `getBuyPriceAfterFee`\n\t\treturn getBuyPriceAfterFee(getSharesSupply(), _amount, _protocolFeePercent, _holdersFeePercent, _subjectFeePercent);\n\t}\n\n\t/**\n\t * @inheritdoc TradeableShares\n\t */\n\tfunction getSellPriceAfterFee(uint256 _amount) public view returns(uint256) {\n\t\t// read the effective fees values\n\t\t(, uint256 _protocolFeePercent) = getProtocolFeeInfo();\n\t\t(, uint256 _holdersFeePercent) = getHoldersFeeInfo();\n\t\t(, uint256 _subjectFeePercent) = getSubjectFeeInfo();\n\n\t\t// delegate to `getSellPriceAfterFee`\n\t\treturn getSellPriceAfterFee(getSharesSupply(), _amount, _protocolFeePercent, _holdersFeePercent, _subjectFeePercent);\n\t}\n\n\t/**\n\t * @dev Executed internally on every trade (buy/sell) to track the trading volume\n\t *\n\t * @param value trading operation value, the price of the buy/sell operation without the fees\n\t */\n\tfunction __increaseTradeVolume(uint256 value) internal {\n\t\t// update the value in the storage\n\t\ttradeVolume += value;\n\t}\n\n\t/**\n\t * @inheritdoc TradeableShares\n\t */\n\tfunction getTradeVolume() public view returns(uint256) {\n\t\t// read the value from the storage\n\t\treturn tradeVolume;\n\t}\n}\n"
    },
    "contracts/bonding_curves/Aliases.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./ERC20Shares.sol\";\nimport \"./ETHShares.sol\";\nimport \"./TradeableShares.sol\";\n\n/**\n * @title Tradeable Keys Alias\n *\n * @notice Displays the function names using the \"keys\" word instead of \"shares\"\n *      in MetaMask, Etherscan, etc.\n */\ninterface TradeableKeys is TradeableShares {\n\t/**\n\t * @notice buyShares alias\n\t */\n\tfunction buyKeys(uint256 amount) external payable;\n\n\t/**\n\t * @notice sellShares alias\n\t */\n\tfunction sellKeys(uint256 amount) external;\n}\n\n/**\n * @title ERC20 Keys Alias\n *\n * @notice Displays the function names using the \"keys\" word instead of \"shares\"\n *      in MetaMask, Etherscan, etc.\n */\ncontract ERC20Keys is ERC20Shares, TradeableKeys {\n\tconstructor(address _owner, SharesSubject memory _sharesSubject, address _protocolFeeDestination, uint64 _protocolFeePercent, HoldersRewardsDistributor _holdersFeeDestination, uint64 _holdersFeePercent, uint64 _subjectFeePercent, uint256 _amount, address _beneficiary, ERC1363 _paymentToken\n\t) ERC20Shares(      _owner,                      _sharesSubject,         _protocolFeeDestination,        _protocolFeePercent,                           _holdersFeeDestination,        _holdersFeePercent,        _subjectFeePercent,         _amount,         _beneficiary,         _paymentToken){}\n\n\t/**\n\t * @inheritdoc TradeableKeys\n\t */\n\tfunction buyKeys(uint256 amount) public payable {\n\t\tbuyShares(amount);\n\t}\n\n\t/**\n\t * @inheritdoc TradeableKeys\n\t */\n\tfunction sellKeys(uint256 amount) public {\n\t\tsellShares(amount);\n\t}\n}\n\n/**\n * @title ETH Keys Alias\n *\n * @notice Displays the function names using the \"keys\" word instead of \"shares\"\n *      in MetaMask, Etherscan, etc.\n */\ncontract ETHKeys is ETHShares, TradeableKeys {\n\tconstructor(address _owner, SharesSubject memory _sharesSubject, address _protocolFeeDestination, uint64 _protocolFeePercent, HoldersRewardsDistributor _holdersFeeDestination, uint64 _holdersFeePercent, uint64 _subjectFeePercent, uint256 _amount, address _beneficiary\n\t) ETHShares(        _owner,                      _sharesSubject,         _protocolFeeDestination,        _protocolFeePercent,                           _holdersFeeDestination,        _holdersFeePercent,        _subjectFeePercent,         _amount,         _beneficiary){}\n\n\t/**\n\t * @inheritdoc TradeableKeys\n\t */\n\tfunction buyKeys(uint256 amount) public payable {\n\t\tbuyShares(amount);\n\t}\n\n\t/**\n\t * @inheritdoc TradeableKeys\n\t */\n\tfunction sellKeys(uint256 amount) public {\n\t\tsellShares(amount);\n\t}\n}\n"
    },
    "contracts/bonding_curves/BondingCurve.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title Bonding Curve\n *\n * @notice A friend.tech-like bonding curve definition\n *\n * @notice Bonding curve defines the price of the smallest unit of the asset as a function\n *      of the asset supply\n */\ninterface BondingCurve {\n\t/**\n\t * @notice Bonding curve function definition. The function calculating the price\n\t *      of the `amount` of shares given the current total supply `supply`\n\t *\n\t * @param supply total shares supply\n\t * @param amount number of shares to buy/sell\n\t * @return the price of the shares (all `amount` amount)\n\t */\n\tfunction getPrice(uint256 supply, uint256 amount) external pure returns(uint256);\n}\n"
    },
    "contracts/bonding_curves/ERC20Shares.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ERC1363Spec.sol\";\nimport \"./AbstractShares.sol\";\n\n/**\n * @title ERC20 Shares\n *\n * @notice TradeableShares implementation using ERC20 token as a payment token\n *\n * @dev Doesn't have \"payable\" functions, that is the functions accepting ETH\n *\n * @dev Based on the friend.tech FriendtechSharesV1.sol\n */\ncontract ERC20Shares is AbstractShares {\n\t/// @dev ERC1363 payment token used for payments\n\tERC1363 private /*immutable*/ paymentToken;\n\n\t/**\n\t * @dev Deploys the ERC20Shares instance and initializes it\n\t *\n\t * @param _owner the address receiving all the RBAC permissions on the contract\n\t * @param _sharesSubject shares subject, usually defined as NFT (ERC721 contract address + NFT ID)\n\t * @param _protocolFeeDestination protocol fee destination, the address protocol fee is sent to\n\t * @param _protocolFeePercent protocol fee percent, applied to all the buy and sell operations;\n\t *      the fee percent is defined with the 18 decimals, 10^18 corresponds to 100%\n\t * @param _holdersFeeDestination shares holders fee destination, the HoldersRewardsDistributor contract\n\t *      the shares holders fee is sent to\n\t * @param _holdersFeePercent shares holders fee percent, applied to all the buy and sell operations,\n\t *      the fee percent is defined with the 18 decimals, 10^18 corresponds to 100%\n\t * @param _subjectFeePercent subject fee percent, applied to all the buy and sell operations,\n\t *      the fee percent is defined with the 18 decimals, 10^18 corresponds to 100%\n\t * @param _amount how many shares to buy immediately upon \"post-construction\", can be zero\n\t * @param _beneficiary the address receiving the shares bought immediately (must be set\n\t *      if `_amount` is not zero)\n\t * @param _paymentToken ERC1363 token used as a payment token instead of ETH\n\t */\n\tconstructor(\n\t\taddress _owner,\n\t\tSharesSubject memory _sharesSubject,\n\t\taddress _protocolFeeDestination,\n\t\tuint64 _protocolFeePercent,\n\t\tHoldersRewardsDistributor _holdersFeeDestination,\n\t\tuint64 _holdersFeePercent,\n\t\tuint64 _subjectFeePercent,\n\t\tuint256 _amount,\n\t\taddress _beneficiary,\n\t\tERC1363 _paymentToken\n\t) initializer {\n\t\t// initialize the deployed instance\n\t\tpostConstruct(\n\t\t\t_owner,\n\t\t\t_sharesSubject,\n\t\t\t_protocolFeeDestination,\n\t\t\t_protocolFeePercent,\n\t\t\t_holdersFeeDestination,\n\t\t\t_holdersFeePercent,\n\t\t\t_subjectFeePercent,\n\t\t\t_amount,\n\t\t\t_beneficiary,\n\t\t\t_paymentToken\n\t\t);\n\t}\n\n\t/**\n\t * @dev \"Constructor replacement\" for initializable, must be execute during or immediately after deployment\n\t *      see https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#initializers\n\t *\n\t * @param _owner the address receiving all the RBAC permissions on the contract\n\t * @param _sharesSubject shares subject, usually defined as NFT (ERC721 contract address + NFT ID)\n\t * @param _protocolFeeDestination protocol fee destination, the address protocol fee is sent to\n\t * @param _protocolFeePercent protocol fee percent, applied to all the buy and sell operations;\n\t *      the fee percent is defined with the 18 decimals, 10^18 corresponds to 100%\n\t * @param _holdersFeeDestination shares holders fee destination, the HoldersRewardsDistributor contract\n\t *      the shares holders fee is sent to\n\t * @param _holdersFeePercent shares holders fee percent, applied to all the buy and sell operations,\n\t *      the fee percent is defined with the 18 decimals, 10^18 corresponds to 100%\n\t * @param _subjectFeePercent subject fee percent, applied to all the buy and sell operations,\n\t *      the fee percent is defined with the 18 decimals, 10^18 corresponds to 100%\n\t * @param _amount how many shares to buy immediately upon \"post-construction\", can be zero\n\t * @param _beneficiary the address receiving the shares bought immediately (must be set\n\t *      if `_amount` is not zero)\n\t * @param _paymentToken ERC20 token used as a payment token instead of ETH\n\t */\n\tfunction postConstruct(\n\t\taddress _owner,\n\t\tSharesSubject memory _sharesSubject,\n\t\taddress _protocolFeeDestination,\n\t\tuint64 _protocolFeePercent,\n\t\tHoldersRewardsDistributor _holdersFeeDestination,\n\t\tuint64 _holdersFeePercent,\n\t\tuint64 _subjectFeePercent,\n\t\tuint256 _amount,\n\t\taddress _beneficiary,\n\t\tERC1363 _paymentToken\n\t) public initializer {\n\t\t// execute parent initializer\n\t\t_postConstruct(\n\t\t\t_owner,\n\t\t\t_sharesSubject,\n\t\t\t_protocolFeeDestination,\n\t\t\t_protocolFeePercent,\n\t\t\t_holdersFeeDestination,\n\t\t\t_holdersFeePercent,\n\t\t\t_subjectFeePercent\n\t\t);\n\t\t// no need to check if payment token is zero since this is designed to be\n\t\t// deployed only from the factory where the ERC20 address in non-modifiable\n\t\t// and is defined on the deployment of the factory\n\t\tpaymentToken = _paymentToken;\n\n\t\t// buy shares if requested\n\t\tif(_amount != 0) {\n\t\t\t__buySharesTo(_amount, _beneficiary);\n\t\t}\n\t}\n\n\t/**\n\t * @notice ERC1363 payment token getter\n\t *\n\t * @return ERC1363 payment token, immutable\n\t */\n\tfunction getPaymentToken() public view returns(ERC1363) {\n\t\t// read from the storage and return\n\t\treturn paymentToken;\n\t}\n\n\t/**\n\t * @inheritdoc BondingCurve\n\t *\n\t * @notice Shifts the curve by multiplying the result by 10^5\n\t */\n\tfunction getPrice(uint256 supply, uint256 amount) public pure override(BondingCurve, FriendTechBondingCurve) returns(uint256) {\n\t\t// shift the curve by 10^5\n\t\treturn 10**5 * super.getPrice(supply, amount);\n\t}\n\n\t/**\n\t * @inheritdoc TradeableShares\n\t */\n\tfunction buyShares(uint256 amount) public payable {\n\t\t// delegate to `buySharesTo`\n\t\tbuySharesTo(amount, msg.sender);\n\t}\n\n\t/**\n\t * @inheritdoc TradeableShares\n\t */\n\tfunction sellShares(uint256 amount) public {\n\t\t// delegate to `sellSharesTo`\n\t\tsellSharesTo(amount, payable(msg.sender));\n\t}\n\n\t/**\n\t * @inheritdoc TradeableShares\n\t */\n\tfunction buySharesTo(uint256 amount, address beneficiary) public payable {\n\t\t// verify the first share is not bought\n\t\trequire(getSharesSupply() > 0 || getSharesIssuer() == msg.sender, \"only the issuer can buy the first share\");\n\n\t\t// delegate to unsafe `__buySharesTo`\n\t\t__buySharesTo(amount, beneficiary);\n\t}\n\n\t/**\n\t * @dev Buys amount of shares for the beneficiary, without checking if the first share was bought\n\t *\n\t * @param amount amount of the shares to buy\n\t * @param beneficiary an address receiving the shares\n\t */\n\tfunction __buySharesTo(uint256 amount, address beneficiary) private {\n\t\t// ERC20 implementation doesn't expect Ether to be sent\n\t\trequire(msg.value == 0, \"only payment in ERC20 token is expected\");\n\n\t\t// cache the supply value\n\t\tuint256 supply = getSharesSupply();\n\n\t\t// update the balances (note: security checks are below)\n\t\tsharesBalances[beneficiary] += amount;\n\t\tsharesSupply = supply + amount;\n\n\t\t// determine the price and process the fees\n\t\tuint256 price = getPrice(supply, amount);\n\t\t(, , uint256 protocolFee) = __processProtocolFee(msg.sender, price);\n\t\t(, , uint256 holdersFee) = __processHoldersFeeAndNotify(msg.sender, price, true, amount, beneficiary);\n\t\t(address issuer, , uint256 subjectFee) = __processSubjectFee(msg.sender, price);\n\n\t\t// do the required ERC20 payment token price transfer\n\t\trequire(\n\t\t\t// do not try to transfer zero price\n\t\t\tprice == 0 || paymentToken.transferFrom(msg.sender, address(this), price),\n\t\t\t\"payment failed\"\n\t\t);\n\n\t\t// update the cumulative trade volume\n\t\t__increaseTradeVolume(price);\n\n\t\t// emit an event\n\t\temit Trade(beneficiary, issuer, true, amount, price, protocolFee, holdersFee, subjectFee, sharesSupply);\n\t}\n\n\t/**\n\t * @inheritdoc TradeableShares\n\t */\n\tfunction sellSharesTo(uint256 amount, address payable beneficiary) public {\n\t\t// verify the amount vs total supply\n\t\tuint256 supply = getSharesSupply();\n\t\trequire(supply > amount, \"cannot sell the last share\");\n\n\t\t// verify the amount vs seller's balance\n\t\tuint256 balance = getSharesBalance(msg.sender);\n\t\trequire(balance >= amount, \"insufficient shares\");\n\n\t\t// update the balances\n\t\tsharesBalances[msg.sender] = balance - amount;\n\t\tsharesSupply = supply - amount;\n\n\t\t// determine the price and process the fees\n\t\tuint256 price = getPrice(sharesSupply, amount);\n\t\t(, , uint256 protocolFee) = __processProtocolFee(address(this), price);\n\t\t(, , uint256 holdersFee) = __processHoldersFeeAndNotify(address(this), price, false, amount, msg.sender);\n\t\t(address issuer, , uint256 subjectFee) = __processSubjectFee(address(this), price);\n\n\t\t// price cannot be zero since the last share cannot be sold\n\t\t// if the price transfer fails, we do fail\n\t\t// note: if any of the fees failed to transfer, they are sent to the seller\n\t\trequire(\n\t\t\tpaymentToken.transfer(beneficiary, price - protocolFee - holdersFee - subjectFee),\n\t\t\t\"payment failed\"\n\t\t);\n\n\t\t// update the cumulative trade volume\n\t\t__increaseTradeVolume(price);\n\n\t\t// emit an event\n\t\temit Trade(beneficiary, issuer, false, amount, price, protocolFee, holdersFee, subjectFee, sharesSupply);\n\t}\n\n\t/**\n\t * @dev Calculates the protocol fee and sends it to the protocol fee destination\n\t *\n\t * @param from the address where the tokens are being sent from, this can be either\n\t *      the the shares buyer, or the contract itself (when selling)\n\t * @param price already calculated price of the trade\n\t */\n\tfunction __processProtocolFee(address from, uint256 price) private returns(\n\t\taddress protocolFeeDestination,\n\t\tuint256 protocolFeePercent,\n\t\tuint256 protocolFee\n\t) {\n\t\t// read fee information in a consistent way\n\t\t(protocolFeeDestination, protocolFeePercent) = getProtocolFeeInfo();\n\n\t\t// calculate the fee\n\t\tprotocolFee = price * protocolFeePercent / 1 ether;\n\n\t\t// do the required ERC20 payment token transfer\n\t\trequire(\n\t\t\t// do not try to transfer zero protocol fee\n\t\t\tprotocolFee == 0 || paymentToken.transferFrom(from, protocolFeeDestination, protocolFee),\n\t\t\t\"protocol fee payment failed\"\n\t\t);\n\t}\n\n\t/**\n\t * @dev Calculates the shares holders fee and sends it to the holders fee destination;\n\t *      notifies the destination (which is a HoldersRewardsDistributor contract) about\n\t *      the trade, submits trader address, and trade amount\n\t *\n\t * @dev isBuy is true if the shares are bought\n\t *      isBuy is false if the shares are sold\n\t *\n\t * @param from the address where the tokens are being sent from, this can be either\n\t *      the the shares buyer, or the contract itself (when selling)\n\t * @param price already calculated price of the trade\n\t * @param isBuy operation type, [true] buying, [false] selling\n\t * @param amount trade amount\n\t * @param trader an account which makes a trade, whose shares balance changes by the `amount`\n\t */\n\tfunction __processHoldersFeeAndNotify(address from, uint256 price, bool isBuy, uint256 amount, address trader) private returns(\n\t\tHoldersRewardsDistributor holdersFeeDestination,\n\t\tuint256 holdersFeePercent,\n\t\tuint256 holdersFee\n\t) {\n\t\t// read fee information in a consistent way\n\t\t(holdersFeeDestination, holdersFeePercent) = getHoldersFeeInfo();\n\n\t\t// calculate the fee\n\t\tholdersFee = price * holdersFeePercent / 1 ether;\n\n\t\t// do the required ERC1363 payment token transfer and HoldersRewardsDistributor sync\n\t\tif(address(holdersFeeDestination) != address(0) && amount != 0) {\n\t\t\t// construct the HoldersRewardsDistributor sync message\n\t\t\tbytes memory syncMessage = abi.encode(trader, isBuy, amount);\n\n\t\t\t// send the fee together with the sync message\n\t\t\tbool success = paymentToken.transferFromAndCall(from, address(holdersFeeDestination), holdersFee, syncMessage);\n\n\t\t\t// we require synchronization to succeed, otherwise we can't guarantee data consistency\n\t\t\t// on the HoldersRewardsDistributor contract's side\n\t\t\trequire(success, \"sync failed\");\n\t\t}\n\t}\n\n\t/**\n\t * @dev Calculates the subject fee and sends it to the issuer\n\t *\n\t * @param from the address where the tokens are being sent from, this can be either\n\t *      the the shares buyer, or the contract itself (when selling)\n\t * @param price already calculated price of the trade\n\t */\n\tfunction __processSubjectFee(address from, uint256 price) private returns(\n\t\taddress subjectFeeDestination,\n\t\tuint256 subjectFeePercent,\n\t\tuint256 subjectFee\n\t) {\n\t\t// read fee information in a consistent way\n\t\t(subjectFeeDestination, subjectFeePercent) = getSubjectFeeInfo();\n\n\t\t// calculate the fee\n\t\tsubjectFee = price * subjectFeePercent / 1 ether;\n\n\t\t// do the required ERC20 payment token transfer\n\t\trequire(\n\t\t\t// do not try to transfer zero subject fee\n\t\t\tsubjectFee == 0 || paymentToken.transferFrom(from, subjectFeeDestination, subjectFee),\n\t\t\t\"subject fee payment failed\"\n\t\t);\n\t}\n}\n"
    },
    "contracts/bonding_curves/ETHShares.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../utils/Transfers.sol\";\nimport \"./AbstractShares.sol\";\n\n/**\n * @title ETH Shares\n *\n * @notice TradeableShares implementation using native ETH for payments\n *\n * @dev Based on the friend.tech FriendtechSharesV1.sol\n */\ncontract ETHShares is AbstractShares {\n\t/// @dev Overrides standard send and transfer Solidity functions\n\tusing Transfers for address payable;\n\n\t/**\n\t * @dev Deploys the ETHShares instance and initializes it\n\t *\n\t * @param _owner the address receiving all the RBAC permissions on the contract\n\t * @param _sharesSubject shares subject, usually defined as NFT (ERC721 contract address + NFT ID)\n\t * @param _protocolFeeDestination protocol fee destination, the address protocol fee is sent to\n\t * @param _protocolFeePercent protocol fee percent, applied to all the buy and sell operations;\n\t *      the fee percent is defined with the 18 decimals, 10^18 corresponds to 100%\n\t * @param _holdersFeeDestination shares holders fee destination, the HoldersRewardsDistributor contract\n\t *      the shares holders fee is sent to\n\t * @param _holdersFeePercent shares holders fee percent, applied to all the buy and sell operations,\n\t *      the fee percent is defined with the 18 decimals, 10^18 corresponds to 100%\n\t * @param _subjectFeePercent subject fee percent, applied to all the buy and sell operations,\n\t *      the fee percent is defined with the 18 decimals, 10^18 corresponds to 100%\n\t * @param _amount how many shares to buy immediately upon \"post-construction\", can be zero\n\t * @param _beneficiary the address receiving the shares bought immediately (must be set\n\t *      if `_amount` is not zero)\n\t */\n\tconstructor(\n\t\taddress _owner,\n\t\tSharesSubject memory _sharesSubject,\n\t\taddress _protocolFeeDestination,\n\t\tuint64 _protocolFeePercent,\n\t\tHoldersRewardsDistributor _holdersFeeDestination,\n\t\tuint64 _holdersFeePercent,\n\t\tuint64 _subjectFeePercent,\n\t\tuint256 _amount,\n\t\taddress _beneficiary\n\t) payable initializer {\n\t\t// initialize the deployed instance\n\t\tpostConstruct(\n\t\t\t_owner,\n\t\t\t_sharesSubject,\n\t\t\t_protocolFeeDestination,\n\t\t\t_protocolFeePercent,\n\t\t\t_holdersFeeDestination,\n\t\t\t_holdersFeePercent,\n\t\t\t_subjectFeePercent,\n\t\t\t_amount,\n\t\t\t_beneficiary\n\t\t);\n\t}\n\n\t/**\n\t * @dev \"Constructor replacement\" for initializable, must be execute during or immediately after deployment\n\t *      see https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#initializers\n\t *\n\t * @param _owner the address receiving all the RBAC permissions on the contract\n\t * @param _sharesSubject shares subject, usually defined as NFT (ERC721 contract address + NFT ID)\n\t * @param _protocolFeeDestination protocol fee destination, the address protocol fee is sent to\n\t * @param _protocolFeePercent protocol fee percent, applied to all the buy and sell operations;\n\t *      the fee percent is defined with the 18 decimals, 10^18 corresponds to 100%\n\t * @param _holdersFeeDestination shares holders fee destination, the HoldersRewardsDistributor contract\n\t *      the shares holders fee is sent to\n\t * @param _holdersFeePercent shares holders fee percent, applied to all the buy and sell operations,\n\t *      the fee percent is defined with the 18 decimals, 10^18 corresponds to 100%\n\t * @param _subjectFeePercent subject fee percent, applied to all the buy and sell operations,\n\t *      the fee percent is defined with the 18 decimals, 10^18 corresponds to 100%\n\t * @param _amount how many shares to buy immediately upon \"post-construction\", can be zero\n\t * @param _beneficiary the address receiving the shares bought immediately (must be set\n\t *      if `_amount` is not zero)\n\t */\n\tfunction postConstruct(\n\t\taddress _owner,\n\t\tSharesSubject memory _sharesSubject,\n\t\taddress _protocolFeeDestination,\n\t\tuint64 _protocolFeePercent,\n\t\tHoldersRewardsDistributor _holdersFeeDestination,\n\t\tuint64 _holdersFeePercent,\n\t\tuint64 _subjectFeePercent,\n\t\tuint256 _amount,\n\t\taddress _beneficiary\n\t) public payable initializer {\n\t\t// execute parent initializer\n\t\t_postConstruct(\n\t\t\t_owner,\n\t\t\t_sharesSubject,\n\t\t\t_protocolFeeDestination,\n\t\t\t_protocolFeePercent,\n\t\t\t_holdersFeeDestination,\n\t\t\t_holdersFeePercent,\n\t\t\t_subjectFeePercent\n\t\t);\n\n\t\t// buy shares if requested\n\t\tif(_amount != 0) {\n\t\t\t__buySharesTo(_amount, _beneficiary);\n\t\t}\n\t\t// otherwise if transaction contains a payment\n\t\telse if(msg.value > 0) {\n\t\t\t//  don't forget to return it back\n\t\t\tpayable(msg.sender).transfer1(msg.value);\n\t\t}\n\t}\n\n\t/**\n\t * @inheritdoc TradeableShares\n\t */\n\tfunction buyShares(uint256 amount) public payable {\n\t\t// delegate to `buySharesTo`\n\t\tbuySharesTo(amount, msg.sender);\n\t}\n\n\t/**\n\t * @inheritdoc TradeableShares\n\t */\n\tfunction sellShares(uint256 amount) public {\n\t\t// delegate to `sellSharesTo`\n\t\tsellSharesTo(amount, payable(msg.sender));\n\t}\n\n\t/**\n\t * @inheritdoc TradeableShares\n\t */\n\tfunction buySharesTo(uint256 amount, address beneficiary) public payable {\n\t\t// verify the first share is not bought\n\t\trequire(getSharesSupply() > 0 || getSharesIssuer() == msg.sender, \"only the issuer can buy the first share\");\n\n\t\t// delegate to unsafe `__buySharesTo`\n\t\t__buySharesTo(amount, beneficiary);\n\t}\n\n\t/**\n\t * @dev Buys amount of shares for the beneficiary, without checking if the first share was bought\n\t *\n\t * @param amount amount of the shares to buy\n\t * @param beneficiary an address receiving the shares\n\t */\n\tfunction __buySharesTo(uint256 amount, address beneficiary) private {\n\t\t// cache the supply value\n\t\tuint256 supply = getSharesSupply();\n\n\t\t// update the balances (note: security checks are below)\n\t\tsharesBalances[beneficiary] += amount;\n\t\tsharesSupply = supply + amount;\n\n\t\t// determine the price and process the fees\n\t\tuint256 price = getPrice(supply, amount);\n\t\t(, , uint256 protocolFee) = __processProtocolFee(price);\n\t\t(, , uint256 holdersFee) = __processHoldersFeeAndNotify(price, true, amount, beneficiary);\n\t\t(address issuer, , uint256 subjectFee) = __processSubjectFee(price);\n\n\t\t// verify the transaction has enough Ether supplied\n\t\tuint256 value = price + protocolFee + holdersFee + subjectFee;\n\t\trequire(msg.value >= value, \"insufficient value supplied\");\n\n\t\t// return the change back to the buyer; here we do fail on error\n\t\t// note: if any of the fees failed to transfer, they are sent to the buyer\n\t\tif(msg.value > value) {\n\t\t\tpayable(msg.sender).transfer1(msg.value - value);\n\t\t}\n\n\t\t// update the cumulative trade volume\n\t\t__increaseTradeVolume(price);\n\n\t\t// emit an event\n\t\temit Trade(beneficiary, issuer, true, amount, price, protocolFee, holdersFee, subjectFee, sharesSupply);\n\t}\n\n\t/**\n\t * @inheritdoc TradeableShares\n\t */\n\tfunction sellSharesTo(uint256 amount, address payable beneficiary) public {\n\t\t// verify the amount vs total supply\n\t\tuint256 supply = getSharesSupply();\n\t\trequire(supply > amount, \"cannot sell the last share\");\n\n\t\t// verify the amount vs seller's balance\n\t\tuint256 balance = getSharesBalance(msg.sender);\n\t\trequire(balance >= amount, \"insufficient shares\");\n\n\t\t// update the balances\n\t\tsharesBalances[msg.sender] = balance - amount;\n\t\tsharesSupply = supply - amount;\n\n\t\t// determine the price and process the fees\n\t\tuint256 price = getPrice(sharesSupply, amount);\n\t\t(, , uint256 protocolFee) = __processProtocolFee(price);\n\t\t(, , uint256 holdersFee) = __processHoldersFeeAndNotify(price, false, amount, msg.sender);\n\t\t(address issuer, , uint256 subjectFee) = __processSubjectFee(price);\n\n\t\t// price cannot be zero since the last share cannot be sold\n\t\t// if the price transfer fails, we do fail\n\t\t// note: if any of the fees failed to transfer, they are sent to the seller\n\t\tbeneficiary.transfer1(price - protocolFee - holdersFee - subjectFee);\n\n\t\t// update the cumulative trade volume\n\t\t__increaseTradeVolume(price);\n\n\t\t// emit an event\n\t\temit Trade(beneficiary, issuer, false, amount, price, protocolFee, holdersFee, subjectFee, sharesSupply);\n\t}\n\n\t/**\n\t * @dev Calculates the protocol fee and sends it to the protocol fee destination\n\t *\n\t * @param price already calculated price of the trade\n\t */\n\tfunction __processProtocolFee(uint256 price) private returns(\n\t\taddress protocolFeeDestination,\n\t\tuint256 protocolFeePercent,\n\t\tuint256 protocolFee\n\t) {\n\t\t// read fee information in a consistent way\n\t\t(protocolFeeDestination, protocolFeePercent) = getProtocolFeeInfo();\n\n\t\t// calculate the fee\n\t\tprotocolFee = price * protocolFeePercent / 1 ether;\n\n\t\t// do the required ETH payment transfer\n\t\t// if the fee payment fails - do not throw and update the fee to zero\n\t\tif(protocolFee != 0 && !payable(protocolFeeDestination).send1(protocolFee)) {\n\t\t\t// protocol fee couldn't be sent or is zero\n\t\t\tprotocolFee = 0;\n\t\t}\n\t}\n\n\t/**\n\t * @dev Calculates the shares holders fee and sends it to the holders fee destination;\n\t *      notifies the destination (which is a HoldersRewardsDistributor contract) about\n\t *      the trade, submits trader address, and trade amount\n\t *\n\t * @dev isBuy is true if the shares are bought\n\t *      isBuy is false if the shares are sold\n\t *\n\t * @param price already calculated price of the trade\n\t * @param isBuy operation type, [true] buying, [false] selling\n\t * @param amount trade amount\n\t * @param trader an account which makes a trade, whose shares balance changes by the `amount`\n\t */\n\tfunction __processHoldersFeeAndNotify(uint256 price, bool isBuy, uint256 amount, address trader) private returns(\n\t\tHoldersRewardsDistributor holdersFeeDestination,\n\t\tuint256 holdersFeePercent,\n\t\tuint256 holdersFee\n\t) {\n\t\t// read fee information in a consistent way\n\t\t(holdersFeeDestination, holdersFeePercent) = getHoldersFeeInfo();\n\n\t\t// calculate the fee\n\t\tholdersFee = price * holdersFeePercent / 1 ether;\n\n\t\t// do the required ETH payment transfer and HoldersRewardsDistributor sync\n\t\tif(address(holdersFeeDestination) != address(0) && amount != 0) {\n\t\t\t// construct the HoldersRewardsDistributor sync message\n\t\t\tbytes memory syncMessage = abi.encode(trader, isBuy, amount);\n\n\t\t\t// send the fee together with the sync message\n\t\t\t// we pass all the gas available since the fee destination address is trusted,\n\t\t\t// and since if the call fails we also fail the entire transaction\n\t\t\t(bool success, ) = address(holdersFeeDestination).call{value: holdersFee}(syncMessage);\n\n\t\t\t// we require synchronization to succeed, otherwise we can't guarantee data consistency\n\t\t\t// on the HoldersRewardsDistributor contract's side\n\t\t\trequire(success, \"sync failed\");\n\t\t}\n\t}\n\n\t/**\n\t * @dev Calculates the subject fee and sends it to the issuer\n\t *\n\t * @param price already calculated price of the trade\n\t */\n\tfunction __processSubjectFee(uint256 price) private returns(\n\t\taddress subjectFeeDestination,\n\t\tuint256 subjectFeePercent,\n\t\tuint256 subjectFee\n\t) {\n\t\t// read fee information in a consistent way\n\t\t(subjectFeeDestination, subjectFeePercent) = getSubjectFeeInfo();\n\n\t\t// calculate the fee\n\t\tsubjectFee = price * subjectFeePercent / 1 ether;\n\n\t\t// do the required ETH payment transfer\n\t\t// if the fee payment fails - do not throw and update the fee to zero\n\t\tif(subjectFee != 0 && !payable(subjectFeeDestination).send1(subjectFee)) {\n\t\t\t// protocol fee couldn't be sent or is zero\n\t\t\tsubjectFee = 0;\n\t\t}\n\t}\n}\n"
    },
    "contracts/bonding_curves/FriendTechBondingCurve.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./BondingCurve.sol\";\n\n/**\n * @title FriendTech Bonding Curve\n *\n * @notice friend.tech definition of the bonding curve function\n */\ncontract FriendTechBondingCurve is BondingCurve {\n\t/**\n\t * @inheritdoc BondingCurve\n\t *\n\t * @param s supply, total shares supply\n\t * @param a amount, number of shares to buy/sell\n\t */\n\tfunction getPrice(uint256 s, uint256 a) public pure virtual returns(uint256) {\n\t\t// this is the original friend tech formula with the underflow fix\n\t\t// the fix allows both supply and amount be zero, as well as\n\t\t// it allows supply be zero when the amount is bigger than one\n\t\tuint256 sum1 = s == 0 ? 0 : (s - 1) * s * (2 * (s - 1) + 1) / 6;\n\t\tuint256 sum2 = s == 0 && a <= 1 ? 0 : (s + a - 1) * (s + a) * (2 * (s + a - 1) + 1) / 6;\n\t\tuint256 summation = sum2 - sum1;\n\t\treturn summation * 1 ether / 16000;\n\t}\n}\n"
    },
    "contracts/bonding_curves/HoldersRewardsDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ERC1363Spec.sol\";\n\n/**\n * @title Bonding Curve Holder Reward Distributor\n *\n * @notice Holder reward distributor keeps track of every trade event happening in the curve,\n *      and based on the amount of shares the holder has, alters the holders' reward weight,\n *      which directly affects the amount of the distributed rewards between the holders\n *\n * @notice Holder reward distributor accepts the fees from the curve and distributes these fees\n *      across shares holders proportionally to their weights\n *\n * @dev Apart from the `accept(uint256,address)` function designed to accept the fees from the\n *      curve contract, the implementation must implement receive(), fallback(), and onTransferReceived()\n *      functions to accept direct payments in both ETH and/or ERC20 payment token\n *\n * @dev receive() and onTransferReceived() with an empty data field must accept the fee in the same way\n *      as an accept() function would do, but in a passive way (without ERC20 transfer)\n *\n * @dev The fallback() and onTransferReceived() with non-empty data field must accept the fee and the trading event;\n *      trading event encoded in the bytes data field contains the information\n *      on the trade which resulted in the fee being sent:\n *\n *      - address trader - shares holder/trader\n *      - bool isBuy - true if shares were bought, false if shares were sold\n *      - uint256 sharesAmount - amount of shares bought or sold\n *\n *      the values above are packed as data = abi.encode(trader, isBuy, sharesAmount)\n *      and can be unpacked as (trader, isBuy, sharesAmount) = abi.decode(data, (address, bool, uint256))\n *\n *      if specified, the data field must be parsed by the implementation and its containing data applied;\n *      standard logic applies, if the data is malformed implementation should throw\n *\n */\ninterface HoldersRewardsDistributor is ERC1363Receiver {\n\t/**\n\t * @dev Fired in `sharesBought` and `sharesSold`\n\t *\n\t * @param trader is a buyer or a seller, depending on the operation type\n\t * @param isBuy true if the event comes from the `sharesBought` and represents the buy operation,\n\t *      false if the event comes from the `sharesSold` and represents the sell operation\n\t * @param sharesAmount amount of the shares bought or sold (see `isBuy`)\n\t */\n\tevent SharesTraded(address indexed trader, bool indexed isBuy, uint256 sharesAmount);\n\n\t/**\n\t * @dev Fired when the fee for the distribution is received\n\t *\n\t * @param feeAmount amount of the fee to distribute between the holders\n\t */\n\tevent FeeReceived(uint256 feeAmount);\n\n\t/**\n\t * @dev Fired in `claimReward`\n\t *\n\t * @param holder address of the trader (and shares holder) who received the reward\n\t * @param rewardAmount amount of the reward sent\n\t */\n\tevent RewardClaimed(address indexed holder, uint256 rewardAmount);\n\n\t/**\n\t * @notice ERC20 payment token distributor is bound to\n\t *\n\t * @return paymentToken ERC20 payment token address the contract is bound to,\n\t *      or zero zero address if it operates with the plain ETH\n\t */\n\tfunction getPaymentToken() external view returns(address paymentToken);\n\n/*\n\t*/\n/**\n\t * @notice Notifies the distributor about the trade event\n\t *\n\t * @dev Trade amount specified affects holder's (buyer's) weight when calculating the reward\n\t *\n\t * @param buyer shares buyer (becomes shares holder if not yet), a.k.a trader\n\t * @param amountBought amount of the shares bought\n\t *//*\n\n\tfunction sharesBought(address buyer, uint256 amountBought) external;\n\n\t*/\n/**\n\t * @notice Notifies the distributor about the trade event\n\t *\n\t * @dev Trade amount specified affects holder's (seller's) weight when calculating the reward\n\t *\n\t * @param seller shares seller (shares holder), a.k.a trader\n\t * @param amountSold amount of the shares sold\n\t *//*\n\n\tfunction sharesSold(address seller, uint256 amountSold) external;\n\n\t*/\n/**\n\t * @notice Executed by the fee sender to send the fee; in case of the ERC20 payment,\n\t *      this is the ask to take the specified amount of the ERC20 token of the specified type;\n\t *      in case of the ETH payment, the amount must be supplied with the transaction itself\n\t *\n\t * @dev When paying with an ERC20 payment token, sender must approve the contract for\n\t *      at least the amount specified before executing this function\n\t *\n\t * @dev Updates the accumulated reward per share\n\t *\n\t * @param feeAmount amount of the fee sent,\n\t *      in the case of ETH payment must be equal to msg.value\n\t *//*\n\n\tfunction accept(uint256 feeAmount) external payable;\n*/\n\n\t/**\n\t * @notice Executed by the holder to claim entire pending reward\n\t *\n\t * @dev Holder can verify pending reward amount with the `pendingReward` function\n\t */\n\tfunction claimTheReward() external;\n\n\t/**\n\t * @notice Pending (claimable) reward. This is the amount which can be claimed using `claimTheReward`\n\t *\n\t * @param holder the holder address to query the reward for\n\t * @return rewardAmount pending reward amount\\\n\t */\n\tfunction pendingReward(address holder) external view returns(uint256 rewardAmount);\n}\n"
    },
    "contracts/bonding_curves/HoldersRewardsDistributorV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./HoldersRewardsDistributor.sol\";\nimport \"../utils/Transfers.sol\";\nimport \"../utils/InitializableAccessControl.sol\";\n\n/**\n * @title Bonding Curve Holder Reward Distributor\n *\n * @notice Holder reward distributor keeps track of every trade event happening in the curve,\n *      and based on the amount of shares the holder has, alters the holders' reward weight,\n *      which directly affects the amount of the distributed rewards between the holders\n *\n * @notice Holder reward distributor accepts the fees from the curve and distributes these fees\n *      across shares holders proportionally to their weights\n *\n * @dev Apart from the `accept(uint256,address)` function designed to accept the fees from the\n *      curve contract, the implementation must implement receive(), fallback(), and onTransferReceived()\n *      functions to accept direct payments in both ETH and/or ERC20 payment token\n *\n * @dev receive() and onTransferReceived() with an empty data field must accept the fee in the same way\n *      as an accept() function would do, but in a passive way (without ERC20 transfer)\n *\n * @dev The fallback() and onTransferReceived() with non-empty data field must accept the fee and the trading event;\n *      trading event encoded in the bytes data field contains the information\n *      on the trade which resulted in the fee being sent:\n *\n *      - address trader - shares holder/trader\n *      - bool isBuy - true if shares were bought, false if shares were sold\n *      - uint256 sharesAmount - amount of shares bought or sold\n *\n *      the values above are packed as data = abi.encode(trader, isBuy, sharesAmount)\n *      and can be unpacked as (trader, isBuy, sharesAmount) = abi.decode(data, (address, bool, uint256))\n *\n *      if specified, the data field must be parsed by the implementation and its containing data applied;\n *      standard logic applies, if the data is malformed implementation should throw\n *\n */\ncontract HoldersRewardsDistributorV1 is HoldersRewardsDistributor, InitializableAccessControl {\n\t// Info of each user.\n\tstruct UserInfo {\n\t\tuint256 shares;\n\t\tuint256 rewardDebt;\n\t\tuint256 claimedAmount;\n\t\tuint256 unclaimedAmount;\n\t}\n\n\t// ERC20 payment token address\n\taddress private /*immutable*/ paymentToken;\n\t/// bonding curve contract address\n\taddress public sharesContractAddress;\n\t/// accumulated reward per share, times 1e18 (with 18 decimal precision)\n\tuint256 public accRewardPerShare;\n\t/// total number of share registered\n\tuint256 public totalShares;\n\t// Info of each user that stakes LP tokens.\n\tmapping(address => UserInfo) public userInfo;\n\n\t/**\n\t * @dev Deploys the distributor contract\n\t *\n\t * @param _owner contract, optional (can be zero address), since there are no admin functions\n\t * @param _sharesContractAddress TradeableShares contract to bind the distributor to,\n\t *      optional (can be zero address), this can be set up later with the\n\t *      `initializeSharesContractAddressIfRequired` function\n\t * @param _paymentToken ERC1363 payment token to bind to, optional (can be zero address),\n\t *      zero address means distributor works with the plain ETH\n\t */\n\tconstructor(address _owner, address _sharesContractAddress, address _paymentToken) initializer {\n\t\t// initialize the deployed instance\n\t\tpostConstruct(_owner, _sharesContractAddress, _paymentToken);\n\t}\n\n\t/**\n\t * @dev \"Constructor replacement\" for initializable, must be execute during or immediately after deployment\n\t *      see https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#initializers\n\t *\n\t * @param _owner contract, optional (can be zero address), since there are no admin functions\n\t * @param _sharesContractAddress TradeableShares contract to bind the distributor to,\n\t *      optional (can be zero address), this can be set up later with the\n\t *      `initializeSharesContractAddressIfRequired` function\n\t * @param _paymentToken ERC1363 payment token to bind to, optional (can be zero address),\n\t *      zero address means distributor works with the plain ETH\n\t */\n\tfunction postConstruct(address _owner, address _sharesContractAddress, address _paymentToken) public initializer {\n\t\t// execute parent initializer(s)\n\t\t_postConstruct(_owner);\n\n\t\tsharesContractAddress = _sharesContractAddress;\n\t\tpaymentToken = _paymentToken;\n\t}\n\n\t/**\n\t * @notice Sets the TradeableShares contract to bind the distributor to\n\t *\n\t * @dev TradeableShares contract can be set only once; fails if it is already set\n\t * @param _sharesContractAddress TradeableShares contract to bind the distributor to\n\t */\n\tfunction initializeSharesContractAddressIfRequired(address _sharesContractAddress) public {\n\t\t// check the address is not yet set\n\t\trequire(sharesContractAddress == address(0) && _sharesContractAddress != address(0), \"already initialized\");\n\n\t\t// set the TradeableShares contract address\n\t\tsharesContractAddress = _sharesContractAddress;\n\t}\n\n\t/**\n\t * @inheritdoc HoldersRewardsDistributor\n\t */\n\tfunction getPaymentToken() public view returns (address) {\n\t\treturn paymentToken;\n\t}\n\n\t/**\n\t * @dev Executed when TradeableShares contract notifies about shares bought event\n\t */\n\tfunction __sharesBought(address _buyer, uint256 _amountBought) private {\n\t\tUserInfo storage userDetail = userInfo[_buyer];\n\t\tif(userDetail.shares > 0) {\n\t\t\t// calculated pending reward if any\n\t\t\tuint256 pending = ((userDetail.shares * accRewardPerShare) / 1e18) - userDetail.rewardDebt;\n\t\t\tif(pending > 0) {\n\t\t\t\t// update unclaimed amount\n\t\t\t\tuserDetail.unclaimedAmount += pending;\n\t\t\t}\n\t\t}\n\n\t\t// update state variables\n\t\tuserDetail.shares += _amountBought;\n\t\ttotalShares += _amountBought;\n\t\tuserDetail.rewardDebt = (userDetail.shares * accRewardPerShare) / 1e18;\n\t}\n\n\t/**\n\t * @dev Executed when TradeableShares contract notifies about shares sold event\n\t */\n\tfunction __sharesSold(address _seller, uint256 _amountSold) private {\n\t\trequire(_amountSold <= userInfo[_seller].shares, \"amount must be <= registered amount\");\n\n\t\tUserInfo storage userDetail = userInfo[_seller];\n\t\t// calculated pending reward if any\n\t\tuint256 pending = ((userDetail.shares * accRewardPerShare) / 1e18) - userDetail.rewardDebt;\n\t\tif(pending > 0) {\n\t\t\t// update unclaimed amount\n\t\t\tuserDetail.unclaimedAmount += pending;\n\t\t}\n\n\t\t// update state variables\n\t\tuserDetail.shares = userDetail.shares - _amountSold;\n\t\ttotalShares = totalShares - _amountSold;\n\t\tuserDetail.rewardDebt = (userDetail.shares * accRewardPerShare) / 1e18;\n\t}\n\n\t/**\n\t * @dev Executed when TradeableShares contract send the fees;\n\t * @dev The very first tranche of the fees might be ignored if it is done by the issuer\n\t */\n\tfunction __accept(uint256 _feeAmount) private {\n\t\t// check the state can accept the changes\n\t\tif(_feeAmount == 0 || totalShares == 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t// update state variables\n\t\taccRewardPerShare += (_feeAmount * 1e18) / totalShares;\n\n\t\t// emit an event\n\t\temit FeeReceived(_feeAmount);\n\t}\n\n\n\t/**\n\t * @dev Processes the fee, and the sync message\n\t *\n\t * @dev Takes care about the encoded bytes data containing trader address, trade operation type,\n\t *      and amount of the shares bought\n\t *\n\t * @dev Format: address | bool | uint256\n\t */\n\tfunction __parseTrade(uint256 _feeAmount, bytes memory data) private {\n\t\tif(totalShares == 0) {\n\t\t\t__parseFirstTrade(_feeAmount, data);\n\t\t}\n\t\telse {\n\t\t\t__parseNextTrade(_feeAmount, data);\n\t\t}\n\t}\n\n\t/**\n\t * @dev Processes the very first fee, and the sync message\n\t */\n\tfunction __parseFirstTrade(uint256 _feeAmount, bytes memory data) private {\n\t\t// the very first sync message must not be empty\n\t\trequire(data.length != 0, \"sync message expected\");\n\n\t\t// verify message length\n\t\trequire(data.length == 96, \"malformed sync message\");\n\n\t\t// decode the sync message\n\t\t(address trader, bool isBuy, uint256 sharesAmount) = abi.decode(data, (address, bool, uint256));\n\t\t// the very first operation can be buy only, and cannot be zero\n\t\trequire(isBuy && sharesAmount >= 1, \"invalid state\");\n\n\t\t// init: notify about the first share\n\t\t__sharesBought(trader, 1);\n\t\t// to save the gas execute the rest of the functions only if there is a need\n\t\tif(sharesAmount > 1) {\n\t\t\t// process the fee\n\t\t\t__accept(_feeAmount);\n\t\t\t// notify about the remaining shares\n\t\t\t__sharesBought(trader, sharesAmount - 1);\n\t\t}\n\n\t\t// emit an event\n\t\temit SharesTraded(trader, true, sharesAmount);\n\t}\n\n\t/**\n\t * @dev Processes not the very first fee, and the sync message\n\t */\n\tfunction __parseNextTrade(uint256 _feeAmount, bytes memory data) private {\n\t\t// process the fee\n\t\t__accept(_feeAmount);\n\n\t\t// if the sync message is empty, we're done\n\t\tif(data.length == 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t// verify message length\n\t\trequire(data.length == 96, \"malformed sync message\");\n\n\t\t// decode the sync message\n\t\t(address trader, bool isBuy, uint256 sharesAmount) = abi.decode(data, (address, bool, uint256));\n\t\tif(isBuy) {\n\t\t\t// notify buy\n\t\t\t__sharesBought(trader, sharesAmount);\n\t\t}\n\t\telse {\n\t\t\t// notify sell\n\t\t\t__sharesSold(trader, sharesAmount);\n\t\t}\n\n\t\t// emit an event\n\t\temit SharesTraded(trader, isBuy, sharesAmount);\n\t}\n\n\t/**\n\t * @inheritdoc HoldersRewardsDistributor\n\t */\n\tfunction claimTheReward() public {\n\t\tuint256 claimableAmount = pendingReward(msg.sender);\n\t\trequire(claimableAmount > 0, \"Nothing to claim\");\n\n\t\tUserInfo storage userDetail = userInfo[msg.sender];\n\t\t// update state variable\n\t\tuserDetail.unclaimedAmount = 0;\n\t\tuserDetail.claimedAmount += claimableAmount;\n\t\tuserDetail.rewardDebt = (userDetail.shares * accRewardPerShare) / 1e18;\n\n\t\t// transfer reward\n\t\tif(paymentToken == address(0)) {\n\t\t\tTransfers.transfer(payable(msg.sender), claimableAmount);\n\t\t}\n\t\telse {\n\t\t\trequire(ERC20(paymentToken).transfer(msg.sender, claimableAmount));\n\t\t}\n\n\t\t// emit an event\n\t\temit RewardClaimed(msg.sender, claimableAmount);\n\t}\n\n\t/**\n\t * @inheritdoc HoldersRewardsDistributor\n\t */\n\tfunction pendingReward(address holder) public view returns (uint256) {\n\t\tUserInfo memory userDetail = userInfo[holder];\n\t\tuint256 pending = ((userDetail.shares * accRewardPerShare) / 1e18) - userDetail.rewardDebt;\n\n\t\treturn userDetail.unclaimedAmount + pending;\n\t}\n\n\t/**\n\t * @inheritdoc ERC1363Receiver\n\t *\n\t * @notice Anyone can send some additional rewards – just use empty `data` for a callback\n\t *\n\t * @dev Non-empty `data` executes trade updates and therefore is restricted to be sent only\n\t *      by `sharesContractAddress`\n\t */\n\tfunction onTransferReceived(address operator, address, uint256 value, bytes memory data) public returns (bytes4) {\n\t\trequire(msg.sender == paymentToken, \"received event from wrong token\");\n\t\trequire(operator == sharesContractAddress, \"not allowed\");\n\n\t\t__parseTrade(value, data);\n\t\treturn ERC1363Receiver(this).onTransferReceived.selector;\n\t}\n\n\t/**\n\t * @notice Receive is public. Anyone can send some additional rewards ;)\n\t */\n\treceive() external payable {\n\t\trequire(paymentToken == address(0), \"not allowed\");\n\t\t__parseTrade(msg.value, bytes(\"\"));\n\t}\n\n\t/**\n\t * @dev Fallback executes trade updates and therefore is restricted to be executed only by `sharesContractAddress`\n\t *\n\t * @notice If you want do donate some rewards - use `receive()`\n\t */\n\tfallback() external payable {\n\t\trequire(paymentToken == address(0), \"not an ETH reward distributor\");\n\n\t\trequire(msg.sender == sharesContractAddress, \"not allowed\");\n\t\t__parseTrade(msg.value, msg.data);\n\t}\n}\n"
    },
    "contracts/bonding_curves/ProtocolFeeDistributorV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ERC20Spec.sol\";\nimport \"../utils/UpgradeableAccessControl.sol\";\nimport \"../utils/Transfers.sol\";\n\n/**\n * @title Protocol Fee Distributor V1\n *\n * @notice Accepts protocol fees from the bonding curve contracts and distributes them\n *      later to the list of recipients via the admin-push mechanism\n *\n * @notice The factory manages protocol fees of the deployed TradeableShares contract:\n *      deployed contracts usually follow the protocol fees set on the factory\n */\ncontract ProtocolFeeDistributorV1 is UpgradeableAccessControl {\n\t// recipient details\n\tstruct RecipientDetails {\n\t\taddress payable recipient;\n\t\tuint32 allocationPercent;\n\t}\n\n\t// list of recipients\n\tRecipientDetails[] private recipients;\n\n\t// ERC20 payment token address\n\tERC20 private /*immutable*/ paymentToken;\n\n\t// max number of recipients allowed\n\tuint8 public MAX_RECIPIENTS_ALLOWED;\n\n\t/**\n\t * @notice Recipient list manager having role can add/update recipient details\n\t *\n\t * @dev Role ROLE_RECIPIENT_LIST_MANAGER manager to add/update recipient details\n\t */\n\tuint32 public constant ROLE_RECIPIENT_LIST_MANAGER = 0x0001_0000;\n\n\t/**\n\t * @notice Distribution manager having role can distributor protocol fees\n\t *      to registered recipients\n\t *\n\t * @dev Role ROLE_DISTRIBUTION_MANAGER manager to distribute ETH/ERC20 to recipients\n\t */\n\tuint32 public constant ROLE_DISTRIBUTION_MANAGER = 0x0002_0000;\n\n\t/**\n\t * @dev Fired in receive()\n\t *\n\t * @param from address of user/contract who has sent Ether\n\t * @param amount amount of ETH received\n\t */\n\tevent ETHReceived(address indexed from, uint256 amount);\n\n\t/**\n\t * @dev Fired in distributeETH()\n\t *\n\t * @param recipient recipient address\n\t * @param amount amount of ETH transferred\n\t */\n\tevent ETHSent(address indexed recipient, uint256 amount);\n\n\t/**\n\t * @dev Fired in distributeERC20()\n\t *\n\t * @param paymentToken ERC20 payment token address\n\t * @param recipient recipient address\n\t * @param amount amount of ERC20 payment token transferred\n\t */\n\tevent ERC20Sent(address indexed paymentToken, address indexed recipient, uint256 amount);\n\n\t/**\n\t * @dev Fired in updateRecipientsList()\n\t *\n\t * @param recipient recipient address\n\t * @param allocation allocated in percentage with 4 decimal precision\n\t */\n\tevent RecipientsListUpdated(address indexed recipient, uint32 allocation);\n\n\t/**\n\t * @dev \"Constructor replacement\" for a smart contract with a delayed initialization (post-deployment initialization)\n\t *\n\t * @param _paymentToken ERC20 payment token address\n\t */\n\tfunction postConstruct(address _paymentToken) public virtual initializer {\n\t\t// execute parent initializer\n\t\t_postConstruct(msg.sender);\n\n\t\trequire(_paymentToken != address(0), \"zero address\");\n\n\t\tpaymentToken = ERC20(_paymentToken);\n\t\tMAX_RECIPIENTS_ALLOWED = 5; // max 5 recipients admin can add\n\t}\n\n\t/**\n\t * @notice ERC20 payment token distributor is bound to\n\t *\n\t * @return ERC20 payment token\n\t */\n\tfunction getPaymentToken() public view returns(ERC20) {\n\t\treturn paymentToken;\n\t}\n\n\t// Function to receive Ether. msg.data must be empty\n\treceive() external payable virtual{\n\t\t// emit an event\n\t\temit ETHReceived(msg.sender, msg.value);\n\t}\n\n\t/**\n\t * @notice distribute Ether to all added recipients\n\t *\n\t * @dev distributes Ether to the recipients based on allocation of each recipient.\n\t *\n\t * @dev Restricted access function which can only accessable to address having\n\t *      ROLE_DISTRIBUTION_MANAGER role.\n\t */\n\tfunction distributeETH() public payable {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_DISTRIBUTION_MANAGER), \"access denied\");\n\t\t// verify whether contract has having enough balance to distribute\n\t\trequire(address(this).balance > 0, \"nothing to distribute\");\n\t\t// verify the recipients list is not empty\n\t\trequire(recipients.length > 0, \"recipients list is empty\");\n\n\t\tuint256 amount = address(this).balance;\n\t\tuint256 allocatedAmount;\n\t\tfor(uint8 i = 0; i < recipients.length; i++) {\n\t\t\tallocatedAmount = amount * recipients[i].allocationPercent / 1e6;\n\n\t\t\tif(allocatedAmount > 0) {\n\t\t\t\t// transfer the ETH to the recipient\n\t\t\t\tTransfers.transfer(recipients[i].recipient, allocatedAmount);\n\t\t\t\t// emit an event\n\t\t\t\temit ETHSent(recipients[i].recipient, allocatedAmount);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @notice distribute ERC20 token to all added recipients\n\t *\n\t * @dev distributes ERC20 token to the recipients based on allocation of each recipient.\n\t *\n\t * @dev Restricted access function which can only accessible to address having\n\t *      ROLE_DISTRIBUTION_MANAGER role\n\t */\n\tfunction distributeERC20() public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_DISTRIBUTION_MANAGER), \"access denied\");\n\t\t// verify whether contract has having enough value to distribute\n\t\trequire(paymentToken.balanceOf(address(this)) > 0, \"nothing to distribute\");\n\t\t// verify recipients list is not empty\n\t\trequire(recipients.length > 0, \"recipients list is empty\");\n\n\t\tuint256 amount = paymentToken.balanceOf(address(this));\n\t\tuint256 allocatedAmount;\n\t\tfor(uint8 i = 0; i < recipients.length; i++) {\n\t\t\tallocatedAmount = amount * recipients[i].allocationPercent / 1e6;\n\n\t\t\tif(allocatedAmount > 0) {\n\t\t\t\trequire(paymentToken.transfer(recipients[i].recipient, allocatedAmount));\n\t\t\t\t// emit an event\n\t\t\t\temit ERC20Sent(address(paymentToken), recipients[i].recipient, allocatedAmount);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @notice Add recipient address and allocation for each recipient\n\t *\n\t * @dev Restricted access function which can only accessible to address having\n\t *      ROLE_RECIPIENT_LIST_MANAGER role.\n\t *\n\t * @dev total recipient allocation of all recipients in the list must be 100%,\n\t *      else transaction will be reverted\n\t *\n\t * @param _recipients array of the recipients containing addresses and allocations\n\t */\n\tfunction updateRecipientsList(RecipientDetails[] calldata _recipients) public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_RECIPIENT_LIST_MANAGER), \"access denied\");\n\t\t// input validations\n\t\trequire(_recipients.length > 0, \"recipients list is empty\");\n\t\trequire(_recipients.length <= MAX_RECIPIENTS_ALLOWED, \"recipients list is too big\");\n\n\t\t// delete old recipients list\n\t\tdelete recipients;\n\n\t\tuint256 totalAllocation;\n\t\tfor(uint8 i = 0; i < _recipients.length; i++){\n\t\t\trequire(_recipients[i].recipient != address(0), \"zero recipient\");\n\n\t\t\ttotalAllocation += _recipients[i].allocationPercent;\n\t\t\trecipients.push(_recipients[i]);\n\n\t\t\t// emit an event\n\t\t\temit RecipientsListUpdated(_recipients[i].recipient, _recipients[i].allocationPercent);\n\t\t}\n\n\t\trequire(totalAllocation == 1e6, \"totalAllocation must be 100%\");\n\t}\n\n\t/**\n\t * @notice Number of recipients added to the contract\n\t *      `getRecipient(i)` can be used to iterate the list, 0 <= i < getRecipientsLength()\n\t *\n\t * @return total number of recipients\n\t */\n\tfunction getRecipientsLength() public view returns(uint8) {\n\t\treturn uint8(recipients.length);\n\t}\n\n\t/**\n\t * @notice Reads an element from the list of recipients\n\t *\n\t * @param i zero-based index of the recipient\n\t * @return recipient as RecipientDetails\n\t */\n\tfunction getRecipient(uint256 i) public view returns(RecipientDetails memory) {\n\t\treturn recipients[i];\n\t}\n\n\t/**\n\t * @notice Returns the entire recipients list\n\t *\n\t * @return RecipientDetails[] recipients list array\n\t */\n\tfunction getRecipients() public view returns(RecipientDetails[] memory) {\n\t\treturn recipients;\n\t}\n}\n"
    },
    "contracts/bonding_curves/RewardSystem.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ERC20Spec.sol\";\nimport \"../utils/UpgradeableAccessControl.sol\";\nimport \"../utils/Transfers.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\n\n/**\n * @title Leaderboard Reward System\n *\n * @notice leaderboard reward system designated to release reward for all leaderboard winner\n *\n * @notice reward system uses merkle root to maintain list of winners and reward amounts,\n *      once new winner list is announced, merkle root will be update which include\n *      new winner list and past winners and tier respective won reward amount.\n *\n * @notice leaderboard reward system is proxy upgradeable.\n *\n */\ncontract RewardSystem is UpgradeableAccessControl {\n\t// Use Zeppelin MerkleProof Library to verify Merkle proofs\n\tusing MerkleProof for bytes32[];\n\n\t// Input data root, Merkle tree root for an array of (address, totalReward) pairs,\n\t// Merkle root effectively \"compresses\" the (potentially) huge array of data elements\n\t// and allows to store it in a single 256-bits storage slot on-chain\n\tbytes32 public root;\n\n\t// userAddress => total claimed reward\n\tmapping(address => uint256) public claimedReward;\n\n\t// ERC20 reward token address\n\t// reward system type:\n\t// zero address means contract supports ETH reward\n\t// non-zero address means contract supports ERC20 reward\n\tERC20 public erc20RewardToken;\n\n\t// cumulative reward claimed\n\tuint256 public totalClaimedReward;\n\n\t/**\n\t * @notice Data Root manager is responsible for supplying the valid input data array\n\t *      Merkle root which then can be used to check total reward won by user.\n\t *\n\t * @dev Role ROLE_DATA_ROOT_MANAGER allows setting the Merkle tree root via setInputDataRoot()\n\t */\n\tuint32 public constant ROLE_DATA_ROOT_MANAGER = 0x0001_0000;\n\n\t/**\n\t * @notice Enables the airdrop, redeeming the tokens\n\t *\n\t * @dev Feature FEATURE_CLAIM_ACTIVE must be enabled in order to\n\t *      allow user to claim pending reward\n\t */\n\tuint32 public constant FEATURE_CLAIM_ACTIVE = 0x0000_0001;\n\n\t/**\n\t * @dev Fired in setInputDataRoot()\n\t *\n\t * @param by an address which executed the operation\n\t * @param root new Merkle root value\n\t */\n\tevent RootChanged(address indexed by, bytes32 root);\n\n\t/**\n\t * @dev Fired in claimEthReward()\n\t *\n\t * @param user user address\n\t * @param amount amount of reward transferred\n\t */\n\tevent EthRewardClaimed(address indexed user, uint256 amount);\n\n\t/**\n\t * @dev Fired in claimErc20Reward()\n\t *\n\t * @param rewardToken erc20 reward token address\n\t * @param user user address\n\t * @param amount amount of reward transferred\n\t */\n\tevent ERC20RewardClaimed(address indexed rewardToken, address indexed user, uint256 amount);\n\n\t/**\n\t * @dev Fired in the default receive()\n\t *\n\t * @param value amount received \n\t */\n\tevent PaymentReceived(uint256 value);\n\n\t/**\n\t * @dev \"Constructor replacement\" for a smart contract with a delayed initialization (post-deployment initialization)\n\t *\n\t * @param _erc20RewardToken ERC20 reward token address\n\t *      zero address means contract supports ETH reward\n\t *      non-zero address means contract supports ERC20 reward\n\t */\n\tfunction postConstruct(address _erc20RewardToken) public virtual initializer {\n\t\t// execute parent initializer\n\t\t_postConstruct(msg.sender);\n\n\t\t// zero address is OK meaning we use ETH reward mode\n\t\terc20RewardToken = ERC20(_erc20RewardToken);\n\t}\n\n\t// Function to receive Ether. msg.data must be empty\n\treceive() external payable {\n\t\trequire(rewardSystemType(), \"ETH payments not supported\");\n\t\temit PaymentReceived(msg.value);\n\t}\n\n\t/**\n\t * @notice total amount of token `_totalReward` to an address `_to`, verifying the validity\n\t *      of a `(_to, _totalReward)` pair via the Merkle proof `_proof`\n\t *\n\t * @dev Merkle tree and proof can be constructed using the `web3-utils`, `merkletreejs`,\n\t *      and `keccak256` npm packages:\n\t *      1. Hash the original array data elements (_to, _totalReward) via `web3.utils.soliditySha3`,\n\t *         making sure the packing order.\n\t *      2. Create a sorted MerkleTree (`merkletreejs`) from the hashed array, use `keccak256`\n\t *         from the `keccak256` npm package as a hashing function, do not hash leaves\n\t *         (already hashed in step 1); Ex. MerkleTree options: {hashLeaves: false, sortPairs: true}\n\t *      3. For any given data element (_to, _totalReward) the proof is constructed by hashing it\n\t *         (as in step 1) and querying the MerkleTree for a proof, providing the hashed element\n\t *         as a leaf\n\t *\n\t * @dev Throws is the data or merkle proof supplied is not valid\n\t *\n\t * @param _to an address to whom reward to be sent\n\t * @param _totalReward total reward accumulated by a user across all competitions\n\t * @param _proof Merkle proof for the (_to, _totalReward) pair supplied\n\t */\n\tfunction claimReward(address payable _to, uint256 _totalReward, bytes32[] memory _proof) external {\n\t\t// verify airdrop is in active state\n\t\trequire(isFeatureEnabled(FEATURE_CLAIM_ACTIVE), \"redeems are disabled\");\n\n\t\t// verify the `(_to, _totalReward)` pair is valid\n\t\trequire(isClaimValid(_to, _totalReward, _proof), \"invalid request\");\n\n\t\t// check user has reward to claim\n\t\trequire(claimedReward[_to] < _totalReward, \"nothing to claim\");\n\t\tuint256 claimableAmount = _totalReward - claimedReward[_to];\n\n\t\t// update reward details\n\t\tclaimedReward[_to] += claimableAmount;\n\t\ttotalClaimedReward += claimableAmount;\n\n\t\tif (rewardSystemType()) {\n\t\t\t// transfer ether to user\n\t\t\tTransfers.transfer(_to, claimableAmount);\n\n\t\t\t// emit an event\n\t\t\temit EthRewardClaimed(_to, claimableAmount);\n\t\t}\n\t\telse {\n\t\t\t// transfer erc20 reward token to user\n\t\t\terc20RewardToken.transfer(_to, claimableAmount);\n\n\t\t\t// emit an event\n\t\t\temit ERC20RewardClaimed(address(erc20RewardToken), _to, claimableAmount);\n\t\t}\n\t}\n\n\t/**\n\t * @notice Restricted access function to update input data root (Merkle tree root),\n\t *      and to define, effectively, the tokens to be created by this smart contract\n\t *\n\t * @dev Requires executor to have `ROLE_DATA_MANAGER` permission\n\t *\n\t * @param _root Merkle tree root for the input data array\n\t */\n\tfunction setInputDataRoot(bytes32 _root) public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_DATA_ROOT_MANAGER), \"access denied\");\n\n\t\t// update input data Merkle tree root\n\t\troot = _root;\n\n\t\t// emit an event\n\t\temit RootChanged(msg.sender, _root);\n\t}\n\n\t/**\n\t * @notice Verifies the validity of a `(_to, _totalReward)` pair supplied based on the Merkle root\n\t *      of the entire `(_to, _totalReward)` data array (pre-stored in the contract), and the Merkle\n\t *      proof `_proof` for the particular `(_to, _totalReward)` pair supplied\n\t *\n\t * @dev Merkle tree and proof can be constructed using the `web3-utils`, `merkletreejs`,\n\t *      and `keccak256` npm packages:\n\t *      1. Hash the original array data elements (_to, _totalReward) via `web3.utils.soliditySha3`,\n\t *         making sure the packing order.\n\t *      2. Create a sorted MerkleTree (`merkletreejs`) from the hashed array, use `keccak256`\n\t *         from the `keccak256` npm package as a hashing function, do not hash leaves\n\t *         (already hashed in step 1); Ex. MerkleTree options: {hashLeaves: false, sortPairs: true}\n\t *      3. For any given data element (_to, _totalReward) the proof is constructed by hashing it\n\t *         (as in step 1) and querying the MerkleTree for a proof, providing the hashed element\n\t *         as a leaf\n\t *\n\t * @param _to an address to whom reward to be sent\n\t * @param _totalReward total reward accumulated by a user across all competitions\n\t * @param _proof Merkle proof for the (_to, _totalReward) pair supplied\n\t * @return true if Merkle proof is valid (data belongs to the original array), false otherwise\n\t */\n\tfunction isClaimValid(address _to, uint256 _totalReward, bytes32[] memory _proof) public view returns(bool) {\n\t\t// construct Merkle tree leaf from the inputs supplied\n\t\tbytes32 leaf = keccak256(abi.encodePacked(_to, _totalReward));\n\n\t\t// verify the proof supplied, and return the verification result\n\t\treturn _proof.verify(root, leaf);\n\t}\n\n\t/**\n\t * @notice Reward system type\n\t *\n\t * @return true if contract supports ETH reward\n\t *         false if contract supports ERC20 reward\n\t */\n\tfunction rewardSystemType() public view returns(bool) {\n\t\t// derive from the token address\n\t\treturn address(erc20RewardToken) == address(0);\n\t}\n}\n"
    },
    "contracts/bonding_curves/SharesFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./TradeableShares.sol\";\n\n/**\n * @title Shares Factory\n *\n * @notice Creates/deploys TradeableShares contracts\n *\n * @notice The factory manages protocol fees of the deployed TradeableShares contract:\n *      deployed contracts usually follow the protocol fees set on the factory\n *\n * @dev Based on the friend.tech FriendtechSharesV1.sol\n */\ninterface SharesFactory {\n\t/**\n\t * @dev Enum of all possible TradeableShares implementations the factory can deploy\n\t */\n\tenum ImplementationType {\n\t\t/// @dev ETHShares implementation\n\t\tETH,\n\t\t/// @dev ERC20Shares implementation bound to the ERC20 payment token\n\t\tERC20\n\t}\n\n\t/**\n\t * @dev Shares deployment request is used to enable the TradeableShares\n\t *      deployment with meta-transactions\n\t * @dev See `executeDeploymentRequest()`\n\t */\n\tstruct SharesDeploymentRequest {\n\t\t/// @dev TradeableShares implementation type\n\t\tImplementationType implementationType;\n\t\t/// @dev shares subject, owner of the curve\n\t\tTradeableShares.SharesSubject sharesSubject;\n\t\t/// @dev an address to mint the NFT defined by the subject if it doesn't exist\n\t\taddress issuer;\n\t\t/// @dev how many shares to buy immediately after the deployment\n\t\tuint256 amount;\n\t\t/// @dev unix timestamp when the request becomes valid\n\t\tuint256 validFromTimestamp;\n\t\t/// @dev unix timestamp when the request expires (becomes invalid)\n\t\tuint256 expiresAtTimestamp;\n\t\t/// @dev nonce of the request (sequential number, increased by one)\n\t\tuint256 nonce;\n\t}\n\n\t/**\n\t * @dev Fired in\n\t *      `setProtocolFeeDestination`\n\t *      `setProtocolFeePercent`\n\t *      `setHoldersFeePercent`\n\t *      `setSubjectFeePercent`\n\t *      `setProtocolFee`\n\t *\n\t * @param protocolFeeDestination address where the protocol fee is sent\n\t * @param protocolFeePercent protocol fee percent, value 10^18 corresponds to 100%\n\t * @param holdersFeePercent shares holders fee percent, value 10^18 corresponds to 100%\n\t * @param subjectFeePercent subject fee percent, value 10^18 corresponds to 100%\n\t */\n\tevent ProtocolFeeUpdated(\n\t\taddress protocolFeeDestination,\n\t\tuint64 protocolFeePercent,\n\t\tuint64 holdersFeePercent,\n\t\tuint64 subjectFeePercent\n\t);\n\n\t/**\n\t * @dev Fired in `deploySharesContract` and `registerSharesContract`\n\t *\n\t * @param creator shares creator, a.k.a. shares issuer, or current owner\n\t * @param implementationContract newly deployed or registered TradeableShares contract\n\t * @param holdersRewardsDistributor the shares holders fee destination, HoldersRewardsDistributor contract,\n\t *      this can be zero if shares contract is deployed without the shares holders fee distribution\n\t * @param implementationType type of the TradeableShares, see ImplementationType\n\t * @param sharesSubject current shares subject\n\t * @param newDeployment true if the factory deployed this TradeableShares contract,\n\t *      false if TradeableShares contract was already deployed and factory just registered it\n\t */\n\tevent SharesContractRegistered(\n\t\taddress indexed creator,\n\t\tTradeableShares indexed implementationContract,\n\t\tHoldersRewardsDistributor indexed holdersRewardsDistributor,\n\t\tImplementationType implementationType,\n\t\tTradeableShares.SharesSubject sharesSubject,\n\t\tbool newDeployment\n\t);\n\n\t/**\n\t * @dev Fired in `executeDeploymentRequest` and in `rewind`\n\t */\n\tevent NonceUsed(address indexed issuer, uint256 nonce);\n\n\t/**\n\t * @notice Address of the already deployed TradeableShares implementation\n\t *      to be used by the factory to deploy the TradeableShares contracts EIP-1167 clones\n\t *\n\t * @param _implementationType TradeableShares implementation type\n\t * @return the address of the already deployed TradeableShares implementation corresponding\n\t *      to the given implementation type\n\t */\n\tfunction getSharesImplAddress(ImplementationType _implementationType) external view returns(address);\n\n\t/**\n\t * @notice Address of the already deployed HoldersRewardsDistributor implementation\n\t *      to be used by the factory to deploy the HoldersRewardsDistributor contracts EIP-1167 clones\n\t *\n\t * @dev If the HoldersRewardsDistributor implementation is missing, the TradeableShares contract\n\t *      can still be deployed, not being attached to the HoldersRewardsDistributor\n\t *\n\t * @param _implementationType TradeableShares implementation type\n\t * @return the address of the already deployed HoldersRewardsDistributor implementation corresponding\n\t *      to the given implementation type\n\t */\n\tfunction getDistributorImplAddress(ImplementationType _implementationType) external view returns(address);\n\n\t/**\n\t * @notice Protocol fee destination is the address receiving the protocol fee\n\t *\n\t * @return feeDestination protocol fee destination, address\n\t */\n\tfunction getProtocolFeeDestination() external view returns(address feeDestination);\n\n\t/**\n\t * @notice Protocol fee percent is the percentage of the buy/sell transaction volume\n\t *      sent to the protocol fee destination\n\t *\n\t * @dev The value has 18 decimals, 100% is represented as 10^18\n\t *\n\t * @return feePercent protocol fee percent\n\t */\n\tfunction getProtocolFeePercent() external view returns(uint256 feePercent);\n\n\t/**\n\t * @notice Shares holders fee percent is the percentage of the buy/sell transaction volume\n\t *      sent to the shares holders rewards distributor contract\n\t *\n\t * @dev The value has 18 decimals, 100% is represented as 10^18\n\t *\n\t * @return feePercent shares holders fee percent\n\t */\n\tfunction getHoldersFeePercent() external view returns(uint256 feePercent);\n\n\t/**\n\t * @notice Subject fee percent is the percentage of the buy/sell transaction volume\n\t *      sent to the subject issuer\n\t *\n\t * @dev The value has 18 decimals, 100% is represented as 10^18\n\t *\n\t * @dev Implementation may return different values for different callers,\n\t *      for example it can read SharesSubject from the caller TradeableShares contract\n\t *      and dynamically determine the subject fee\n\t *\n\t * @return feePercent subject fee percent\n\t */\n\tfunction getSubjectFeePercent() external view returns(uint256 feePercent);\n\n\t/**\n\t * @notice Sets the protocol fee destination\n\t *\n\t * @dev Implementation must check the consistency of the protocol fee destination and percent\n\t *      set by this and `setProtocolFeePercent` functions\n\t *\n\t * @param feeDestination protocol fee destination to set\n\t */\n\tfunction setProtocolFeeDestination(address feeDestination) external;\n\n\t/**\n\t * @notice Sets the protocol fee percent\n\t *\n\t * @dev Implementation must check the consistency of the protocol fee destination and percent\n\t *      set by this and `setProtocolFeeDestination` functions\n\t *\n\t * @param feePercent protocol fee percent to set, examples: 10^18 is 100%, 10^17 is 10%\n\t */\n\tfunction setProtocolFeePercent(uint64 feePercent) external;\n\n\t/**\n\t * @notice Sets the shares holders fee percent\n\t *\n\t * @param feePercent shares holders fee percent to set, examples: 10^18 is 100%, 10^17 is 10%\n\t */\n\tfunction setHoldersFeePercent(uint64 feePercent) external;\n\n\t/**\n\t * @notice Sets the subject fee percent\n\t *\n\t * @param feePercent subject fee percent to set, examples: 10^18 is 100%, 10^17 is 10%\n\t */\n\tfunction setSubjectFeePercent(uint64 feePercent) external;\n\n\t/**\n\t * @notice Sets all the fees at once:\n\t *      protocolFeeDestination\n\t *      protocolFeePercent\n\t *      holdersFeePercent\n\t *      subjectFeePercent\n\t *\n\t * @param protocolFeeDestination protocol fee destination to set\n\t * @param protocolFeePercent protocol fee percent to set, examples: 10^18 is 100%, 10^17 is 10%\n\t * @param holdersFeePercent shares holders fee percent to set, examples: 10^18 is 100%, 10^17 is 10%\n\t * @param subjectFeePercent subject fee percent to set, examples: 10^18 is 100%, 10^17 is 10%\n\t */\n\tfunction setProtocolFee(\n\t\taddress protocolFeeDestination,\n\t\tuint64 protocolFeePercent,\n\t\tuint64 holdersFeePercent,\n\t\tuint64 subjectFeePercent\n\t) external;\n\n\t/**\n\t * @notice Deploys the TradeableShares implementation for the specified subject;\n\t *      the curve remains paused, no shares are being bought immediately\n\t *\n\t * @notice Tries minting the NFT defined by the subject if it doesn't exist\n\t *\n\t * @dev Implementation must guarantee only one TradeableShares contract per subject\n\t *\n\t * @param implementationType TradeableShares implementation type\n\t * @param sharesSubject shares subject, owner of the curve\n\t * @return deployed TradeableShares contract\n\t */\n\tfunction deploySharesContractPaused(\n\t\tImplementationType implementationType,\n\t\tTradeableShares.SharesSubject calldata sharesSubject\n\t) external returns(TradeableShares);\n\n\t/**\n\t * @notice Deploys the TradeableShares implementation for the specified subject;\n\t *      the curve launches immediately, the first share is issued to the subject issuer (NFT owner)\n\t *\n\t * @notice Tries minting the NFT defined by the subject if it doesn't exist\n\t *\n\t * @dev Implementation must guarantee only one TradeableShares contract per subject\n\t *\n\t * @param implementationType TradeableShares implementation type\n\t * @param sharesSubject shares subject, owner of the curve\n\t * @return deployed TradeableShares contract\n\t */\n\tfunction deploySharesContract(\n\t\tImplementationType implementationType,\n\t\tTradeableShares.SharesSubject calldata sharesSubject\n\t) external returns(TradeableShares);\n\n\t/**\n\t * @notice Deploys the TradeableShares implementation for the specified subject;\n\t *      allows to immediately buy any amount of shares (including zero)\n\t *\n\t * @notice Tries minting the NFT defined by the subject if it doesn't exist\n\t *\n\t * @dev Implementation must guarantee only one TradeableShares contract per subject\n\t *\n\t * @param implementationType TradeableShares implementation type\n\t * @param sharesSubject shares subject, owner of the curve\n\t * @param amount how many shares to buy immediately after the deployment\n\t * @return deployed TradeableShares contract\n\t */\n\tfunction deploySharesContractAndBuy(\n\t\tImplementationType implementationType,\n\t\tTradeableShares.SharesSubject calldata sharesSubject,\n\t\tuint256 amount\n\t) external payable returns(TradeableShares);\n\n\t/**\n\t * @notice Deploys the TradeableShares implementation for the specified subject;\n\t *      allows to immediately buy any amount of shares (including zero)\n\t *\n\t * @notice Tries minting the NFT defined by the subject if it doesn't exist\n\t *\n\t * @dev Implementation must guarantee only one TradeableShares contract per subject\n\t *\n\t * @param implementationType TradeableShares implementation type\n\t * @param sharesSubject shares subject, owner of the curve\n\t * @param issuer an address to mint the NFT defined by the subject if it doesn't exist\n\t * @param amount how many shares to buy immediately after the deployment\n\t * @return deployed TradeableShares contract\n\t */\n\tfunction mintSubjectAndDeployShares(\n\t\tImplementationType implementationType,\n\t\tTradeableShares.SharesSubject calldata sharesSubject,\n\t\taddress issuer,\n\t\tuint256 amount\n\t) external payable returns(TradeableShares);\n\n\t/**\n\t * @notice Executes signed SharesDeploymentRequest; this is identical to executing `mintSubjectAndDeployShares`\n\t *      on behalf of the signer and allows the transaction to be relayed so that the gas is payed by the\n\t *      relayer\n\t *\n\t * @param req the deployment request to fulfill, containing same data as in `mintSubjectAndDeployShares`\n\t * @param signature the deployment request EIP712 signature issued by the address allowed to execute\n\t *      the request\n\t * @return deployed TradeableShares contract\n\t */\n\tfunction executeDeploymentRequest(\n\t\tSharesDeploymentRequest calldata req,\n\t\tbytes calldata signature\n\t) external payable returns(TradeableShares);\n\n\t/**\n\t * @notice Gets current (unused) nonce for the given issuer address;\n\t *      unused nonce is required to build the SharesDeploymentRequest and sign it\n\t *      nonces increment by one after each use\n\t *\n\t * @param issuer the issuer address to get the nonce for\n\t * @return current (unused) nonce; incremented by one after\n\t *      each successful execution of the `executeDeploymentRequest` function\n\t */\n\tfunction getNonce(address issuer) external view returns(uint256);\n\n\t/**\n\t * @notice Rewinds forward the nonce for the issuer specified, used to\n\t *      discard one or more signed requests to `executeDeploymentRequest`\n\t *\n\t * @dev Implementation must not allow to decrease the nonce, only increasing (rewinding)\n\t *      must be possible\n\t *\n\t * @param issuer the issuer address to rewind the nonce for\n\t * @param nonce the nonce value to rewind to\n\t */\n\tfunction rewindNonce(address issuer, uint256 nonce) external;\n\n\t/**\n\t * @notice Gets the already deployed TradeableShares contract\n\t *\n\t * @param sharesSubject shares subject, owner of the curve\n\t * @return deployed TradeableShares contract\n\t */\n\tfunction lookupSharesContract(\n\t\tTradeableShares.SharesSubject calldata sharesSubject\n\t) external view returns(TradeableShares);\n\n\t/**\n\t * @notice Registers or re-registers the already deployed TradeableShares contract\n\t *\n\t * @dev Initial registration is usually done manually by authorized address,\n\t *      Re-registration is usually done by the shares contract itself\n\t *      and implementations must keep the access to this function open for\n\t *      the already registered contracts\n\t *\n\t * @param shares already deployed TradeableShares contract\n\t */\n\tfunction registerSharesContract(TradeableShares shares) external;\n\n\t/**\n\t * @notice Executed only by the previously registered TradeableShares contracts\n\t *      to notify the factory about the subject change.\n\t *\n\t * @dev The factory may throw if the subject is already taken by another contract\n\t */\n\tfunction notifySubjectUpdated() external;\n}\n\n"
    },
    "contracts/bonding_curves/SharesFactoryV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ERC721SpecExt.sol\";\nimport \"../utils/UpgradeableAccessControl.sol\";\nimport \"./TypedStructLib.sol\";\nimport \"./SharesFactory.sol\";\nimport \"./ETHShares.sol\";\nimport \"./ERC20Shares.sol\";\nimport \"./HoldersRewardsDistributorV1.sol\";\n\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/cryptography/draft-EIP712Upgradeable.sol\";\n\n/**\n * @title Shares Factory V1\n *\n * @notice Role-based access control (RBAC) based implementation of the SharesFactory\n *\n * @dev Based on the friend.tech FriendtechSharesV1.sol\n */\ncontract SharesFactoryV1 is SharesFactory, UpgradeableAccessControl, EIP712Upgradeable {\n\t// libraries in use\n\tusing ECDSAUpgradeable for bytes32;\n\tusing SharesSubjectLib for TradeableShares.SharesSubject;\n\tusing TypedStructLib for SharesDeploymentRequest;\n\n\t/**\n\t * @dev ERC20 payment token address, effectively immutable (cannot be updated)\n\t */\n\tERC1363 private /* immutable */ paymentToken;\n\n\t/**\n\t * @dev Protocol fee destination is the address receiving the protocol fee\n\t */\n\taddress private protocolFeeDestination;\n\n\t/**\n\t * @dev Protocol fee percent with 18 decimals (10^18 = 100%)\n\t */\n\tuint64 private protocolFeePercent;\n\n\t/**\n\t * @dev Shares holders fee percent with 18 decimals (10^18 = 100%)\n\t */\n\tuint64 private holdersFeePercent;\n\n\t/**\n\t * @dev Subject fee percent with 18 decimals (10^18 = 100%)\n\t */\n\tuint64 private subjectFeePercent;\n\n\t/**\n\t * @dev An address receiving the ownership of the deployed TradeableShares contracts\n\t *\n\t * @dev This should be the MultiSig address, not to EOA and not the\n\t *      RBAC managed smart contract, so that this address cannot act in a scalable way;\n\t *      this reduces the risk of misuse, and/or malicious use\n\t */\n\taddress private sharesOwnerAddress;\n\n\t/**\n\t * @dev Deployed shares contracts mapping, keeps track of the deployed contracts subjects\n\t *      Maps SharesSubject => TradeableShares\n\t */\n\tmapping(bytes32 => TradeableShares) private shares;\n\n\t/**\n\t * @dev Reverse deployed shares contracts mapping, keeps track of the deployed contracts\n\t *      Maps TradeableShares address => SharesSubject\n\t */\n\tmapping(address => TradeableShares.SharesSubject) private subjects;\n\n\t/**\n\t * @dev TradeableShares implementations mapping storing deployed TradeableShares\n\t *      address for every supported implementation type, used by the factory to\n\t *      deploy the TradeableShares contracts EIP-1167 clones\n\t *\n\t * @dev Maps TradeableShares ImplementationType => TradeableShares deployed implementation address\n\t */\n\tmapping(ImplementationType => address) private sharesImplementations;\n\n\t/**\n\t * @dev HoldersRewardsDistributor implementations mapping storing deployed HoldersRewardsDistributor\n\t *      address for every supported implementation type, used by the factory to\n\t *      deploy the HoldersRewardsDistributor contracts EIP-1167 clones\n\t *\n\t * @dev If available, HoldersRewardsDistributor implementation is attached to the shares contract\n\t *      during the deployment, allowing it to send shares holders fees to the distributor\n\t *\n\t * @dev Maps TradeableShares ImplementationType => HoldersRewardsDistributor deployed implementation address\n\t */\n\tmapping(ImplementationType => address) private distributorsImplementations;\n\n\t/**\n\t * @dev Keeps track of the used nonces for every possible issuer\n\t *      Maps address => number of used nonces\n\t */\n\tmapping(address => uint256) private nonces;\n\n\t/**\n\t * @notice Enables [TradeableShares] curve deployment functionality\n\t * @dev Feature FEATURE_SHARES_DEPLOYMENT_ENABLED enables `deploySharesContractPaused`,\n\t *      `deploySharesContract`, and `deploySharesContractAndBuy` functions\n\t */\n\tuint32 public constant FEATURE_SHARES_DEPLOYMENT_ENABLED = 0x0000_0001;\n\n\t/**\n\t * @notice Allows the [TradeableShares] curve deployer not to buy any shares on deployment;\n\t *      if disabled the deployer always gets at least one share,\n\t *      effectively launching the curve and allowing anyone to buy\n\t *\n\t * @dev Feature FEATURE_ALLOW_PAUSED_DEPLOYMENTS enables `deploySharesContractPaused` function\n\t */\n\tuint32 public constant FEATURE_ALLOW_PAUSED_DEPLOYMENTS = 0x0000_0002;\n\n\t/**\n\t * @notice Allows the [TradeableShares] curve deployer to exclusively buy\n\t *      any amount of the initial shares; if disabled the deployer always gets\n\t *      no more than only one share\n\t *\n\t * @dev Feature FEATURE_ALLOW_EXCLUSIVE_BUY enables `deploySharesContractAndBuy` function\n\t */\n\tuint32 public constant FEATURE_ALLOW_EXCLUSIVE_BUY = 0x0000_0004;\n\n\t/**\n\t * @notice Protocol fee manager sets protocol fee destination address (protocolFeeDestination)\n\t *      and protocol fee percent (protocolFeePercent)\n\t *\n\t * @dev Role ROLE_PROTOCOL_FEE_MANAGER is required to execute\n\t *      `setProtocolFeeDestination` and `setProtocolFeePercent` functions\n\t */\n\tuint32 public constant ROLE_PROTOCOL_FEE_MANAGER = 0x0001_0000;\n\n\t/**\n\t * @notice Shares holders fee manager sets shares holders fee percent (holdersFeePercent)\n\t *\n\t * @dev Role ROLE_HOLDERS_FEE_MANAGER is required to execute `setHoldersFeePercent` function\n\t */\n\tuint32 public constant ROLE_HOLDERS_FEE_MANAGER = 0x0002_0000;\n\n\t/**\n\t * @notice Subject fee manager sets subject fee percent (subjectFeePercent)\n\t *\n\t * @dev Role ROLE_SUBJECT_FEE_MANAGER is required to execute `setSubjectFeePercent` function\n\t */\n\tuint32 public constant ROLE_SUBJECT_FEE_MANAGER = 0x0004_0000;\n\n\t/**\n\t * @notice Shares registrar deploys new and registers already deployed TradeableShares instances\n\t *\n\t * @dev Role ROLE_SHARES_REGISTRAR is required to execute `deploySharesContract`\n\t *      and `registerSharesContract` functions\n\t */\n\tuint32 public constant ROLE_SHARES_REGISTRAR = 0x0008_0000;\n\n\t/**\n\t * @notice Factory deployment manager\n\t *      - registers already deployed TradeableShares implementations to be used by the factory\n\t *        to deploy the TradeableShares contracts EIP-1167 clones\n\t *      - sets/unsets/updates the shares owner address `sharesOwnerAddress`\n\t *\n\t * @dev Role ROLE_SHARES_IMPLEMENTATION_REGISTRAR is required to execute functions:\n\t *      - `setImplementationAddress`\n\t *      - `setSharesOwnerAddress`\n\t */\n\tuint32 public constant ROLE_FACTORY_DEPLOYMENT_MANAGER = 0x0010_0000;\n\n\t/**\n\t * @dev Fired in setSharesOwnerAddress\n\t *\n\t * @param sharesOwnerAddress new shares owner address, or zero\n\t */\n\tevent SharesOwnerAddressUpdated(address indexed sharesOwnerAddress);\n\n\t/**\n\t * @dev Fired in `setSharesImplAddress`\n\t *\n\t * @param implementationType TradeableShares implementation type\n\t * @param implementationAddress the address of the already deployed TradeableShares implementation\n\t *      corresponding to the given implementation type, or zero address\n\t */\n\tevent SharesImplAddressUpdated(ImplementationType implementationType, address implementationAddress);\n\n\t/**\n\t * @dev Fired in `setDistributorImplAddress`\n\t *\n\t * @param implementationType HoldersRewardsDistributor implementation type\n\t * @param implementationAddress the address of the already deployed HoldersRewardsDistributor implementation\n\t *      corresponding to the given implementation type, or zero address\n\t */\n\tevent DistributorImplAddressUpdated(ImplementationType implementationType, address implementationAddress);\n\n\t/**\n\t * @dev \"Constructor replacement\" for upgradeable, must be execute immediately after proxy deployment\n\t *      see https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#initializers\n\t *\n\t * @param _paymentToken ERC20 payment token address to bind to, immutable\n\t */\n\tfunction postConstruct(ERC1363 _paymentToken) public initializer {\n\t\t// execute parent initializer(s)\n\t\t__EIP712_init_unchained(\"SharesFactory\", \"1\");\n\t\t_postConstruct(msg.sender);\n\n\t\t// verify token address is set\n\t\trequire(address(_paymentToken) != address(0), \"zero address\");\n\n\t\t// set up the immutable ERC20 payment token contract\n\t\tpaymentToken = _paymentToken;\n\t}\n\n\t/**\n\t * @notice ERC1363 payment token contract which the factory uses to deploy the `ERC20` curve type\n\t *\n\t * @dev Immutable, client applications may cache this value\n\t *\n\t * @return ERC1363 payment token contract\n\t */\n\tfunction getPaymentToken() public view returns(ERC1363) {\n\t\t// return the (effectively) immutable value from the storage\n\t\treturn paymentToken;\n\t}\n\n\t/**\n\t * @notice An address receiving the ownership of the deployed TradeableShares contracts\n\t *\n\t * @dev This should be the MultiSig address, not to EOA and not the\n\t *      RBAC managed smart contract, so that this address cannot act in a scalable way;\n\t *      this reduces the risk of misuse, and/or malicious use\n\t *\n\t * @return currently active shares owner address, or zero if not set\n\t */\n\tfunction getSharesOwnerAddress() public view returns(address) {\n\t\t// read it from the storage\n\t\treturn sharesOwnerAddress;\n\t}\n\n\t/**\n\t * @notice Sets/unsets/updates the shares owner address `sharesOwnerAddress`, which is\n\t *      an address receiving the ownership of the deployed TradeableShares contracts\n\t *\n\t * @dev This should be the MultiSig address, not to EOA and not the\n\t *      RBAC managed smart contract, so that this address cannot act in a scalable way;\n\t *      this reduces the risk of misuse, and/or malicious use\n\t *\n\t * @dev Once changed/set, the address affects only new TradeableShares deployments\n\t *\n\t * @param _sharesOwnerAddress new shares owner address to set, or zero to unset\n\t */\n\tfunction setSharesOwnerAddress(address _sharesOwnerAddress) public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_FACTORY_DEPLOYMENT_MANAGER), \"access denied\");\n\n\t\t// update the storage (note: this address is allowed to be zero)\n\t\tsharesOwnerAddress = _sharesOwnerAddress;\n\n\t\t// emit an event\n\t\temit SharesOwnerAddressUpdated(_sharesOwnerAddress);\n\t}\n\n\t/**\n\t * @inheritdoc SharesFactory\n\t */\n\tfunction getSharesImplAddress(ImplementationType _implementationType) public view returns(address) {\n\t\t// read the result from storage\n\t\treturn sharesImplementations[_implementationType];\n\t}\n\n\t/**\n\t * @notice Sets the address of the already deployed TradeableShares implementation\n\t *      to be used by the factory to deploy the TradeableShares contracts EIP-1167 clones\n\t *\n\t * @param _implementationType TradeableShares implementation type\n\t * @param _implementationAddress address of the already deployed TradeableShares implementation\n\t *      corresponding to the given implementation type\n\t */\n\tfunction setSharesImplAddress(ImplementationType _implementationType, address _implementationAddress) public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_FACTORY_DEPLOYMENT_MANAGER), \"access denied\");\n\n\t\t// register/update/deregister implementation\n\t\tsharesImplementations[_implementationType] = _implementationAddress;\n\n\t\t// emit an event\n\t\temit SharesImplAddressUpdated(_implementationType, _implementationAddress);\n\t}\n\n\t/**\n\t * @inheritdoc SharesFactory\n\t */\n\tfunction getDistributorImplAddress(ImplementationType _implementationType) public view returns(address) {\n\t\t// read the result from storage\n\t\treturn distributorsImplementations[_implementationType];\n\t}\n\n\t/**\n\t * @notice Sets the address of the already deployed HoldersRewardsDistributor implementation\n\t *      to be used by the factory to deploy the HoldersRewardsDistributor contracts EIP-1167 clones\n\t *\n\t * @param _implementationType HoldersRewardsDistributor implementation type\n\t * @param _implementationAddress address of the already deployed HoldersRewardsDistributor implementation\n\t *      corresponding to the given implementation type\n\t */\n\tfunction setDistributorImplAddress(ImplementationType _implementationType, address _implementationAddress) public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_FACTORY_DEPLOYMENT_MANAGER), \"access denied\");\n\n\t\t// register/update/deregister implementation\n\t\tdistributorsImplementations[_implementationType] = _implementationAddress;\n\n\t\t// emit an event\n\t\temit DistributorImplAddressUpdated(_implementationType, _implementationAddress);\n\t}\n\n\t/**\n\t * @inheritdoc SharesFactory\n\t */\n\tfunction getProtocolFeeDestination() public view returns(address feeDestination) {\n\t\t// read the result from storage\n\t\treturn protocolFeeDestination;\n\t}\n\n\t/**\n\t * @inheritdoc SharesFactory\n\t */\n\tfunction getProtocolFeePercent() public view returns(uint256 feePercent) {\n\t\t// read the result from storage\n\t\treturn protocolFeePercent;\n\t}\n\n\t/**\n\t * @inheritdoc SharesFactory\n\t */\n\tfunction getHoldersFeePercent() public view returns(uint256 feePercent) {\n\t\t// read the result from storage\n\t\treturn holdersFeePercent;\n\t}\n\n\t/**\n\t * @inheritdoc SharesFactory\n\t */\n\tfunction getSubjectFeePercent() public view returns(uint256 feePercent) {\n\t\t// read the result from storage\n\t\treturn subjectFeePercent;\n\t}\n\n\t/**\n\t * @inheritdoc SharesFactory\n\t */\n\tfunction setProtocolFeeDestination(address _feeDestination) public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_PROTOCOL_FEE_MANAGER), \"access denied\");\n\t\t// verify state change doesn't result into the discrepancy\n\t\trequire(_feeDestination != address(0) || protocolFeePercent == 0, \"protocolFeePercent must be set to zero first\");\n\n\t\t// update contract's state\n\t\tprotocolFeeDestination = _feeDestination;\n\n\t\t// emit an event\n\t\temit ProtocolFeeUpdated(_feeDestination, protocolFeePercent, holdersFeePercent, subjectFeePercent);\n\t}\n\n\t/**\n\t * @inheritdoc SharesFactory\n\t */\n\tfunction setProtocolFeePercent(uint64 _feePercent) public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_PROTOCOL_FEE_MANAGER), \"access denied\");\n\t\t// verify state change doesn't result into the discrepancy\n\t\trequire(_feePercent == 0 || protocolFeeDestination != address(0), \"protocolFeeDestination must be set first\");\n\t\t// verify the fee is not mistakenly too small or big (0.00000001%, 30%)\n\t\trequire(_feePercent == 0 || _feePercent > 1000000 && _feePercent < 300000000000000000, \"malformed fee percent\");\n\n\t\t// update contract's state\n\t\tprotocolFeePercent = _feePercent;\n\n\t\t// emit an event\n\t\temit ProtocolFeeUpdated(protocolFeeDestination, _feePercent, holdersFeePercent, subjectFeePercent);\n\t}\n\n\t/**\n\t * @inheritdoc SharesFactory\n\t */\n\tfunction setHoldersFeePercent(uint64 _feePercent) public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_HOLDERS_FEE_MANAGER), \"access denied\");\n\t\t// verify the fee is not mistakenly too small or big (0.00000001%, 30%)\n\t\trequire(_feePercent == 0 || _feePercent > 1000000 && _feePercent < 300000000000000000, \"malformed fee percent\");\n\n\t\t// update contract's state\n\t\tholdersFeePercent = _feePercent;\n\n\t\t// emit an event\n\t\temit ProtocolFeeUpdated(protocolFeeDestination, protocolFeePercent, _feePercent, subjectFeePercent);\n\t}\n\n\t/**\n\t * @inheritdoc SharesFactory\n\t */\n\tfunction setSubjectFeePercent(uint64 _feePercent) public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_SUBJECT_FEE_MANAGER), \"access denied\");\n\t\t// verify the fee is not mistakenly too small or big (0.00000001%, 30%)\n\t\trequire(_feePercent == 0 || _feePercent > 1000000 && _feePercent < 300000000000000000, \"malformed fee percent\");\n\n\t\t// update contract's state\n\t\tsubjectFeePercent = _feePercent;\n\n\t\t// emit an event\n\t\temit ProtocolFeeUpdated(protocolFeeDestination, protocolFeePercent, holdersFeePercent, _feePercent);\n\t}\n\n\t/**\n\t * @inheritdoc SharesFactory\n\t */\n\tfunction setProtocolFee(\n\t\taddress _protocolFeeDestination,\n\t\tuint64 _protocolFeePercent,\n\t\tuint64 _holdersFeePercent,\n\t\tuint64 _subjectFeePercent\n\t) public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_PROTOCOL_FEE_MANAGER | ROLE_HOLDERS_FEE_MANAGER | ROLE_SUBJECT_FEE_MANAGER), \"access denied\");\n\n\t\t// verify state change doesn't result into the discrepancy\n\t\trequire(_protocolFeePercent == 0 || _protocolFeeDestination != address(0), \"zero address\");\n\t\t// verify the fee is not mistakenly too small or big (0.00000001%, 30%)\n\t\trequire(\n\t\t\t(_protocolFeePercent == 0 || _protocolFeePercent > 1000000 && _protocolFeePercent < 300000000000000000)\n\t\t\t&& (_holdersFeePercent == 0 || _holdersFeePercent > 1000000 && _holdersFeePercent < 300000000000000000)\n\t\t\t&& (_subjectFeePercent == 0 || _subjectFeePercent > 1000000 && _subjectFeePercent < 300000000000000000),\n\t\t\t\"malformed fee percent\"\n\t\t);\n\n\t\t// update contract's state\n\t\tprotocolFeeDestination = _protocolFeeDestination;\n\t\tprotocolFeePercent = _protocolFeePercent;\n\t\tholdersFeePercent = _holdersFeePercent;\n\t\tsubjectFeePercent = _subjectFeePercent;\n\n\t\t// emit an event\n\t\temit ProtocolFeeUpdated(_protocolFeeDestination, _protocolFeePercent, _holdersFeePercent, _subjectFeePercent);\n\t}\n\n\t/**\n\t * @inheritdoc SharesFactory\n\t */\n\tfunction deploySharesContractPaused(\n\t\tImplementationType _implementationType,\n\t\tTradeableShares.SharesSubject calldata _sharesSubject\n\t) public returns(TradeableShares) {\n\t\t// delegate to `deploySharesContractAndBuy`\n\t\treturn deploySharesContractAndBuy(_implementationType, _sharesSubject, 0);\n\t}\n\n\t/**\n\t * @inheritdoc SharesFactory\n\t */\n\tfunction deploySharesContract(\n\t\tImplementationType _implementationType,\n\t\tTradeableShares.SharesSubject calldata _sharesSubject\n\t) public returns(TradeableShares) {\n\t\t// delegate to `deploySharesContractAndBuy`\n\t\treturn deploySharesContractAndBuy(_implementationType, _sharesSubject, 1);\n\t}\n\n\t/**\n\t * @inheritdoc SharesFactory\n\t */\n\tfunction deploySharesContractAndBuy(\n\t\tImplementationType _implementationType,\n\t\tTradeableShares.SharesSubject calldata _sharesSubject,\n\t\tuint256 _amount\n\t) public payable returns(TradeableShares) {\n\t\t// delegate to `mintSubjectAndDeployShares`\n\t\treturn mintSubjectAndDeployShares(_implementationType, _sharesSubject, msg.sender, _amount);\n\t}\n\n\t/**\n\t * @inheritdoc SharesFactory\n\t */\n\tfunction mintSubjectAndDeployShares(\n\t\tImplementationType _implementationType,\n\t\tTradeableShares.SharesSubject calldata _sharesSubject,\n\t\taddress _issuer,\n\t\tuint256 _amount\n\t) public payable returns(TradeableShares) {\n\t\t// delegate to unsafe `__mintSubjectAndDeployShares`\n\t\treturn __mintSubjectAndDeployShares(_implementationType, _sharesSubject, _issuer, _amount, msg.sender);\n\t}\n\n\t/**\n\t * @dev Deploys the TradeableShares implementation for the specified subject;\n\t *      allows to immediately buy any amount of shares (including zero)\n\t *\n\t * @dev Tries minting the NFT defined by the subject if it doesn't exist\n\t *\n\t * @dev Unsafe, uses the specified `_authorizedBy` to check the access permission, which\n\t *      is either msg.sender, or the derived signer (if used in EIP712 meta tx mode)\n\t *\n\t * @param _implementationType TradeableShares implementation type\n\t * @param _sharesSubject shares subject, owner of the curve\n\t * @param _issuer an address to mint the NFT defined by the subject if it doesn't exist\n\t * @param _amount how many shares to buy immediately after the deployment\n\t * @param _authorizedBy must be either msg.sender or EIP712 signer if executed by the relayer\n\t * @return deployed TradeableShares contract\n\t */\n\tfunction __mintSubjectAndDeployShares(\n\t\tImplementationType _implementationType,\n\t\tTradeableShares.SharesSubject calldata _sharesSubject,\n\t\taddress _issuer,\n\t\tuint256 _amount,\n\t\taddress _authorizedBy\n\t) private returns(TradeableShares) {\n\t\t// verify deployments are enabled\n\t\trequire(isFeatureEnabled(FEATURE_SHARES_DEPLOYMENT_ENABLED), \"shares deployments disabled\");\n\n\t\t// verify paused deployments are enabled\n\t\trequire(\n\t\t\t// zero amount means paused deployment\n\t\t\t_amount != 0 || isFeatureEnabled(FEATURE_ALLOW_PAUSED_DEPLOYMENTS)\n\t\t\t\t// we do not allow to bypass the feature with meta-tx\n\t\t\t\t|| isSenderInRole(ROLE_SHARES_REGISTRAR),\n\t\t\t\"paused deployments disabled\"\n\t\t);\n\n\t\t// verify exclusive buys are enabled (if exclusive buy is requested)\n\t\trequire(\n\t\t\t_amount <= 1 || isFeatureEnabled(FEATURE_ALLOW_EXCLUSIVE_BUY)\n\t\t\t\t// we do not allow to bypass the feature with meta-tx\n\t\t\t\t|| isSenderInRole(ROLE_SHARES_REGISTRAR),\n\t\t\t\"exclusive buys disabled\"\n\t\t);\n\n\t\t// determine the issuer\n\t\taddress issuer = _sharesSubject.getSharesIssuer();\n\n\t\t// verify the access permission:\n\t\t// contract can be deployed either by the shares subject owner, or by the shares registrar\n\t\trequire(\n\t\t\t// contract can be deployed either by the shares subject owner\n\t\t\tmsg.sender == issuer\n\t\t\t// or by the shares registrar (role)\n\t\t\t|| isOperatorInRole(_authorizedBy, ROLE_SHARES_REGISTRAR)\n\t\t\t// or by the ERC721 contract owner\n\t\t\t|| _authorizedBy == _sharesSubject.getCollectionOwner(),\n\t\t\t\"access denied\"\n\t\t);\n\n\t\t// if issuer couldn't determined, we might need to mint the corresponding NFT\n\t\tif(issuer == address(0)) {\n\t\t\t// ensure the address to mint to is defined\n\t\t\t// if not - we cannot mint, but the error is in the shares subject in the first place\n\t\t\trequire(_issuer != address(0), \"invalid subject\");\n\t\t\t// try to mint, we expect this function to fail in case of an error\n\t\t\tMintableERC721(_sharesSubject.tokenAddress).mint(_issuer, _sharesSubject.tokenId);\n\t\t\t// set the issuer to the address NFT was minted to\n\t\t\tissuer = _issuer;\n\t\t}\n\n\t\t// at this point issuer cannot be zero, but it can be different from msg.sender\n\t\t// assert(issuer != address(0));\n\n\t\t// get shares implementation address for the implementation type specified\n\t\taddress sharesImplAddress = getSharesImplAddress(_implementationType);\n\n\t\t// verify the implementation address is registered for the implementation type specified\n\t\trequire(sharesImplAddress != address(0), \"implementation not registered\");\n\n\t\t// \"clone\" the impl (deploy a minimalistic EIP-1167 proxy)\n\t\tTradeableShares sharesContract = TradeableShares(Clones.clone(sharesImplAddress));\n\n\t\t// get holders rewards distributor implementation address for the implementation type specified\n\t\taddress distributorImplAddress = getDistributorImplAddress(_implementationType);\n\n\t\t// distributorImplAddress can be zero, in this case we will deploy the shares\n\t\t// without the HoldersRewardsDistributor attached to the contract\n\t\tHoldersRewardsDistributor distributorContract = HoldersRewardsDistributor(address(0));\n\n\t\t// if distributorImplAddress is defined, clone and initialize the HoldersRewardsDistributor\n\t\tif(distributorImplAddress != address(0)) {\n\t\t\t// \"clone\" the impl (deploy a minimalistic EIP-1167 proxy)\n\t\t\tdistributorContract = HoldersRewardsDistributor(Clones.clone(distributorImplAddress));\n\n\t\t\t// proxy initialization logic is implementation dependent\n\t\t\tHoldersRewardsDistributorV1(payable(address(distributorContract))).postConstruct(\n\t\t\t\tsharesOwnerAddress,\n\t\t\t\taddress(sharesContract),\n\t\t\t\t_implementationType == ImplementationType.ETH? address(0): address(paymentToken)\n\t\t\t);\n\t\t}\n\n\t\t// initialize TradeableShares EIP-1167 proxy\n\t\t__initSharesContract(sharesContract, distributorContract, _implementationType, _sharesSubject, _amount, issuer);\n\n\t\t// verify the shares subject is not yet mapped (not in use)\n\t\tbytes32 sharesKey = _sharesSubject.getSharesKey();\n\t\trequire(address(shares[sharesKey]) == address(0), \"subject in use\");\n\n\t\t// register the deployed implementation into the mappings\n\t\tshares[sharesKey] = sharesContract;\n\t\tsubjects[address(sharesContract)] = _sharesSubject;\n\n\t\t// emit an event\n\t\temit SharesContractRegistered(issuer, sharesContract, distributorContract, _implementationType, _sharesSubject, true);\n\n\t\t// return the result - deployed address\n\t\treturn sharesContract;\n\t}\n\n\t/**\n\t * @dev Part of the `__mintSubjectAndDeployShares` routine moved into\n\t *      a separate routine to fix the \"Stack too deep\" issue\n\t */\n\tfunction __initSharesContract(\n\t\tTradeableShares _sharesContract,\n\t\tHoldersRewardsDistributor _distributorContract,\n\t\tImplementationType _implementationType,\n\t\tTradeableShares.SharesSubject calldata _sharesSubject,\n\t\tuint256 _amount,\n\t\taddress _beneficiary\n\t) private {\n\t\t// determine the effective shares holders fee percent\n\t\t// this also caches the fee on stack and saves a bit of gas\n\t\tuint64 _holdersFeePercent = address(_distributorContract) == address(0)? 0: holdersFeePercent;\n\n\t\t// proxy initialization logic is implementation dependent\n\t\t// switch(_implementationType)\n\t\tif(_implementationType == ImplementationType.ETH) {\n\t\t\t// initialize the Ethereum version by invoking the postConstruct on the proxy\n\t\t\tETHShares(address(_sharesContract)).postConstruct{value: msg.value}(\n\t\t\t\tsharesOwnerAddress,\n\t\t\t\t_sharesSubject,\n\t\t\t\tprotocolFeeDestination,\n\t\t\t\tprotocolFeePercent,\n\t\t\t\t_distributorContract,\n\t\t\t\t_holdersFeePercent,\n\t\t\t\tsubjectFeePercent,\n\t\t\t\t_amount,\n\t\t\t\t_beneficiary\n\t\t\t);\n\t\t}\n\t\telse if(_implementationType == ImplementationType.ERC20) {\n\t\t\t// factory doesn't support sending the change back\n\t\t\trequire(msg.value == 0, \"non-zero value\");\n\n\t\t\t// if there is a request of the immediate shares buy\n\t\t\tif(_amount > 1) {\n\t\t\t\t// determine how much tokens we need\n\t\t\t\tuint256 toPay = _sharesContract.getBuyPriceAfterFee(0, _amount, protocolFeePercent, _holdersFeePercent, subjectFeePercent);\n\t\t\t\t// get the tokens required to buy\n\t\t\t\trequire(paymentToken.transferFrom(msg.sender, address(this), toPay));\n\t\t\t\t// approve the tokens to be spent\n\t\t\t\trequire(paymentToken.approve(address(_sharesContract), toPay));\n\t\t\t}\n\n\t\t\t// initialize the ERC20 version with the ERC20 as a payment token by invoking the postConstruct on the proxy\n\t\t\tERC20Shares(address(_sharesContract)).postConstruct(\n\t\t\t\tsharesOwnerAddress,\n\t\t\t\t_sharesSubject,\n\t\t\t\tprotocolFeeDestination,\n\t\t\t\tprotocolFeePercent,\n\t\t\t\t_distributorContract,\n\t\t\t\t_holdersFeePercent,\n\t\t\t\tsubjectFeePercent,\n\t\t\t\t_amount,\n\t\t\t\t_beneficiary,\n\t\t\t\tpaymentToken\n\t\t\t);\n\n\t\t\t// if there was a request of the immediate shares buy\n\t\t\tif(_amount > 1) {\n\t\t\t\t// transfer the remaining tokens (if any) back to the sender\n\t\t\t\trequire(paymentToken.transfer(msg.sender, paymentToken.balanceOf(address(this))));\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// throw if the implementation type is unknown\n\t\t\t// this must be an unreachable else block because the if-else blocks above\n\t\t\t// should have been taken care about all possible implementation types\n\t\t\trevert(\"unknown implementation type\");\n\t\t}\n\t}\n\n\t/**\n\t * @inheritdoc SharesFactory\n\t */\n\tfunction executeDeploymentRequest(\n\t\tSharesDeploymentRequest calldata req,\n\t\tbytes calldata signature\n\t) public payable returns(TradeableShares) {\n\t\t// verify the request validity\n\t\trequire(req.validFromTimestamp <= block.timestamp, \"not yet valid\");\n\t\trequire(req.expiresAtTimestamp > block.timestamp, \"expired\");\n\n\t\t// verify and use nonce\n\t\t__useNonce(req.issuer, req.nonce);\n\n\t\t// derive the request signer\n\t\t// this also verifies that the signature is valid\n\t\taddress signer = _hashTypedDataV4(req.hashStruct()).recover(signature);\n\n\t\t// delegate to unsafe `__mintSubjectAndDeployShares`\n\t\treturn __mintSubjectAndDeployShares(req.implementationType, req.sharesSubject, req.issuer, req.amount, signer);\n\t}\n\n\t/**\n\t * @dev Verifies the nonce is valid and marks it as used\n\t *      Throws if nonce is already used or if it is invalid\n\t *\n\t * @param _issuer the owner of the nonce\n\t * @param _nonce the nonce to be used\n\t */\n\tfunction __useNonce(address _issuer, uint256 _nonce) private {\n\t\t// verify the nonce wasn't yet used and use it\n\t\trequire(nonces[_issuer]++ == _nonce, \"invalid nonce\");\n\n\t\t// emit an event\n\t\temit NonceUsed(_issuer, _nonce);\n\t}\n\n\t/**\n\t * @inheritdoc SharesFactory\n\t */\n\tfunction getNonce(address _issuer) external view returns(uint256) {\n\t\t// read the nonce from the storage\n\t\treturn nonces[_issuer];\n\t}\n\n\t/**\n\t * @inheritdoc SharesFactory\n\t */\n\tfunction rewindNonce(address _issuer, uint256 _nonce) external {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_SHARES_REGISTRAR), \"access denied\");\n\n\t\t// make sure nonce is not decreasing\n\t\trequire(nonces[_issuer] < _nonce, \"new nonce must be bigger than the current one\");\n\n\t\t// rewind the nonce to the value requested\n\t\tnonces[_issuer] = _nonce;\n\n\t\t// emit an event\n\t\temit NonceUsed(_issuer, _nonce - 1);\n\t}\n\n\t/**\n\t * @inheritdoc SharesFactory\n\t */\n\tfunction lookupSharesContract(\n\t\tTradeableShares.SharesSubject calldata _sharesSubject\n\t) public view returns(TradeableShares) {\n\t\treturn shares[_sharesSubject.getSharesKey()];\n\t}\n\n\t/**\n\t * @inheritdoc SharesFactory\n\t *\n\t * @dev Note: this restricted function allows the authorized address to register\n\t *      the shares contract with the invalid subject\n\t */\n\tfunction registerSharesContract(TradeableShares _sharesContract) external {\n\t\t// verify the access permission: contract can be registered only by the shares registrar\n\t\trequire(isSenderInRole(ROLE_SHARES_REGISTRAR), \"access denied\");\n\n\t\t// delegate to unsafe `__registerSharesContract`\n\t\t__registerSharesContract(_sharesContract);\n\t}\n\n\t/**\n\t * @inheritdoc SharesFactory\n\t */\n\tfunction notifySubjectUpdated() external {\n\t\t// read the registered subject (this can be zero if not registered)\n\t\tTradeableShares.SharesSubject memory registeredSubject = subjects[msg.sender];\n\n\t\t// ensure the subject is registered (we know the caller, we already registered it)\n\t\trequire(!registeredSubject.isZero(), \"not registered\");\n\t\t// we do not allow binding to non-existent NFTs (consistency with `__mintSubjectAndDeployShares`)\n\t\trequire(TradeableShares(msg.sender).getSharesSubject().getSharesIssuer() != address(0), \"invalid subject\");\n\n\t\t// delegate to unsafe `__registerSharesContract`\n\t\t__registerSharesContract(TradeableShares(msg.sender));\n\t}\n\n\t/**\n\t * @dev Registers the TradeableShares contract;\n\t *      unsafe, doesn't verify the access permissions, must be kept private at all times\n\t *\n\t * @param _sharesContract TradeableShares contract to register\n\t */\n\tfunction __registerSharesContract(TradeableShares _sharesContract) private {\n\t\t// determine current shares subject\n\t\tTradeableShares.SharesSubject memory sharesSubject = _sharesContract.getSharesSubject();\n\t\t// this contract may had already been registered under the different subject\n\t\tTradeableShares.SharesSubject memory registeredSubject = subjects[address(_sharesContract)];\n\n\t\t// if it was already registered and subject didn't change there is nothing to do\n\t\tif(sharesSubject.equals(registeredSubject)) {\n\t\t\t// exit from the function silently\n\t\t\treturn;\n\t\t}\n\n\t\t// verify the shares subject is not yet mapped (not in use)\n\t\tbytes32 sharesKey = sharesSubject.getSharesKey();\n\t\trequire(address(shares[sharesKey]) == address(0), \"subject in use\");\n\n\t\t// cleanup previously registered subject mapping if any\n\t\tdelete shares[registeredSubject.getSharesKey()];\n\n\t\t// register the deployed implementation into the mappings\n\t\tshares[sharesKey] = _sharesContract;\n\t\tsubjects[address(_sharesContract)] = sharesSubject;\n\n\t\t// emit an event\n\t\temit SharesContractRegistered(\n\t\t\t_sharesContract.getSharesIssuer(),\n\t\t\t_sharesContract,\n\t\t\t_sharesContract.getHoldersFeeDestination(),\n\t\t\tdetermineImplementationType(_sharesContract),\n\t\t\t_sharesContract.getSharesSubject(),\n\t\t\tfalse\n\t\t);\n\t}\n\n\t/**\n\t * @notice Tries to determine the implementation type of the already deployed TradeableShares contract;\n\t *      the result should not be considered reliable and can be used only as a hint\n\t *\n\t * @param _sharesContract deployed TradeableShares instance\n\t * @return implementation type of the instance specified\n\t */\n\tfunction determineImplementationType(TradeableShares _sharesContract) public view returns(ImplementationType) {\n\t\t// determine the implementation type\n\t\tImplementationType implementationType;\n\n\t\t// try to treat the implementation as ERC20\n\t\ttry ERC20Shares(address(_sharesContract)).getPaymentToken() returns (ERC1363 token) {\n\t\t\t// for the ERC20Shares impl we support only ERC20 token known to factory\n\t\t\trequire(token == paymentToken, \"unknown ERC20 implementation type\");\n\n\t\t\t// implementation type is successfully determined as ERC20\n\t\t\timplementationType = ImplementationType.ERC20;\n\t\t}\n\t\tcatch {\n\t\t\t// fallback to ETH\n\t\t\timplementationType = ImplementationType.ETH;\n\t\t}\n\n\t\t// return the result\n\t\treturn implementationType;\n\t}\n}\n"
    },
    "contracts/bonding_curves/SharesSubjectLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ERC721Spec.sol\";\nimport \"../interfaces/ERC721SpecExt.sol\";\nimport \"./TradeableShares.sol\";\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title Shares Subject Library\n *\n * @notice Auxiliary functions to work with SharesSubject struct\n */\nlibrary SharesSubjectLib {\n\t/**\n\t * @notice Determines current owner of the shares subject, which is a corresponding NFT owner\n\t *\n\t * @dev This function returns zero address if NFT doesn't exist, or even if NFT contract doesn't exist\n\t *\n\t * @param sharesSubject shares subject, owner of the curve\n\t * @return address of the issuer, underlying NFT owner; or zero address\n\t */\n\tfunction getSharesIssuer(TradeableShares.SharesSubject memory sharesSubject) internal view returns(address) {\n\t\t// we have to check if the address is callable, otherwise staticall would throw\n\t\tif(isCallable(sharesSubject.tokenAddress)) {\n\t\t\t// try to avoid an exception / failed call in the ownerOf function by checking NFT existence first\n\t\t\t// this is required *only* to avoid \"partially failed\" transaction display on etherscan\n\t\t\t{\n\t\t\t\t// we use staticcall instead of ABI function call to guaranty immutable call\n\t\t\t\t(bool success, bytes memory data) = sharesSubject.tokenAddress.staticcall{gas: 4900}(\n\t\t\t\t\t// MintableERC721 interface: function exists(uint256) external view returns(bool)\n\t\t\t\t\tabi.encodeWithSelector(MintableERC721.exists.selector, sharesSubject.tokenId)\n\t\t\t\t);\n\t\t\t\t// only if the call was successful\n\t\t\t\tif(success) {\n\t\t\t\t\t// try to decode the result as a bool,\n\t\t\t\t\t// and if we know for sure token doesn't exist,\n\t\t\t\t\tif(!abi.decode(data, (bool))) {\n\t\t\t\t\t\t// just return zero address as a default result in case of any error\n\t\t\t\t\t\treturn address(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// try to get the ERC721 owner of the underlying NFT\n\t\t\t{\n\t\t\t\t// we use staticcall instead of ABI function call to guaranty immutable call\n\t\t\t\t(bool success, bytes memory data) = sharesSubject.tokenAddress.staticcall{gas: 4900}(\n\t\t\t\t\t// ERC721 interface: function ownerOf(uint256) external view returns(address)\n\t\t\t\t\tabi.encodeWithSelector(ERC721.ownerOf.selector, sharesSubject.tokenId)\n\t\t\t\t);\n\t\t\t\t// only if the call was successful\n\t\t\t\tif(success) {\n\t\t\t\t\t// try to decode the result as an address and return\n\t\t\t\t\treturn abi.decode(data, (address));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// return the default zero address value in case of any errors\n\t\treturn address(0);\n\t}\n\n\t/**\n\t * @notice Determines the owner of the shares subject's underlying NFT collection\n\t *\n\t * @dev This function returns zero address if the underlying ERC721 contract is not OZ ownable\n\t *      (doesn't have `owner()` function), doesn't exist, or if any other error occurs\n\t *\n\t * @param sharesSubject shares subject, owner of the curve\n\t * @return address of the NFT collection owner (OZ ownable); or zero address\n\t */\n\tfunction getCollectionOwner(TradeableShares.SharesSubject memory sharesSubject) internal view returns(address) {\n\t\t// we have to check if the address is callable, otherwise staticall would throw\n\t\tif(isCallable(sharesSubject.tokenAddress)) {\n\t\t\t// try to derive the owner via the OZ Ownable interface owner()\n\t\t\t// we use staticcall instead of ABI function call to guaranty immutable call\n\t\t\t(bool success, bytes memory data) = sharesSubject.tokenAddress.staticcall{gas: 4900}(\n\t\t\t\t// OZ Ownable interface: function owner() external view returns(address)\n\t\t\t\tabi.encodeWithSelector(Ownable.owner.selector)\n\t\t\t);\n\n\t\t\t// only if the call was successful\n\t\t\tif(success) {\n\t\t\t\t// try to decode the result as an address and return\n\t\t\t\treturn abi.decode(data, (address));\n\t\t\t}\n\t\t}\n\n\t\t// return the default zero address value in case of any errors\n\t\treturn address(0);\n\t}\n\n\t/**\n\t * @notice Calculates the keccak256 bytes32 key for the shares subject to be used in the mappings\n\t *\n\t * @param sharesSubject shares subject, owner of the curve\n\t * @return keccak256 of the shares subject\n\t */\n\tfunction getSharesKey(TradeableShares.SharesSubject memory sharesSubject) internal pure returns(bytes32) {\n\t\t// calculate the keccak256 from the concatenated internals of the SharesSubject struct\n\t\treturn keccak256(abi.encode(sharesSubject.tokenAddress, sharesSubject.tokenId));\n\t}\n\n\t/**\n\t * @notice Checks if two subjects - subject 1 and subject 2 - are equal\n\t *      Returns false if any of the subjects is not initialized (have zero ERC721 address)\n\t *\n\t * @param sharesSubject1 subject 1\n\t * @param sharesSubject2 subject 2\n\t * @return true if subject 1 and subject 2 are equal\n\t */\n\tfunction equals(\n\t\tTradeableShares.SharesSubject memory sharesSubject1,\n\t\tTradeableShares.SharesSubject memory sharesSubject2\n\t) internal pure returns(bool) {\n\t\treturn sharesSubject1.tokenAddress != address(0)\n\t\t\t&& sharesSubject1.tokenAddress == sharesSubject2.tokenAddress\n\t\t\t&& sharesSubject1.tokenId == sharesSubject2.tokenId;\n\t}\n\n\t/**\n\t * @notice Verifies if the shares subject contains a value; this function is useful\n\t *      to check if the value in storage (mapping) was initialized\n\t *\n\t * @param sharesSubject the shares subject to check\n\t * @return true if the subject has a value, false otherwise (zero value)\n\t */\n\tfunction isZero(TradeableShares.SharesSubject memory sharesSubject) internal pure returns(bool) {\n\t\treturn sharesSubject.tokenAddress == address(0) && sharesSubject.tokenId == 0;\n\t}\n\n\t/**\n\t * @notice Checks if account can be called (is callable, already deployed contract)\n\t *\n\t * @dev Verifies if the bytecode on the specified address is present\n\t *\n\t * @param account an address to check\n\t * @return true if address denotes already deployed callable contract\n\t */\n\tfunction isCallable(address account) internal view returns(bool) {\n\t\t// This method relies on extcodesize, which returns 0 for contracts in\n\t\t// construction, since the code is only stored at the end of the\n\t\t// constructor execution.\n\n\t\tuint256 size;\n\t\tassembly {\n\t\t\tsize := extcodesize(account)\n\t\t}\n\t\treturn size > 0;\n\t}\n}\n"
    },
    "contracts/bonding_curves/TradeableShares.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./BondingCurve.sol\";\nimport \"./HoldersRewardsDistributor.sol\";\n\n/**\n * @title Tradeable Shares\n *\n * @notice Tradeable shares is a non-transferable, but buyable/sellable fungible token-like asset,\n *      which is sold/bought solely by the shares contract at the predefined by\n *      the bonding curve function price\n *\n * @notice The shares is bound to its \"subject\" – an NFT; the NFT owner gets the subject fee\n *      emerging in every buy/sell operation\n *\n * @dev Based on the friend.tech FriendtechSharesV1.sol\n */\ninterface TradeableShares is BondingCurve {\n\t/**\n\t * @notice Shares subject is an NFT defined by its ERC721 contract address and NFT ID\n\t *       Note: this is different from the original FriendTech implementation where\n\t *       shares subject is always equal to the issuer address\n\t */\n\tstruct SharesSubject {\n\t\t/// @dev ERC721 contract address\n\t\taddress tokenAddress;\n\n\t\t/// @dev NFT ID\n\t\tuint256 tokenId;\n\t}\n\n\t/**\n\t * @dev Fired in `buyShares` and `sellShares` functions, this event logs\n\t *      the entire trading activity happening on the curve\n\t *\n\t * @dev Trader, that is the buyer or seller, depending on the operation type is the transaction sender\n\t *\n\t * @param beneficiary the address which receives shares or funds, usually this is the trader itself\n\t * @param issuer subject issuer, usually an owner of the NFT defined by the subject\n\t * @param isBuy true if the event comes from the `buyShares` and represents the buy operation,\n\t *      false if the event comes from the `sellShares` and represents the sell operation\n\t * @param sharesAmount amount of the shares bought or sold (see `isBuy`)\n\t * @param paidAmount amount of ETH spent or gained by the buyer or seller;\n\t *      this is implementation dependent and can represent an amount of ERC20 payment token\n\t * @param protocolFeeAmount amount of fees paid to the protocol\n\t * @param holdersFeeAmount amount of fees paid to the shares holders\n\t * @param subjectFeeAmount amount of fees paid to the subject (issuer)\n\t * @param supply total shares supply after the operation\n\t */\n\tevent Trade(\n\t\taddress indexed beneficiary,\n\t\taddress indexed issuer,\n\t\tbool indexed isBuy,\n\t\tuint256 sharesAmount,\n\t\tuint256 paidAmount,\n\t\tuint256 protocolFeeAmount,\n\t\tuint256 holdersFeeAmount,\n\t\tuint256 subjectFeeAmount,\n\t\tuint256 supply\n\t);\n\n\t/**\n\t * @notice Shares subject, usually defined as NFT (ERC721 contract address + NFT ID)\n\t *\n\t * @dev Immutable, client applications may cache this value\n\t *\n\t * @return Shares subject as a SharesSubject struct, this is an NFT if all currently known implementations\n\t */\n\tfunction getSharesSubject() external view returns(SharesSubject calldata);\n\n\t/**\n\t * @notice Protocol fee destination, the address protocol fee is sent to\n\t *\n\t * @dev Mutable, can be changed by the protocol fee manager\n\t *\n\t * @return the address where the protocol fee is sent to\n\t */\n\tfunction getProtocolFeeDestination() external view returns(address);\n\n\t/**\n\t * @notice Protocol fee percent, applied to all the buy and sell operations;\n\t *      the fee percent is defined with the 18 decimals, 10^18 corresponds to 100%\n\t *\n\t * @notice Protocol fee is sent to the protocol fee destination (see `getProtocolFeeDestination`)\n\t *\n\t * @dev Immutable, client applications may cache this value\n\t *\n\t * @return protocol fee percent with the 18 decimals (10^18 is 100%)\n\t */\n\tfunction getProtocolFeePercent() external view returns(uint256);\n\n\t/**\n\t * @notice Protocol fee destination and protocol fee percent as a tuple;\n\t *      the fee percent is defined with the 18 decimals, 10^18 corresponds to 100%\n\t *\n\t * @dev Implementation must always return zero fee percent if fee destination is zero address\n\t *\n\t * @return feeDestination protocol fee destination\n\t * @return feePercent protocol fee percent, zero if protocol fee destination is zero\n\t */\n\tfunction getProtocolFeeInfo() external view returns(address feeDestination, uint256 feePercent);\n\n\t/**\n\t * @notice Shares holders reward distributor contract attached to the shares contract\n\t *      in order to receive its portion of the fees to be distributed among the shares holders\n\t *\n\t * @dev Immutable, client applications may cache this value; holders fee destination is not\n\t *      an arbitrary address capable of receiving ETH or ERC20, but a HoldersRewardsDistributor\n\t *      smart contract, which not only receives the fees but also receives updated on the\n\t *      trading activity in the shares contract\n\t *\n\t * @return the contract where the holders fee is sent to\n\t */\n\tfunction getHoldersFeeDestination() external view returns(HoldersRewardsDistributor);\n\n\t/**\n\t * @notice Shares holders fee percent, applied to all the buy and sell operations;\n\t *      the fee percent is defined with the 18 decimals, 10^18 corresponds to 100%\n\t *\n\t * @notice Shares holders fee is sent to the holders fee destination (see `getHoldersFeeDestination`)\n\t *\n\t * @dev Immutable, client applications may cache this value\n\t *\n\t * @return shares holders fee percent with the 18 decimals (10^18 is 100%)\n\t */\n\tfunction getHoldersFeePercent() external view returns(uint256);\n\n\t/**\n\t * @notice Shares holders fee destination and shares holders fee percent as a tuple;\n\t *      the fee percent is defined with the 18 decimals, 10^18 corresponds to 100%\n\t *\n\t * @dev Implementation must always return zero fee percent if fee destination is zero\n\t *\n\t * @return feeDestination shares holders fee destination\n\t * @return feePercent shares holders fee percent, zero if holders fee destination is zero\n\t */\n\tfunction getHoldersFeeInfo() external view returns(HoldersRewardsDistributor feeDestination, uint256 feePercent);\n\n\t/**\n\t * @notice Subject fee destination and subject fee percent as a tuple;\n\t *      subject fee destination is shares issuer address;\n\t *      the fee percent is defined with the 18 decimals, 10^18 corresponds to 100%;\n\t *\n\t * @dev Implementation must always return zero fee percent if fee destination is zero address\n\t *\n\t * @return feeDestination protocol fee destination\n\t * @return feePercent protocol fee percent, zero if subject fee destination is zero\n\t */\n\tfunction getSubjectFeeInfo() external view returns(address feeDestination, uint256 feePercent);\n\n\t/**\n\t * @notice Subject fee percent, applied to all the buy and sell operations,\n\t *      the fee percent is defined with the 18 decimals, 10^18 corresponds to 100%\n\t *\n\t * @notice Subject fee is sent to the subject fee issuer (see `getSharesIssuer`)\n\t *\n\t * @dev Immutable, client applications may cache this value\n\t *\n\t * @return subject fee percent with the 18 decimals (10^18 is 100%)\n\t */\n\tfunction getSubjectFeePercent() external view returns(uint256);\n\n\t/**\n\t * @notice Shares issuer, the receiver of the shares fees\n\t *\n\t * @dev Mutable, changes (potentially frequently and unpredictably) when the NFT owner changes;\n\t *      subject to the front-run attacks, off-chain client applications must not rely on this address\n\t *      in anyway\n\t *\n\t * @return nftOwner subject issuer, the owner of the NFT\n\t */\n\tfunction getSharesIssuer() external view returns(address nftOwner);\n\n\t/**\n\t * @notice Shares balance of the given holder; this function is similar to ERC20.balanceOf()\n\t *\n\t * @param holder the address to check the balance for\n\t *\n\t * @return balance number of shares the holder has\n\t */\n\tfunction getSharesBalance(address holder) external view returns(uint256 balance);\n\n\t/**\n\t * @notice Total amount of the shares in existence, the sum of all individual shares balances;\n\t *      this function is similar to ERC20.totalSupply()\n\t *\n\t * @return supply total shares supply\n\t */\n\tfunction getSharesSupply() external view returns(uint256 supply);\n\n\t/**\n\t * @notice The price of the `amount` of shares to buy calculated based on\n\t *      the specified total shares supply\n\t *\n\t * @param supply total shares supply\n\t * @param amount number of shares to buy\n\t * @return the price of the shares to buy\n\t */\n\tfunction getBuyPrice(uint256 supply, uint256 amount) external pure returns(uint256);\n\n\t/**\n\t * @notice The price of the `amount` of shares to sell calculated based on\n\t *      the specified total shares supply\n\t *\n\t * @param supply total shares supply\n\t * @param amount number of shares to sell\n\t * @return the price of the shares to sell\n\t */\n\tfunction getSellPrice(uint256 supply, uint256 amount) external pure returns(uint256);\n\n\t/**\n\t * @notice The price of the `amount` of shares to buy, including all fees;\n\t *      calculated based on the specified total shares supply and fees percentages\n\t *\n\t * @param supply total shares supply\n\t * @param amount number of shares to buy\n\t * @param protocolFeePercent protocol fee percent\n\t * @param holdersFeePercent shares holders fee percent\n\t * @param subjectFeePercent protocol fee percent\n\t * @return the price of the shares to buy\n\t */\n\tfunction getBuyPriceAfterFee(\n\t\tuint256 supply,\n\t\tuint256 amount,\n\t\tuint256 protocolFeePercent,\n\t\tuint256 holdersFeePercent,\n\t\tuint256 subjectFeePercent\n\t) external pure returns(uint256);\n\n\t/**\n\t * @notice The price of the `amount` of shares to sell, including all fees;\n\t *      calculated based on the specified total shares supply and fees percentages\n\t *\n\t * @param supply total shares supply\n\t * @param amount number of shares to sell\n\t * @param protocolFeePercent protocol fee percent\n\t * @param holdersFeePercent shares holders fee percent\n\t * @param subjectFeePercent protocol fee percent\n\t * @return the price of the shares to sell\n\t */\n\tfunction getSellPriceAfterFee(\n\t\tuint256 supply,\n\t\tuint256 amount,\n\t\tuint256 protocolFeePercent,\n\t\tuint256 holdersFeePercent,\n\t\tuint256 subjectFeePercent\n\t) external pure returns(uint256);\n\n\t/**\n\t * @notice Current price of the `amount` of shares to buy; calculated based on\n\t *      the current total shares supply\n\t *\n\t * @param amount number of shares to buy\n\t * @return the price of the shares to buy\n\t */\n\tfunction getBuyPrice(uint256 amount) external view returns(uint256);\n\n\t/**\n\t * @notice Current price of the `amount` of shares to sell; calculated based on\n\t *      the current total shares supply\n\t *\n\t * @param amount number of shares to sell\n\t * @return the price of the shares to sell\n\t */\n\tfunction getSellPrice(uint256 amount) external view returns(uint256);\n\n\t/**\n\t * @notice Current price of the `amount` of shares to buy, including all fees;\n\t *      calculated based on the current total shares supply and fees percentages\n\t *\n\t * @param amount number of shares to buy\n\t * @return the price of the shares to buy\n\t */\n\tfunction getBuyPriceAfterFee(uint256 amount) external view returns(uint256);\n\n\t/**\n\t * @notice Current price of the `amount` of shares to sell, including all fees;\n\t *      calculated based on the current total shares supply and fees percentages\n\t *\n\t * @param amount number of shares to sell\n\t * @return the price of the shares to sell\n\t */\n\tfunction getSellPriceAfterFee(uint256 amount) external view returns(uint256);\n\n\t/**\n\t * @notice Buy `amount` of shares. Sender has to supply `getBuyPriceAfterFee(amount)` ETH.\n\t *      First share can be bought only by current subject issuer.\n\t *\n\t * @dev Depending on the implementation, ERC20 token payment may be required instead of ETH.\n\t *      In such a case, implementation must through if ETH is sent, effectively overriding\n\t *      the function definition as non-payable\n\t *\n\t * @param amount amount of the shares to buy\n\t */\n\tfunction buyShares(uint256 amount) external payable;\n\n\t/**\n\t * @notice Buy `amount` of shares in the favor of the address specified (beneficiary).\n\t *      Sender has to supply `getBuyPriceAfterFee(amount)` ETH.\n\t *      First share can be bought only by current subject issuer.\n\t *\n\t * @dev Depending on the implementation, ERC20 token payment may be required instead of ETH.\n\t *      In such a case, implementation must through if ETH is sent, effectively overriding\n\t *      the function definition as non-payable\n\t *\n\t * @param amount amount of the shares to buy\n\t * @param beneficiary an address receiving the shares\n\t */\n\tfunction buySharesTo(uint256 amount, address beneficiary) external payable;\n\n\t/**\n\t * @notice Sell `amount` of shares. Sender gets `getSellPriceAfterFee(amount)` of ETH.\n\t *      Last share cannot be sold.\n\t *\n\t * @dev Depending on the implementation, ERC20 token may be payed instead of ETH.\n\t *\n\t * @param amount amount of the shares to sell\n\t */\n\tfunction sellShares(uint256 amount) external;\n\n\t/**\n\t * @notice Sell `amount` of shares in the favor of the address specified (beneficiary).\n\t *      The beneficiary gets `getSellPriceAfterFee(amount)` of ETH.\n\t *      Last share cannot be sold.\n\t *\n\t * @dev Depending on the implementation, ERC20 token may be payed instead of ETH.\n\t *\n\t * @param amount amount of the shares to sell\n\t * @param beneficiary an address receiving the funds from the sale\n\t */\n\tfunction sellSharesTo(uint256 amount, address payable beneficiary) external;\n\n\t/**\n\t * @notice Cumulative value of all trades; allows to derive cumulative fees paid\n\t *\n\t * @dev This value cannot decrease over time; it can increase or remain constant\n\t *      if no trades are happening\n\t *\n\t * @return Sum of the modulo of all trading operations\n\t */\n\tfunction getTradeVolume() external view returns(uint256);\n}\n"
    },
    "contracts/bonding_curves/TypedStructLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./SharesFactory.sol\";\n\n/**\n * @title EIP712 Typed Struct Library\n *\n * @notice Calculates EIP712 typed structured data typeHash and hashStruct\n */\nlibrary TypedStructLib {\n\t/**\n\t * @notice SharesDeploymentRequest typeHash\n\t */\n\tfunction hashType(SharesFactory.SharesDeploymentRequest calldata) internal pure returns(bytes32) {\n\t\t// hashType(SharesDeploymentRequest) = keccak256(\"SharesDeploymentRequest(ImplementationType implementationType,TradeableShares.SharesSubject sharesSubject,address issuer,uint256 amount,uint256 validFromTimestamp,uint256 expiresAtTimestamp,uint256 nonce)\")\n\t\treturn 0x7acc9d8c19a06f50ae6d92c5e1206302e8aeac9f7f8bf014389ca2a4354650fd;\n\t}\n\n\t/**\n\t * @notice SharesSubject typeHash\n\t */\n\tfunction hashType(TradeableShares.SharesSubject calldata) internal pure returns(bytes32) {\n\t\t// hashType(SharesSubject) = keccak256(\"SharesSubject(address tokenAddress,uint256 tokenId)\")\n\t\treturn 0x685dd8e2693cf377e50b3e95f06b61dff4c1705fa19df1071074d64f4e1469eb;\n\t}\n\n\t/**\n\t * @notice SharesDeploymentRequest hashStruct\n\t */\n\tfunction hashStruct(SharesFactory.SharesDeploymentRequest calldata request) internal pure returns(bytes32) {\n\t\treturn keccak256(abi.encode(\n\t\t\thashType(request),\n\t\t\trequest.implementationType,\n\t\t\thashStruct(request.sharesSubject),\n\t\t\trequest.issuer,\n\t\t\trequest.amount,\n\t\t\trequest.validFromTimestamp,\n\t\t\trequest.expiresAtTimestamp,\n\t\t\trequest.nonce\n\t\t));\n\t}\n\n\t/**\n\t * @notice SharesSubject hashStruct\n\t */\n\tfunction hashStruct(TradeableShares.SharesSubject calldata sharesSubject) internal pure returns(bytes32) {\n\t\treturn keccak256(abi.encode(\n\t\t\thashType(sharesSubject),\n\t\t\tsharesSubject.tokenAddress,\n\t\t\tsharesSubject.tokenId\n\t\t));\n\t}\n\n}\n"
    },
    "contracts/interfaces/ERC1363Spec.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./ERC20Spec.sol\";\nimport \"./ERC165Spec.sol\";\n\n/**\n * @title ERC1363 Interface\n *\n * @dev Interface defining a ERC1363 Payable Token contract.\n *      Implementing contracts MUST implement the ERC1363 interface as well as the ERC20 and ERC165 interfaces.\n */\ninterface ERC1363 is ERC20, ERC165  {\n\t/*\n\t * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n\t * 0xb0202a11 ===\n\t *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n\t *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n\t *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n\t *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n\t *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n\t *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n\t */\n\n\t/**\n\t * @notice Transfer tokens from `msg.sender` to another address and then call `onTransferReceived` on receiver\n\t * @param to address The address which you want to transfer to\n\t * @param value uint256 The amount of tokens to be transferred\n\t * @return true unless throwing\n\t */\n\tfunction transferAndCall(address to, uint256 value) external returns (bool);\n\n\t/**\n\t * @notice Transfer tokens from `msg.sender` to another address and then call `onTransferReceived` on receiver\n\t * @param to address The address which you want to transfer to\n\t * @param value uint256 The amount of tokens to be transferred\n\t * @param data bytes Additional data with no specified format, sent in call to `to`\n\t * @return true unless throwing\n\t */\n\tfunction transferAndCall(address to, uint256 value, bytes memory data) external returns (bool);\n\n\t/**\n\t * @notice Transfer tokens from one address to another and then call `onTransferReceived` on receiver\n\t * @param from address The address which you want to send tokens from\n\t * @param to address The address which you want to transfer to\n\t * @param value uint256 The amount of tokens to be transferred\n\t * @return true unless throwing\n\t */\n\tfunction transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n\n\t/**\n\t * @notice Transfer tokens from one address to another and then call `onTransferReceived` on receiver\n\t * @param from address The address which you want to send tokens from\n\t * @param to address The address which you want to transfer to\n\t * @param value uint256 The amount of tokens to be transferred\n\t * @param data bytes Additional data with no specified format, sent in call to `to`\n\t * @return true unless throwing\n\t */\n\tfunction transferFromAndCall(address from, address to, uint256 value, bytes memory data) external returns (bool);\n\n\t/**\n\t * @notice Approve the passed address to spend the specified amount of tokens on behalf of msg.sender\n\t * and then call `onApprovalReceived` on spender.\n\t * @param spender address The address which will spend the funds\n\t * @param value uint256 The amount of tokens to be spent\n\t */\n\tfunction approveAndCall(address spender, uint256 value) external returns (bool);\n\n\t/**\n\t * @notice Approve the passed address to spend the specified amount of tokens on behalf of msg.sender\n\t * and then call `onApprovalReceived` on spender.\n\t * @param spender address The address which will spend the funds\n\t * @param value uint256 The amount of tokens to be spent\n\t * @param data bytes Additional data with no specified format, sent in call to `spender`\n\t */\n\tfunction approveAndCall(address spender, uint256 value, bytes memory data) external returns (bool);\n}\n\n/**\n * @title ERC1363Receiver Interface\n *\n * @dev Interface for any contract that wants to support `transferAndCall` or `transferFromAndCall`\n *      from ERC1363 token contracts.\n */\ninterface ERC1363Receiver {\n\t/*\n\t * Note: the ERC-165 identifier for this interface is 0x88a7ca5c.\n\t * 0x88a7ca5c === bytes4(keccak256(\"onTransferReceived(address,address,uint256,bytes)\"))\n\t */\n\n\t/**\n\t * @notice Handle the receipt of ERC1363 tokens\n\t *\n\t * @dev Any ERC1363 smart contract calls this function on the recipient\n\t *      after a `transfer` or a `transferFrom`. This function MAY throw to revert and reject the\n\t *      transfer. Return of other than the magic value MUST result in the\n\t *      transaction being reverted.\n\t *      Note: the token contract address is always the message sender.\n\t *\n\t * @param operator address The address which called `transferAndCall` or `transferFromAndCall` function\n\t * @param from address The address which are token transferred from\n\t * @param value uint256 The amount of tokens transferred\n\t * @param data bytes Additional data with no specified format\n\t * @return `bytes4(keccak256(\"onTransferReceived(address,address,uint256,bytes)\"))`\n\t *      unless throwing\n\t */\n\tfunction onTransferReceived(address operator, address from, uint256 value, bytes memory data) external returns (bytes4);\n}\n\n/**\n * @title ERC1363Spender Interface\n *\n * @dev Interface for any contract that wants to support `approveAndCall`\n *      from ERC1363 token contracts.\n */\ninterface ERC1363Spender {\n\t/*\n\t * Note: the ERC-165 identifier for this interface is 0x7b04a2d0.\n\t * 0x7b04a2d0 === bytes4(keccak256(\"onApprovalReceived(address,uint256,bytes)\"))\n\t */\n\n\t/**\n\t * @notice Handle the approval of ERC1363 tokens\n\t *\n\t * @dev Any ERC1363 smart contract calls this function on the recipient\n\t *      after an `approve`. This function MAY throw to revert and reject the\n\t *      approval. Return of other than the magic value MUST result in the\n\t *      transaction being reverted.\n\t *      Note: the token contract address is always the message sender.\n\t *\n\t * @param owner address The address which called `approveAndCall` function\n\t * @param value uint256 The amount of tokens to be spent\n\t * @param data bytes Additional data with no specified format\n\t * @return `bytes4(keccak256(\"onApprovalReceived(address,uint256,bytes)\"))`\n\t *      unless throwing\n\t */\n\tfunction onApprovalReceived(address owner, uint256 value, bytes memory data) external returns (bytes4);\n}\n"
    },
    "contracts/interfaces/ERC165Spec.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title ERC-165 Standard Interface Detection\n *\n * @dev Interface of the ERC165 standard, as defined in the\n *       https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * @dev Implementers can declare support of contract interfaces,\n *      which can then be queried by others.\n *\n * @author Christian Reitwießner, Nick Johnson, Fabian Vogelsteller, Jordi Baylina, Konrad Feldmeier, William Entriken\n */\ninterface ERC165 {\n\t/**\n\t * @notice Query if a contract implements an interface\n\t *\n\t * @dev Interface identification is specified in ERC-165.\n\t *      This function uses less than 30,000 gas.\n\t *\n\t * @param interfaceID The interface identifier, as specified in ERC-165\n\t * @return `true` if the contract implements `interfaceID` and\n\t *      `interfaceID` is not 0xffffffff, `false` otherwise\n\t */\n\tfunction supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/ERC20Spec.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title EIP-20: ERC-20 Token Standard\n *\n * @notice The ERC-20 (Ethereum Request for Comments 20), proposed by Fabian Vogelsteller in November 2015,\n *      is a Token Standard that implements an API for tokens within Smart Contracts.\n *\n * @notice It provides functionalities like to transfer tokens from one account to another,\n *      to get the current token balance of an account and also the total supply of the token available on the network.\n *      Besides these it also has some other functionalities like to approve that an amount of\n *      token from an account can be spent by a third party account.\n *\n * @notice If a Smart Contract implements the following methods and events it can be called an ERC-20 Token\n *      Contract and, once deployed, it will be responsible to keep track of the created tokens on Ethereum.\n *\n * @notice See https://ethereum.org/en/developers/docs/standards/tokens/erc-20/\n * @notice See https://eips.ethereum.org/EIPS/eip-20\n */\ninterface ERC20 {\n\t/**\n\t * @dev Fired in transfer(), transferFrom() to indicate that token transfer happened\n\t *\n\t * @param from an address tokens were consumed from\n\t * @param to an address tokens were sent to\n\t * @param value number of tokens transferred\n\t */\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n\n\t/**\n\t * @dev Fired in approve() to indicate an approval event happened\n\t *\n\t * @param owner an address which granted a permission to transfer\n\t *      tokens on its behalf\n\t * @param spender an address which received a permission to transfer\n\t *      tokens on behalf of the owner `_owner`\n\t * @param value amount of tokens granted to transfer on behalf\n\t */\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\n\n\t/**\n\t * @return name of the token (ex.: USD Coin)\n\t */\n\t// OPTIONAL - This method can be used to improve usability,\n\t// but interfaces and other contracts MUST NOT expect these values to be present.\n\t// function name() external view returns (string memory);\n\n\t/**\n\t * @return symbol of the token (ex.: USDC)\n\t */\n\t// OPTIONAL - This method can be used to improve usability,\n\t// but interfaces and other contracts MUST NOT expect these values to be present.\n\t// function symbol() external view returns (string memory);\n\n\t/**\n\t * @dev Returns the number of decimals used to get its user representation.\n\t *      For example, if `decimals` equals `2`, a balance of `505` tokens should\n\t *      be displayed to a user as `5,05` (`505 / 10 ** 2`).\n\t *\n\t * @dev Tokens usually opt for a value of 18, imitating the relationship between\n\t *      Ether and Wei. This is the value {ERC20} uses, unless this function is\n\t *      overridden;\n\t *\n\t * @dev NOTE: This information is only used for _display_ purposes: it in\n\t *      no way affects any of the arithmetic of the contract, including\n\t *      {IERC20-balanceOf} and {IERC20-transfer}.\n\t *\n\t * @return token decimals\n\t */\n\t// OPTIONAL - This method can be used to improve usability,\n\t// but interfaces and other contracts MUST NOT expect these values to be present.\n\t// function decimals() external view returns (uint8);\n\n\t/**\n\t * @return the amount of tokens in existence\n\t */\n\tfunction totalSupply() external view returns (uint256);\n\n\t/**\n\t * @notice Gets the balance of a particular address\n\t *\n\t * @param _owner the address to query the the balance for\n\t * @return balance an amount of tokens owned by the address specified\n\t */\n\tfunction balanceOf(address _owner) external view returns (uint256 balance);\n\n\t/**\n\t * @notice Transfers some tokens to an external address or a smart contract\n\t *\n\t * @dev Called by token owner (an address which has a\n\t *      positive token balance tracked by this smart contract)\n\t * @dev Throws on any error like\n\t *      * insufficient token balance or\n\t *      * incorrect `_to` address:\n\t *          * zero address or\n\t *          * self address or\n\t *          * smart contract which doesn't support ERC20\n\t *\n\t * @param _to an address to transfer tokens to,\n\t *      must be either an external address or a smart contract,\n\t *      compliant with the ERC20 standard\n\t * @param _value amount of tokens to be transferred,, zero\n\t *      value is allowed\n\t * @return success true on success, throws otherwise\n\t */\n\tfunction transfer(address _to, uint256 _value) external returns (bool success);\n\n\t/**\n\t * @notice Transfers some tokens on behalf of address `_from' (token owner)\n\t *      to some other address `_to`\n\t *\n\t * @dev Called by token owner on his own or approved address,\n\t *      an address approved earlier by token owner to\n\t *      transfer some amount of tokens on its behalf\n\t * @dev Throws on any error like\n\t *      * insufficient token balance or\n\t *      * incorrect `_to` address:\n\t *          * zero address or\n\t *          * same as `_from` address (self transfer)\n\t *          * smart contract which doesn't support ERC20\n\t *\n\t * @param _from token owner which approved caller (transaction sender)\n\t *      to transfer `_value` of tokens on its behalf\n\t * @param _to an address to transfer tokens to,\n\t *      must be either an external address or a smart contract,\n\t *      compliant with the ERC20 standard\n\t * @param _value amount of tokens to be transferred,, zero\n\t *      value is allowed\n\t * @return success true on success, throws otherwise\n\t */\n\tfunction transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n\n\t/**\n\t * @notice Approves address called `_spender` to transfer some amount\n\t *      of tokens on behalf of the owner (transaction sender)\n\t *\n\t * @dev Transaction sender must not necessarily own any tokens to grant the permission\n\t *\n\t * @param _spender an address approved by the caller (token owner)\n\t *      to spend some tokens on its behalf\n\t * @param _value an amount of tokens spender `_spender` is allowed to\n\t *      transfer on behalf of the token owner\n\t * @return success true on success, throws otherwise\n\t */\n\tfunction approve(address _spender, uint256 _value) external returns (bool success);\n\n\t/**\n\t * @notice Returns the amount which _spender is still allowed to withdraw from _owner.\n\t *\n\t * @dev A function to check an amount of tokens owner approved\n\t *      to transfer on its behalf by some other address called \"spender\"\n\t *\n\t * @param _owner an address which approves transferring some tokens on its behalf\n\t * @param _spender an address approved to transfer some tokens on behalf\n\t * @return remaining an amount of tokens approved address `_spender` can transfer on behalf\n\t *      of token owner `_owner`\n\t */\n\tfunction allowance(address _owner, address _spender) external view returns (uint256 remaining);\n}\n\n/**\n * @title Mintable/burnable ERC20 Extension\n *\n * @notice Adds mint/burn functions to ERC20 interface, these functions\n *      are usually present in ERC20 implementations, but these become\n *      a must for the bridged tokens in L2 since the bridge on L2\n *      needs to have a way to mint tokens deposited from L1 to L2\n *      and to burn tokens to be withdrawn from L2 to L1\n */\ninterface MintableBurnableERC20 is ERC20 {\n\t/**\n\t * @dev Mints (creates) some tokens to address specified\n\t * @dev The value specified is treated as is without taking\n\t *      into account what `decimals` value is\n\t *\n\t * @param _to an address to mint tokens to\n\t * @param _value an amount of tokens to mint (create)\n\t */\n\tfunction mint(address _to, uint256 _value) external;\n\n\t/**\n\t * @dev Burns (destroys) some tokens from the address specified\n\t *\n\t * @dev The value specified is treated as is without taking\n\t *      into account what `decimals` value is\n\t *\n\t * @param _from an address to burn some tokens from\n\t * @param _value an amount of tokens to burn (destroy)\n\t */\n\tfunction burn(address _from, uint256 _value) external;\n}\n"
    },
    "contracts/interfaces/ERC721Spec.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./ERC165Spec.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard\n *\n * @notice See https://eips.ethereum.org/EIPS/eip-721\n *\n * @dev Solidity issue #3412: The ERC721 interfaces include explicit mutability guarantees for each function.\n *      Mutability guarantees are, in order weak to strong: payable, implicit nonpayable, view, and pure.\n *      Implementation MUST meet the mutability guarantee in this interface and MAY meet a stronger guarantee.\n *      For example, a payable function in this interface may be implemented as nonpayable\n *      (no state mutability specified) in implementing contract.\n *      It is expected a later Solidity release will allow stricter contract to inherit from this interface,\n *      but current workaround is that we edit this interface to add stricter mutability before inheriting:\n *      we have removed all \"payable\" modifiers.\n *\n * @dev The ERC-165 identifier for this interface is 0x80ac58cd.\n *\n * @author William Entriken, Dieter Shirley, Jacob Evans, Nastassia Sachs\n */\ninterface ERC721 is ERC165 {\n\t/// @dev This emits when ownership of any NFT changes by any mechanism.\n\t///  This event emits when NFTs are created (`from` == 0) and destroyed\n\t///  (`to` == 0). Exception: during contract creation, any number of NFTs\n\t///  may be created and assigned without emitting Transfer. At the time of\n\t///  any transfer, the approved address for that NFT (if any) is reset to none.\n\tevent Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\n\n\t/// @dev This emits when the approved address for an NFT is changed or\n\t///  reaffirmed. The zero address indicates there is no approved address.\n\t///  When a Transfer event emits, this also indicates that the approved\n\t///  address for that NFT (if any) is reset to none.\n\tevent Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\n\n\t/// @dev This emits when an operator is enabled or disabled for an owner.\n\t///  The operator can manage all NFTs of the owner.\n\tevent ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n\n\t/// @notice Count all NFTs assigned to an owner\n\t/// @dev NFTs assigned to the zero address are considered invalid, and this\n\t///  function throws for queries about the zero address.\n\t/// @param _owner An address for whom to query the balance\n\t/// @return The number of NFTs owned by `_owner`, possibly zero\n\tfunction balanceOf(address _owner) external view returns (uint256);\n\n\t/// @notice Find the owner of an NFT\n\t/// @dev NFTs assigned to zero address are considered invalid, and queries\n\t///  about them do throw.\n\t/// @param _tokenId The identifier for an NFT\n\t/// @return The address of the owner of the NFT\n\tfunction ownerOf(uint256 _tokenId) external view returns (address);\n\n\t/// @notice Transfers the ownership of an NFT from one address to another address\n\t/// @dev Throws unless `msg.sender` is the current owner, an authorized\n\t///  operator, or the approved address for this NFT. Throws if `_from` is\n\t///  not the current owner. Throws if `_to` is the zero address. Throws if\n\t///  `_tokenId` is not a valid NFT. When transfer is complete, this function\n\t///  checks if `_to` is a smart contract (code size > 0). If so, it calls\n\t///  `onERC721Received` on `_to` and throws if the return value is not\n\t///  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n\t/// @param _from The current owner of the NFT\n\t/// @param _to The new owner\n\t/// @param _tokenId The NFT to transfer\n\t/// @param _data Additional data with no specified format, sent in call to `_to`\n\tfunction safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external /*payable*/;\n\n\t/// @notice Transfers the ownership of an NFT from one address to another address\n\t/// @dev This works identically to the other function with an extra data parameter,\n\t///  except this function just sets data to \"\".\n\t/// @param _from The current owner of the NFT\n\t/// @param _to The new owner\n\t/// @param _tokenId The NFT to transfer\n\tfunction safeTransferFrom(address _from, address _to, uint256 _tokenId) external /*payable*/;\n\n\t/// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\n\t///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\n\t///  THEY MAY BE PERMANENTLY LOST\n\t/// @dev Throws unless `msg.sender` is the current owner, an authorized\n\t///  operator, or the approved address for this NFT. Throws if `_from` is\n\t///  not the current owner. Throws if `_to` is the zero address. Throws if\n\t///  `_tokenId` is not a valid NFT.\n\t/// @param _from The current owner of the NFT\n\t/// @param _to The new owner\n\t/// @param _tokenId The NFT to transfer\n\tfunction transferFrom(address _from, address _to, uint256 _tokenId) external /*payable*/;\n\n\t/// @notice Change or reaffirm the approved address for an NFT\n\t/// @dev The zero address indicates there is no approved address.\n\t///  Throws unless `msg.sender` is the current NFT owner, or an authorized\n\t///  operator of the current owner.\n\t/// @param _approved The new approved NFT controller\n\t/// @param _tokenId The NFT to approve\n\tfunction approve(address _approved, uint256 _tokenId) external /*payable*/;\n\n\t/// @notice Enable or disable approval for a third party (\"operator\") to manage\n\t///  all of `msg.sender`'s assets\n\t/// @dev Emits the ApprovalForAll event. The contract MUST allow\n\t///  multiple operators per owner.\n\t/// @param _operator Address to add to the set of authorized operators\n\t/// @param _approved True if the operator is approved, false to revoke approval\n\tfunction setApprovalForAll(address _operator, bool _approved) external;\n\n\t/// @notice Get the approved address for a single NFT\n\t/// @dev Throws if `_tokenId` is not a valid NFT.\n\t/// @param _tokenId The NFT to find the approved address for\n\t/// @return The approved address for this NFT, or the zero address if there is none\n\tfunction getApproved(uint256 _tokenId) external view returns (address);\n\n\t/// @notice Query if an address is an authorized operator for another address\n\t/// @param _owner The address that owns the NFTs\n\t/// @param _operator The address that acts on behalf of the owner\n\t/// @return True if `_operator` is an approved operator for `_owner`, false otherwise\n\tfunction isApprovedForAll(address _owner, address _operator) external view returns (bool);\n}\n\n/// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.\ninterface ERC721TokenReceiver {\n\t/// @notice Handle the receipt of an NFT\n\t/// @dev The ERC721 smart contract calls this function on the recipient\n\t///  after a `transfer`. This function MAY throw to revert and reject the\n\t///  transfer. Return of other than the magic value MUST result in the\n\t///  transaction being reverted.\n\t///  Note: the contract address is always the message sender.\n\t/// @param _operator The address which called `safeTransferFrom` function\n\t/// @param _from The address which previously owned the token\n\t/// @param _tokenId The NFT identifier which is being transferred\n\t/// @param _data Additional data with no specified format\n\t/// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n\t///  unless throwing\n\tfunction onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4);\n}\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n *\n * @notice See https://eips.ethereum.org/EIPS/eip-721\n *\n * @dev The ERC-165 identifier for this interface is 0x5b5e139f.\n *\n * @author William Entriken, Dieter Shirley, Jacob Evans, Nastassia Sachs\n */\ninterface ERC721Metadata is ERC721 {\n\t/// @notice A descriptive name for a collection of NFTs in this contract\n\tfunction name() external view returns (string memory _name);\n\n\t/// @notice An abbreviated name for NFTs in this contract\n\tfunction symbol() external view returns (string memory _symbol);\n\n\t/// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\n\t/// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\n\t///  3986. The URI may point to a JSON file that conforms to the \"ERC721\n\t///  Metadata JSON Schema\".\n\tfunction tokenURI(uint256 _tokenId) external view returns (string memory);\n}\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n *\n * @notice See https://eips.ethereum.org/EIPS/eip-721\n *\n * @dev The ERC-165 identifier for this interface is 0x780e9d63.\n *\n * @author William Entriken, Dieter Shirley, Jacob Evans, Nastassia Sachs\n */\ninterface ERC721Enumerable is ERC721 {\n\t/// @notice Count NFTs tracked by this contract\n\t/// @return A count of valid NFTs tracked by this contract, where each one of\n\t///  them has an assigned and queryable owner not equal to the zero address\n\tfunction totalSupply() external view returns (uint256);\n\n\t/// @notice Enumerate valid NFTs\n\t/// @dev Throws if `_index` >= `totalSupply()`.\n\t/// @param _index A counter less than `totalSupply()`\n\t/// @return The token identifier for the `_index`th NFT,\n\t///  (sort order not specified)\n\tfunction tokenByIndex(uint256 _index) external view returns (uint256);\n\n\t/// @notice Enumerate NFTs assigned to an owner\n\t/// @dev Throws if `_index` >= `balanceOf(_owner)` or if\n\t///  `_owner` is the zero address, representing invalid NFTs.\n\t/// @param _owner An address where we are interested in NFTs owned by them\n\t/// @param _index A counter less than `balanceOf(_owner)`\n\t/// @return The token identifier for the `_index`th NFT assigned to `_owner`,\n\t///   (sort order not specified)\n\tfunction tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/ERC721SpecExt.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title Mintable ERC721\n *\n * @notice Defines mint capabilities for Alethea ERC721 tokens.\n *      This interface should be treated as a definition of what mintable means for ERC721\n *\n * @author Basil Gorin\n */\ninterface MintableERC721 {\n\t/**\n\t * @notice Checks if specified token exists\n\t *\n\t * @dev Returns whether the specified token ID has an ownership\n\t *      information associated with it\n\t *\n\t * @param _tokenId ID of the token to query existence for\n\t * @return whether the token exists (true - exists, false - doesn't exist)\n\t */\n\tfunction exists(uint256 _tokenId) external view returns(bool);\n\n\t/**\n\t * @dev Creates new token with token ID specified\n\t *      and assigns an ownership `_to` for this token\n\t *\n\t * @dev Unsafe: doesn't execute `onERC721Received` on the receiver.\n\t *      Prefer the use of `safeMint` instead of `mint`.\n\t *\n\t * @dev Should have a restricted access handled by the implementation\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId ID of the token to mint\n\t */\n\tfunction mint(address _to, uint256 _tokenId) external;\n\n\t/**\n\t * @dev Creates new tokens starting with token ID specified\n\t *      and assigns an ownership `_to` for these tokens\n\t *\n\t * @dev Token IDs to be minted: [_tokenId, _tokenId + n)\n\t *\n\t * @dev n must be greater or equal 2: `n > 1`\n\t *\n\t * @dev Unsafe: doesn't execute `onERC721Received` on the receiver.\n\t *      Prefer the use of `safeMintBatch` instead of `mintBatch`.\n\t *\n\t * @dev Should have a restricted access handled by the implementation\n\t *\n\t * @param _to an address to mint tokens to\n\t * @param _tokenId ID of the first token to mint\n\t * @param n how many tokens to mint, sequentially increasing the _tokenId\n\t */\n\tfunction mintBatch(address _to, uint256 _tokenId, uint256 n) external;\n\n\t/**\n\t * @dev Creates new token with token ID specified\n\t *      and assigns an ownership `_to` for this token\n\t *\n\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\n\t *      `onERC721Received` on `_to` and throws if the return value is not\n\t *      `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n\t *\n\t * @dev Should have a restricted access handled by the implementation\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId ID of the token to mint\n\t */\n\tfunction safeMint(address _to, uint256 _tokenId) external;\n\n\t/**\n\t * @dev Creates new token with token ID specified\n\t *      and assigns an ownership `_to` for this token\n\t *\n\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\n\t *      `onERC721Received` on `_to` and throws if the return value is not\n\t *      `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n\t *\n\t * @dev Should have a restricted access handled by the implementation\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId ID of the token to mint\n\t * @param _data additional data with no specified format, sent in call to `_to`\n\t */\n\tfunction safeMint(address _to, uint256 _tokenId, bytes memory _data) external;\n\n\t/**\n\t * @dev Creates new tokens starting with token ID specified\n\t *      and assigns an ownership `_to` for these tokens\n\t *\n\t * @dev Token IDs to be minted: [_tokenId, _tokenId + n)\n\t *\n\t * @dev n must be greater or equal 2: `n > 1`\n\t *\n\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\n\t *      `onERC721Received` on `_to` and throws if the return value is not\n\t *      `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n\t *\n\t * @dev Should have a restricted access handled by the implementation\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId ID of the token to mint\n\t * @param n how many tokens to mint, sequentially increasing the _tokenId\n\t */\n\tfunction safeMintBatch(address _to, uint256 _tokenId, uint256 n) external;\n\n\t/**\n\t * @dev Creates new tokens starting with token ID specified\n\t *      and assigns an ownership `_to` for these tokens\n\t *\n\t * @dev Token IDs to be minted: [_tokenId, _tokenId + n)\n\t *\n\t * @dev n must be greater or equal 2: `n > 1`\n\t *\n\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\n\t *      `onERC721Received` on `_to` and throws if the return value is not\n\t *      `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n\t *\n\t * @dev Should have a restricted access handled by the implementation\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId ID of the token to mint\n\t * @param n how many tokens to mint, sequentially increasing the _tokenId\n\t * @param _data additional data with no specified format, sent in call to `_to`\n\t */\n\tfunction safeMintBatch(address _to, uint256 _tokenId, uint256 n, bytes memory _data) external;\n}\n\n/**\n * @title Alethea Burnable ERC721\n *\n * @notice Defines burn capabilities for Alethea ERC721 tokens.\n *      This interface should be treated as a definition of what burnable means for ERC721\n *\n * @author Basil Gorin\n */\ninterface BurnableERC721 {\n\t/**\n\t * @notice Destroys the token with token ID specified\n\t *\n\t * @dev Should be accessible publicly by token owners.\n\t *      May have a restricted access handled by the implementation\n\t *\n\t * @param _tokenId ID of the token to burn\n\t */\n\tfunction burn(uint256 _tokenId) external;\n}\n\n/**\n * @title With Base URI\n *\n * @notice A marker interface for the contracts having the baseURI() function\n *      or public string variable named baseURI\n *      NFT implementations like TinyERC721, or ShortERC721 are example of such smart contracts\n *\n * @author Basil Gorin\n */\ninterface WithBaseURI {\n\t/**\n\t * @dev Usually used in NFT implementations to construct ERC721Metadata.tokenURI as\n\t *      `base URI + token ID` if token URI is not set (not present in `_tokenURIs` mapping)\n\t *\n\t * @dev For example, if base URI is https://api.com/token/, then token #1\n\t *      will have an URI https://api.com/token/1\n\t */\n\tfunction baseURI() external view returns(string memory);\n}\n"
    },
    "contracts/mocks/MaliciousFeeDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../bonding_curves/ProtocolFeeDistributorV1.sol\";\n\n/**\n * @title Malicious Fee Distributor\n *\n * @notice Tries to consume all the gas when payment is sent\n */\ncontract MaliciousFeeDistributor is ProtocolFeeDistributorV1 {\n\t// Function to receive Ether. msg.data must be empty\n\treceive() external payable override {\n\t\t// try to consume all the gas and fail the entire transaction\n\t\tuint256 i = 0;\n\t\twhile(true) {\n\t\t\ti++;\n\t\t}\n\t}\n}\n"
    },
    "contracts/utils/InitializableAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.2;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\n/**\n * @title Initializable Role-based Access Control (RBAC) // ERC1967Proxy\n *\n * @notice Access control smart contract provides an API to check\n *      if a specific operation is permitted globally and/or\n *      if a particular user has a permission to execute it.\n *\n * @notice This contract is inherited by other contracts requiring the role-based access control (RBAC)\n *      protection for the restricted access functions\n *\n * @notice It deals with two main entities: features and roles.\n *\n * @notice Features are designed to be used to enable/disable public functions\n *      of the smart contract (used by a wide audience).\n * @notice User roles are designed to control the access to restricted functions\n *      of the smart contract (used by a limited set of maintainers).\n *\n * @notice Terms \"role\", \"permissions\" and \"set of permissions\" have equal meaning\n *      in the documentation text and may be used interchangeably.\n * @notice Terms \"permission\", \"single permission\" implies only one permission bit set.\n *\n * @notice Access manager is a special role which allows to grant/revoke other roles.\n *      Access managers can only grant/revoke permissions which they have themselves.\n *      As an example, access manager with no other roles set can only grant/revoke its own\n *      access manager permission and nothing else.\n *\n * @notice Access manager permission should be treated carefully, as a super admin permission:\n *      Access manager with even no other permission can interfere with another account by\n *      granting own access manager permission to it and effectively creating more powerful\n *      permission set than its own.\n *\n * @dev Both current and OpenZeppelin AccessControl implementations feature a similar API\n *      to check/know \"who is allowed to do this thing\".\n * @dev Zeppelin implementation is more flexible:\n *      - it allows setting unlimited number of roles, while current is limited to 256 different roles\n *      - it allows setting an admin for each role, while current allows having only one global admin\n * @dev Current implementation is more lightweight:\n *      - it uses only 1 bit per role, while Zeppelin uses 256 bits\n *      - it allows setting up to 256 roles at once, in a single transaction, while Zeppelin allows\n *        setting only one role in a single transaction\n *\n * @dev This smart contract is designed to be inherited by other\n *      smart contracts which require access control management capabilities.\n *\n * @dev Access manager permission has a bit 255 set.\n *      This bit must not be used by inheriting contracts for any other permissions/features.\n *\n * @dev This is an initializable version of the RBAC, based on Zeppelin implementation,\n *      it can be used for ERC1967 proxies, as well as for EIP-1167 minimal proxies\n *      see https://docs.openzeppelin.com/contracts/4.x/upgradeable\n *      see https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable\n *      see https://forum.openzeppelin.com/t/uups-proxies-tutorial-solidity-javascript/7786\n *      see https://eips.ethereum.org/EIPS/eip-1167\n *      see https://docs.openzeppelin.com/contracts/4.x/api/proxy#Clones\n *\n * @author Basil Gorin\n */\nabstract contract InitializableAccessControl is Initializable {\n\t/**\n\t * @dev Privileged addresses with defined roles/permissions\n\t * @dev In the context of ERC20/ERC721 tokens these can be permissions to\n\t *      allow minting or burning tokens, transferring on behalf and so on\n\t *\n\t * @dev Maps user address to the permissions bitmask (role), where each bit\n\t *      represents a permission\n\t * @dev Bitmask 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n\t *      represents all possible permissions\n\t * @dev 'This' address mapping represents global features of the smart contract\n\t *\n\t * @dev We keep the mapping private to prevent direct writes to it from the inheriting\n\t *      contracts, `getRole()` and `updateRole()` functions should be used instead\n\t */\n\tmapping(address => uint256) private userRoles;\n\n\t/**\n\t * @dev Empty reserved space in storage. The size of the __gap array is calculated so that\n\t *      the amount of storage used by a contract always adds up to the 50.\n\t *      See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n\t */\n\tuint256[49] private __gap;\n\n\t/**\n\t * @notice Access manager is responsible for assigning the roles to users,\n\t *      enabling/disabling global features of the smart contract\n\t * @notice Access manager can add, remove and update user roles,\n\t *      remove and update global features\n\t *\n\t * @dev Role ROLE_ACCESS_MANAGER allows modifying user roles and global features\n\t * @dev Role ROLE_ACCESS_MANAGER has single bit at position 255 enabled\n\t */\n\tuint256 public constant ROLE_ACCESS_MANAGER = 0x8000000000000000000000000000000000000000000000000000000000000000;\n\n\t/**\n\t * @notice Upgrade manager is responsible for smart contract upgrades,\n\t *      see https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable\n\t *      see https://docs.openzeppelin.com/contracts/4.x/upgradeable\n\t *\n\t * @dev Role ROLE_UPGRADE_MANAGER allows passing the _authorizeUpgrade() check\n\t * @dev Role ROLE_UPGRADE_MANAGER has single bit at position 254 enabled\n\t */\n\tuint256 public constant ROLE_UPGRADE_MANAGER = 0x4000000000000000000000000000000000000000000000000000000000000000;\n\n\t/**\n\t * @dev Bitmask representing all the possible permissions (super admin role)\n\t * @dev Has all the bits are enabled (2^256 - 1 value)\n\t */\n\tuint256 private constant FULL_PRIVILEGES_MASK = type(uint256).max; // before 0.8.0: uint256(-1) overflows to 0xFFFF...\n\n\t/**\n\t * @dev Fired in updateRole() and updateFeatures()\n\t *\n\t * @param operator address which was granted/revoked permissions\n\t * @param requested permissions requested\n\t * @param assigned permissions effectively set\n\t */\n\tevent RoleUpdated(address indexed operator, uint256 requested, uint256 assigned);\n\n\t/**\n\t * @notice Function modifier making a function defined as public behave as restricted\n\t *      (so that only a pre-configured set of accounts can execute it)\n\t *\n\t * @param role the role transaction executor is required to have;\n\t *      the function throws an \"access denied\" exception if this condition is not met\n\t */\n\tmodifier restrictedTo(uint256 role) {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(role), \"access denied\");\n\n\t\t// execute the rest of the function\n\t\t_;\n\t}\n\n\t/**\n\t * @dev Creates/deploys the ACL implementation to be used in a proxy\n\t *\n\t * @dev Note:\n\t *      the implementation is already initialized and\n\t *      `_postConstruct` is not executable on the implementation\n\t *      `_postConstruct` is still available in the context of a proxy\n\t *      and should be executed on the proxy deployment (in the same tx)\n\t */\n\t // constructor() initializer {}\n\n\t/**\n\t * @dev Contract initializer, sets the contract owner to have full privileges\n\t *\n\t * @dev Can be executed only once, reverts when executed second time\n\t *\n\t * @dev IMPORTANT:\n\t *      this function SHOULD be executed during proxy deployment (in the same transaction)\n\t *\n\t * @param _owner smart contract owner having full privileges\n\t */\n\tfunction _postConstruct(address _owner) internal virtual onlyInitializing {\n\t\t// grant owner full privileges\n\t\t__setRole(_owner, FULL_PRIVILEGES_MASK, FULL_PRIVILEGES_MASK);\n\t}\n\n\t/**\n\t * @dev Highest version that has been initialized.\n\t *      Non-zero value means contract was already initialized.\n\t * @dev see {Initializable}, {reinitializer}.\n\t *\n\t * @return highest version that has been initialized\n\t */\n/*\n\tfunction getInitializedVersion() public view returns(uint64) {\n\t\t// delegate to `_getInitializedVersion`\n\t\treturn _getInitializedVersion();\n\t}\n*/\n\n\t/**\n\t * @notice Retrieves globally set of features enabled\n\t *\n\t * @dev Effectively reads userRoles role for the contract itself\n\t *\n\t * @return 256-bit bitmask of the features enabled\n\t */\n\tfunction features() public view returns (uint256) {\n\t\t// features are stored in 'this' address mapping of `userRoles`\n\t\treturn getRole(address(this));\n\t}\n\n\t/**\n\t * @notice Updates set of the globally enabled features (`features`),\n\t *      taking into account sender's permissions\n\t *\n\t * @dev Requires transaction sender to have `ROLE_ACCESS_MANAGER` permission\n\t * @dev Function is left for backward compatibility with older versions\n\t *\n\t * @param _mask bitmask representing a set of features to enable/disable\n\t */\n\tfunction updateFeatures(uint256 _mask) public {\n\t\t// delegate call to `updateRole`\n\t\tupdateRole(address(this), _mask);\n\t}\n\n\t/**\n\t * @notice Reads the permissions (role) for a given user from the `userRoles` mapping\n\t *      (privileged addresses with defined roles/permissions)\n\t * @notice In the context of ERC20/ERC721 tokens these can be permissions to\n\t *      allow minting or burning tokens, transferring on behalf and so on\n\t *\n\t * @dev Having a simple getter instead of making the mapping public\n\t *      allows enforcing the encapsulation of the mapping and protects from\n\t *      writing to it directly in the inheriting smart contracts\n\t *\n\t * @param operator address of a user to read permissions for,\n\t *      or self address to read global features of the smart contract\n\t */\n\tfunction getRole(address operator) public view returns(uint256) {\n\t\t// read the value from `userRoles` and return\n\t\treturn userRoles[operator];\n\t}\n\n\t/**\n\t * @notice Updates set of permissions (role) for a given user,\n\t *      taking into account sender's permissions.\n\t *\n\t * @dev Setting role to zero is equivalent to removing an all permissions\n\t * @dev Setting role to `FULL_PRIVILEGES_MASK` is equivalent to\n\t *      copying senders' permissions (role) to the user\n\t * @dev Requires transaction sender to have `ROLE_ACCESS_MANAGER` permission\n\t *\n\t * @param operator address of a user to alter permissions for,\n\t *       or self address to alter global features of the smart contract\n\t * @param role bitmask representing a set of permissions to\n\t *      enable/disable for a user specified\n\t */\n\tfunction updateRole(address operator, uint256 role) public {\n\t\t// caller must have a permission to update user roles\n\t\trequire(isSenderInRole(ROLE_ACCESS_MANAGER), \"access denied\");\n\n\t\t// evaluate the role and reassign it\n\t\t__setRole(operator, role, _evaluateBy(msg.sender, getRole(operator), role));\n\t}\n\n\t/**\n\t * @notice Determines the permission bitmask an operator can set on the\n\t *      target permission set\n\t * @notice Used to calculate the permission bitmask to be set when requested\n\t *     in `updateRole` and `updateFeatures` functions\n\t *\n\t * @dev Calculated based on:\n\t *      1) operator's own permission set read from userRoles[operator]\n\t *      2) target permission set - what is already set on the target\n\t *      3) desired permission set - what do we want set target to\n\t *\n\t * @dev Corner cases:\n\t *      1) Operator is super admin and its permission set is `FULL_PRIVILEGES_MASK`:\n\t *        `desired` bitset is returned regardless of the `target` permission set value\n\t *        (what operator sets is what they get)\n\t *      2) Operator with no permissions (zero bitset):\n\t *        `target` bitset is returned regardless of the `desired` value\n\t *        (operator has no authority and cannot modify anything)\n\t *\n\t * @dev Example:\n\t *      Consider an operator with the permissions bitmask     00001111\n\t *      is about to modify the target permission set          01010101\n\t *      Operator wants to set that permission set to          00110011\n\t *      Based on their role, an operator has the permissions\n\t *      to update only lowest 4 bits on the target, meaning that\n\t *      high 4 bits of the target set in this example is left\n\t *      unchanged and low 4 bits get changed as desired:      01010011\n\t *\n\t * @param operator address of the contract operator which is about to set the permissions\n\t * @param target input set of permissions to operator is going to modify\n\t * @param desired desired set of permissions operator would like to set\n\t * @return resulting set of permissions given operator will set\n\t */\n\tfunction _evaluateBy(address operator, uint256 target, uint256 desired) internal view returns (uint256) {\n\t\t// read operator's permissions\n\t\tuint256 p = getRole(operator);\n\n\t\t// taking into account operator's permissions,\n\t\t// 1) enable the permissions desired on the `target`\n\t\ttarget |= p & desired;\n\t\t// 2) disable the permissions desired on the `target`\n\t\ttarget &= FULL_PRIVILEGES_MASK ^ (p & (FULL_PRIVILEGES_MASK ^ desired));\n\n\t\t// return calculated result\n\t\treturn target;\n\t}\n\n\t/**\n\t * @notice Checks if requested set of features is enabled globally on the contract\n\t *\n\t * @param required set of features to check against\n\t * @return true if all the features requested are enabled, false otherwise\n\t */\n\tfunction isFeatureEnabled(uint256 required) public view returns (bool) {\n\t\t// delegate call to `__hasRole`, passing `features` property\n\t\treturn __hasRole(features(), required);\n\t}\n\n\t/**\n\t * @notice Checks if transaction sender `msg.sender` has all the permissions required\n\t *\n\t * @dev Used in smart contracts only. Off-chain clients should use `isOperatorInRole`.\n\t *\n\t * @param required set of permissions (role) to check against\n\t * @return true if all the permissions requested are enabled, false otherwise\n\t */\n\tfunction isSenderInRole(uint256 required) public view returns (bool) {\n\t\t// delegate call to `isOperatorInRole`, passing transaction sender\n\t\treturn isOperatorInRole(msg.sender, required);\n\t}\n\n\t/**\n\t * @notice Checks if operator has all the permissions (role) required\n\t *\n\t * @param operator address of the user to check role for\n\t * @param required set of permissions (role) to check\n\t * @return true if all the permissions requested are enabled, false otherwise\n\t */\n\tfunction isOperatorInRole(address operator, uint256 required) public view returns (bool) {\n\t\t// delegate call to `__hasRole`, passing operator's permissions (role)\n\t\treturn __hasRole(getRole(operator), required);\n\t}\n\n\t/**\n\t * @dev Sets the `assignedRole` role to the operator, logs both `requestedRole` and `actualRole`\n\t *\n\t * @dev Unsafe:\n\t *      provides direct write access to `userRoles` mapping without any security checks,\n\t *      doesn't verify the executor (msg.sender) permissions,\n\t *      must be kept private at all times\n\t *\n\t * @param operator address of a user to alter permissions for,\n\t *       or self address to alter global features of the smart contract\n\t * @param requestedRole bitmask representing a set of permissions requested\n\t *      to be enabled/disabled for a user specified, used only to be logged into event\n\t * @param assignedRole bitmask representing a set of permissions to\n\t *      enable/disable for a user specified, used to update the mapping and to be logged into event\n\t */\n\tfunction __setRole(address operator, uint256 requestedRole, uint256 assignedRole) private {\n\t\t// assign the role to the operator\n\t\tuserRoles[operator] = assignedRole;\n\n\t\t// fire an event\n\t\temit RoleUpdated(operator, requestedRole, assignedRole);\n\t}\n\n\t/**\n\t * @dev Checks if role `actual` contains all the permissions required `required`\n\t *\n\t * @param actual existent role\n\t * @param required required role\n\t * @return true if actual has required role (all permissions), false otherwise\n\t */\n\tfunction __hasRole(uint256 actual, uint256 required) private pure returns (bool) {\n\t\t// check the bitmask for the role required and return the result\n\t\treturn actual & required == required;\n\t}\n}\n"
    },
    "contracts/utils/Transfers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @notice Replaces built-in Solidity address.transfer and address.send functions\n *      with the address.call function\n */\nlibrary Transfers {\n\t/// @dev Mimics address.send forwarding 4,900 gas\n\tfunction send(address payable to, uint256 value) internal returns(bool) {\n\t\t(bool success, ) = to.call{gas: 4900, value: value}(\"\");\n\t\treturn success;\n\t}\n\n\t/// @dev Mimics address.transfer forwarding 4,900 gas\n\tfunction transfer(address payable to, uint256 value) internal {\n\t\trequire(send(to, value), \"failed to send ether\");\n\t}\n\n\t/// @dev Alias for `send`\n\tfunction send1(address payable to, uint256 value) internal returns(bool) {\n\t\treturn send(to, value);\n\t}\n\n\t/// @dev Alias for `transfer`\n\tfunction transfer1(address payable to, uint256 value) internal {\n\t\ttransfer(to, value);\n\t}\n}\n"
    },
    "contracts/utils/UpgradeableAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.2;\n\nimport \"./InitializableAccessControl.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\n/**\n * @title Upgradeable Role-based Access Control (RBAC) // ERC1967Proxy\n *\n * @notice Access control smart contract provides an API to check\n *      if a specific operation is permitted globally and/or\n *      if a particular user has a permission to execute it.\n *\n * @notice This contract is inherited by other contracts requiring the role-based access control (RBAC)\n *      protection for the restricted access functions\n *\n * @notice It deals with two main entities: features and roles.\n *\n * @notice Features are designed to be used to enable/disable public functions\n *      of the smart contract (used by a wide audience).\n * @notice User roles are designed to control the access to restricted functions\n *      of the smart contract (used by a limited set of maintainers).\n *\n * @notice Terms \"role\", \"permissions\" and \"set of permissions\" have equal meaning\n *      in the documentation text and may be used interchangeably.\n * @notice Terms \"permission\", \"single permission\" implies only one permission bit set.\n *\n * @notice Access manager is a special role which allows to grant/revoke other roles.\n *      Access managers can only grant/revoke permissions which they have themselves.\n *      As an example, access manager with no other roles set can only grant/revoke its own\n *      access manager permission and nothing else.\n *\n * @notice Access manager permission should be treated carefully, as a super admin permission:\n *      Access manager with even no other permission can interfere with another account by\n *      granting own access manager permission to it and effectively creating more powerful\n *      permission set than its own.\n *\n * @dev Both current and OpenZeppelin AccessControl implementations feature a similar API\n *      to check/know \"who is allowed to do this thing\".\n * @dev Zeppelin implementation is more flexible:\n *      - it allows setting unlimited number of roles, while current is limited to 256 different roles\n *      - it allows setting an admin for each role, while current allows having only one global admin\n * @dev Current implementation is more lightweight:\n *      - it uses only 1 bit per role, while Zeppelin uses 256 bits\n *      - it allows setting up to 256 roles at once, in a single transaction, while Zeppelin allows\n *        setting only one role in a single transaction\n *\n * @dev This smart contract is designed to be inherited by other\n *      smart contracts which require access control management capabilities.\n *\n * @dev Access manager permission has a bit 255 set.\n *      This bit must not be used by inheriting contracts for any other permissions/features.\n *\n * @dev This is an upgradeable version of the ACL, based on Zeppelin implementation for ERC1967,\n *      see https://docs.openzeppelin.com/contracts/4.x/upgradeable\n *      see https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable\n *      see https://forum.openzeppelin.com/t/uups-proxies-tutorial-solidity-javascript/7786\n *\n * @author Basil Gorin\n */\nabstract contract UpgradeableAccessControl is InitializableAccessControl, UUPSUpgradeable {\n\t/**\n\t * @dev Creates/deploys the ACL implementation to be used in a proxy\n\t *\n\t * @dev Note:\n\t *      the implementation is already initialized and\n\t *      `_postConstruct` is not executable on the implementation\n\t *      `_postConstruct` is still available in the context of a proxy\n\t *      and should be executed on the proxy deployment (in the same tx)\n\t */\n\tconstructor() initializer {}\n\n\t/**\n\t * @notice Returns an address of the implementation smart contract,\n\t *      see ERC1967Upgrade._getImplementation()\n\t *\n\t * @return the current implementation address\n\t */\n\tfunction getImplementation() public view virtual returns (address) {\n\t\t// delegate to `ERC1967Upgrade._getImplementation()`\n\t\treturn _getImplementation();\n\t}\n\n\t/**\n\t * @inheritdoc UUPSUpgradeable\n\t */\n\tfunction _authorizeUpgrade(address) internal virtual override {\n\t\t// caller must have a permission to upgrade the contract\n\t\trequire(isSenderInRole(ROLE_UPGRADE_MANAGER), \"access denied\");\n\t}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}