{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-upgradeable/proxy/beacon/IBeaconUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeaconUpgradeable {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeaconUpgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/StorageSlotUpgradeable.sol\";\nimport \"../utils/Initializable.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967UpgradeUpgradeable is Initializable {\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n        __ERC1967Upgrade_init_unchained();\n    }\n\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            _functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallSecure(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        address oldImplementation = _getImplementation();\n\n        // Initial upgrade and setup call\n        _setImplementation(newImplementation);\n        if (data.length > 0 || forceCall) {\n            _functionDelegateCall(newImplementation, data);\n        }\n\n        // Perform rollback test if not already in progress\n        StorageSlotUpgradeable.BooleanSlot storage rollbackTesting = StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT);\n        if (!rollbackTesting.value) {\n            // Trigger rollback using upgradeTo from the new implementation\n            rollbackTesting.value = true;\n            _functionDelegateCall(\n                newImplementation,\n                abi.encodeWithSignature(\"upgradeTo(address)\", oldImplementation)\n            );\n            rollbackTesting.value = false;\n            // Check rollback was effective\n            require(oldImplementation == _getImplementation(), \"ERC1967Upgrade: upgrade breaks further upgrades\");\n            // Finally reset to the new implementation and log the upgrade\n            _upgradeTo(newImplementation);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            _functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function _functionDelegateCall(address target, bytes memory data) private returns (bytes memory) {\n        require(AddressUpgradeable.isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return AddressUpgradeable.verifyCallResult(success, returndata, \"Address: low-level delegate call failed\");\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() initializer {}\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\n        // contract may have been reentered.\n        require(_initializing ? _isConstructor() : !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} modifier, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/utils/UUPSUpgradeable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1967/ERC1967UpgradeUpgradeable.sol\";\nimport \"./Initializable.sol\";\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n *\n * _Available since v4.1._\n */\nabstract contract UUPSUpgradeable is Initializable, ERC1967UpgradeUpgradeable {\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n        __ERC1967Upgrade_init_unchained();\n        __UUPSUpgradeable_init_unchained();\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n    address private immutable __self = address(this);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        require(address(this) != __self, \"Function must be called through delegatecall\");\n        require(_getImplementation() == __self, \"Function must be called through active proxy\");\n        _;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeTo(address newImplementation) external virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallSecure(newImplementation, new bytes(0), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallSecure(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeTo} and {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlotUpgradeable {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "contracts/interfaces/ERC165Spec.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title ERC-165 Standard Interface Detection\n *\n * @dev Interface of the ERC165 standard, as defined in the\n *       https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * @dev Implementers can declare support of contract interfaces,\n *      which can then be queried by others.\n *\n * @author Christian Reitwießner, Nick Johnson, Fabian Vogelsteller, Jordi Baylina, Konrad Feldmeier, William Entriken\n */\ninterface ERC165 {\n\t/**\n\t * @notice Query if a contract implements an interface\n\t *\n\t * @dev Interface identification is specified in ERC-165.\n\t *      This function uses less than 30,000 gas.\n\t *\n\t * @param interfaceID The interface identifier, as specified in ERC-165\n\t * @return `true` if the contract implements `interfaceID` and\n\t *      `interfaceID` is not 0xffffffff, `false` otherwise\n\t */\n\tfunction supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/ERC20Spec.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title EIP-20: ERC-20 Token Standard\n *\n * @notice The ERC-20 (Ethereum Request for Comments 20), proposed by Fabian Vogelsteller in November 2015,\n *      is a Token Standard that implements an API for tokens within Smart Contracts.\n *\n * @notice It provides functionalities like to transfer tokens from one account to another,\n *      to get the current token balance of an account and also the total supply of the token available on the network.\n *      Besides these it also has some other functionalities like to approve that an amount of\n *      token from an account can be spent by a third party account.\n *\n * @notice If a Smart Contract implements the following methods and events it can be called an ERC-20 Token\n *      Contract and, once deployed, it will be responsible to keep track of the created tokens on Ethereum.\n *\n * @notice See https://ethereum.org/en/developers/docs/standards/tokens/erc-20/\n * @notice See https://eips.ethereum.org/EIPS/eip-20\n */\ninterface ERC20 {\n\t/**\n\t * @dev Fired in transfer(), transferFrom() to indicate that token transfer happened\n\t *\n\t * @param from an address tokens were consumed from\n\t * @param to an address tokens were sent to\n\t * @param value number of tokens transferred\n\t */\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n\n\t/**\n\t * @dev Fired in approve() to indicate an approval event happened\n\t *\n\t * @param owner an address which granted a permission to transfer\n\t *      tokens on its behalf\n\t * @param spender an address which received a permission to transfer\n\t *      tokens on behalf of the owner `_owner`\n\t * @param value amount of tokens granted to transfer on behalf\n\t */\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\n\n\t/**\n\t * @return name of the token (ex.: USD Coin)\n\t */\n\t// OPTIONAL - This method can be used to improve usability,\n\t// but interfaces and other contracts MUST NOT expect these values to be present.\n\t// function name() external view returns (string memory);\n\n\t/**\n\t * @return symbol of the token (ex.: USDC)\n\t */\n\t// OPTIONAL - This method can be used to improve usability,\n\t// but interfaces and other contracts MUST NOT expect these values to be present.\n\t// function symbol() external view returns (string memory);\n\n\t/**\n\t * @dev Returns the number of decimals used to get its user representation.\n\t *      For example, if `decimals` equals `2`, a balance of `505` tokens should\n\t *      be displayed to a user as `5,05` (`505 / 10 ** 2`).\n\t *\n\t * @dev Tokens usually opt for a value of 18, imitating the relationship between\n\t *      Ether and Wei. This is the value {ERC20} uses, unless this function is\n\t *      overridden;\n\t *\n\t * @dev NOTE: This information is only used for _display_ purposes: it in\n\t *      no way affects any of the arithmetic of the contract, including\n\t *      {IERC20-balanceOf} and {IERC20-transfer}.\n\t *\n\t * @return token decimals\n\t */\n\t// OPTIONAL - This method can be used to improve usability,\n\t// but interfaces and other contracts MUST NOT expect these values to be present.\n\t// function decimals() external view returns (uint8);\n\n\t/**\n\t * @return the amount of tokens in existence\n\t */\n\tfunction totalSupply() external view returns (uint256);\n\n\t/**\n\t * @notice Gets the balance of a particular address\n\t *\n\t * @param _owner the address to query the the balance for\n\t * @return balance an amount of tokens owned by the address specified\n\t */\n\tfunction balanceOf(address _owner) external view returns (uint256 balance);\n\n\t/**\n\t * @notice Transfers some tokens to an external address or a smart contract\n\t *\n\t * @dev Called by token owner (an address which has a\n\t *      positive token balance tracked by this smart contract)\n\t * @dev Throws on any error like\n\t *      * insufficient token balance or\n\t *      * incorrect `_to` address:\n\t *          * zero address or\n\t *          * self address or\n\t *          * smart contract which doesn't support ERC20\n\t *\n\t * @param _to an address to transfer tokens to,\n\t *      must be either an external address or a smart contract,\n\t *      compliant with the ERC20 standard\n\t * @param _value amount of tokens to be transferred,, zero\n\t *      value is allowed\n\t * @return success true on success, throws otherwise\n\t */\n\tfunction transfer(address _to, uint256 _value) external returns (bool success);\n\n\t/**\n\t * @notice Transfers some tokens on behalf of address `_from' (token owner)\n\t *      to some other address `_to`\n\t *\n\t * @dev Called by token owner on his own or approved address,\n\t *      an address approved earlier by token owner to\n\t *      transfer some amount of tokens on its behalf\n\t * @dev Throws on any error like\n\t *      * insufficient token balance or\n\t *      * incorrect `_to` address:\n\t *          * zero address or\n\t *          * same as `_from` address (self transfer)\n\t *          * smart contract which doesn't support ERC20\n\t *\n\t * @param _from token owner which approved caller (transaction sender)\n\t *      to transfer `_value` of tokens on its behalf\n\t * @param _to an address to transfer tokens to,\n\t *      must be either an external address or a smart contract,\n\t *      compliant with the ERC20 standard\n\t * @param _value amount of tokens to be transferred,, zero\n\t *      value is allowed\n\t * @return success true on success, throws otherwise\n\t */\n\tfunction transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n\n\t/**\n\t * @notice Approves address called `_spender` to transfer some amount\n\t *      of tokens on behalf of the owner (transaction sender)\n\t *\n\t * @dev Transaction sender must not necessarily own any tokens to grant the permission\n\t *\n\t * @param _spender an address approved by the caller (token owner)\n\t *      to spend some tokens on its behalf\n\t * @param _value an amount of tokens spender `_spender` is allowed to\n\t *      transfer on behalf of the token owner\n\t * @return success true on success, throws otherwise\n\t */\n\tfunction approve(address _spender, uint256 _value) external returns (bool success);\n\n\t/**\n\t * @notice Returns the amount which _spender is still allowed to withdraw from _owner.\n\t *\n\t * @dev A function to check an amount of tokens owner approved\n\t *      to transfer on its behalf by some other address called \"spender\"\n\t *\n\t * @param _owner an address which approves transferring some tokens on its behalf\n\t * @param _spender an address approved to transfer some tokens on behalf\n\t * @return remaining an amount of tokens approved address `_spender` can transfer on behalf\n\t *      of token owner `_owner`\n\t */\n\tfunction allowance(address _owner, address _spender) external view returns (uint256 remaining);\n}\n"
    },
    "contracts/interfaces/ERC721Spec.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./ERC165Spec.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard\n *\n * @notice See https://eips.ethereum.org/EIPS/eip-721\n *\n * @dev Solidity issue #3412: The ERC721 interfaces include explicit mutability guarantees for each function.\n *      Mutability guarantees are, in order weak to strong: payable, implicit nonpayable, view, and pure.\n *      Implementation MUST meet the mutability guarantee in this interface and MAY meet a stronger guarantee.\n *      For example, a payable function in this interface may be implemented as nonpayable\n *      (no state mutability specified) in implementing contract.\n *      It is expected a later Solidity release will allow stricter contract to inherit from this interface,\n *      but current workaround is that we edit this interface to add stricter mutability before inheriting:\n *      we have removed all \"payable\" modifiers.\n *\n * @dev The ERC-165 identifier for this interface is 0x80ac58cd.\n *\n * @author William Entriken, Dieter Shirley, Jacob Evans, Nastassia Sachs\n */\ninterface ERC721 is ERC165 {\n\t/// @dev This emits when ownership of any NFT changes by any mechanism.\n\t///  This event emits when NFTs are created (`from` == 0) and destroyed\n\t///  (`to` == 0). Exception: during contract creation, any number of NFTs\n\t///  may be created and assigned without emitting Transfer. At the time of\n\t///  any transfer, the approved address for that NFT (if any) is reset to none.\n\tevent Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\n\n\t/// @dev This emits when the approved address for an NFT is changed or\n\t///  reaffirmed. The zero address indicates there is no approved address.\n\t///  When a Transfer event emits, this also indicates that the approved\n\t///  address for that NFT (if any) is reset to none.\n\tevent Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\n\n\t/// @dev This emits when an operator is enabled or disabled for an owner.\n\t///  The operator can manage all NFTs of the owner.\n\tevent ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n\n\t/// @notice Count all NFTs assigned to an owner\n\t/// @dev NFTs assigned to the zero address are considered invalid, and this\n\t///  function throws for queries about the zero address.\n\t/// @param _owner An address for whom to query the balance\n\t/// @return The number of NFTs owned by `_owner`, possibly zero\n\tfunction balanceOf(address _owner) external view returns (uint256);\n\n\t/// @notice Find the owner of an NFT\n\t/// @dev NFTs assigned to zero address are considered invalid, and queries\n\t///  about them do throw.\n\t/// @param _tokenId The identifier for an NFT\n\t/// @return The address of the owner of the NFT\n\tfunction ownerOf(uint256 _tokenId) external view returns (address);\n\n\t/// @notice Transfers the ownership of an NFT from one address to another address\n\t/// @dev Throws unless `msg.sender` is the current owner, an authorized\n\t///  operator, or the approved address for this NFT. Throws if `_from` is\n\t///  not the current owner. Throws if `_to` is the zero address. Throws if\n\t///  `_tokenId` is not a valid NFT. When transfer is complete, this function\n\t///  checks if `_to` is a smart contract (code size > 0). If so, it calls\n\t///  `onERC721Received` on `_to` and throws if the return value is not\n\t///  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n\t/// @param _from The current owner of the NFT\n\t/// @param _to The new owner\n\t/// @param _tokenId The NFT to transfer\n\t/// @param _data Additional data with no specified format, sent in call to `_to`\n\tfunction safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external /*payable*/;\n\n\t/// @notice Transfers the ownership of an NFT from one address to another address\n\t/// @dev This works identically to the other function with an extra data parameter,\n\t///  except this function just sets data to \"\".\n\t/// @param _from The current owner of the NFT\n\t/// @param _to The new owner\n\t/// @param _tokenId The NFT to transfer\n\tfunction safeTransferFrom(address _from, address _to, uint256 _tokenId) external /*payable*/;\n\n\t/// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\n\t///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\n\t///  THEY MAY BE PERMANENTLY LOST\n\t/// @dev Throws unless `msg.sender` is the current owner, an authorized\n\t///  operator, or the approved address for this NFT. Throws if `_from` is\n\t///  not the current owner. Throws if `_to` is the zero address. Throws if\n\t///  `_tokenId` is not a valid NFT.\n\t/// @param _from The current owner of the NFT\n\t/// @param _to The new owner\n\t/// @param _tokenId The NFT to transfer\n\tfunction transferFrom(address _from, address _to, uint256 _tokenId) external /*payable*/;\n\n\t/// @notice Change or reaffirm the approved address for an NFT\n\t/// @dev The zero address indicates there is no approved address.\n\t///  Throws unless `msg.sender` is the current NFT owner, or an authorized\n\t///  operator of the current owner.\n\t/// @param _approved The new approved NFT controller\n\t/// @param _tokenId The NFT to approve\n\tfunction approve(address _approved, uint256 _tokenId) external /*payable*/;\n\n\t/// @notice Enable or disable approval for a third party (\"operator\") to manage\n\t///  all of `msg.sender`'s assets\n\t/// @dev Emits the ApprovalForAll event. The contract MUST allow\n\t///  multiple operators per owner.\n\t/// @param _operator Address to add to the set of authorized operators\n\t/// @param _approved True if the operator is approved, false to revoke approval\n\tfunction setApprovalForAll(address _operator, bool _approved) external;\n\n\t/// @notice Get the approved address for a single NFT\n\t/// @dev Throws if `_tokenId` is not a valid NFT.\n\t/// @param _tokenId The NFT to find the approved address for\n\t/// @return The approved address for this NFT, or the zero address if there is none\n\tfunction getApproved(uint256 _tokenId) external view returns (address);\n\n\t/// @notice Query if an address is an authorized operator for another address\n\t/// @param _owner The address that owns the NFTs\n\t/// @param _operator The address that acts on behalf of the owner\n\t/// @return True if `_operator` is an approved operator for `_owner`, false otherwise\n\tfunction isApprovedForAll(address _owner, address _operator) external view returns (bool);\n}\n\n/// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.\ninterface ERC721TokenReceiver {\n\t/// @notice Handle the receipt of an NFT\n\t/// @dev The ERC721 smart contract calls this function on the recipient\n\t///  after a `transfer`. This function MAY throw to revert and reject the\n\t///  transfer. Return of other than the magic value MUST result in the\n\t///  transaction being reverted.\n\t///  Note: the contract address is always the message sender.\n\t/// @param _operator The address which called `safeTransferFrom` function\n\t/// @param _from The address which previously owned the token\n\t/// @param _tokenId The NFT identifier which is being transferred\n\t/// @param _data Additional data with no specified format\n\t/// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n\t///  unless throwing\n\tfunction onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4);\n}\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n *\n * @notice See https://eips.ethereum.org/EIPS/eip-721\n *\n * @dev The ERC-165 identifier for this interface is 0x5b5e139f.\n *\n * @author William Entriken, Dieter Shirley, Jacob Evans, Nastassia Sachs\n */\ninterface ERC721Metadata is ERC721 {\n\t/// @notice A descriptive name for a collection of NFTs in this contract\n\tfunction name() external view returns (string memory _name);\n\n\t/// @notice An abbreviated name for NFTs in this contract\n\tfunction symbol() external view returns (string memory _symbol);\n\n\t/// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\n\t/// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\n\t///  3986. The URI may point to a JSON file that conforms to the \"ERC721\n\t///  Metadata JSON Schema\".\n\tfunction tokenURI(uint256 _tokenId) external view returns (string memory);\n}\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n *\n * @notice See https://eips.ethereum.org/EIPS/eip-721\n *\n * @dev The ERC-165 identifier for this interface is 0x780e9d63.\n *\n * @author William Entriken, Dieter Shirley, Jacob Evans, Nastassia Sachs\n */\ninterface ERC721Enumerable is ERC721 {\n\t/// @notice Count NFTs tracked by this contract\n\t/// @return A count of valid NFTs tracked by this contract, where each one of\n\t///  them has an assigned and queryable owner not equal to the zero address\n\tfunction totalSupply() external view returns (uint256);\n\n\t/// @notice Enumerate valid NFTs\n\t/// @dev Throws if `_index` >= `totalSupply()`.\n\t/// @param _index A counter less than `totalSupply()`\n\t/// @return The token identifier for the `_index`th NFT,\n\t///  (sort order not specified)\n\tfunction tokenByIndex(uint256 _index) external view returns (uint256);\n\n\t/// @notice Enumerate NFTs assigned to an owner\n\t/// @dev Throws if `_index` >= `balanceOf(_owner)` or if\n\t///  `_owner` is the zero address, representing invalid NFTs.\n\t/// @param _owner An address where we are interested in NFTs owned by them\n\t/// @param _index A counter less than `balanceOf(_owner)`\n\t/// @return The token identifier for the `_index`th NFT assigned to `_owner`,\n\t///   (sort order not specified)\n\tfunction tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\n}\n"
    },
    "contracts/lib/StringUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title String Utils Library\n *\n * @dev Library for working with strings, primarily converting\n *      between strings and integer types\n *\n * @author Basil Gorin\n */\nlibrary StringUtils {\n\t/**\n\t * @dev Converts a string to unsigned integer using the specified `base`\n\t * @dev Throws on invalid input\n\t *      (wrong characters for a given `base`)\n\t * @dev Throws if given `base` is not supported\n\t * @param a string to convert\n\t * @param base number base, one of 2, 8, 10, 16\n\t * @return i a number representing given string\n\t */\n\tfunction atoi(string memory a, uint8 base) internal pure returns (uint256 i) {\n\t\t// check if the base is valid\n\t\trequire(base == 2 || base == 8 || base == 10 || base == 16);\n\n\t\t// convert string into bytes for convenient iteration\n\t\tbytes memory buf = bytes(a);\n\n\t\t// iterate over the string (bytes buffer)\n\t\tfor(uint256 p = 0; p < buf.length; p++) {\n\t\t\t// extract the digit\n\t\t\tuint8 digit = uint8(buf[p]) - 0x30;\n\n\t\t\t// if digit is greater then 10 - mind the gap\n\t\t\t// see `itoa` function for more details\n\t\t\tif(digit > 10) {\n\t\t\t\t// remove the gap\n\t\t\t\tdigit -= 7;\n\t\t\t}\n\n\t\t\t// check if digit meets the base\n\t\t\trequire(digit < base);\n\n\t\t\t// move to the next digit slot\n\t\t\ti *= base;\n\n\t\t\t// add digit to the result\n\t\t\ti += digit;\n\t\t}\n\n\t\t// return the result\n\t\treturn i;\n\t}\n\n\t/**\n\t * @dev Converts a integer to a string using the specified `base`\n\t * @dev Throws if given `base` is not supported\n\t * @param i integer to convert\n\t * @param base number base, one of 2, 8, 10, 16\n\t * @return a a string representing given integer\n\t */\n\tfunction itoa(uint256 i, uint8 base) internal pure returns (string memory a) {\n\t\t// check if the base is valid\n\t\trequire(base == 2 || base == 8 || base == 10 || base == 16);\n\n\t\t// for zero input the result is \"0\" string for any base\n\t\tif(i == 0) {\n\t\t\treturn \"0\";\n\t\t}\n\n\t\t// bytes buffer to put ASCII characters into\n\t\tbytes memory buf = new bytes(256);\n\n\t\t// position within a buffer to be used in cycle\n\t\tuint256 p = 0;\n\n\t\t// extract digits one by one in a cycle\n\t\twhile(i > 0) {\n\t\t\t// extract current digit\n\t\t\tuint8 digit = uint8(i % base);\n\n\t\t\t// convert it to an ASCII code\n\t\t\t// 0x20 is \" \"\n\t\t\t// 0x30-0x39 is \"0\"-\"9\"\n\t\t\t// 0x41-0x5A is \"A\"-\"Z\"\n\t\t\t// 0x61-0x7A is \"a\"-\"z\" (\"A\"-\"Z\" XOR \" \")\n\t\t\tuint8 ascii = digit + 0x30;\n\n\t\t\t// if digit is greater then 10,\n\t\t\t// fix the 0x3A-0x40 gap of punctuation marks\n\t\t\t// (7 characters in ASCII table)\n\t\t\tif(digit >= 10) {\n\t\t\t\t// jump through the gap\n\t\t\t\tascii += 7;\n\t\t\t}\n\n\t\t\t// write character into the buffer\n\t\t\tbuf[p++] = bytes1(ascii);\n\n\t\t\t// move to the next digit\n\t\t\ti /= base;\n\t\t}\n\n\t\t// `p` contains real length of the buffer now,\n\t\t// allocate the resulting buffer of that size\n\t\tbytes memory result = new bytes(p);\n\n\t\t// copy the buffer in the reversed order\n\t\tfor(p = 0; p < result.length; p++) {\n\t\t\t// copy from the beginning of the original buffer\n\t\t\t// to the end of resulting smaller buffer\n\t\t\tresult[result.length - p - 1] = buf[p];\n\t\t}\n\n\t\t// construct string and return\n\t\treturn string(result);\n\t}\n\n\t/**\n\t * @dev Concatenates two strings `s1` and `s2`, for example, if\n\t *      `s1` == `foo` and `s2` == `bar`, the result `s` == `foobar`\n\t * @param s1 first string\n\t * @param s2 second string\n\t * @return s concatenation result s1 + s2\n\t */\n\tfunction concat(string memory s1, string memory s2) internal pure returns (string memory s) {\n\t\t// an old way of string concatenation (Solidity 0.4) is commented out\n/*\n\t\t// convert s1 into buffer 1\n\t\tbytes memory buf1 = bytes(s1);\n\t\t// convert s2 into buffer 2\n\t\tbytes memory buf2 = bytes(s2);\n\t\t// create a buffer for concatenation result\n\t\tbytes memory buf = new bytes(buf1.length + buf2.length);\n\n\t\t// copy buffer 1 into buffer\n\t\tfor(uint256 i = 0; i < buf1.length; i++) {\n\t\t\tbuf[i] = buf1[i];\n\t\t}\n\n\t\t// copy buffer 2 into buffer\n\t\tfor(uint256 j = buf1.length; j < buf2.length; j++) {\n\t\t\tbuf[j] = buf2[j - buf1.length];\n\t\t}\n\n\t\t// construct string and return\n\t\treturn string(buf);\n*/\n\n\t\t// simply use built in function\n\t\treturn string(abi.encodePacked(s1, s2));\n\t}\n}\n"
    },
    "contracts/protocol/IntelligentNFTv2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ERC20Spec.sol\";\nimport \"../interfaces/ERC721Spec.sol\";\nimport \"../lib/StringUtils.sol\";\nimport \"../utils/AccessControl.sol\";\n\n/**\n * @title Intelligent NFT Interface\n *        Version 2\n *\n * @notice External interface of IntelligentNFTv2 declared to support ERC165 detection.\n *      Despite some similarity with ERC721 interfaces, iNFT is not ERC721, any similarity\n *      should be treated as coincidental. Client applications may benefit from this similarity\n *      to reuse some of the ERC721 client code for display/reading.\n *\n * @dev See Intelligent NFT documentation below.\n *\n * @author Basil Gorin\n */\ninterface IntelligentNFTv2Spec {\n\t/**\n\t * @dev ERC20/ERC721 like name - Intelligent NFT\n\t *\n\t * @return \"Intelligent NFT\"\n\t */\n\tfunction name() external view returns (string memory);\n\n\t/**\n\t * @dev ERC20/ERC721 like symbol - iNFT\n\t *\n\t * @return \"iNFT\"\n\t */\n\tfunction symbol() external view returns (string memory);\n\n\t/**\n\t * @dev ERC721 like link to the iNFT metadata\n\t *\n\t * @param recordId iNFT ID to get metadata URI for\n\t */\n\tfunction tokenURI(uint256 recordId) external view returns (string memory);\n\n\t/**\n\t * @dev ERC20/ERC721 like counter of the iNFTs in existence (upper bound),\n\t *      some (or all) of which may not exist due to target NFT destruction\n\t *\n\t * @return amount of iNFT tracked by this smart contract\n\t */\n\tfunction totalSupply() external view returns (uint256);\n\n\t/**\n\t * @dev Check if iNFT binding with the given ID exists\n\t *\n\t * @return true if iNFT binding exist, false otherwise\n\t */\n\tfunction exists(uint256 recordId) external view returns (bool);\n\n\t/**\n\t * @dev ERC721 like function to get owner of the iNFT, which is by definition\n\t *      an owner of the underlying NFT\n\t */\n\tfunction ownerOf(uint256 recordId) external view returns (address);\n}\n\n/**\n * @title Intelligent NFT (iNFT)\n *        Version 2\n *\n * @notice Intelligent NFT (iNFT) represents an enhancement to an existing NFT\n *      (we call it a \"target\" or \"target NFT\"), it binds a GPT-3 prompt (a \"personality prompt\",\n *      delivered as a Personality Pod ERC721 token bound to iNFT)\n *      to the target to embed intelligence, is controlled and belongs to the owner of the target.\n *\n * @notice iNFT stores AI Personality and some amount of ALI tokens locked, available for\n *      unlocking when iNFT is destroyed\n *\n * @notice iNFT is not an ERC721 token, but it has some very limited similarity to an ERC721:\n *      every record is identified by ID and this ID has an owner, which is effectively the target NFT owner;\n *      still, it doesn't store ownership information itself and fully relies on the target ownership instead\n *\n * @dev Internally iNFTs consist of:\n *      - target NFT - smart contract address and ID of the NFT the iNFT is bound to\n *      - AI Personality - smart contract address and ID of the AI Personality used to produce given iNFT,\n *        representing a \"personality prompt\", and locked within an iNFT\n *      - ALI tokens amount - amount of the ALI tokens used to produce given iNFT, also locked\n *\n * @dev iNFTs can be\n *      - created, this process requires an AI Personality and ALI tokens to be locked\n *      - destroyed, this process releases an AI Personality and ALI tokens previously locked\n *\n * @author Basil Gorin\n */\ncontract IntelligentNFTv2 is IntelligentNFTv2Spec, AccessControl, ERC165 {\n\t/**\n\t * @inheritdoc IntelligentNFTv2Spec\n\t */\n\tstring public override name = \"Intelligent NFT\";\n\n\t/**\n\t * @inheritdoc IntelligentNFTv2Spec\n\t */\n\tstring public override symbol = \"iNFT\";\n\n\t/**\n\t * @dev Each intelligent token, represented by its unique ID, is bound to the target NFT,\n\t *      defined by the pair of the target NFT smart contract address and unique token ID\n\t *      within the target NFT smart contract\n\t *\n\t * @dev Effectively iNFT is owned by the target NFT owner\n\t *\n\t * @dev Additionally, each token holds an AI Personality and some amount of ALI tokens bound to it\n\t *\n\t * @dev `IntelliBinding` keeps all the binding information, including target NFT coordinates,\n\t *      bound AI Personality ID, and amount of ALI ERC20 tokens bound to the iNFT\n\t */\n\tstruct IntelliBinding {\n\t\t// Note: structure members are reordered to fit into less memory slots, see EVM memory layout\n\t\t// ----- SLOT.1 (256/256)\n\t\t/**\n\t\t * @dev Specific AI Personality is defined by the pair of AI Personality smart contract address\n\t\t *       and AI Personality ID\n\t\t *\n\t\t * @dev Address of the AI Personality smart contract\n\t\t */\n\t\taddress personalityContract;\n\n\t\t/**\n\t\t * @dev AI Personality ID within the AI Personality smart contract\n\t\t */\n\t\tuint96 personalityId;\n\n\t\t// ----- SLOT.2 (256/256)\n\t\t/**\n\t\t * @dev Amount of an ALI ERC20 tokens bound to (owned by) the iNFTs\n\t\t *\n\t\t * @dev ALI ERC20 smart contract address is defined globally as `aliContract` constant\n\t\t */\n\t\tuint96 aliValue;\n\n\t\t/**\n\t\t * @dev Address of the target NFT deployed smart contract,\n\t\t *      this is a contract a particular iNFT is bound to\n\t\t */\n\t\taddress targetContract;\n\n\t\t// ----- SLOT.3 (256/256)\n\t\t/**\n\t\t * @dev Target NFT ID within the target NFT smart contract,\n\t\t *      effectively target NFT ID and contract address define the owner of an iNFT\n\t\t */\n\t\tuint256 targetId;\n\t}\n\n\t/**\n\t * @notice iNFT binding storage, stores binding information for each existing iNFT\n\t * @dev Maps iNFT ID to its binding data, which includes underlying NFT data\n\t */\n\tmapping(uint256 => IntelliBinding) public bindings;\n\n\t/**\n\t * @notice Reverse iNFT binding allows to find iNFT bound to a particular NFT\n\t * @dev Maps target NFT (smart contract address and unique token ID) to the iNFT ID:\n\t *      NFT Contract => NFT ID => iNFT ID\n\t */\n\tmapping(address => mapping(uint256 => uint256)) public reverseBindings;\n\n\t/**\n\t * @notice Ai Personality to iNFT binding allows to find iNFT bound to a particular Ai Personality\n\t * @dev Maps Ai Personality NFT (unique token ID) to the linked iNFT:\n\t *      AI Personality Contract => AI Personality ID => iNFT ID\n\t */\n\tmapping(address => mapping(uint256 => uint256)) public personalityBindings;\n\n\t/**\n\t * @notice Total amount (maximum value estimate) of iNFT in existence.\n\t *       This value can be higher than number of effectively accessible iNFTs\n\t *       since when underlying NFT gets burned this value doesn't get updated.\n\t */\n\tuint256 public override totalSupply;\n\n\t/**\n\t * @notice Each iNFT holds some ALI tokens, which are tracked by the ALI token ERC20 smart contract defined here\n\t */\n\taddress public immutable aliContract;\n\n\t/**\n\t * @notice ALI token balance the contract is aware of, cumulative ALI obligation,\n\t *      i.e. sum of all iNFT locked ALI balances\n\t *\n\t * @dev Sum of all `IntelliBinding.aliValue` for each iNFT in existence\n\t */\n\tuint256 public aliBalance;\n\n\t/**\n\t * @dev Base URI is used to construct ERC721Metadata.tokenURI as\n\t *      `base URI + token ID` if token URI is not set (not present in `_tokenURIs` mapping)\n\t *\n\t * @dev For example, if base URI is https://api.com/token/, then token #1\n\t *      will have an URI https://api.com/token/1\n\t *\n\t * @dev If token URI is set with `setTokenURI()` it will be returned as is via `tokenURI()`\n\t */\n\tstring public baseURI = \"\";\n\n\t/**\n\t * @dev Optional mapping for token URIs to be returned as is when `tokenURI()`\n\t *      is called; if mapping doesn't exist for token, the URI is constructed\n\t *      as `base URI + token ID`, where plus (+) denotes string concatenation\n\t */\n\tmapping(uint256 => string) internal _tokenURIs;\n\n\t/**\n\t * @notice Minter is responsible for creating (minting) iNFTs\n\t *\n\t * @dev Role ROLE_MINTER allows minting iNFTs (calling `mint` function)\n\t */\n\tuint32 public constant ROLE_MINTER = 0x0001_0000;\n\n\t/**\n\t * @notice Burner is responsible for destroying (burning) iNFTs\n\t *\n\t * @dev Role ROLE_BURNER allows burning iNFTs (calling `burn` function)\n\t */\n\tuint32 public constant ROLE_BURNER = 0x0002_0000;\n\n\t/**\n\t * @notice Editor is responsible for editing (updating) iNFT records in general,\n\t *      adding/removing locked ALI tokens to/from iNFT in particular\n\t *\n\t * @dev Role ROLE_EDITOR allows editing iNFTs (calling `increaseAli`, `decreaseAli` functions)\n\t */\n\tuint32 public constant ROLE_EDITOR = 0x0004_0000;\n\n\t/**\n\t * @notice URI manager is responsible for managing base URI\n\t *      part of the token URI ERC721Metadata interface\n\t *\n\t * @dev Role ROLE_URI_MANAGER allows updating the base URI\n\t *      (executing `setBaseURI` function)\n\t */\n\tuint32 public constant ROLE_URI_MANAGER = 0x0010_0000;\n\n\t/**\n\t * @dev Fired in setBaseURI()\n\t *\n\t * @param _by an address which executed update\n\t * @param _oldVal old _baseURI value\n\t * @param _newVal new _baseURI value\n\t */\n\tevent BaseURIUpdated(address indexed _by, string _oldVal, string _newVal);\n\n\t/**\n\t * @dev Fired in setTokenURI()\n\t *\n\t * @param _by an address which executed update\n\t * @param _tokenId token ID which URI was updated\n\t * @param _oldVal old _baseURI value\n\t * @param _newVal new _baseURI value\n\t */\n\tevent TokenURIUpdated(address indexed _by, uint256 indexed _tokenId, string _oldVal, string _newVal);\n\n\t/**\n\t * @dev Fired in mint() when new iNFT is created\n\t *\n\t * @param _by an address which executed the mint function\n\t * @param _owner current owner of the NFT\n\t * @param _recordId ID of the iNFT minted (created, bound)\n\t * @param _aliValue amount of ALI tokens locked within newly created iNFT\n\t * @param _personalityContract AI Personality smart contract address\n\t * @param _personalityId ID of the AI Personality locked within newly created iNFT\n\t * @param _targetContract target NFT smart contract address\n\t * @param _targetId target NFT ID (where this iNFT binds to and belongs to)\n\t */\n\tevent Minted(\n\t\taddress indexed _by,\n\t\taddress indexed _owner,\n\t\tuint256 indexed _recordId,\n\t\tuint96 _aliValue,\n\t\taddress _personalityContract,\n\t\tuint96 _personalityId,\n\t\taddress _targetContract,\n\t\tuint256 _targetId\n\t);\n\n\t/**\n\t * @dev Fired in increaseAli() and decreaseAli() when iNFT record is updated\n\t *\n\t * @param _by an address which executed the update\n\t * @param _owner iNFT (target NFT) owner\n\t * @param _recordId ID of the updated iNFT\n\t * @param _oldAliValue amount of ALI tokens locked within iNFT before update\n\t * @param _newAliValue amount of ALI tokens locked within iNFT after update\n\t */\n\tevent Updated(\n\t\taddress indexed _by,\n\t\taddress indexed _owner,\n\t\tuint256 indexed _recordId,\n\t\tuint96 _oldAliValue,\n\t\tuint96 _newAliValue\n\t);\n\n\t/**\n\t * @dev Fired in burn() when an existing iNFT gets destroyed\n\t *\n\t * @param _by an address which executed the burn function\n\t * @param _recordId ID of the iNFT burnt (destroyed, unbound)\n\t * @param _recipient and address which received unlocked AI Personality and ALI tokens\n\t * @param _aliValue amount of ALI tokens transferred from the destroyed iNFT\n\t * @param _personalityContract AI Personality smart contract address\n\t * @param _personalityId ID of the AI Personality transferred from the destroyed iNFT\n\t * @param _targetContract target NFT smart contract\n\t * @param _targetId target NFT ID (where this iNFT was bound to and belonged to)\n\t */\n\tevent Burnt(\n\t\taddress indexed _by,\n\t\tuint256 indexed _recordId,\n\t\taddress indexed _recipient,\n\t\tuint96 _aliValue,\n\t\taddress _personalityContract,\n\t\tuint96 _personalityId,\n\t\taddress _targetContract,\n\t\tuint256 _targetId\n\t);\n\n\t/**\n\t * @dev Creates/deploys an iNFT instance bound to already deployed ALI token instance\n\t *\n\t * @param _ali address of the deployed ALI ERC20 Token instance the iNFT is bound to\n\t */\n\tconstructor(address _ali) {\n\t\t// verify the inputs are set\n\t\trequire(_ali != address(0), \"ALI Token addr is not set\");\n\n\t\t// verify _ali is a valid ERC20\n\t\trequire(ERC165(_ali).supportsInterface(type(ERC20).interfaceId), \"unexpected ALI Token type\");\n\n\t\t// setup smart contract internal state\n\t\taliContract = _ali;\n\t}\n\n\t/**\n\t * @inheritdoc ERC165\n\t */\n\tfunction supportsInterface(bytes4 interfaceId) public pure override returns (bool) {\n\t\t// reconstruct from current interface and super interface\n\t\treturn interfaceId == type(IntelligentNFTv2Spec).interfaceId;\n\t}\n\n\t/**\n\t * @dev Restricted access function which updates base URI used to construct\n\t *      ERC721Metadata.tokenURI\n\t *\n\t * @param _baseURI new base URI to set\n\t */\n\tfunction setBaseURI(string memory _baseURI) public virtual {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_URI_MANAGER), \"access denied\");\n\n\t\t// emit an event first - to log both old and new values\n\t\temit BaseURIUpdated(msg.sender, baseURI, _baseURI);\n\n\t\t// and update base URI\n\t\tbaseURI = _baseURI;\n\t}\n\n\t/**\n\t * @dev Returns token URI if it was previously set with `setTokenURI`,\n\t *      otherwise constructs it as base URI + token ID\n\t *\n\t * @param _recordId iNFT ID to query metadata link URI for\n\t * @return URI link to fetch iNFT metadata from\n\t */\n\tfunction tokenURI(uint256 _recordId) public view override returns (string memory) {\n\t\t// verify token exists\n\t\trequire(exists(_recordId), \"iNFT doesn't exist\");\n\n\t\t// read the token URI for the token specified\n\t\tstring memory _tokenURI = _tokenURIs[_recordId];\n\n\t\t// if token URI is set\n\t\tif(bytes(_tokenURI).length > 0) {\n\t\t\t// just return it\n\t\t\treturn _tokenURI;\n\t\t}\n\n\t\t// if base URI is not set\n\t\tif(bytes(baseURI).length == 0) {\n\t\t\t// return an empty string\n\t\t\treturn \"\";\n\t\t}\n\n\t\t// otherwise concatenate base URI + token ID\n\t\treturn StringUtils.concat(baseURI, StringUtils.itoa(_recordId, 10));\n\t}\n\n\t/**\n\t * @dev Sets the token URI for the token defined by its ID\n\t *\n\t * @param _tokenId an ID of the token to set URI for\n\t * @param _tokenURI token URI to set\n\t */\n\tfunction setTokenURI(uint256 _tokenId, string memory _tokenURI) public virtual {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_URI_MANAGER), \"access denied\");\n\n\t\t// we do not verify token existence: we want to be able to\n\t\t// preallocate token URIs before tokens are actually minted\n\n\t\t// emit an event first - to log both old and new values\n\t\temit TokenURIUpdated(msg.sender, _tokenId, _tokenURIs[_tokenId], _tokenURI);\n\n\t\t// and update token URI\n\t\t_tokenURIs[_tokenId] = _tokenURI;\n\t}\n\n\t/**\n\t * @notice Verifies if given iNFT exists\n\t *\n\t * @param recordId iNFT ID to verify existence of\n\t * @return true if iNFT exists, false otherwise\n\t */\n\tfunction exists(uint256 recordId) public view override returns (bool) {\n\t\t// verify if biding exists for that tokenId and return the result\n\t\treturn bindings[recordId].targetContract != address(0);\n\t}\n\n\t/**\n\t * @notice Returns an owner of the given iNFT.\n\t *      By definition iNFT owner is an owner of the target NFT\n\t *\n\t * @param recordId iNFT ID to query ownership information for\n\t * @return address of the given iNFT owner\n\t */\n\tfunction ownerOf(uint256 recordId) public view override returns (address) {\n\t\t// get the link to the token binding (we need to access only one field)\n\t\tIntelliBinding storage binding = bindings[recordId];\n\n\t\t// verify the binding exists and throw standard Zeppelin message if not\n\t\trequire(binding.targetContract != address(0), \"iNFT doesn't exist\");\n\n\t\t// delegate `ownerOf` call to the target NFT smart contract\n\t\treturn ERC721(binding.targetContract).ownerOf(binding.targetId);\n\t}\n\n\t/**\n\t * @dev Restricted access function which creates an iNFT, binding it to the specified\n\t *      NFT, locking the AI Personality specified, and funded with the amount of ALI specified\n\t *\n\t * @dev Locks AI Personality defined by its ID within iNFT smart contract;\n\t *      AI Personality must be transferred to the iNFT smart contract\n\t *      prior to calling the `mint`, but in the same transaction with `mint`\n\t *\n\t * @dev Locks specified amount of ALI token within iNFT smart contract;\n\t *      ALI token amount must be transferred to the iNFT smart contract\n\t *      prior to calling the `mint`, but in the same transaction with `mint`\n\t *\n\t * @dev To summarize, minting transaction (a transaction which executes `mint`) must\n\t *      1) transfer AI Personality\n\t *      2) transfer ALI tokens if they are to be locked\n\t *      3) mint iNFT\n\t *      NOTE: breaking the items above into multiple transactions is not acceptable!\n\t *            (results in a security risk)\n\t *\n\t * @dev The NFT to be linked to is not required to owned by the funder, but it must exist;\n\t *      throws if target NFT doesn't exist\n\t *\n\t * @dev This is a restricted function which is accessed by iNFT Linker\n\t *\n\t * @param recordId ID of the iNFT to mint (create, bind)\n\t * @param aliValue amount of ALI tokens to bind to newly created iNFT\n\t * @param personalityContract AI Personality contract address\n\t * @param personalityId ID of the AI Personality to bind to newly created iNFT\n\t * @param targetContract target NFT smart contract\n\t * @param targetId target NFT ID (where this iNFT binds to and belongs to)\n\t */\n\tfunction mint(\n\t\tuint256 recordId,\n\t\tuint96 aliValue,\n\t\taddress personalityContract,\n\t\tuint96 personalityId,\n\t\taddress targetContract,\n\t\tuint256 targetId\n\t) public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_MINTER), \"access denied\");\n\n\t\t// verify personalityContract is a valid ERC721\n\t\trequire(ERC165(personalityContract).supportsInterface(type(ERC721).interfaceId), \"personality is not ERC721\");\n\n\t\t// verify targetContract is a valid ERC721\n\t\trequire(ERC165(targetContract).supportsInterface(type(ERC721).interfaceId), \"target NFT is not ERC721\");\n\n\t\t// verify this iNFT is not yet minted\n\t\trequire(!exists(recordId), \"iNFT already exists\");\n\n\t\t// verify target NFT is not yet bound to\n\t\trequire(reverseBindings[targetContract][targetId] == 0, \"NFT is already bound\");\n\n\t\t// verify AI Personality is not yet locked\n\t\trequire(personalityBindings[personalityContract][personalityId] == 0, \"personality already linked\");\n\n\t\t// verify if AI Personality is already transferred to iNFT\n\t\trequire(ERC721(personalityContract).ownerOf(personalityId) == address(this), \"personality is not yet transferred\");\n\n\t\t// retrieve NFT owner and verify if target NFT exists\n\t\taddress owner = ERC721(targetContract).ownerOf(targetId);\n\t\t// Note: we do not require funder to be NFT owner,\n\t\t// if required this constraint should be added by the caller (iNFT Linker)\n\t\trequire(owner != address(0), \"target NFT doesn't exist\");\n\n\t\t// in case when ALI tokens are expected to be locked within iNFT\n\t\tif(aliValue > 0) {\n\t\t\t// verify ALI tokens are already transferred to iNFT\n\t\t\trequire(aliBalance + aliValue <= ERC20(aliContract).balanceOf(address(this)), \"ALI tokens not yet transferred\");\n\n\t\t\t// update ALI balance on the contract\n\t\t\taliBalance += aliValue;\n\t\t}\n\n\t\t// bind AI Personality transferred and ALI ERC20 value transferred to an NFT specified\n\t\tbindings[recordId] = IntelliBinding({\n\t\t\tpersonalityContract : personalityContract,\n\t\t\tpersonalityId : personalityId,\n\t\t\taliValue : aliValue,\n\t\t\ttargetContract : targetContract,\n\t\t\ttargetId : targetId\n\t\t});\n\n\t\t// fill in the reverse binding\n\t\treverseBindings[targetContract][targetId] = recordId;\n\n\t\t// fill in the AI Personality to iNFT binding\n\t\tpersonalityBindings[personalityContract][personalityId] = recordId;\n\n\t\t// increase total supply counter\n\t\ttotalSupply++;\n\n\t\t// emit an event\n\t\temit Minted(\n\t\t\tmsg.sender,\n\t\t\towner,\n\t\t\trecordId,\n\t\t\taliValue,\n\t\t\tpersonalityContract,\n\t\t\tpersonalityId,\n\t\t\ttargetContract,\n\t\t\ttargetId\n\t\t);\n\t}\n\n\t/**\n\t * @dev Restricted access function which creates several iNFTs, binding them to the specified\n\t *      NFTs, locking the AI Personalities specified, each funded with the amount of ALI specified\n\t *\n\t * @dev Locks AI Personalities defined by their IDs within iNFT smart contract;\n\t *      AI Personalities must be transferred to the iNFT smart contract\n\t *      prior to calling the `mintBatch`, but in the same transaction with `mintBatch`\n\t *\n\t * @dev Locks specified amount of ALI token within iNFT smart contract for each iNFT minted;\n\t *      ALI token amount must be transferred to the iNFT smart contract\n\t *      prior to calling the `mintBatch`, but in the same transaction with `mintBatch`\n\t *\n\t * @dev To summarize, minting transaction (a transaction which executes `mintBatch`) must\n\t *      1) transfer AI Personality\n\t *      2) transfer ALI tokens if they are to be locked\n\t *      3) mint iNFT\n\t *      NOTE: breaking the items above into multiple transactions is not acceptable!\n\t *            (results in a security risk)\n\t *\n\t * @dev The NFTs to be linked to are not required to owned by the funder, but they must exist;\n\t *      throws if target NFTs don't exist\n\t *\n\t * @dev iNFT IDs to be minted: [recordId, recordId + n)\n\t * @dev AI Personality IDs to be locked: [personalityId, personalityId + n)\n\t * @dev NFT IDs to be bound to: [targetId, targetId + n)\n\t *\n\t * @dev n must be greater or equal 2: `n > 1`\n\t *\n\t * @dev This is a restricted function which is accessed by iNFT Linker\n\t *\n\t * @param recordId ID of the first iNFT to mint (create, bind)\n\t * @param aliValue amount of ALI tokens to bind to each newly created iNFT\n\t * @param personalityContract AI Personality contract address\n\t * @param personalityId ID of the first AI Personality to bind to newly created iNFT\n\t * @param targetContract target NFT smart contract\n\t * @param targetId first target NFT ID (where this iNFT binds to and belongs to)\n\t * @param n how many iNFTs to mint, sequentially increasing the recordId, personalityId, and targetId\n\t */\n\tfunction mintBatch(\n\t\tuint256 recordId,\n\t\tuint96 aliValue,\n\t\taddress personalityContract,\n\t\tuint96 personalityId,\n\t\taddress targetContract,\n\t\tuint256 targetId,\n\t\tuint96 n\n\t) public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_MINTER), \"access denied\");\n\n\t\t// verify n is set properly\n\t\trequire(n > 1, \"n is too small\");\n\n\t\t// verify personalityContract is a valid ERC721\n\t\trequire(ERC165(personalityContract).supportsInterface(type(ERC721).interfaceId), \"personality is not ERC721\");\n\n\t\t// verify targetContract is a valid ERC721\n\t\trequire(ERC165(targetContract).supportsInterface(type(ERC721).interfaceId), \"target NFT is not ERC721\");\n\n\t\t// verifications: for each iNFT in a batch\n\t\tfor(uint96 i = 0; i < n; i++) {\n\t\t\t// verify this token ID is not yet bound\n\t\t\trequire(!exists(recordId + i), \"iNFT already exists\");\n\n\t\t\t// verify the AI Personality is not yet bound\n\t\t\trequire(personalityBindings[personalityContract][personalityId + i] == 0, \"personality already linked\");\n\n\t\t\t// verify if AI Personality is already transferred to iNFT\n\t\t\trequire(ERC721(personalityContract).ownerOf(personalityId + i) == address(this), \"personality is not yet transferred\");\n\n\t\t\t// retrieve NFT owner and verify if target NFT exists\n\t\t\taddress owner = ERC721(targetContract).ownerOf(targetId + i);\n\t\t\t// Note: we do not require funder to be NFT owner,\n\t\t\t// if required this constraint should be added by the caller (iNFT Linker)\n\t\t\trequire(owner != address(0), \"target NFT doesn't exist\");\n\n\t\t\t// emit an event - we log owner for each iNFT\n\t\t\t// and its convenient to do it here when we have the owner inline\n\t\t\temit Minted(\n\t\t\t\tmsg.sender,\n\t\t\t\towner,\n\t\t\t\trecordId + i,\n\t\t\t\taliValue,\n\t\t\t\tpersonalityContract,\n\t\t\t\tpersonalityId + i,\n\t\t\t\ttargetContract,\n\t\t\t\ttargetId + i\n\t\t\t);\n\t\t}\n\n\t\t// cumulative ALI value may overflow uint96, store it into uint256 on stack\n\t\tuint256 _aliValue = uint256(aliValue) * n;\n\n\t\t// in case when ALI tokens are expected to be locked within iNFT\n\t\tif(_aliValue > 0) {\n\t\t\t// verify ALI tokens are already transferred to iNFT\n\t\t\trequire(aliBalance + _aliValue <= ERC20(aliContract).balanceOf(address(this)), \"ALI tokens not yet transferred\");\n\t\t\t// update ALI balance on the contract\n\t\t\taliBalance += _aliValue;\n\t\t}\n\n\t\t// minting: for each iNFT in a batch\n\t\tfor(uint96 i = 0; i < n; i++) {\n\t\t\t// bind AI Personality transferred and ALI ERC20 value transferred to an NFT specified\n\t\t\tbindings[recordId + i] = IntelliBinding({\n\t\t\t\tpersonalityContract : personalityContract,\n\t\t\t\tpersonalityId : personalityId + i,\n\t\t\t\taliValue : aliValue,\n\t\t\t\ttargetContract : targetContract,\n\t\t\t\ttargetId : targetId + i\n\t\t\t});\n\n\t\t\t// fill in the AI Personality to iNFT binding\n\t\t\tpersonalityBindings[personalityContract][personalityId + i] = recordId + i;\n\n\t\t\t// fill in the reverse binding\n\t\t\treverseBindings[targetContract][targetId + i] = recordId + i;\n\t\t}\n\n\t\t// increase total supply counter\n\t\ttotalSupply += n;\n\t}\n\n\t/**\n\t * @dev Restricted access function which destroys an iNFT, unbinding it from the\n\t *      linked NFT, releasing an AI Personality, and ALI tokens locked in the iNFT\n\t *\n\t * @dev Transfers an AI Personality locked in iNFT to its owner via ERC721.safeTransferFrom;\n\t *      owner must be an EOA or implement ERC721Receiver.onERC721Received properly\n\t * @dev Transfers ALI tokens locked in iNFT to its owner\n\t * @dev Since iNFT owner is determined as underlying NFT owner, this underlying NFT must\n\t *      exist and its ownerOf function must not throw and must return non-zero owner address\n\t *      for the underlying NFT ID\n\t *\n\t * @dev Doesn't verify if it's safe to send ALI tokens to the NFT owner, this check\n\t *      must be handled by the transaction executor\n\t *\n\t * @dev This is a restricted function which is accessed by iNFT Linker\n\t *\n\t * @param recordId ID of the iNFT to burn (destroy, unbind)\n\t */\n\tfunction burn(uint256 recordId) public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_BURNER), \"access denied\");\n\n\t\t// decrease total supply counter\n\t\ttotalSupply--;\n\n\t\t// read the token binding (we'll need to access all the fields)\n\t\tIntelliBinding memory binding = bindings[recordId];\n\n\t\t// verify binding exists\n\t\trequire(binding.targetContract != address(0), \"not bound\");\n\n\t\t// destroy binding first to protect from any reentrancy possibility\n\t\tdelete bindings[recordId];\n\n\t\t// free the reverse binding\n\t\tdelete reverseBindings[binding.targetContract][binding.targetId];\n\n\t\t// free the AI Personality binding\n\t\tdelete personalityBindings[binding.personalityContract][binding.personalityId];\n\n\t\t// determine an owner of the underlying NFT\n\t\taddress owner = ERC721(binding.targetContract).ownerOf(binding.targetId);\n\n\t\t// verify that owner address is set (not a zero address)\n\t\trequire(owner != address(0), \"no such NFT\");\n\n\t\t// transfer the AI Personality to the NFT owner\n\t\t// using safe transfer since we don't know if owner address can accept the AI Personality right now\n\t\tERC721(binding.personalityContract).safeTransferFrom(address(this), owner, binding.personalityId);\n\n\t\t// in case when ALI tokens were locked within iNFT\n\t\tif(binding.aliValue > 0) {\n\t\t\t// update ALI balance on the contract prior to token transfer (reentrancy style)\n\t\t\taliBalance -= binding.aliValue;\n\n\t\t\t// transfer the ALI tokens to the NFT owner\n\t\t\tERC20(aliContract).transfer(owner, binding.aliValue);\n\t\t}\n\n\t\t// emit an event\n\t\temit Burnt(\n\t\t\tmsg.sender,\n\t\t\trecordId,\n\t\t\towner,\n\t\t\tbinding.aliValue,\n\t\t\tbinding.personalityContract,\n\t\t\tbinding.personalityId,\n\t\t\tbinding.targetContract,\n\t\t\tbinding.targetId\n\t\t);\n\t}\n\n\t/**\n\t * @dev Restricted access function which updates iNFT record by increasing locked ALI tokens value,\n\t *      effectively locking additional ALI tokens to the iNFT\n\t *\n\t * @dev Locks specified amount of ALI token within iNFT smart contract;\n\t *      ALI token amount must be transferred to the iNFT smart contract\n\t *      prior to calling the `increaseAli`, but in the same transaction with `increaseAli`\n\t *\n\t * @dev To summarize, update transaction (a transaction which executes `increaseAli`) must\n\t *      1) transfer ALI tokens\n\t *      2) update the iNFT\n\t *      NOTE: breaking the items above into multiple transactions is not acceptable!\n\t *            (results in a security risk)\n\t *\n\t * @dev This is a restricted function which is accessed by iNFT Linker\n\t *\n\t * @param recordId ID of the iNFT to update\n\t * @param aliDelta amount of ALI tokens to lock\n\t */\n\tfunction increaseAli(uint256 recordId, uint96 aliDelta) public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_EDITOR), \"access denied\");\n\n\t\t// verify the inputs are set\n\t\trequire(aliDelta != 0, \"zero value\");\n\n\t\t// get iNFT owner for logging (check iNFT record exists under the hood)\n\t\taddress owner = ownerOf(recordId);\n\n\t\t// cache the ALI value of the record\n\t\tuint96 aliValue = bindings[recordId].aliValue;\n\n\t\t// verify ALI tokens are already transferred to iNFT\n\t\trequire(aliBalance + aliDelta <= ERC20(aliContract).balanceOf(address(this)), \"ALI tokens not yet transferred\");\n\n\t\t// update ALI balance on the contract\n\t\taliBalance += aliDelta;\n\n\t\t// update ALI balance on the binding\n\t\tbindings[recordId].aliValue = aliValue + aliDelta;\n\n\t\t// emit an event\n\t\temit Updated(msg.sender, owner, recordId, aliValue, aliValue + aliDelta);\n\t}\n\n\t/**\n\t * @dev Restricted access function which updates iNFT record by decreasing locked ALI tokens value,\n\t *      effectively unlocking some or all ALI tokens from the iNFT\n\t *\n\t * @dev Unlocked tokens are sent to the recipient address specified\n\t *\n\t * @dev This is a restricted function which is accessed by iNFT Linker\n\t *\n\t * @param recordId ID of the iNFT to update\n\t * @param aliDelta amount of ALI tokens to unlock\n\t * @param recipient an address to send unlocked tokens to\n\t */\n\tfunction decreaseAli(uint256 recordId, uint96 aliDelta, address recipient) public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_EDITOR), \"access denied\");\n\n\t\t// verify the inputs are set\n\t\trequire(aliDelta != 0, \"zero value\");\n\t\trequire(recipient != address(0), \"zero address\");\n\n\t\t// get iNFT owner for logging (check iNFT record exists under the hood)\n\t\taddress owner = ownerOf(recordId);\n\n\t\t// cache the ALI value of the record\n\t\tuint96 aliValue = bindings[recordId].aliValue;\n\n\t\t// positive or zero resulting balance check\n\t\trequire(aliValue >= aliDelta, \"not enough ALI\");\n\n\t\t// update ALI balance on the contract\n\t\taliBalance -= aliDelta;\n\n\t\t// update ALI balance on the binding\n\t\tbindings[recordId].aliValue = aliValue - aliDelta;\n\n\t\t// transfer the ALI tokens to the recipient\n\t\tERC20(aliContract).transfer(recipient, aliDelta);\n\n\t\t// emit an event\n\t\temit Updated(msg.sender, owner, recordId, aliValue, aliValue - aliDelta);\n\t}\n\n\t/**\n\t * @notice Determines how many tokens are locked in a particular iNFT\n\t *\n\t * @dev A shortcut for bindings(recordId).aliValue\n\t * @dev Throws if iNFT specified doesn't exist\n\t *\n\t * @param recordId iNFT ID to query locked tokens balance for\n\t * @return locked tokens balance, bindings[recordId].aliValue\n\t */\n\tfunction lockedValue(uint256 recordId) public view returns(uint96) {\n\t\t// ensure iNFT exists\n\t\trequire(exists(recordId), \"iNFT doesn't exist\");\n\n\t\t// read and return ALI value locked in the binding\n\t\treturn bindings[recordId].aliValue;\n\t}\n}\n"
    },
    "contracts/protocol/IntelliLinkerV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ERC721Spec.sol\";\nimport \"./IntelligentNFTv2.sol\";\nimport \"../utils/UpgradeableAccessControl.sol\";\n\n/**\n * @title Intelligent Token Linker (iNFT Linker)\n *\n * @notice iNFT Linker is a helper smart contract responsible for managing iNFTs.\n *      It creates and destroys iNFTs, determines iNFT creation price and destruction fee.\n *\n * @dev Known limitations (to be resolved in the future releases):\n *      - doesn't check AI Personality / target NFT compatibility: any personality\n *        can be linked to any NFT (NFT contract must be whitelisted)\n *      - doesn't support unlinking + linking in a single transaction\n *      - doesn't support AI Personality smart contract upgrades: in case when new\n *        AI Personality contract is deployed, new iNFT Linker should also be deployed\n *\n * @dev V2 modification\n *      - supports two separate whitelists for linking and unlinking\n *      - is upgradeable\n *\n * @dev V3 modification: \"custom iNFT request\" feature\n *      - separates feature \"ALLOW_ANY_NFT_CONTRACT\" into \"ALLOW_ANY_NFT_CONTRACT_FOR_LINKING\"\n *        and \"ALLOW_ANY_NFT_CONTRACT_FOR_UNLINKING\"\n *      - introduces two separate blacklists for linking and unlinking, having the priority over\n *        the whitelists introduced in V2\n *\n * @dev NOTE: Contract MUST NOT be deployed from scratch, only V2 -> V3 upgrade is supported!\n *\n * @author Basil Gorin\n */\ncontract IntelliLinkerV3 is UpgradeableAccessControl {\n\t/**\n\t * @dev iNFT Linker locks/unlocks ALI tokens defined by `aliContract` to mint/burn iNFT\n\t */\n\taddress public aliContract;\n\n\t/**\n\t * @dev iNFT Linker locks/unlocks AI Personality defined by `personalityContract` to mint/burn iNFT\n\t */\n\taddress public personalityContract;\n\n\t/**\n\t * @dev iNFT Linker mints/burns iNFTs defined by `iNftContract`\n\t */\n\taddress public iNftContract;\n\n\t/**\n\t * @dev iNFTs may get created with the ALI tokens bound to them,\n\t *      linking fee may get charged when creating an iNFT\n\t *\n\t * @dev Linking price, how much ALI tokens is charged upon iNFT creation;\n\t *      `linkPrice - linkFee` is locked within the iNFT created\n\t */\n\tuint96 public linkPrice;\n\n\t/**\n\t * @dev iNFTs may get created with the ALI tokens bound to them,\n\t *      linking fee may get charged when creating an iNFT\n\t *\n\t * @dev Linking fee, how much ALI tokens is sent into treasury `feeDestination`\n\t *      upon iNFT creation\n\t *\n\t * @dev Both `linkFee` and `feeDestination` must be set for the fee to be charged;\n\t *      both `linkFee` and `feeDestination` can be either set or unset\n\t */\n\tuint96 public linkFee;\n\n\t/**\n\t * @dev iNFTs may get created with the ALI tokens bound to them,\n\t *      linking fee may get charged when creating an iNFT\n\t *\n\t * @dev Treasury `feeDestination` is an address to send linking fee to upon iNFT creation\n\t *\n\t * @dev Both `linkFee` and `feeDestination` must be set for the fee to be charged;\n\t *      both `linkFee` and `feeDestination` can be either set or unset\n\t */\n\taddress public feeDestination;\n\n\t/**\n\t/**\n\t * @dev Next iNFT ID to mint; initially this is the first \"free\" ID which can be minted;\n\t *      at any point in time this should point to a free, mintable ID for iNFT\n\t *\n\t * @dev iNFT ID space up to 0xFFFF_FFFF (uint32 max) is reserved for the sales\n\t */\n\tuint256 public nextId;\n\n\t/**\n\t * @notice Whitelist / blacklist mapping storing special linking / unlinking permissions\n\t *\n\t * @dev Target NFT Contracts which have special permissions (allowed or forbidden)\n\t *      for iNFT to be linked to / unlinked from;\n\t *      allowance permissions are not taken into account if features\n\t *      ALLOW_ANY_NFT_CONTRACT_FOR_LINKING / ALLOW_ANY_NFT_CONTRACT_FOR_UNLINKING are enabled\n\t *      forbiddance permissions are not taken into account if features\n\t *      ALLOW_ANY_NFT_CONTRACT_FOR_LINKING / ALLOW_ANY_NFT_CONTRACT_FOR_UNLINKING are disabled\n\t *\n\t * @dev Lowest bit (zero) defines if contract is allowed to be linked to;\n\t *      Next bit (one) defines if contract is allowed to be unlinked from;\n\t *      Next bit (two) defines if contract is forbidden to be linked to;\n\t *      Next bit (three) defines if contract is forbidden to be unlinked from;\n\t */\n\tmapping(address => uint8) public whitelistedTargetContracts;\n\n\t/**\n\t * @notice Enables iNFT linking (creation)\n\t *\n\t * @dev Feature FEATURE_LINKING must be enabled\n\t *      as a prerequisite for `link()` function to succeed\n\t */\n\tuint32 public constant FEATURE_LINKING = 0x0000_0001;\n\n\t/**\n\t * @notice Enables iNFT unlinking (destruction)\n\t *\n\t * @dev Feature FEATURE_UNLINKING must be enabled\n\t *      for the `unlink()` and `unlinkNFT()` functions to succeed\n\t */\n\tuint32 public constant FEATURE_UNLINKING = 0x0000_0002;\n\n\t/**\n\t * @notice Allows linker to link (mint) iNFT to any target NFT contract,\n\t *      independently whether it was previously whitelisted or not\n\t * @dev Feature FEATURE_ALLOW_ANY_NFT_CONTRACT_FOR_LINKING allows linking (minting) iNFTs\n\t *      to any target NFT contract, without a check if it's whitelisted in\n\t *      `whitelistedTargetContracts` or not\n\t */\n\tuint32 public constant FEATURE_ALLOW_ANY_NFT_CONTRACT_FOR_LINKING = 0x0000_0004;\n\n\t/**\n\t * @notice Allows linker to unlink (burn) iNFT bound to any target NFT contract,\n\t *      independently whether it was previously whitelisted or not\n\t * @dev Feature FEATURE_ALLOW_ANY_NFT_CONTRACT_FOR_UNLINKING allows unlinking (burning) iNFTs\n\t *      bound to any target NFT contract, without a check if it's whitelisted in\n\t *      `whitelistedTargetContracts` or not\n\t */\n\tuint32 public constant FEATURE_ALLOW_ANY_NFT_CONTRACT_FOR_UNLINKING = 0x0000_0040;\n\n\t/**\n\t * @notice Enables depositing more ALI to already existing iNFTs\n\t *\n\t * @dev Feature FEATURE_DEPOSITS must be enabled\n\t *      for the `deposit()` function to succeed\n\t */\n\tuint32 public constant FEATURE_DEPOSITS = 0x0000_0008;\n\n\t/**\n\t * @notice Enables ALI withdrawals from the iNFT (without destroying them)\n\t *\n\t * @dev Feature FEATURE_WITHDRAWALS must be enabled\n\t *      for the `withdraw()` function to succeed\n\t */\n\tuint32 public constant FEATURE_WITHDRAWALS = 0x0000_0010;\n\n\t/**\n\t * @notice Link price manager is responsible for updating linking price\n\t *\n\t * @dev Role ROLE_LINK_PRICE_MANAGER allows `updateLinkPrice` execution,\n\t *      and `linkPrice` modification\n\t */\n\tuint32 public constant ROLE_LINK_PRICE_MANAGER = 0x0001_0000;\n\n\t/**\n\t * @notice Next ID manager is responsible for updating `nextId` variable,\n\t *      pointing to the next iNFT ID free slot\n\t *\n\t * @dev Role ROLE_NEXT_ID_MANAGER allows `updateNextId` execution,\n\t *     and `nextId` modification\n\t */\n\tuint32 public constant ROLE_NEXT_ID_MANAGER = 0x0002_0000;\n\n\t/**\n\t * @notice Whitelist manager is responsible for managing the target NFT contracts\n\t *     whitelist, which are the contracts iNFT is allowed to be bound to\n\t *\n\t * @dev Role ROLE_WHITELIST_MANAGER allows `whitelistTargetContract` execution,\n\t *     and `whitelistedTargetContracts` mapping modification\n\t */\n\tuint32 public constant ROLE_WHITELIST_MANAGER = 0x0004_0000;\n\n\t/**\n\t * @dev Fired in link() when new iNFT is created\n\t *\n\t * @param _by an address which executed (and funded) the link function\n\t * @param _iNftId ID of the iNFT minted\n\t * @param _linkPrice amount of ALI tokens locked (transferred) to newly created iNFT\n\t * @param _linkFee amount of ALI tokens charged as a fee and sent to the treasury\n\t * @param _personalityContract AI Personality contract address\n\t * @param _personalityId ID of the AI Personality locked (transferred) to newly created iNFT\n\t * @param _targetContract target NFT smart contract\n\t * @param _targetId target NFT ID (where this iNFT binds to and belongs to)\n\t */\n\tevent Linked(\n\t\taddress indexed _by,\n\t\tuint256 _iNftId,\n\t\tuint96 _linkPrice,\n\t\tuint96 _linkFee,\n\t\taddress indexed _personalityContract,\n\t\tuint96 indexed _personalityId,\n\t\taddress _targetContract,\n\t\tuint256 _targetId\n\t);\n\n\t/**\n\t * @dev Fired in unlink() when an existing iNFT gets destroyed\n\t *\n\t * @param _by an address which executed the unlink function\n\t *      (and which received unlocked AI Personality and ALI tokens)\n\t * @param _iNftId ID of the iNFT burnt\n\t */\n\tevent Unlinked(address indexed _by, uint256 indexed _iNftId);\n\n\t/**\n\t * @dev Fired in deposit(), withdraw() when an iNFT ALI balance gets changed\n\t *\n\t * @param _by an address which executed the deposit/withdraw function\n\t *      (in case of withdraw it received unlocked ALI tokens)\n\t * @param _iNftId ID of the iNFT to update\n\t * @param _aliDelta locked ALI tokens delta, positive for deposit, negative for withdraw\n\t * @param _feeValue amount of ALI tokens charged as a fee\n\t */\n\tevent LinkUpdated(address indexed _by, uint256 indexed _iNftId, int128 _aliDelta, uint96 _feeValue);\n\n\t/**\n\t * @dev Fired in updateLinkPrice()\n\t *\n\t * @param _by an address which executed the operation\n\t * @param _linkPrice new linking price set\n\t * @param _linkFee new linking fee set\n\t * @param _feeDestination new treasury address set\n\t */\n\tevent LinkPriceChanged(address indexed _by, uint96 _linkPrice, uint96 _linkFee, address indexed _feeDestination);\n\n\t/**\n\t * @dev Fired in updateNextId()\n\t *\n\t * @param _by an address which executed the operation\n\t * @param _oldVal old nextId value\n\t * @param _newVal new nextId value\n\t */\n\tevent NextIdChanged(address indexed _by, uint256 _oldVal, uint256 _newVal);\n\n\t/**\n\t * @dev Fired in whitelistTargetContract()\n\t *\n\t * @param _by an address which executed the operation\n\t * @param _targetContract target NFT contract address affected\n\t * @param _oldVal old whitelisted raw value (contains 4 flags)\n\t * @param _newVal new whitelisted raw value (contains 4 flags)\n\t */\n\tevent TargetContractWhitelisted(address indexed _by, address indexed _targetContract, uint8 _oldVal, uint8 _newVal);\n\n\t/**\n\t * @dev NOTE: No postConstruct() initializer function!\n\t *      Contract must not be deployed from scratch, only V2 -> V3 upgrade is supported\n\t */\n\n\t/**\n\t * @notice Links given AI Personality with the given NFT and forms an iNFT.\n\t *      AI Personality specified and `linkPrice` ALI are transferred into minted iNFT\n\t *      and are effectively locked within an iNFT until it is destructed (burnt)\n\t *\n\t * @dev AI Personality and ALI tokens are transferred from the transaction sender account\n\t *      to iNFT smart contract\n\t * @dev Sender must approve both AI Personality and ALI tokens transfers to be\n\t *      performed by the linker contract\n\t *\n\t * @param personalityId AI Personality ID to be locked into iNFT\n\t * @param targetContract NFT address iNFT to be linked to\n\t * @param targetId NFT ID iNFT to be linked to\n\t */\n\tfunction link(uint96 personalityId, address targetContract, uint256 targetId) public virtual {\n\t\t// verify linking is enabled\n\t\trequire(isFeatureEnabled(FEATURE_LINKING), \"linking is disabled\");\n\n\t\t// verify AI Personality belongs to transaction sender\n\t\trequire(ERC721(personalityContract).ownerOf(personalityId) == msg.sender, \"access denied\");\n\t\t// verify NFT contract is either whitelisted or any NFT contract is allowed globally\n\t\trequire(isAllowedForLinking(targetContract), \"not a whitelisted NFT contract\");\n\n\t\t// if linking fee is set\n\t\tif(linkFee > 0) {\n\t\t\t// transfer ALI tokens to the treasury - `feeDestination`\n\t\t\tERC20(aliContract).transferFrom(msg.sender, feeDestination, linkFee);\n\t\t}\n\n\t\t// if linking price is set\n\t\tif(linkPrice > 0) {\n\t\t\t// transfer ALI tokens to iNFT contract to be locked\n\t\t\tERC20(aliContract).transferFrom(msg.sender, iNftContract, linkPrice - linkFee);\n\t\t}\n\n\t\t// transfer AI Personality to iNFT contract to be locked\n\t\tERC721(personalityContract).transferFrom(msg.sender, iNftContract, personalityId);\n\n\t\t// mint the next iNFT, increment next iNFT ID to be minted\n\t\tIntelligentNFTv2(iNftContract).mint(nextId++, linkPrice - linkFee, personalityContract, personalityId, targetContract, targetId);\n\n\t\t// emit an event\n\t\temit Linked(msg.sender, nextId - 1, linkPrice, linkFee, personalityContract, personalityId, targetContract, targetId);\n\t}\n\n\t/**\n\t * @notice Destroys given iNFT, unlinking it from underlying NFT and unlocking\n\t *      the AI Personality and ALI tokens locked in iNFT.\n\t *      AI Personality and ALI tokens are transferred to the underlying NFT owner\n\t *\n\t * @dev Can be executed only by iNFT owner (effectively underlying NFT owner)\n\t *\n\t * @param iNftId ID of the iNFT to unlink\n\t */\n\tfunction unlink(uint256 iNftId) public virtual {\n\t\t// verify unlinking is enabled\n\t\trequire(isFeatureEnabled(FEATURE_UNLINKING), \"unlinking is disabled\");\n\n\t\t// get a link to an iNFT contract to perform several actions with it\n\t\tIntelligentNFTv2 iNFT = IntelligentNFTv2(iNftContract);\n\n\t\t// get target NFT contract address from the iNFT binding\n\t\t(,,,address targetContract,) = iNFT.bindings(iNftId);\n\t\t// verify NFT contract is either whitelisted or any NFT contract is allowed globally\n\t\trequire(isAllowedForUnlinking(targetContract), \"not a whitelisted NFT contract\");\n\n\t\t// verify the transaction is executed by iNFT owner (effectively by underlying NFT owner)\n\t\trequire(iNFT.ownerOf(iNftId) == msg.sender, \"not an iNFT owner\");\n\n\t\t// burn the iNFT unlocking the AI Personality and ALI tokens - delegate to `IntelligentNFTv2.burn`\n\t\tiNFT.burn(iNftId);\n\n\t\t// emit an event\n\t\temit Unlinked(msg.sender, iNftId);\n\t}\n\n\t/**\n\t * @notice Unlinks given NFT by destroying iNFTs and unlocking\n\t *      the AI Personality and ALI tokens locked in iNFTs.\n\t *      AI Personality and ALI tokens are transferred to the underlying NFT owner\n\t *\n\t * @dev Can be executed only by NFT owner (effectively underlying NFT owner)\n\t *\n\t * @param nftContract NFT address iNFTs to be unlinked to\n\t * @param nftId NFT ID iNFTs to be unlinked to\n\t */\n\tfunction unlinkNFT(address nftContract, uint256 nftId) public virtual {\n\t\t// verify unlinking is enabled\n\t\trequire(isFeatureEnabled(FEATURE_UNLINKING), \"unlinking is disabled\");\n\n\t\t// get a link to an iNFT contract to perform several actions with it\n\t\tIntelligentNFTv2 iNFT = IntelligentNFTv2(iNftContract);\n\n\t\t// verify the transaction is executed by NFT owner\n\t\trequire(ERC721(nftContract).ownerOf(nftId) == msg.sender, \"not an NFT owner\");\n\n\t\t// get iNFT ID linked with given NFT\n\t\tuint256 iNftId = iNFT.reverseBindings(nftContract, nftId);\n\n\t\t// verify NFT contract is either whitelisted or any NFT contract is allowed globally\n\t\trequire(isAllowedForUnlinking(nftContract), \"not a whitelisted NFT contract\");\n\n\t\t// burn the iNFT unlocking the AI Personality and ALI tokens - delegate to `IntelligentNFTv2.burn`\n\t\tiNFT.burn(iNftId);\n\n\t\t// emit an event\n\t\temit Unlinked(msg.sender, iNftId);\n\t}\n\n\t/**\n\t * @notice Deposits additional ALI tokens into already existing iNFT\n\t *\n\t * @dev Can be executed only by NFT owner (effectively underlying NFT owner)\n\t *\n\t * @dev ALI tokens are transferred from the transaction sender account to iNFT smart contract\n\t *      Sender must approve ALI tokens transfers to be performed by the linker contract\n\t *\n\t * @param iNftId ID of the iNFT to transfer (and lock) tokens to\n\t * @param aliValue amount of ALI tokens to transfer (and lock)\n\t */\n\tfunction deposit(uint256 iNftId, uint96 aliValue) public virtual {\n\t\t// verify deposits are enabled\n\t\trequire(isFeatureEnabled(FEATURE_DEPOSITS), \"deposits are disabled\");\n\n\t\t// get a link to an iNFT contract to perform several actions with it\n\t\tIntelligentNFTv2 iNFT = IntelligentNFTv2(iNftContract);\n\n\t\t// verify the transaction is executed by iNFT owner (effectively by underlying NFT owner)\n\t\trequire(iNFT.ownerOf(iNftId) == msg.sender, \"not an iNFT owner\");\n\n\t\t// effective ALI value locked in iNFT may get altered according to the linking fee set\n\t\t// init effective fee as if linking fee is not set\n\t\tuint96 _linkFee = 0;\n\t\t// init effective ALI value locked as if linking fee is not set\n\t\tuint96 _aliValue = aliValue;\n\t\t// in case when link price/fee are set (effectively meaning fee percent is set)\n\t\tif(linkPrice != 0 && linkFee != 0) {\n\t\t\t// we need to make sure the fee is charged from the value supplied\n\t\t\t// proportionally to the value supplied and fee percent\n\t\t\t_linkFee = uint96(uint256(_aliValue) * linkFee / linkPrice);\n\n\t\t\t// recalculate ALI value to be locked accordingly\n\t\t\t_aliValue = aliValue - _linkFee;\n\n\t\t\t// transfer ALI tokens to the treasury - `feeDestination`\n\t\t\tERC20(aliContract).transferFrom(msg.sender, feeDestination, _linkFee);\n\t\t}\n\n\t\t// transfer ALI tokens to iNFT contract to be locked\n\t\tERC20(aliContract).transferFrom(msg.sender, iNftContract, _aliValue);\n\n\t\t// update the iNFT record\n\t\tiNFT.increaseAli(iNftId, _aliValue);\n\n\t\t// emit an event\n\t\temit LinkUpdated(msg.sender, iNftId, int128(uint128(_aliValue)), _linkFee);\n\t}\n\n\t/**\n\t * @notice Withdraws some ALI tokens from already existing iNFT without destroying it\n\t *\n\t * @dev Can be executed only by NFT owner (effectively underlying NFT owner)\n\t *\n\t * @dev ALI tokens are transferred to the iNFT owner (transaction executor)\n\t *\n\t * @param iNftId ID of the iNFT to unlock tokens from\n\t * @param aliValue amount of ALI tokens to unlock\n\t */\n\tfunction withdraw(uint256 iNftId, uint96 aliValue) public virtual {\n\t\t// verify withdrawals are enabled\n\t\trequire(isFeatureEnabled(FEATURE_WITHDRAWALS), \"withdrawals are disabled\");\n\n\t\t// get a link to an iNFT contract to perform several actions with it\n\t\tIntelligentNFTv2 iNFT = IntelligentNFTv2(iNftContract);\n\n\t\t// verify the transaction is executed by iNFT owner (effectively by underlying NFT owner)\n\t\trequire(iNFT.ownerOf(iNftId) == msg.sender, \"not an iNFT owner\");\n\n\t\t// ensure iNFT locked balance doesn't go below `linkPrice - linkFee`\n\t\trequire(iNFT.lockedValue(iNftId) >= aliValue + linkPrice, \"deposit too low\");\n\n\t\t// update the iNFT record and transfer tokens back to the iNFT owner\n\t\tiNFT.decreaseAli(iNftId, aliValue, msg.sender);\n\n\t\t// emit an event\n\t\temit LinkUpdated(msg.sender, iNftId, -int128(uint128(aliValue)), 0);\n\t}\n\n\t/**\n\t * @dev Restricted access function to modify\n\t *      - linking price `linkPrice`,\n\t *      - linking fee `linkFee`, and\n\t *      - treasury address `feeDestination`\n\t *\n\t * @dev Requires executor to have ROLE_LINK_PRICE_MANAGER permission\n\t * @dev Requires linking price to be either unset (zero), or not less than 1e12 (0.000001 ALI)\n\t * @dev Requires both linking fee and treasury address to be either set or unset (zero);\n\t *      if set, linking fee must not be less than 1e12 (0.000001 ALI);\n\t *      if set, linking fee must not exceed linking price\n\t *\n\t * @param _linkPrice new linking price to be set\n\t * @param _linkFee new linking fee to be set\n\t * @param _feeDestination treasury address\n\t */\n\tfunction updateLinkPrice(uint96 _linkPrice, uint96 _linkFee, address _feeDestination) public virtual {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_LINK_PRICE_MANAGER), \"access denied\");\n\n\t\t// verify the price is not too low if it's set\n\t\trequire(_linkPrice == 0 || _linkPrice >= 1e12, \"invalid price\");\n\n\t\t// linking fee/treasury should be either both set or both unset\n\t\t// linking fee must not be too low if set\n\t\trequire(_linkFee == 0 && _feeDestination == address(0) || _linkFee >= 1e12 && _feeDestination != address(0), \"invalid linking fee/treasury\");\n\t\t// linking fee must not exceed linking price\n\t\trequire(_linkFee <= _linkPrice, \"linking fee exceeds linking price\");\n\n\t\t// update the linking price, fee, and treasury address\n\t\tlinkPrice = _linkPrice;\n\t\tlinkFee = _linkFee;\n\t\tfeeDestination = _feeDestination;\n\n\t\t// emit an event\n\t\temit LinkPriceChanged(msg.sender, _linkPrice, _linkFee, _feeDestination);\n\t}\n\n\t/**\n\t * @dev Restricted access function to modify next iNFT ID `nextId`\n\t *\n\t * @param _nextId new next iNFT ID to be set\n\t */\n\tfunction updateNextId(uint256 _nextId) public virtual {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_NEXT_ID_MANAGER), \"access denied\");\n\n\t\t// verify nextId is in safe bounds\n\t\trequire(_nextId > 0xFFFF_FFFF, \"value too low\");\n\n\t\t// emit a event\n\t\temit NextIdChanged(msg.sender, nextId, _nextId);\n\n\t\t// update next ID\n\t\tnextId = _nextId;\n\t}\n\n\t/**\n\t * @dev Restricted access function to manage whitelisted / blacklisted NFT contracts mapping\n\t *      `whitelistedTargetContracts`\n\t *\n\t * @dev Requires executor to have ROLE_WHITELIST_MANAGER permission\n\t *\n\t * @param targetContract target NFT contract address to add/remove to/from the whitelist\n\t * @param allowedForLinking true to add, false to remove to/from whitelist (allowed for linking)\n\t * @param allowedForUnlinking true to add, false to remove to/from whitelist (allowed for unlinking)\n\t * @param forbiddenForLinking true to add, false to remove to/from blacklist (forbidden for linking)\n\t * @param forbiddenForUnlinking true to add, false to remove to/from blacklist (forbidden for unlinking)\n\t */\n\tfunction whitelistTargetContract(\n\t\taddress targetContract,\n\t\tbool allowedForLinking,\n\t\tbool allowedForUnlinking,\n\t\tbool forbiddenForLinking,\n\t\tbool forbiddenForUnlinking\n\t) public virtual {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_WHITELIST_MANAGER), \"access denied\");\n\n\t\t// verify the address is set\n\t\trequire(targetContract != address(0), \"zero address\");\n\n\t\t// delisting is always possible, whitelisting - only for valid ERC721\n\t\tif(allowedForLinking) {\n\t\t\t// verify targetContract is a valid ERC721\n\t\t\trequire(ERC165(targetContract).supportsInterface(type(ERC721).interfaceId), \"target NFT is not ERC721\");\n\t\t}\n\n\t\t// derive the uint8 value representing two boolean flags:\n\t\t// Lowest bit (zero) defines if contract is allowed to be linked to;\n\t\t// Next bit (one) defines if contract is allowed to be unlinked from\n\t\tuint8 newVal = (allowedForLinking?     0x1: 0x0)\n\t\t             | (allowedForUnlinking?   0x2: 0x0)\n\t\t             | (forbiddenForLinking?   0x4: 0x0)\n\t\t             | (forbiddenForUnlinking? 0x8: 0x0);\n\n\t\t// emit an event\n\t\temit TargetContractWhitelisted(msg.sender, targetContract, whitelistedTargetContracts[targetContract], newVal);\n\n\t\t// update the contract address in the whitelist\n\t\twhitelistedTargetContracts[targetContract] = newVal;\n\t}\n\n\t/**\n\t * @notice Decodes the bit packed integer in whitelistedTargetContracts into boolean tuple\n\t *\n\t * @dev This function returns the values previously set with `whitelistTargetContract` or\n\t *      (false, false, false, false) if the values were not set\n\t *\n\t * @param targetContract target NFT contract address to read the data from whitelist for\n\t * @return allowedForLinking allowed for linking flag\n\t * @return allowedForUnlinking allowed for unlinking flag\n\t * @return forbiddenForLinking forbidden for linking flag\n\t * @return forbiddenForUnlinking forbidden for unlinking flag\n\t */\n\tfunction isWhitelisted(address targetContract) public view virtual returns(\n\t\tbool allowedForLinking,\n\t\tbool allowedForUnlinking,\n\t\tbool forbiddenForLinking,\n\t\tbool forbiddenForUnlinking\n\t) {\n\t\t// read the int (bit packed) value\n\t\tuint8 val = whitelistedTargetContracts[targetContract];\n\n\t\t// decode into boolean values\n\t\tallowedForLinking     = val & 0x1 == 0x1;\n\t\tallowedForUnlinking   = val & 0x2 == 0x2;\n\t\tforbiddenForLinking   = val & 0x4 == 0x4;\n\t\tforbiddenForUnlinking = val & 0x8 == 0x8;\n\n\t\t// results are returned implicitly\n\t}\n\n\t/**\n\t * @notice Checks if specified target NFT contract is allowed to be linked to\n\t *\n\t * @dev Using this function can be more convenient than accessing the\n\t *      `whitelistedTargetContracts` directly since the mapping contains linking/unlinking\n\t *      flags packed into uint8\n\t *\n\t * @param targetContract target NFT contract address to query for\n\t * @return true if target NFT contract is allowed to be linked to, false otherwise\n\t */\n\tfunction isAllowedForLinking(address targetContract) public view virtual returns (bool) {\n\t\t// extract the information required from the mapping using helper function\n\t\t(bool allowedForLinking,, bool forbiddenForLinking,) = isWhitelisted(targetContract);\n\n\t\t// evaluate the result based on the values read\n\t\treturn !forbiddenForLinking && (allowedForLinking || isFeatureEnabled(FEATURE_ALLOW_ANY_NFT_CONTRACT_FOR_LINKING));\n\t}\n\n\t/**\n\t * @notice Checks if specified target NFT contract is allowed to be unlinked from\n\t *\n\t * @dev Using this function can be more convenient than accessing the\n\t *      `whitelistedTargetContracts` directly since the mapping contains linking/unlinking\n\t *      flags packed into uint8\n\t *\n\t * @param targetContract target NFT contract address to query for\n\t * @return true if target NFT contract is allowed to be unlinked from, false otherwise\n\t */\n\tfunction isAllowedForUnlinking(address targetContract) public view virtual returns (bool) {\n\t\t// extract the information required from the mapping using helper function\n\t\t(, bool allowedForUnlinking,, bool forbiddenForUnlinking) = isWhitelisted(targetContract);\n\n\t\t// evaluate the result based on the values read\n\t\treturn !forbiddenForUnlinking && (allowedForUnlinking || isFeatureEnabled(FEATURE_ALLOW_ANY_NFT_CONTRACT_FOR_UNLINKING));\n\t}\n}\n"
    },
    "contracts/utils/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title Access Control List\n *\n * @notice Access control smart contract provides an API to check\n *      if specific operation is permitted globally and/or\n *      if particular user has a permission to execute it.\n *\n * @notice It deals with two main entities: features and roles.\n *\n * @notice Features are designed to be used to enable/disable specific\n *      functions (public functions) of the smart contract for everyone.\n * @notice User roles are designed to restrict access to specific\n *      functions (restricted functions) of the smart contract to some users.\n *\n * @notice Terms \"role\", \"permissions\" and \"set of permissions\" have equal meaning\n *      in the documentation text and may be used interchangeably.\n * @notice Terms \"permission\", \"single permission\" implies only one permission bit set.\n *\n * @notice Access manager is a special role which allows to grant/revoke other roles.\n *      Access managers can only grant/revoke permissions which they have themselves.\n *      As an example, access manager with no other roles set can only grant/revoke its own\n *      access manager permission and nothing else.\n *\n * @notice Access manager permission should be treated carefully, as a super admin permission:\n *      Access manager with even no other permission can interfere with another account by\n *      granting own access manager permission to it and effectively creating more powerful\n *      permission set than its own.\n *\n * @dev Both current and OpenZeppelin AccessControl implementations feature a similar API\n *      to check/know \"who is allowed to do this thing\".\n * @dev Zeppelin implementation is more flexible:\n *      - it allows setting unlimited number of roles, while current is limited to 256 different roles\n *      - it allows setting an admin for each role, while current allows having only one global admin\n * @dev Current implementation is more lightweight:\n *      - it uses only 1 bit per role, while Zeppelin uses 256 bits\n *      - it allows setting up to 256 roles at once, in a single transaction, while Zeppelin allows\n *        setting only one role in a single transaction\n *\n * @dev This smart contract is designed to be inherited by other\n *      smart contracts which require access control management capabilities.\n *\n * @dev Access manager permission has a bit 255 set.\n *      This bit must not be used by inheriting contracts for any other permissions/features.\n *\n * @author Basil Gorin\n */\ncontract AccessControl {\n\t/**\n\t * @notice Access manager is responsible for assigning the roles to users,\n\t *      enabling/disabling global features of the smart contract\n\t * @notice Access manager can add, remove and update user roles,\n\t *      remove and update global features\n\t *\n\t * @dev Role ROLE_ACCESS_MANAGER allows modifying user roles and global features\n\t * @dev Role ROLE_ACCESS_MANAGER has single bit at position 255 enabled\n\t */\n\tuint256 public constant ROLE_ACCESS_MANAGER = 0x8000000000000000000000000000000000000000000000000000000000000000;\n\n\t/**\n\t * @dev Bitmask representing all the possible permissions (super admin role)\n\t * @dev Has all the bits are enabled (2^256 - 1 value)\n\t */\n\tuint256 private constant FULL_PRIVILEGES_MASK = type(uint256).max; // before 0.8.0: uint256(-1) overflows to 0xFFFF...\n\n\t/**\n\t * @notice Privileged addresses with defined roles/permissions\n\t * @notice In the context of ERC20/ERC721 tokens these can be permissions to\n\t *      allow minting or burning tokens, transferring on behalf and so on\n\t *\n\t * @dev Maps user address to the permissions bitmask (role), where each bit\n\t *      represents a permission\n\t * @dev Bitmask 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n\t *      represents all possible permissions\n\t * @dev 'This' address mapping represents global features of the smart contract\n\t */\n\tmapping(address => uint256) public userRoles;\n\n\t/**\n\t * @dev Fired in updateRole() and updateFeatures()\n\t *\n\t * @param _by operator which called the function\n\t * @param _to address which was granted/revoked permissions\n\t * @param _requested permissions requested\n\t * @param _actual permissions effectively set\n\t */\n\tevent RoleUpdated(address indexed _by, address indexed _to, uint256 _requested, uint256 _actual);\n\n\t/**\n\t * @notice Creates an access control instance,\n\t *      setting contract creator to have full privileges\n\t */\n\tconstructor() {\n\t\t// contract creator has full privileges\n\t\tuserRoles[msg.sender] = FULL_PRIVILEGES_MASK;\n\t}\n\n\t/**\n\t * @notice Retrieves globally set of features enabled\n\t *\n\t * @dev Effectively reads userRoles role for the contract itself\n\t *\n\t * @return 256-bit bitmask of the features enabled\n\t */\n\tfunction features() public view returns(uint256) {\n\t\t// features are stored in 'this' address  mapping of `userRoles` structure\n\t\treturn userRoles[address(this)];\n\t}\n\n\t/**\n\t * @notice Updates set of the globally enabled features (`features`),\n\t *      taking into account sender's permissions\n\t *\n\t * @dev Requires transaction sender to have `ROLE_ACCESS_MANAGER` permission\n\t * @dev Function is left for backward compatibility with older versions\n\t *\n\t * @param _mask bitmask representing a set of features to enable/disable\n\t */\n\tfunction updateFeatures(uint256 _mask) public {\n\t\t// delegate call to `updateRole`\n\t\tupdateRole(address(this), _mask);\n\t}\n\n\t/**\n\t * @notice Updates set of permissions (role) for a given user,\n\t *      taking into account sender's permissions.\n\t *\n\t * @dev Setting role to zero is equivalent to removing an all permissions\n\t * @dev Setting role to `FULL_PRIVILEGES_MASK` is equivalent to\n\t *      copying senders' permissions (role) to the user\n\t * @dev Requires transaction sender to have `ROLE_ACCESS_MANAGER` permission\n\t *\n\t * @param operator address of a user to alter permissions for or zero\n\t *      to alter global features of the smart contract\n\t * @param role bitmask representing a set of permissions to\n\t *      enable/disable for a user specified\n\t */\n\tfunction updateRole(address operator, uint256 role) public {\n\t\t// caller must have a permission to update user roles\n\t\trequire(isSenderInRole(ROLE_ACCESS_MANAGER), \"access denied\");\n\n\t\t// evaluate the role and reassign it\n\t\tuserRoles[operator] = evaluateBy(msg.sender, userRoles[operator], role);\n\n\t\t// fire an event\n\t\temit RoleUpdated(msg.sender, operator, role, userRoles[operator]);\n\t}\n\n\t/**\n\t * @notice Determines the permission bitmask an operator can set on the\n\t *      target permission set\n\t * @notice Used to calculate the permission bitmask to be set when requested\n\t *     in `updateRole` and `updateFeatures` functions\n\t *\n\t * @dev Calculated based on:\n\t *      1) operator's own permission set read from userRoles[operator]\n\t *      2) target permission set - what is already set on the target\n\t *      3) desired permission set - what do we want set target to\n\t *\n\t * @dev Corner cases:\n\t *      1) Operator is super admin and its permission set is `FULL_PRIVILEGES_MASK`:\n\t *        `desired` bitset is returned regardless of the `target` permission set value\n\t *        (what operator sets is what they get)\n\t *      2) Operator with no permissions (zero bitset):\n\t *        `target` bitset is returned regardless of the `desired` value\n\t *        (operator has no authority and cannot modify anything)\n\t *\n\t * @dev Example:\n\t *      Consider an operator with the permissions bitmask     00001111\n\t *      is about to modify the target permission set          01010101\n\t *      Operator wants to set that permission set to          00110011\n\t *      Based on their role, an operator has the permissions\n\t *      to update only lowest 4 bits on the target, meaning that\n\t *      high 4 bits of the target set in this example is left\n\t *      unchanged and low 4 bits get changed as desired:      01010011\n\t *\n\t * @param operator address of the contract operator which is about to set the permissions\n\t * @param target input set of permissions to operator is going to modify\n\t * @param desired desired set of permissions operator would like to set\n\t * @return resulting set of permissions given operator will set\n\t */\n\tfunction evaluateBy(address operator, uint256 target, uint256 desired) public view returns(uint256) {\n\t\t// read operator's permissions\n\t\tuint256 p = userRoles[operator];\n\n\t\t// taking into account operator's permissions,\n\t\t// 1) enable the permissions desired on the `target`\n\t\ttarget |= p & desired;\n\t\t// 2) disable the permissions desired on the `target`\n\t\ttarget &= FULL_PRIVILEGES_MASK ^ (p & (FULL_PRIVILEGES_MASK ^ desired));\n\n\t\t// return calculated result\n\t\treturn target;\n\t}\n\n\t/**\n\t * @notice Checks if requested set of features is enabled globally on the contract\n\t *\n\t * @param required set of features to check against\n\t * @return true if all the features requested are enabled, false otherwise\n\t */\n\tfunction isFeatureEnabled(uint256 required) public view returns(bool) {\n\t\t// delegate call to `__hasRole`, passing `features` property\n\t\treturn __hasRole(features(), required);\n\t}\n\n\t/**\n\t * @notice Checks if transaction sender `msg.sender` has all the permissions required\n\t *\n\t * @param required set of permissions (role) to check against\n\t * @return true if all the permissions requested are enabled, false otherwise\n\t */\n\tfunction isSenderInRole(uint256 required) public view returns(bool) {\n\t\t// delegate call to `isOperatorInRole`, passing transaction sender\n\t\treturn isOperatorInRole(msg.sender, required);\n\t}\n\n\t/**\n\t * @notice Checks if operator has all the permissions (role) required\n\t *\n\t * @param operator address of the user to check role for\n\t * @param required set of permissions (role) to check\n\t * @return true if all the permissions requested are enabled, false otherwise\n\t */\n\tfunction isOperatorInRole(address operator, uint256 required) public view returns(bool) {\n\t\t// delegate call to `__hasRole`, passing operator's permissions (role)\n\t\treturn __hasRole(userRoles[operator], required);\n\t}\n\n\t/**\n\t * @dev Checks if role `actual` contains all the permissions required `required`\n\t *\n\t * @param actual existent role\n\t * @param required required role\n\t * @return true if actual has required role (all permissions), false otherwise\n\t */\n\tfunction __hasRole(uint256 actual, uint256 required) internal pure returns(bool) {\n\t\t// check the bitmask for the role required and return the result\n\t\treturn actual & required == required;\n\t}\n}\n"
    },
    "contracts/utils/UpgradeableAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\n/**\n * @title Upgradeable Access Control List // ERC1967Proxy\n *\n * @notice Access control smart contract provides an API to check\n *      if a specific operation is permitted globally and/or\n *      if a particular user has a permission to execute it.\n *\n * @notice It deals with two main entities: features and roles.\n *\n * @notice Features are designed to be used to enable/disable public functions\n *      of the smart contract (used by a wide audience).\n * @notice User roles are designed to control the access to restricted functions\n *      of the smart contract (used by a limited set of maintainers).\n *\n * @notice Terms \"role\", \"permissions\" and \"set of permissions\" have equal meaning\n *      in the documentation text and may be used interchangeably.\n * @notice Terms \"permission\", \"single permission\" implies only one permission bit set.\n *\n * @notice Access manager is a special role which allows to grant/revoke other roles.\n *      Access managers can only grant/revoke permissions which they have themselves.\n *      As an example, access manager with no other roles set can only grant/revoke its own\n *      access manager permission and nothing else.\n *\n * @notice Access manager permission should be treated carefully, as a super admin permission:\n *      Access manager with even no other permission can interfere with another account by\n *      granting own access manager permission to it and effectively creating more powerful\n *      permission set than its own.\n *\n * @dev Both current and OpenZeppelin AccessControl implementations feature a similar API\n *      to check/know \"who is allowed to do this thing\".\n * @dev Zeppelin implementation is more flexible:\n *      - it allows setting unlimited number of roles, while current is limited to 256 different roles\n *      - it allows setting an admin for each role, while current allows having only one global admin\n * @dev Current implementation is more lightweight:\n *      - it uses only 1 bit per role, while Zeppelin uses 256 bits\n *      - it allows setting up to 256 roles at once, in a single transaction, while Zeppelin allows\n *        setting only one role in a single transaction\n *\n * @dev This smart contract is designed to be inherited by other\n *      smart contracts which require access control management capabilities.\n *\n * @dev Access manager permission has a bit 255 set.\n *      This bit must not be used by inheriting contracts for any other permissions/features.\n *\n * @dev This is an upgradeable version of the ACL, based on Zeppelin implementation for ERC1967,\n *      see https://docs.openzeppelin.com/contracts/4.x/upgradeable\n *      see https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable\n *      see https://forum.openzeppelin.com/t/uups-proxies-tutorial-solidity-javascript/7786\n *\n * @author Basil Gorin\n */\nabstract contract UpgradeableAccessControl is UUPSUpgradeable {\n\t/**\n\t * @notice Privileged addresses with defined roles/permissions\n\t * @notice In the context of ERC20/ERC721 tokens these can be permissions to\n\t *      allow minting or burning tokens, transferring on behalf and so on\n\t *\n\t * @dev Maps user address to the permissions bitmask (role), where each bit\n\t *      represents a permission\n\t * @dev Bitmask 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n\t *      represents all possible permissions\n\t * @dev 'This' address mapping represents global features of the smart contract\n\t */\n\tmapping(address => uint256) public userRoles;\n\n\t/**\n\t * @dev Empty reserved space in storage. The size of the __gap array is calculated so that\n\t *      the amount of storage used by a contract always adds up to the 50.\n\t *      See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n\t */\n\tuint256[49] private __gap;\n\n\t/**\n\t * @notice Access manager is responsible for assigning the roles to users,\n\t *      enabling/disabling global features of the smart contract\n\t * @notice Access manager can add, remove and update user roles,\n\t *      remove and update global features\n\t *\n\t * @dev Role ROLE_ACCESS_MANAGER allows modifying user roles and global features\n\t * @dev Role ROLE_ACCESS_MANAGER has single bit at position 255 enabled\n\t */\n\tuint256 public constant ROLE_ACCESS_MANAGER = 0x8000000000000000000000000000000000000000000000000000000000000000;\n\n\t/**\n\t * @notice Upgrade manager is responsible for smart contract upgrades,\n\t *      see https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable\n\t *      see https://docs.openzeppelin.com/contracts/4.x/upgradeable\n\t *\n\t * @dev Role ROLE_UPGRADE_MANAGER allows passing the _authorizeUpgrade() check\n\t * @dev Role ROLE_UPGRADE_MANAGER has single bit at position 254 enabled\n\t */\n\tuint256 public constant ROLE_UPGRADE_MANAGER = 0x4000000000000000000000000000000000000000000000000000000000000000;\n\n\t/**\n\t * @dev Bitmask representing all the possible permissions (super admin role)\n\t * @dev Has all the bits are enabled (2^256 - 1 value)\n\t */\n\tuint256 private constant FULL_PRIVILEGES_MASK = type(uint256).max; // before 0.8.0: uint256(-1) overflows to 0xFFFF...\n\n\t/**\n\t * @dev Fired in updateRole() and updateFeatures()\n\t *\n\t * @param _by operator which called the function\n\t * @param _to address which was granted/revoked permissions\n\t * @param _requested permissions requested\n\t * @param _actual permissions effectively set\n\t */\n\tevent RoleUpdated(address indexed _by, address indexed _to, uint256 _requested, uint256 _actual);\n\n\t/**\n\t * @dev UUPS initializer, sets the contract owner to have full privileges\n\t *\n\t * @dev Can be executed only in constructor during deployment,\n\t *      reverts when executed in already deployed contract\n\t *\n\t * @dev IMPORTANT:\n\t *      this function MUST be executed during proxy deployment (in proxy constructor),\n\t *      otherwise it renders useless and cannot be executed at all,\n\t *      resulting in no admin control over the proxy and no possibility to do future upgrades\n\t *\n\t * @param _owner smart contract owner having full privileges\n\t */\n\tfunction _postConstruct(address _owner) internal virtual initializer {\n\t\t// ensure this function is execute only in constructor\n\t\trequire(!AddressUpgradeable.isContract(address(this)), \"invalid context\");\n\n\t\t// grant owner full privileges\n\t\tuserRoles[_owner] = FULL_PRIVILEGES_MASK;\n\n\t\t// fire an event\n\t\temit RoleUpdated(msg.sender, _owner, FULL_PRIVILEGES_MASK, FULL_PRIVILEGES_MASK);\n\t}\n\n\t/**\n\t * @notice Returns an address of the implementation smart contract,\n\t *      see ERC1967Upgrade._getImplementation()\n\t *\n\t * @return the current implementation address\n\t */\n\tfunction getImplementation() public view virtual returns (address) {\n\t\t// delegate to `ERC1967Upgrade._getImplementation()`\n\t\treturn _getImplementation();\n\t}\n\n\t/**\n\t * @notice Retrieves globally set of features enabled\n\t *\n\t * @dev Effectively reads userRoles role for the contract itself\n\t *\n\t * @return 256-bit bitmask of the features enabled\n\t */\n\tfunction features() public view returns (uint256) {\n\t\t// features are stored in 'this' address  mapping of `userRoles` structure\n\t\treturn userRoles[address(this)];\n\t}\n\n\t/**\n\t * @notice Updates set of the globally enabled features (`features`),\n\t *      taking into account sender's permissions\n\t *\n\t * @dev Requires transaction sender to have `ROLE_ACCESS_MANAGER` permission\n\t * @dev Function is left for backward compatibility with older versions\n\t *\n\t * @param _mask bitmask representing a set of features to enable/disable\n\t */\n\tfunction updateFeatures(uint256 _mask) public {\n\t\t// delegate call to `updateRole`\n\t\tupdateRole(address(this), _mask);\n\t}\n\n\t/**\n\t * @notice Updates set of permissions (role) for a given user,\n\t *      taking into account sender's permissions.\n\t *\n\t * @dev Setting role to zero is equivalent to removing an all permissions\n\t * @dev Setting role to `FULL_PRIVILEGES_MASK` is equivalent to\n\t *      copying senders' permissions (role) to the user\n\t * @dev Requires transaction sender to have `ROLE_ACCESS_MANAGER` permission\n\t *\n\t * @param operator address of a user to alter permissions for or zero\n\t *      to alter global features of the smart contract\n\t * @param role bitmask representing a set of permissions to\n\t *      enable/disable for a user specified\n\t */\n\tfunction updateRole(address operator, uint256 role) public {\n\t\t// caller must have a permission to update user roles\n\t\trequire(isSenderInRole(ROLE_ACCESS_MANAGER), \"access denied\");\n\n\t\t// evaluate the role and reassign it\n\t\tuserRoles[operator] = evaluateBy(msg.sender, userRoles[operator], role);\n\n\t\t// fire an event\n\t\temit RoleUpdated(msg.sender, operator, role, userRoles[operator]);\n\t}\n\n\t/**\n\t * @notice Determines the permission bitmask an operator can set on the\n\t *      target permission set\n\t * @notice Used to calculate the permission bitmask to be set when requested\n\t *     in `updateRole` and `updateFeatures` functions\n\t *\n\t * @dev Calculated based on:\n\t *      1) operator's own permission set read from userRoles[operator]\n\t *      2) target permission set - what is already set on the target\n\t *      3) desired permission set - what do we want set target to\n\t *\n\t * @dev Corner cases:\n\t *      1) Operator is super admin and its permission set is `FULL_PRIVILEGES_MASK`:\n\t *        `desired` bitset is returned regardless of the `target` permission set value\n\t *        (what operator sets is what they get)\n\t *      2) Operator with no permissions (zero bitset):\n\t *        `target` bitset is returned regardless of the `desired` value\n\t *        (operator has no authority and cannot modify anything)\n\t *\n\t * @dev Example:\n\t *      Consider an operator with the permissions bitmask     00001111\n\t *      is about to modify the target permission set          01010101\n\t *      Operator wants to set that permission set to          00110011\n\t *      Based on their role, an operator has the permissions\n\t *      to update only lowest 4 bits on the target, meaning that\n\t *      high 4 bits of the target set in this example is left\n\t *      unchanged and low 4 bits get changed as desired:      01010011\n\t *\n\t * @param operator address of the contract operator which is about to set the permissions\n\t * @param target input set of permissions to operator is going to modify\n\t * @param desired desired set of permissions operator would like to set\n\t * @return resulting set of permissions given operator will set\n\t */\n\tfunction evaluateBy(address operator, uint256 target, uint256 desired) public view returns (uint256) {\n\t\t// read operator's permissions\n\t\tuint256 p = userRoles[operator];\n\n\t\t// taking into account operator's permissions,\n\t\t// 1) enable the permissions desired on the `target`\n\t\ttarget |= p & desired;\n\t\t// 2) disable the permissions desired on the `target`\n\t\ttarget &= FULL_PRIVILEGES_MASK ^ (p & (FULL_PRIVILEGES_MASK ^ desired));\n\n\t\t// return calculated result\n\t\treturn target;\n\t}\n\n\t/**\n\t * @notice Checks if requested set of features is enabled globally on the contract\n\t *\n\t * @param required set of features to check against\n\t * @return true if all the features requested are enabled, false otherwise\n\t */\n\tfunction isFeatureEnabled(uint256 required) public view returns (bool) {\n\t\t// delegate call to `__hasRole`, passing `features` property\n\t\treturn __hasRole(features(), required);\n\t}\n\n\t/**\n\t * @notice Checks if transaction sender `msg.sender` has all the permissions required\n\t *\n\t * @param required set of permissions (role) to check against\n\t * @return true if all the permissions requested are enabled, false otherwise\n\t */\n\tfunction isSenderInRole(uint256 required) public view returns (bool) {\n\t\t// delegate call to `isOperatorInRole`, passing transaction sender\n\t\treturn isOperatorInRole(msg.sender, required);\n\t}\n\n\t/**\n\t * @notice Checks if operator has all the permissions (role) required\n\t *\n\t * @param operator address of the user to check role for\n\t * @param required set of permissions (role) to check\n\t * @return true if all the permissions requested are enabled, false otherwise\n\t */\n\tfunction isOperatorInRole(address operator, uint256 required) public view returns (bool) {\n\t\t// delegate call to `__hasRole`, passing operator's permissions (role)\n\t\treturn __hasRole(userRoles[operator], required);\n\t}\n\n\t/**\n\t * @dev Checks if role `actual` contains all the permissions required `required`\n\t *\n\t * @param actual existent role\n\t * @param required required role\n\t * @return true if actual has required role (all permissions), false otherwise\n\t */\n\tfunction __hasRole(uint256 actual, uint256 required) internal pure returns (bool) {\n\t\t// check the bitmask for the role required and return the result\n\t\treturn actual & required == required;\n\t}\n\n\t/**\n\t * @inheritdoc UUPSUpgradeable\n\t */\n\tfunction _authorizeUpgrade(address) internal virtual override {\n\t\t// caller must have a permission to upgrade the contract\n\t\trequire(isSenderInRole(ROLE_UPGRADE_MANAGER), \"access denied\");\n\t}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}