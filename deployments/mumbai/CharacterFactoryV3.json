{
    "address": "0xfB0A28D5Ba2A238E1F0cd82cD459a0cAc3db1F3A",
    "abi": [
      {
        "inputs": [
          {
            "internalType": "uint256",
            "name": "_totalMintHardcap",
            "type": "uint256"
          }
        ],
        "stateMutability": "nonpayable",
        "type": "constructor"
      },
      {
        "anonymous": false,
        "inputs": [
          {
            "indexed": true,
            "internalType": "address",
            "name": "authorizer",
            "type": "address"
          },
          {
            "indexed": true,
            "internalType": "bytes32",
            "name": "nonce",
            "type": "bytes32"
          }
        ],
        "name": "AuthorizationCanceled",
        "type": "event"
      },
      {
        "anonymous": false,
        "inputs": [
          {
            "indexed": true,
            "internalType": "address",
            "name": "authorizer",
            "type": "address"
          },
          {
            "indexed": true,
            "internalType": "bytes32",
            "name": "nonce",
            "type": "bytes32"
          }
        ],
        "name": "AuthorizationUsed",
        "type": "event"
      },
      {
        "anonymous": false,
        "inputs": [
          {
            "indexed": true,
            "internalType": "address",
            "name": "erc721Address",
            "type": "address"
          },
          {
            "indexed": true,
            "internalType": "address",
            "name": "to",
            "type": "address"
          },
          {
            "indexed": true,
            "internalType": "uint256",
            "name": "tokenId",
            "type": "uint256"
          }
        ],
        "name": "Minted",
        "type": "event"
      },
      {
        "anonymous": false,
        "inputs": [
          {
            "indexed": true,
            "internalType": "address",
            "name": "_by",
            "type": "address"
          },
          {
            "indexed": true,
            "internalType": "address",
            "name": "_to",
            "type": "address"
          },
          {
            "indexed": false,
            "internalType": "uint256",
            "name": "_requested",
            "type": "uint256"
          },
          {
            "indexed": false,
            "internalType": "uint256",
            "name": "_actual",
            "type": "uint256"
          }
        ],
        "name": "RoleUpdated",
        "type": "event"
      },
      {
        "anonymous": false,
        "inputs": [
          {
            "indexed": true,
            "internalType": "address",
            "name": "authorizer",
            "type": "address"
          },
          {
            "indexed": false,
            "internalType": "uint256",
            "name": "oldLimit",
            "type": "uint256"
          },
          {
            "indexed": false,
            "internalType": "uint256",
            "name": "newLimit",
            "type": "uint256"
          }
        ],
        "name": "TotalMintHardcapUpdated",
        "type": "event"
      },
      {
        "inputs": [],
        "name": "CANCEL_AUTHORIZATION_TYPEHASH",
        "outputs": [
          {
            "internalType": "bytes32",
            "name": "",
            "type": "bytes32"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [],
        "name": "DOMAIN_SEPARATOR",
        "outputs": [
          {
            "internalType": "bytes32",
            "name": "",
            "type": "bytes32"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [],
        "name": "DOMAIN_TYPEHASH",
        "outputs": [
          {
            "internalType": "bytes32",
            "name": "",
            "type": "bytes32"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [],
        "name": "FEATURE_MINTING_WITH_AUTH",
        "outputs": [
          {
            "internalType": "uint32",
            "name": "",
            "type": "uint32"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [],
        "name": "MINT_WITH_AUTHORIZATION_TYPEHASH",
        "outputs": [
          {
            "internalType": "bytes32",
            "name": "",
            "type": "bytes32"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [],
        "name": "ROLE_ACCESS_MANAGER",
        "outputs": [
          {
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [],
        "name": "ROLE_FACTORY_MINTER",
        "outputs": [
          {
            "internalType": "uint32",
            "name": "",
            "type": "uint32"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [],
        "name": "ROLE_MINT_HARDCAP_MANAGER",
        "outputs": [
          {
            "internalType": "uint32",
            "name": "",
            "type": "uint32"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "address",
            "name": "_authorizer",
            "type": "address"
          },
          {
            "internalType": "bytes32",
            "name": "_nonce",
            "type": "bytes32"
          }
        ],
        "name": "authorizationState",
        "outputs": [
          {
            "internalType": "bool",
            "name": "",
            "type": "bool"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "address",
            "name": "_authorizer",
            "type": "address"
          },
          {
            "internalType": "bytes32",
            "name": "_nonce",
            "type": "bytes32"
          },
          {
            "internalType": "uint8",
            "name": "v",
            "type": "uint8"
          },
          {
            "internalType": "bytes32",
            "name": "r",
            "type": "bytes32"
          },
          {
            "internalType": "bytes32",
            "name": "s",
            "type": "bytes32"
          }
        ],
        "name": "cancelAuthorization",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "bytes32",
            "name": "_nonce",
            "type": "bytes32"
          }
        ],
        "name": "cancelAuthorization",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "address",
            "name": "operator",
            "type": "address"
          },
          {
            "internalType": "uint256",
            "name": "target",
            "type": "uint256"
          },
          {
            "internalType": "uint256",
            "name": "desired",
            "type": "uint256"
          }
        ],
        "name": "evaluateBy",
        "outputs": [
          {
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [],
        "name": "features",
        "outputs": [
          {
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "uint256",
            "name": "required",
            "type": "uint256"
          }
        ],
        "name": "isFeatureEnabled",
        "outputs": [
          {
            "internalType": "bool",
            "name": "",
            "type": "bool"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "address",
            "name": "operator",
            "type": "address"
          },
          {
            "internalType": "uint256",
            "name": "required",
            "type": "uint256"
          }
        ],
        "name": "isOperatorInRole",
        "outputs": [
          {
            "internalType": "bool",
            "name": "",
            "type": "bool"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "uint256",
            "name": "required",
            "type": "uint256"
          }
        ],
        "name": "isSenderInRole",
        "outputs": [
          {
            "internalType": "bool",
            "name": "",
            "type": "bool"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "address",
            "name": "_targetErc721",
            "type": "address"
          },
          {
            "internalType": "address",
            "name": "_to",
            "type": "address"
          },
          {
            "internalType": "uint256",
            "name": "_tokenId",
            "type": "uint256"
          }
        ],
        "name": "mint",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "address",
            "name": "_targetErc721",
            "type": "address"
          },
          {
            "internalType": "address",
            "name": "_to",
            "type": "address"
          },
          {
            "internalType": "uint256",
            "name": "_tokenId",
            "type": "uint256"
          },
          {
            "internalType": "uint256",
            "name": "_validAfter",
            "type": "uint256"
          },
          {
            "internalType": "uint256",
            "name": "_validBefore",
            "type": "uint256"
          },
          {
            "internalType": "bytes32",
            "name": "_nonce",
            "type": "bytes32"
          },
          {
            "internalType": "uint8",
            "name": "v",
            "type": "uint8"
          },
          {
            "internalType": "bytes32",
            "name": "r",
            "type": "bytes32"
          },
          {
            "internalType": "bytes32",
            "name": "s",
            "type": "bytes32"
          }
        ],
        "name": "mintWithAuthorization",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
      },
      {
        "inputs": [],
        "name": "totalMint",
        "outputs": [
          {
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [],
        "name": "totalMintHardcap",
        "outputs": [
          {
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "uint256",
            "name": "_mask",
            "type": "uint256"
          }
        ],
        "name": "updateFeatures",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "address",
            "name": "operator",
            "type": "address"
          },
          {
            "internalType": "uint256",
            "name": "role",
            "type": "uint256"
          }
        ],
        "name": "updateRole",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "uint256",
            "name": "_totalMintHardcap",
            "type": "uint256"
          }
        ],
        "name": "updateTotalMintHardcap",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "address",
            "name": "",
            "type": "address"
          }
        ],
        "name": "userRoles",
        "outputs": [
          {
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      }
    ],
    "transactionHash": "0xc2b46302517d83098fa26be6ebdda5888adfe362f51795709a0f6acf2cc37ef4",
    "receipt": {
      "to": null,
      "from": "0xfB085D724583E4fFf5A8aCe5651511b04CAe0b6c",
      "contractAddress": "0xfB0A28D5Ba2A238E1F0cd82cD459a0cAc3db1F3A",
      "transactionIndex": 3,
      "gasUsed": "942479",
      "logsBloom": "0x00000000000000020000000000000000000000000000000000000000000000000000000000000000000000004000000000008000000000000000000000000000000000000000000000000000000000800000000000000000000100000000000000000008000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000000000002000000200000000000000020000000000000000001000000000000000000000000004000000000000000000001000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000100000",
      "blockHash": "0xf88a963077e06636dba9e7947d52ade80d2529ea6d784c40c944165702507a9d",
      "transactionHash": "0xc2b46302517d83098fa26be6ebdda5888adfe362f51795709a0f6acf2cc37ef4",
      "logs": [
        {
          "transactionIndex": 3,
          "blockNumber": 36310593,
          "transactionHash": "0xc2b46302517d83098fa26be6ebdda5888adfe362f51795709a0f6acf2cc37ef4",
          "address": "0x0000000000000000000000000000000000001010",
          "topics": [
            "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
            "0x0000000000000000000000000000000000000000000000000000000000001010",
            "0x000000000000000000000000fb085d724583e4fff5a8ace5651511b04cae0b6c",
            "0x000000000000000000000000c26880a0af2ea0c7e8130e6ec47af756465452e8"
          ],
          "data": "0x0000000000000000000000000000000000000000000000000093a99f73d85e100000000000000000000000000000000000000000000000000c3417318abff2a6000000000000000000000000000000000000000000001fba815b2b0787a53ffb0000000000000000000000000000000000000000000000000ba06d9216e79496000000000000000000000000000000000000000000001fba81eed4a6fb7d9e0b",
          "logIndex": 9,
          "blockHash": "0xf88a963077e06636dba9e7947d52ade80d2529ea6d784c40c944165702507a9d"
        }
      ],
      "blockNumber": 36310593,
      "cumulativeGasUsed": "1754940",
      "status": 1,
      "byzantium": true
    },
    "args": [
      10000
    ],
    "numDeployments": 1,
    "solcInputHash": "4cde0e91cd97c7c23a3014052276f151",
    "metadata": "{\"compiler\":{\"version\":\"0.8.15+commit.e14f2714\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalMintHardcap\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"authorizer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"nonce\",\"type\":\"bytes32\"}],\"name\":\"AuthorizationCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"authorizer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"nonce\",\"type\":\"bytes32\"}],\"name\":\"AuthorizationUsed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"erc721Address\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Minted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_by\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_requested\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_actual\",\"type\":\"uint256\"}],\"name\":\"RoleUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"authorizer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldLimit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newLimit\",\"type\":\"uint256\"}],\"name\":\"TotalMintHardcapUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CANCEL_AUTHORIZATION_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DOMAIN_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FEATURE_MINTING_WITH_AUTH\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MINT_WITH_AUTHORIZATION_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ROLE_ACCESS_MANAGER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ROLE_FACTORY_MINTER\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ROLE_MINT_HARDCAP_MANAGER\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_authorizer\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_nonce\",\"type\":\"bytes32\"}],\"name\":\"authorizationState\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_authorizer\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_nonce\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"cancelAuthorization\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_nonce\",\"type\":\"bytes32\"}],\"name\":\"cancelAuthorization\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"target\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"desired\",\"type\":\"uint256\"}],\"name\":\"evaluateBy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"features\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"required\",\"type\":\"uint256\"}],\"name\":\"isFeatureEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"required\",\"type\":\"uint256\"}],\"name\":\"isOperatorInRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"required\",\"type\":\"uint256\"}],\"name\":\"isSenderInRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_targetErc721\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_targetErc721\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_validAfter\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_validBefore\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_nonce\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"mintWithAuthorization\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalMint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalMintHardcap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_mask\",\"type\":\"uint256\"}],\"name\":\"updateFeatures\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"role\",\"type\":\"uint256\"}],\"name\":\"updateRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalMintHardcap\",\"type\":\"uint256\"}],\"name\":\"updateTotalMintHardcap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userRoles\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"The signature is constructed via EIP-712 similar to EIP-2612, or EIP-3009Target ERC721 contract(s) must allow helper to mint the tokens, this should be configured      as part of the deployment or setup processesVersion 3 (NFTFactoryV3) adds total mint limiting feature allowing to set the NFT total     mint hardcap; factory stops minting when total mint of the contract reaches the hardcap\",\"events\":{\"AuthorizationCanceled(address,bytes32)\":{\"details\":\"Fired whenever the nonce gets cancelled (ex.: `cancelAuthorization`)Both `AuthorizationUsed` and `AuthorizationCanceled` imply the nonce      cannot be longer used, the only difference is that `AuthorizationCanceled`      implies no smart contract state change made (except the nonce marked as cancelled)\",\"params\":{\"authorizer\":\"an address which has cancelled the nonce\",\"nonce\":\"the nonce cancelled\"}},\"AuthorizationUsed(address,bytes32)\":{\"details\":\"Fired whenever the nonce gets used (ex.: `transferWithAuthorization`, `receiveWithAuthorization`)\",\"params\":{\"authorizer\":\"an address which has used the nonce\",\"nonce\":\"the nonce used\"}},\"Minted(address,address,uint256)\":{\"details\":\"Fired in mint() and mintWithAuthorization() after an NFT is minted\",\"params\":{\"erc721Address\":\"ERC721 contract address which was minted\",\"to\":\"an address NFT was minted to\",\"tokenId\":\"NFT ID which was minted\"}},\"TotalMintHardcapUpdated(address,uint256,uint256)\":{\"details\":\"Fired whenever total mint hardcap is updated (ex.: `updateTotalMintHardcap`)\",\"params\":{\"authorizer\":\"an address which has updated total mint hardcap\",\"newLimit\":\"new total mint hardcap\",\"oldLimit\":\"old total mint hardcap\"}}},\"kind\":\"dev\",\"methods\":{\"authorizationState(address,bytes32)\":{\"details\":\"Nonces are expected to be client-side randomly generated 32-byte data      unique to the authorizer's address\",\"params\":{\"_authorizer\":\"Authorizer's address\",\"_nonce\":\"Nonce of the authorization\"},\"returns\":{\"_0\":\"true if the nonce is used\"}},\"cancelAuthorization(address,bytes32,uint8,bytes32,bytes32)\":{\"params\":{\"_authorizer\":\"transaction authorizer\",\"_nonce\":\"unique random nonce to cancel (mark as used)\",\"r\":\"half of the ECDSA signature pair\",\"s\":\"half of the ECDSA signature pair\",\"v\":\"the recovery byte of the signature\"}},\"cancelAuthorization(bytes32)\":{\"params\":{\"_nonce\":\"unique random nonce to cancel (mark as used)\"}},\"constructor\":{\"params\":{\"_totalMintHardcap\":\"NFTFactoryV3 total mint limit, factory stops minting the ERC721      if its total mint (totalMint()) reaches the total mint hardcap (totalMintHardcap())\"}},\"evaluateBy(address,uint256,uint256)\":{\"details\":\"Calculated based on:      1) operator's own permission set read from userRoles[operator]      2) target permission set - what is already set on the target      3) desired permission set - what do we want set target toCorner cases:      1) Operator is super admin and its permission set is `FULL_PRIVILEGES_MASK`:        `desired` bitset is returned regardless of the `target` permission set value        (what operator sets is what they get)      2) Operator with no permissions (zero bitset):        `target` bitset is returned regardless of the `desired` value        (operator has no authority and cannot modify anything)Example:      Consider an operator with the permissions bitmask     00001111      is about to modify the target permission set          01010101      Operator wants to set that permission set to          00110011      Based on their role, an operator has the permissions      to update only lowest 4 bits on the target, meaning that      high 4 bits of the target set in this example is left      unchanged and low 4 bits get changed as desired:      01010011\",\"params\":{\"desired\":\"desired set of permissions operator would like to set\",\"operator\":\"address of the contract operator which is about to set the permissions\",\"target\":\"input set of permissions to operator is going to modify\"},\"returns\":{\"_0\":\"resulting set of permissions given operator will set\"}},\"features()\":{\"details\":\"Effectively reads userRoles role for the contract itself\",\"returns\":{\"_0\":\"256-bit bitmask of the features enabled\"}},\"isFeatureEnabled(uint256)\":{\"params\":{\"required\":\"set of features to check against\"},\"returns\":{\"_0\":\"true if all the features requested are enabled, false otherwise\"}},\"isOperatorInRole(address,uint256)\":{\"params\":{\"operator\":\"address of the user to check role for\",\"required\":\"set of permissions (role) to check\"},\"returns\":{\"_0\":\"true if all the permissions requested are enabled, false otherwise\"}},\"isSenderInRole(uint256)\":{\"params\":{\"required\":\"set of permissions (role) to check against\"},\"returns\":{\"_0\":\"true if all the permissions requested are enabled, false otherwise\"}},\"mint(address,address,uint256)\":{\"details\":\"Doesn't allow minting the token with ID zeroRequires an executor to have ROLE_MINTER permissionRequires target ERC721 contract to be mintable (`MintableERC721`)Requires target ERC721 contract instance to allow minting via helper\",\"params\":{\"_targetErc721\":\"target ERC721 contract instance to mint token on,      compatible with `MintableERC721`\",\"_to\":\"an address to mint token to\",\"_tokenId\":\"target ERC721 token ID to mint\"}},\"mintWithAuthorization(address,address,uint256,uint256,uint256,bytes32,uint8,bytes32,bytes32)\":{\"params\":{\"_nonce\":\"unique random nonce\",\"_targetErc721\":\"target ERC721 contract instance to mint token on,      compatible with `MintableERC721`\",\"_to\":\"an address to mint token to\",\"_tokenId\":\"target ERC721 token ID to mint\",\"_validAfter\":\"signature valid after time (unix timestamp)\",\"_validBefore\":\"signature valid before time (unix timestamp)\",\"r\":\"half of the ECDSA signature pair\",\"s\":\"half of the ECDSA signature pair\",\"v\":\"the recovery byte of the signature\"}},\"updateFeatures(uint256)\":{\"details\":\"Requires transaction sender to have `ROLE_ACCESS_MANAGER` permissionFunction is left for backward compatibility with older versions\",\"params\":{\"_mask\":\"bitmask representing a set of features to enable/disable\"}},\"updateRole(address,uint256)\":{\"details\":\"Setting role to zero is equivalent to removing an all permissionsSetting role to `FULL_PRIVILEGES_MASK` is equivalent to      copying senders' permissions (role) to the userRequires transaction sender to have `ROLE_ACCESS_MANAGER` permission\",\"params\":{\"operator\":\"address of a user to alter permissions for or zero      to alter global features of the smart contract\",\"role\":\"bitmask representing a set of permissions to      enable/disable for a user specified\"}},\"updateTotalMintHardcap(uint256)\":{\"details\":\"Requires transaction sender to have `ROLE_MINT_HARDCAP_MANAGER` permission\",\"params\":{\"_totalMintHardcap\":\"new NFTFactoryV3 total mint hardcap\"}}},\"stateVariables\":{\"DOMAIN_TYPEHASH\":{\"details\":\"Note: we do not include version into the domain typehash/separator,      it is implied version is concatenated to the name field, like \\\"NFTFactoryV2\\\"\"},\"FEATURE_MINTING_WITH_AUTH\":{\"details\":\"Feature FEATURE_MINTING_WITH_AUTH must be enabled in order for      `mintWithAuthorization()` function to succeed\"},\"ROLE_FACTORY_MINTER\":{\"details\":\"Role ROLE_FACTORY_MINTER allows minting tokens      (executing `mint` function)\"},\"ROLE_MINT_HARDCAP_MANAGER\":{\"details\":\"Role ROLE_MINT_HARDCAP_MANAGER allows updating total mint hardcap      (executing `updateTotalMintHardcap` function)\"},\"totalMint\":{\"details\":\"Number of ERC721 token been mint by NFTFactoryV3\"},\"totalMintHardcap\":{\"details\":\"The factory `mint` and `mintWithAuthorization` function throws      if factory `totalMint` value is equal or bigger than `totalMintHardcap`\"},\"usedNonces\":{\"details\":\"A record of used nonces for EIP-712 transactionsA record of used nonces for signing/validating signatures      in `mintWithAuthorization` for every mintMaps authorizer address => nonce => true/false (used unused)\"}},\"title\":\"Alethea NFT Factory\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"CANCEL_AUTHORIZATION_TYPEHASH()\":{\"notice\":\"EIP-712 CancelAuthorization struct typeHash,      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\"},\"DOMAIN_SEPARATOR()\":{\"notice\":\"EIP-712 contract's domain separator,      see https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator\"},\"DOMAIN_TYPEHASH()\":{\"notice\":\"EIP-712 contract's domain typeHash,      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\"},\"FEATURE_MINTING_WITH_AUTH()\":{\"notice\":\"Enables meta transaction minting (minting with an authorization      via an EIP712 signature)\"},\"MINT_WITH_AUTHORIZATION_TYPEHASH()\":{\"notice\":\"EIP-712 MintWithAuthorization struct typeHash,      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\"},\"ROLE_ACCESS_MANAGER()\":{\"notice\":\"Access manager is responsible for assigning the roles to users,      enabling/disabling global features of the smart contractAccess manager can add, remove and update user roles,      remove and update global features\"},\"ROLE_FACTORY_MINTER()\":{\"notice\":\"Factory minter is responsible for creating (minting)      tokens to an arbitrary address\"},\"ROLE_MINT_HARDCAP_MANAGER()\":{\"notice\":\"Mint hardcap manager is responsible for updating      NFTFactoryV3 total mint hardcap\"},\"authorizationState(address,bytes32)\":{\"notice\":\"Returns the state of an authorization, more specifically      if the specified nonce was already used by the address specified\"},\"cancelAuthorization(address,bytes32,uint8,bytes32,bytes32)\":{\"notice\":\"Cancels the authorization (using EIP-712 signature)\"},\"cancelAuthorization(bytes32)\":{\"notice\":\"Cancels the authorization\"},\"constructor\":{\"notice\":\"Deploys the helper contract and initializes DOMAIN_SEPARATOR using the created smart contract address\"},\"evaluateBy(address,uint256,uint256)\":{\"notice\":\"Determines the permission bitmask an operator can set on the      target permission setUsed to calculate the permission bitmask to be set when requested     in `updateRole` and `updateFeatures` functions\"},\"features()\":{\"notice\":\"Retrieves globally set of features enabled\"},\"isFeatureEnabled(uint256)\":{\"notice\":\"Checks if requested set of features is enabled globally on the contract\"},\"isOperatorInRole(address,uint256)\":{\"notice\":\"Checks if operator has all the permissions (role) required\"},\"isSenderInRole(uint256)\":{\"notice\":\"Checks if transaction sender `msg.sender` has all the permissions required\"},\"mint(address,address,uint256)\":{\"notice\":\"Restricted access function to mint an NFT\"},\"mintWithAuthorization(address,address,uint256,uint256,uint256,bytes32,uint8,bytes32,bytes32)\":{\"notice\":\"Executes a mint function with a signed authorization\"},\"totalMintHardcap()\":{\"notice\":\"Total Mint Hardcap affects factory capability to mint: once      factory total mint reaches the hardcap, factory stops minting it\"},\"updateFeatures(uint256)\":{\"notice\":\"Updates set of the globally enabled features (`features`),      taking into account sender's permissions\"},\"updateRole(address,uint256)\":{\"notice\":\"Updates set of permissions (role) for a given user,      taking into account sender's permissions.\"},\"updateTotalMintHardcap(uint256)\":{\"notice\":\"Updates total mint hardcap of NFTFactoryV3 contract.\"},\"userRoles(address)\":{\"notice\":\"Privileged addresses with defined roles/permissionsIn the context of ERC20/ERC721 tokens these can be permissions to      allow minting or burning tokens, transferring on behalf and so on\"}},\"notice\":\"NFT Factory is a helper smart contract responsible for minting arbitrary NFTsIt supports two mechanisms:      - minting delegation: authorized address executes mint function on the helper,        and helper executes minting function on the target ERC721 contract as an internal transaction      - meta transaction minting or minting with an authorization: authorized address signs        the minting authorization message and any address executes mint function on the helperSecond mechanism allows to shift the gas costs for the transaction to any address      (usually this is the NFT beneficiary - an address which receives an NFT)\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/protocol/NFTFactoryV3.sol\":\"NFTFactoryV3\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/interfaces/ERC165Spec.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/**\\n * @title ERC-165 Standard Interface Detection\\n *\\n * @dev Interface of the ERC165 standard, as defined in the\\n *       https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * @dev Implementers can declare support of contract interfaces,\\n *      which can then be queried by others.\\n *\\n * @author Christian Reitwie\\u00dfner, Nick Johnson, Fabian Vogelsteller, Jordi Baylina, Konrad Feldmeier, William Entriken\\n */\\ninterface ERC165 {\\n\\t/**\\n\\t * @notice Query if a contract implements an interface\\n\\t *\\n\\t * @dev Interface identification is specified in ERC-165.\\n\\t *      This function uses less than 30,000 gas.\\n\\t *\\n\\t * @param interfaceID The interface identifier, as specified in ERC-165\\n\\t * @return `true` if the contract implements `interfaceID` and\\n\\t *      `interfaceID` is not 0xffffffff, `false` otherwise\\n\\t */\\n\\tfunction supportsInterface(bytes4 interfaceID) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x9b8e0a0ee2ddff1014108266f62a95dab3f76f08deba2e6177ec2ed251128f9d\",\"license\":\"MIT\"},\"contracts/interfaces/ERC721Spec.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"./ERC165Spec.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard\\n *\\n * @notice See https://eips.ethereum.org/EIPS/eip-721\\n *\\n * @dev Solidity issue #3412: The ERC721 interfaces include explicit mutability guarantees for each function.\\n *      Mutability guarantees are, in order weak to strong: payable, implicit nonpayable, view, and pure.\\n *      Implementation MUST meet the mutability guarantee in this interface and MAY meet a stronger guarantee.\\n *      For example, a payable function in this interface may be implemented as nonpayable\\n *      (no state mutability specified) in implementing contract.\\n *      It is expected a later Solidity release will allow stricter contract to inherit from this interface,\\n *      but current workaround is that we edit this interface to add stricter mutability before inheriting:\\n *      we have removed all \\\"payable\\\" modifiers.\\n *\\n * @dev The ERC-165 identifier for this interface is 0x80ac58cd.\\n *\\n * @author William Entriken, Dieter Shirley, Jacob Evans, Nastassia Sachs\\n */\\ninterface ERC721 is ERC165 {\\n\\t/// @dev This emits when ownership of any NFT changes by any mechanism.\\n\\t///  This event emits when NFTs are created (`from` == 0) and destroyed\\n\\t///  (`to` == 0). Exception: during contract creation, any number of NFTs\\n\\t///  may be created and assigned without emitting Transfer. At the time of\\n\\t///  any transfer, the approved address for that NFT (if any) is reset to none.\\n\\tevent Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\\n\\n\\t/// @dev This emits when the approved address for an NFT is changed or\\n\\t///  reaffirmed. The zero address indicates there is no approved address.\\n\\t///  When a Transfer event emits, this also indicates that the approved\\n\\t///  address for that NFT (if any) is reset to none.\\n\\tevent Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\\n\\n\\t/// @dev This emits when an operator is enabled or disabled for an owner.\\n\\t///  The operator can manage all NFTs of the owner.\\n\\tevent ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\\n\\n\\t/// @notice Count all NFTs assigned to an owner\\n\\t/// @dev NFTs assigned to the zero address are considered invalid, and this\\n\\t///  function throws for queries about the zero address.\\n\\t/// @param _owner An address for whom to query the balance\\n\\t/// @return The number of NFTs owned by `_owner`, possibly zero\\n\\tfunction balanceOf(address _owner) external view returns (uint256);\\n\\n\\t/// @notice Find the owner of an NFT\\n\\t/// @dev NFTs assigned to zero address are considered invalid, and queries\\n\\t///  about them do throw.\\n\\t/// @param _tokenId The identifier for an NFT\\n\\t/// @return The address of the owner of the NFT\\n\\tfunction ownerOf(uint256 _tokenId) external view returns (address);\\n\\n\\t/// @notice Transfers the ownership of an NFT from one address to another address\\n\\t/// @dev Throws unless `msg.sender` is the current owner, an authorized\\n\\t///  operator, or the approved address for this NFT. Throws if `_from` is\\n\\t///  not the current owner. Throws if `_to` is the zero address. Throws if\\n\\t///  `_tokenId` is not a valid NFT. When transfer is complete, this function\\n\\t///  checks if `_to` is a smart contract (code size > 0). If so, it calls\\n\\t///  `onERC721Received` on `_to` and throws if the return value is not\\n\\t///  `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`.\\n\\t/// @param _from The current owner of the NFT\\n\\t/// @param _to The new owner\\n\\t/// @param _tokenId The NFT to transfer\\n\\t/// @param _data Additional data with no specified format, sent in call to `_to`\\n\\tfunction safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external /*payable*/;\\n\\n\\t/// @notice Transfers the ownership of an NFT from one address to another address\\n\\t/// @dev This works identically to the other function with an extra data parameter,\\n\\t///  except this function just sets data to \\\"\\\".\\n\\t/// @param _from The current owner of the NFT\\n\\t/// @param _to The new owner\\n\\t/// @param _tokenId The NFT to transfer\\n\\tfunction safeTransferFrom(address _from, address _to, uint256 _tokenId) external /*payable*/;\\n\\n\\t/// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\\n\\t///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\\n\\t///  THEY MAY BE PERMANENTLY LOST\\n\\t/// @dev Throws unless `msg.sender` is the current owner, an authorized\\n\\t///  operator, or the approved address for this NFT. Throws if `_from` is\\n\\t///  not the current owner. Throws if `_to` is the zero address. Throws if\\n\\t///  `_tokenId` is not a valid NFT.\\n\\t/// @param _from The current owner of the NFT\\n\\t/// @param _to The new owner\\n\\t/// @param _tokenId The NFT to transfer\\n\\tfunction transferFrom(address _from, address _to, uint256 _tokenId) external /*payable*/;\\n\\n\\t/// @notice Change or reaffirm the approved address for an NFT\\n\\t/// @dev The zero address indicates there is no approved address.\\n\\t///  Throws unless `msg.sender` is the current NFT owner, or an authorized\\n\\t///  operator of the current owner.\\n\\t/// @param _approved The new approved NFT controller\\n\\t/// @param _tokenId The NFT to approve\\n\\tfunction approve(address _approved, uint256 _tokenId) external /*payable*/;\\n\\n\\t/// @notice Enable or disable approval for a third party (\\\"operator\\\") to manage\\n\\t///  all of `msg.sender`'s assets\\n\\t/// @dev Emits the ApprovalForAll event. The contract MUST allow\\n\\t///  multiple operators per owner.\\n\\t/// @param _operator Address to add to the set of authorized operators\\n\\t/// @param _approved True if the operator is approved, false to revoke approval\\n\\tfunction setApprovalForAll(address _operator, bool _approved) external;\\n\\n\\t/// @notice Get the approved address for a single NFT\\n\\t/// @dev Throws if `_tokenId` is not a valid NFT.\\n\\t/// @param _tokenId The NFT to find the approved address for\\n\\t/// @return The approved address for this NFT, or the zero address if there is none\\n\\tfunction getApproved(uint256 _tokenId) external view returns (address);\\n\\n\\t/// @notice Query if an address is an authorized operator for another address\\n\\t/// @param _owner The address that owns the NFTs\\n\\t/// @param _operator The address that acts on behalf of the owner\\n\\t/// @return True if `_operator` is an approved operator for `_owner`, false otherwise\\n\\tfunction isApprovedForAll(address _owner, address _operator) external view returns (bool);\\n}\\n\\n/// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.\\ninterface ERC721TokenReceiver {\\n\\t/// @notice Handle the receipt of an NFT\\n\\t/// @dev The ERC721 smart contract calls this function on the recipient\\n\\t///  after a `transfer`. This function MAY throw to revert and reject the\\n\\t///  transfer. Return of other than the magic value MUST result in the\\n\\t///  transaction being reverted.\\n\\t///  Note: the contract address is always the message sender.\\n\\t/// @param _operator The address which called `safeTransferFrom` function\\n\\t/// @param _from The address which previously owned the token\\n\\t/// @param _tokenId The NFT identifier which is being transferred\\n\\t/// @param _data Additional data with no specified format\\n\\t/// @return `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`\\n\\t///  unless throwing\\n\\tfunction onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4);\\n}\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n *\\n * @notice See https://eips.ethereum.org/EIPS/eip-721\\n *\\n * @dev The ERC-165 identifier for this interface is 0x5b5e139f.\\n *\\n * @author William Entriken, Dieter Shirley, Jacob Evans, Nastassia Sachs\\n */\\ninterface ERC721Metadata is ERC721 {\\n\\t/// @notice A descriptive name for a collection of NFTs in this contract\\n\\tfunction name() external view returns (string memory _name);\\n\\n\\t/// @notice An abbreviated name for NFTs in this contract\\n\\tfunction symbol() external view returns (string memory _symbol);\\n\\n\\t/// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\\n\\t/// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\\n\\t///  3986. The URI may point to a JSON file that conforms to the \\\"ERC721\\n\\t///  Metadata JSON Schema\\\".\\n\\tfunction tokenURI(uint256 _tokenId) external view returns (string memory);\\n}\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n *\\n * @notice See https://eips.ethereum.org/EIPS/eip-721\\n *\\n * @dev The ERC-165 identifier for this interface is 0x780e9d63.\\n *\\n * @author William Entriken, Dieter Shirley, Jacob Evans, Nastassia Sachs\\n */\\ninterface ERC721Enumerable is ERC721 {\\n\\t/// @notice Count NFTs tracked by this contract\\n\\t/// @return A count of valid NFTs tracked by this contract, where each one of\\n\\t///  them has an assigned and queryable owner not equal to the zero address\\n\\tfunction totalSupply() external view returns (uint256);\\n\\n\\t/// @notice Enumerate valid NFTs\\n\\t/// @dev Throws if `_index` >= `totalSupply()`.\\n\\t/// @param _index A counter less than `totalSupply()`\\n\\t/// @return The token identifier for the `_index`th NFT,\\n\\t///  (sort order not specified)\\n\\tfunction tokenByIndex(uint256 _index) external view returns (uint256);\\n\\n\\t/// @notice Enumerate NFTs assigned to an owner\\n\\t/// @dev Throws if `_index` >= `balanceOf(_owner)` or if\\n\\t///  `_owner` is the zero address, representing invalid NFTs.\\n\\t/// @param _owner An address where we are interested in NFTs owned by them\\n\\t/// @param _index A counter less than `balanceOf(_owner)`\\n\\t/// @return The token identifier for the `_index`th NFT assigned to `_owner`,\\n\\t///   (sort order not specified)\\n\\tfunction tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xe57d29caebdb7151575f0644ba5c5865fcc498e87f255aae97523871893f56c2\",\"license\":\"MIT\"},\"contracts/interfaces/ERC721SpecExt.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/**\\n * @title Mintable ERC721\\n *\\n * @notice Defines mint capabilities for Alethea ERC721 tokens.\\n *      This interface should be treated as a definition of what mintable means for ERC721\\n *\\n * @author Basil Gorin\\n */\\ninterface MintableERC721 {\\n\\t/**\\n\\t * @notice Checks if specified token exists\\n\\t *\\n\\t * @dev Returns whether the specified token ID has an ownership\\n\\t *      information associated with it\\n\\t *\\n\\t * @param _tokenId ID of the token to query existence for\\n\\t * @return whether the token exists (true - exists, false - doesn't exist)\\n\\t */\\n\\tfunction exists(uint256 _tokenId) external view returns(bool);\\n\\n\\t/**\\n\\t * @dev Creates new token with token ID specified\\n\\t *      and assigns an ownership `_to` for this token\\n\\t *\\n\\t * @dev Unsafe: doesn't execute `onERC721Received` on the receiver.\\n\\t *      Prefer the use of `saveMint` instead of `mint`.\\n\\t *\\n\\t * @dev Should have a restricted access handled by the implementation\\n\\t *\\n\\t * @param _to an address to mint token to\\n\\t * @param _tokenId ID of the token to mint\\n\\t */\\n\\tfunction mint(address _to, uint256 _tokenId) external;\\n\\n\\t/**\\n\\t * @dev Creates new tokens starting with token ID specified\\n\\t *      and assigns an ownership `_to` for these tokens\\n\\t *\\n\\t * @dev Token IDs to be minted: [_tokenId, _tokenId + n)\\n\\t *\\n\\t * @dev n must be greater or equal 2: `n > 1`\\n\\t *\\n\\t * @dev Unsafe: doesn't execute `onERC721Received` on the receiver.\\n\\t *      Prefer the use of `saveMintBatch` instead of `mintBatch`.\\n\\t *\\n\\t * @dev Should have a restricted access handled by the implementation\\n\\t *\\n\\t * @param _to an address to mint tokens to\\n\\t * @param _tokenId ID of the first token to mint\\n\\t * @param n how many tokens to mint, sequentially increasing the _tokenId\\n\\t */\\n\\tfunction mintBatch(address _to, uint256 _tokenId, uint256 n) external;\\n\\n\\t/**\\n\\t * @dev Creates new token with token ID specified\\n\\t *      and assigns an ownership `_to` for this token\\n\\t *\\n\\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\\n\\t *      `onERC721Received` on `_to` and throws if the return value is not\\n\\t *      `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`.\\n\\t *\\n\\t * @dev Should have a restricted access handled by the implementation\\n\\t *\\n\\t * @param _to an address to mint token to\\n\\t * @param _tokenId ID of the token to mint\\n\\t */\\n\\tfunction safeMint(address _to, uint256 _tokenId) external;\\n\\n\\t/**\\n\\t * @dev Creates new token with token ID specified\\n\\t *      and assigns an ownership `_to` for this token\\n\\t *\\n\\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\\n\\t *      `onERC721Received` on `_to` and throws if the return value is not\\n\\t *      `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`.\\n\\t *\\n\\t * @dev Should have a restricted access handled by the implementation\\n\\t *\\n\\t * @param _to an address to mint token to\\n\\t * @param _tokenId ID of the token to mint\\n\\t * @param _data additional data with no specified format, sent in call to `_to`\\n\\t */\\n\\tfunction safeMint(address _to, uint256 _tokenId, bytes memory _data) external;\\n\\n\\t/**\\n\\t * @dev Creates new tokens starting with token ID specified\\n\\t *      and assigns an ownership `_to` for these tokens\\n\\t *\\n\\t * @dev Token IDs to be minted: [_tokenId, _tokenId + n)\\n\\t *\\n\\t * @dev n must be greater or equal 2: `n > 1`\\n\\t *\\n\\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\\n\\t *      `onERC721Received` on `_to` and throws if the return value is not\\n\\t *      `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`.\\n\\t *\\n\\t * @dev Should have a restricted access handled by the implementation\\n\\t *\\n\\t * @param _to an address to mint token to\\n\\t * @param _tokenId ID of the token to mint\\n\\t * @param n how many tokens to mint, sequentially increasing the _tokenId\\n\\t */\\n\\tfunction safeMintBatch(address _to, uint256 _tokenId, uint256 n) external;\\n\\n\\t/**\\n\\t * @dev Creates new tokens starting with token ID specified\\n\\t *      and assigns an ownership `_to` for these tokens\\n\\t *\\n\\t * @dev Token IDs to be minted: [_tokenId, _tokenId + n)\\n\\t *\\n\\t * @dev n must be greater or equal 2: `n > 1`\\n\\t *\\n\\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\\n\\t *      `onERC721Received` on `_to` and throws if the return value is not\\n\\t *      `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`.\\n\\t *\\n\\t * @dev Should have a restricted access handled by the implementation\\n\\t *\\n\\t * @param _to an address to mint token to\\n\\t * @param _tokenId ID of the token to mint\\n\\t * @param n how many tokens to mint, sequentially increasing the _tokenId\\n\\t * @param _data additional data with no specified format, sent in call to `_to`\\n\\t */\\n\\tfunction safeMintBatch(address _to, uint256 _tokenId, uint256 n, bytes memory _data) external;\\n}\\n\\n/**\\n * @title Alethea Burnable ERC721\\n *\\n * @notice Defines burn capabilities for Alethea ERC721 tokens.\\n *      This interface should be treated as a definition of what burnable means for ERC721\\n *\\n * @author Basil Gorin\\n */\\ninterface BurnableERC721 {\\n\\t/**\\n\\t * @notice Destroys the token with token ID specified\\n\\t *\\n\\t * @dev Should be accessible publicly by token owners.\\n\\t *      May have a restricted access handled by the implementation\\n\\t *\\n\\t * @param _tokenId ID of the token to burn\\n\\t */\\n\\tfunction burn(uint256 _tokenId) external;\\n}\\n\\n/**\\n * @title With Base URI\\n *\\n * @notice A marker interface for the contracts having the baseURI() function\\n *      or public string variable named baseURI\\n *      NFT implementations like TinyERC721, or ShortERC721 are example of such smart contracts\\n *\\n * @author Basil Gorin\\n */\\ninterface WithBaseURI {\\n\\t/**\\n\\t * @dev Usually used in NFT implementations to construct ERC721Metadata.tokenURI as\\n\\t *      `base URI + token ID` if token URI is not set (not present in `_tokenURIs` mapping)\\n\\t *\\n\\t * @dev For example, if base URI is https://api.com/token/, then token #1\\n\\t *      will have an URI https://api.com/token/1\\n\\t */\\n\\tfunction baseURI() external view returns(string memory);\\n}\\n\",\"keccak256\":\"0xe6ec34852d09cb5b47a3711cac1315d217af81b504492a5f19d3250ef29620b2\",\"license\":\"MIT\"},\"contracts/lib/ECDSA.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n *\\n * @dev Copy of the Zeppelin's library:\\n *      https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b0cf6fbb7a70f31527f36579ad644e1cf12fdf4e/contracts/utils/cryptography/ECDSA.sol\\n */\\nlibrary ECDSA {\\n\\t/**\\n\\t * @dev Returns the address that signed a hashed message (`hash`) with\\n\\t * `signature`. This address can then be used for verification purposes.\\n\\t *\\n\\t * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n\\t * this function rejects them by requiring the `s` value to be in the lower\\n\\t * half order, and the `v` value to be either 27 or 28.\\n\\t *\\n\\t * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n\\t * verification to be secure: it is possible to craft signatures that\\n\\t * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n\\t * this is by receiving a hash of the original message (which may otherwise\\n\\t * be too long), and then calling {toEthSignedMessageHash} on it.\\n\\t *\\n\\t * Documentation for signature generation:\\n\\t * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n\\t * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n\\t */\\n\\tfunction recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n\\t\\t// Divide the signature in r, s and v variables\\n\\t\\tbytes32 r;\\n\\t\\tbytes32 s;\\n\\t\\tuint8 v;\\n\\n\\t\\t// Check the signature length\\n\\t\\t// - case 65: r,s,v signature (standard)\\n\\t\\t// - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\\n\\t\\tif (signature.length == 65) {\\n\\t\\t\\t// ecrecover takes the signature parameters, and the only way to get them\\n\\t\\t\\t// currently is to use assembly.\\n\\t\\t\\tassembly {\\n\\t\\t\\t\\tr := mload(add(signature, 0x20))\\n\\t\\t\\t\\ts := mload(add(signature, 0x40))\\n\\t\\t\\t\\tv := byte(0, mload(add(signature, 0x60)))\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if (signature.length == 64) {\\n\\t\\t\\t// ecrecover takes the signature parameters, and the only way to get them\\n\\t\\t\\t// currently is to use assembly.\\n\\t\\t\\tassembly {\\n\\t\\t\\t\\tlet vs := mload(add(signature, 0x40))\\n\\t\\t\\t\\tr := mload(add(signature, 0x20))\\n\\t\\t\\t\\ts := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n\\t\\t\\t\\tv := add(shr(255, vs), 27)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\trevert(\\\"invalid signature length\\\");\\n\\t\\t}\\n\\n\\t\\treturn recover(hash, v, r, s);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Overload of {ECDSA-recover} that receives the `v`,\\n\\t * `r` and `s` signature fields separately.\\n\\t */\\n\\tfunction recover(\\n\\t\\tbytes32 hash,\\n\\t\\tuint8 v,\\n\\t\\tbytes32 r,\\n\\t\\tbytes32 s\\n\\t) internal pure returns (address) {\\n\\t\\t// EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n\\t\\t// unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n\\t\\t// the valid range for s in (281): 0 < s < secp256k1n \\u00f7 2 + 1, and for v in (282): v \\u2208 {27, 28}. Most\\n\\t\\t// signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n\\t\\t//\\n\\t\\t// If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n\\t\\t// with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n\\t\\t// vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n\\t\\t// these malleable signatures as well.\\n\\t\\trequire(\\n\\t\\t\\tuint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0,\\n\\t\\t\\t\\\"invalid signature 's' value\\\"\\n\\t\\t);\\n\\t\\trequire(v == 27 || v == 28, \\\"invalid signature 'v' value\\\");\\n\\n\\t\\t// If the signature is valid (and not malleable), return the signer address\\n\\t\\taddress signer = ecrecover(hash, v, r, s);\\n\\t\\trequire(signer != address(0), \\\"invalid signature\\\");\\n\\n\\t\\treturn signer;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n\\t * produces hash corresponding to the one signed with the\\n\\t * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n\\t * JSON-RPC method as part of EIP-191.\\n\\t *\\n\\t * See {recover}.\\n\\t */\\n\\tfunction toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n\\t\\t// 32 is the length in bytes of hash,\\n\\t\\t// enforced by the type signature above\\n\\t\\treturn keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns an Ethereum Signed Typed Data, created from a\\n\\t * `domainSeparator` and a `structHash`. This produces hash corresponding\\n\\t * to the one signed with the\\n\\t * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n\\t * JSON-RPC method as part of EIP-712.\\n\\t *\\n\\t * See {recover}.\\n\\t */\\n\\tfunction toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n\\t\\treturn keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n\\t}\\n}\\n\",\"keccak256\":\"0xadc0107053170d40a04da6f2da244286cb84a4dab28f8e50c1b4d386fc597f87\",\"license\":\"MIT\"},\"contracts/protocol/NFTFactoryV3.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\nimport \\\"../interfaces/ERC721Spec.sol\\\";\\r\\nimport \\\"../interfaces/ERC721SpecExt.sol\\\";\\r\\nimport \\\"../utils/AccessControl.sol\\\";\\r\\nimport \\\"../lib/ECDSA.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Alethea NFT Factory\\r\\n *\\r\\n * @notice NFT Factory is a helper smart contract responsible for minting arbitrary NFTs\\r\\n *\\r\\n * @notice It supports two mechanisms:\\r\\n *      - minting delegation: authorized address executes mint function on the helper,\\r\\n *        and helper executes minting function on the target ERC721 contract as an internal transaction\\r\\n *      - meta transaction minting or minting with an authorization: authorized address signs\\r\\n *        the minting authorization message and any address executes mint function on the helper\\r\\n *\\r\\n * @notice Second mechanism allows to shift the gas costs for the transaction to any address\\r\\n *      (usually this is the NFT beneficiary - an address which receives an NFT)\\r\\n *\\r\\n * @dev The signature is constructed via EIP-712 similar to EIP-2612, or EIP-3009\\r\\n *\\r\\n * @dev Target ERC721 contract(s) must allow helper to mint the tokens, this should be configured\\r\\n *      as part of the deployment or setup processes\\r\\n *\\r\\n * @dev Version 3 (NFTFactoryV3) adds total mint limiting feature allowing to set the NFT total\\r\\n *     mint hardcap; factory stops minting when total mint of the contract reaches the hardcap\\r\\n */\\r\\ncontract NFTFactoryV3 is AccessControl {\\r\\n    /**\\r\\n\\t * @dev Number of ERC721 token been mint by NFTFactoryV3\\r\\n\\t */\\r\\n\\tuint256 public totalMint;\\r\\n    \\r\\n    /**\\r\\n\\t * @notice Total Mint Hardcap affects factory capability to mint: once\\r\\n\\t *      factory total mint reaches the hardcap, factory stops minting it\\r\\n\\t *\\r\\n\\t * @dev The factory `mint` and `mintWithAuthorization` function throws\\r\\n\\t *      if factory `totalMint` value is equal or bigger than `totalMintHardcap`\\r\\n\\t */\\r\\n\\tuint256 public totalMintHardcap;\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev A record of used nonces for EIP-712 transactions\\r\\n\\t *\\r\\n\\t * @dev A record of used nonces for signing/validating signatures\\r\\n\\t *      in `mintWithAuthorization` for every mint\\r\\n\\t *\\r\\n\\t * @dev Maps authorizer address => nonce => true/false (used unused)\\r\\n\\t */\\r\\n\\tmapping(address => mapping(bytes32 => bool)) private usedNonces;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice EIP-712 contract's domain separator,\\r\\n\\t *      see https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator\\r\\n\\t */\\r\\n\\tbytes32 public immutable DOMAIN_SEPARATOR;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice EIP-712 contract's domain typeHash,\\r\\n\\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\\r\\n\\t *\\r\\n\\t * @dev Note: we do not include version into the domain typehash/separator,\\r\\n\\t *      it is implied version is concatenated to the name field, like \\\"NFTFactoryV2\\\"\\r\\n\\t */\\r\\n\\t// keccak256(\\\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\\\")\\r\\n\\tbytes32 public constant DOMAIN_TYPEHASH = 0x8cad95687ba82c2ce50e74f7b754645e5117c3a5bec8151c0726d5857980a866;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice EIP-712 MintWithAuthorization struct typeHash,\\r\\n\\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\\r\\n\\t */\\r\\n\\t// keccak256(\\\"MintWithAuthorization(address contract,address to,uint256 tokenId,uint256 validAfter,uint256 validBefore,bytes32 nonce)\\\")\\r\\n\\tbytes32 public constant MINT_WITH_AUTHORIZATION_TYPEHASH = 0x495835d970a03ff092657fca9abde67d34a0bb73a0bba258a5fa90c4ce4340f6;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice EIP-712 CancelAuthorization struct typeHash,\\r\\n\\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\\r\\n\\t */\\r\\n\\t// keccak256(\\\"CancelAuthorization(address authorizer,bytes32 nonce)\\\")\\r\\n\\tbytes32 public constant CANCEL_AUTHORIZATION_TYPEHASH = 0x158b0a9edf7a828aad02f63cd515c68ef2f50ba807396f6d12842833a1597429;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Enables meta transaction minting (minting with an authorization\\r\\n\\t *      via an EIP712 signature)\\r\\n\\t * @dev Feature FEATURE_MINTING_WITH_AUTH must be enabled in order for\\r\\n\\t *      `mintWithAuthorization()` function to succeed\\r\\n\\t */\\r\\n\\tuint32 public constant FEATURE_MINTING_WITH_AUTH = 0x0000_0001;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Factory minter is responsible for creating (minting)\\r\\n\\t *      tokens to an arbitrary address\\r\\n\\t * @dev Role ROLE_FACTORY_MINTER allows minting tokens\\r\\n\\t *      (executing `mint` function)\\r\\n\\t */\\r\\n\\tuint32 public constant ROLE_FACTORY_MINTER = 0x0001_0000;\\r\\n\\r\\n    /**\\r\\n\\t * @notice Mint hardcap manager is responsible for updating\\r\\n     *      NFTFactoryV3 total mint hardcap\\r\\n\\t *\\r\\n\\t * @dev Role ROLE_MINT_HARDCAP_MANAGER allows updating total mint hardcap\\r\\n     *      (executing `updateTotalMintHardcap` function)\\r\\n\\t */\\r\\n\\tuint32 public constant ROLE_MINT_HARDCAP_MANAGER = 0x0002_0000;\\r\\n\\r\\n    /**\\r\\n\\t * @dev Fired whenever total mint hardcap is updated (ex.: `updateTotalMintHardcap`)\\r\\n\\t *\\r\\n\\t * @param authorizer an address which has updated total mint hardcap\\r\\n\\t * @param oldLimit old total mint hardcap\\r\\n\\t * @param newLimit new total mint hardcap\\r\\n\\t */\\r\\n\\tevent TotalMintHardcapUpdated(address indexed authorizer, uint256 oldLimit, uint256 newLimit);\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Fired in mint() and mintWithAuthorization() after an NFT is minted\\r\\n\\t *\\r\\n\\t * @param erc721Address ERC721 contract address which was minted\\r\\n\\t * @param to an address NFT was minted to\\r\\n\\t * @param tokenId NFT ID which was minted\\r\\n\\t */\\r\\n\\tevent Minted(address indexed erc721Address, address indexed to, uint256 indexed tokenId);\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Fired whenever the nonce gets used (ex.: `transferWithAuthorization`, `receiveWithAuthorization`)\\r\\n\\t *\\r\\n\\t * @param authorizer an address which has used the nonce\\r\\n\\t * @param nonce the nonce used\\r\\n\\t */\\r\\n\\tevent AuthorizationUsed(address indexed authorizer, bytes32 indexed nonce);\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Fired whenever the nonce gets cancelled (ex.: `cancelAuthorization`)\\r\\n\\t *\\r\\n\\t * @dev Both `AuthorizationUsed` and `AuthorizationCanceled` imply the nonce\\r\\n\\t *      cannot be longer used, the only difference is that `AuthorizationCanceled`\\r\\n\\t *      implies no smart contract state change made (except the nonce marked as cancelled)\\r\\n\\t *\\r\\n\\t * @param authorizer an address which has cancelled the nonce\\r\\n\\t * @param nonce the nonce cancelled\\r\\n\\t */\\r\\n\\tevent AuthorizationCanceled(address indexed authorizer, bytes32 indexed nonce);\\r\\n\\r\\n\\t/**\\r\\n\\t * Deploys the helper contract and initializes DOMAIN_SEPARATOR using the created smart contract address\\r\\n\\t *\\r\\n\\t * @param _totalMintHardcap NFTFactoryV3 total mint limit, factory stops minting the ERC721\\r\\n\\t *      if its total mint (totalMint()) reaches the total mint hardcap (totalMintHardcap())\\r\\n\\t */\\r\\n\\tconstructor(uint256 _totalMintHardcap) {\\r\\n\\t\\t// build the EIP-712 contract domain separator, see https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator\\r\\n\\t\\t// note: we specify contract version in its name\\r\\n\\t\\tDOMAIN_SEPARATOR = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(\\\"NFTFactoryV3\\\")), block.chainid, address(this)));\\r\\n\\r\\n\\t\\t// verify the hardcap is set\\r\\n\\t\\trequire(_totalMintHardcap != 0, \\\"hardcap is not set\\\");\\r\\n\\r\\n\\t\\t// set the total supply hardcap\\r\\n\\t\\ttotalMintHardcap = _totalMintHardcap;\\r\\n\\t}\\r\\n\\r\\n    /**\\r\\n\\t * @notice Updates total mint hardcap of NFTFactoryV3 contract.\\r\\n\\t *\\r\\n\\t * @dev Requires transaction sender to have `ROLE_MINT_HARDCAP_MANAGER` permission\\r\\n\\t *\\r\\n\\t * @param _totalMintHardcap new NFTFactoryV3 total mint hardcap\\r\\n\\t */\\r\\n\\tfunction updateTotalMintHardcap(uint256 _totalMintHardcap) public {\\r\\n\\t\\t// caller must have a permission to update total mint hardcap\\r\\n\\t\\trequire(isSenderInRole(ROLE_MINT_HARDCAP_MANAGER), \\\"access denied\\\");\\r\\n\\r\\n\\t\\t// emit an event\\r\\n\\t\\temit TotalMintHardcapUpdated(msg.sender, totalMintHardcap, _totalMintHardcap);\\r\\n\\r\\n\\t\\t// update total mint hardcap\\r\\n\\t\\ttotalMintHardcap = _totalMintHardcap;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Restricted access function to mint an NFT\\r\\n\\t *\\r\\n\\t * @dev Doesn't allow minting the token with ID zero\\r\\n\\t * @dev Requires an executor to have ROLE_MINTER permission\\r\\n\\t * @dev Requires target ERC721 contract to be mintable (`MintableERC721`)\\r\\n\\t * @dev Requires target ERC721 contract instance to allow minting via helper\\r\\n\\t *\\r\\n\\t * @param _targetErc721 target ERC721 contract instance to mint token on,\\r\\n\\t *      compatible with `MintableERC721`\\r\\n\\t * @param _to an address to mint token to\\r\\n\\t * @param _tokenId target ERC721 token ID to mint\\r\\n\\t */\\r\\n\\tfunction mint(address _targetErc721, address _to, uint256 _tokenId) external {\\r\\n\\t\\t// delegate to _mint()\\r\\n\\t\\t__mint(msg.sender, _targetErc721, _to, _tokenId);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Auxiliary internally used function to mint an NFT\\r\\n\\t *\\r\\n\\t * @dev Unsafe: doesn't verify real tx executor (msg.sender) permissions, but the permissions of\\r\\n\\t *      the address specified as an executor, must be kept private at all times\\r\\n\\t *\\r\\n\\t * @dev Doesn't allow minting the token with ID zero\\r\\n\\t * @dev Requires an executor to have ROLE_MINTER permission\\r\\n\\t * @dev Requires target ERC721 contract to be mintable (`MintableERC721`)\\r\\n\\t * @dev Requires target ERC721 contract instance to allow minting via helper\\r\\n\\t *\\r\\n\\t * @param _executor an address on which behalf the operation is executed,\\r\\n\\t *      this is usually `msg.sender` but this can be different address for\\r\\n\\t *      the EIP-712 like transactions (mint with authorization)\\r\\n\\t * @param _targetErc721 target ERC721 contract instance to mint token on,\\r\\n\\t *      compatible with `MintableERC721`\\r\\n\\t * @param _to an address to mint token to\\r\\n\\t * @param _tokenId target ERC721 token ID to mint\\r\\n\\t */\\r\\n\\tfunction __mint(address _executor, address _targetErc721, address _to, uint256 _tokenId) private {\\r\\n\\t\\t// verify the access permission\\r\\n\\t\\trequire(isOperatorInRole(_executor, ROLE_FACTORY_MINTER), \\\"access denied\\\");\\r\\n\\r\\n\\t\\t// verify the inputs\\r\\n\\t\\trequire(_targetErc721 != address(0), \\\"ERC721 instance addr is not set\\\");\\r\\n\\t\\trequire(_to != address(0), \\\"NFT receiver addr is not set\\\");\\r\\n\\t\\trequire(_tokenId != 0, \\\"token ID is not set\\\");\\r\\n\\r\\n\\t\\t// verify if total mint hardcap is reached\\r\\n\\t\\trequire(totalMint < totalMintHardcap, \\\"hardcap reached\\\");\\r\\n\\r\\n        // increase total mint counter\\r\\n        totalMint++;\\r\\n\\r\\n\\t\\t// delegate to the target ERC721 contract\\r\\n\\t\\tMintableERC721(_targetErc721).safeMint(_to, _tokenId);\\r\\n\\r\\n\\t\\t// emit an event\\r\\n\\t\\temit Minted(_targetErc721, _to, _tokenId);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Executes a mint function with a signed authorization\\r\\n\\t *\\r\\n\\t * @param _targetErc721 target ERC721 contract instance to mint token on,\\r\\n\\t *      compatible with `MintableERC721`\\r\\n\\t * @param _to an address to mint token to\\r\\n\\t * @param _tokenId target ERC721 token ID to mint\\r\\n\\t * @param _validAfter signature valid after time (unix timestamp)\\r\\n\\t * @param _validBefore signature valid before time (unix timestamp)\\r\\n\\t * @param _nonce unique random nonce\\r\\n\\t * @param v the recovery byte of the signature\\r\\n\\t * @param r half of the ECDSA signature pair\\r\\n\\t * @param s half of the ECDSA signature pair\\r\\n\\t */\\r\\n\\tfunction mintWithAuthorization(\\r\\n\\t\\taddress _targetErc721,\\r\\n\\t\\taddress _to,\\r\\n\\t\\tuint256 _tokenId,\\r\\n\\t\\tuint256 _validAfter,\\r\\n\\t\\tuint256 _validBefore,\\r\\n\\t\\tbytes32 _nonce,\\r\\n\\t\\tuint8 v,\\r\\n\\t\\tbytes32 r,\\r\\n\\t\\tbytes32 s\\r\\n\\t) external {\\r\\n\\t\\t// ensure EIP-712 minting with authorization is enabled\\r\\n\\t\\trequire(isFeatureEnabled(FEATURE_MINTING_WITH_AUTH), \\\"minting with auth is disabled\\\");\\r\\n\\r\\n\\t\\t// derive signer of the EIP712 MintWithAuthorization message\\r\\n\\t\\taddress signer = __deriveSigner(\\r\\n\\t\\t\\tabi.encode(MINT_WITH_AUTHORIZATION_TYPEHASH, _targetErc721, _to, _tokenId, _validAfter, _validBefore, _nonce),\\r\\n\\t\\t\\tv,\\r\\n\\t\\t\\tr,\\r\\n\\t\\t\\ts\\r\\n\\t\\t);\\r\\n\\r\\n\\t\\t// perform message integrity and security validations\\r\\n\\t\\trequire(block.timestamp > _validAfter, \\\"signature not yet valid\\\");\\r\\n\\t\\trequire(block.timestamp < _validBefore, \\\"signature expired\\\");\\r\\n\\r\\n\\t\\t// use the nonce supplied (verify, mark as used, emit event)\\r\\n\\t\\t__useNonce(signer, _nonce, false);\\r\\n\\r\\n\\t\\t// delegate call to `_mint` - execute the logic required\\r\\n\\t\\t__mint(signer, _targetErc721, _to, _tokenId);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Returns the state of an authorization, more specifically\\r\\n\\t *      if the specified nonce was already used by the address specified\\r\\n\\t *\\r\\n\\t * @dev Nonces are expected to be client-side randomly generated 32-byte data\\r\\n\\t *      unique to the authorizer's address\\r\\n\\t *\\r\\n\\t * @param _authorizer Authorizer's address\\r\\n\\t * @param _nonce Nonce of the authorization\\r\\n\\t * @return true if the nonce is used\\r\\n\\t */\\r\\n\\tfunction authorizationState(\\r\\n\\t\\taddress _authorizer,\\r\\n\\t\\tbytes32 _nonce\\r\\n\\t) external view returns (bool) {\\r\\n\\t\\t// simply return the value from the mapping\\r\\n\\t\\treturn usedNonces[_authorizer][_nonce];\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Cancels the authorization (using EIP-712 signature)\\r\\n\\t *\\r\\n\\t * @param _authorizer transaction authorizer\\r\\n\\t * @param _nonce unique random nonce to cancel (mark as used)\\r\\n\\t * @param v the recovery byte of the signature\\r\\n\\t * @param r half of the ECDSA signature pair\\r\\n\\t * @param s half of the ECDSA signature pair\\r\\n\\t */\\r\\n\\tfunction cancelAuthorization(\\r\\n\\t\\taddress _authorizer,\\r\\n\\t\\tbytes32 _nonce,\\r\\n\\t\\tuint8 v,\\r\\n\\t\\tbytes32 r,\\r\\n\\t\\tbytes32 s\\r\\n\\t) external {\\r\\n\\t\\t// derive signer of the EIP712 ReceiveWithAuthorization message\\r\\n\\t\\taddress signer = __deriveSigner(abi.encode(CANCEL_AUTHORIZATION_TYPEHASH, _authorizer, _nonce), v, r, s);\\r\\n\\r\\n\\t\\t// perform message integrity and security validations\\r\\n\\t\\trequire(signer == _authorizer, \\\"invalid signature\\\");\\r\\n\\r\\n\\t\\t// cancel the nonce supplied (verify, mark as used, emit event)\\r\\n\\t\\t__useNonce(_authorizer, _nonce, true);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Cancels the authorization\\r\\n\\t *\\r\\n\\t * @param _nonce unique random nonce to cancel (mark as used)\\r\\n\\t */\\r\\n\\tfunction cancelAuthorization(bytes32 _nonce) public {\\r\\n\\t\\t// cancel the nonce supplied (verify, mark as used, emit event)\\r\\n\\t\\t__useNonce(msg.sender, _nonce, true);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Auxiliary function to verify structured EIP712 message signature and derive its signer\\r\\n\\t *\\r\\n\\t * @param abiEncodedTypehash abi.encode of the message typehash together with all its parameters\\r\\n\\t * @param v the recovery byte of the signature\\r\\n\\t * @param r half of the ECDSA signature pair\\r\\n\\t * @param s half of the ECDSA signature pair\\r\\n\\t */\\r\\n\\tfunction __deriveSigner(bytes memory abiEncodedTypehash, uint8 v, bytes32 r, bytes32 s) private view returns(address) {\\r\\n\\t\\t// build the EIP-712 hashStruct of the message\\r\\n\\t\\tbytes32 hashStruct = keccak256(abiEncodedTypehash);\\r\\n\\r\\n\\t\\t// calculate the EIP-712 digest \\\"\\\\x19\\\\x01\\\" \\u2016 domainSeparator \\u2016 hashStruct(message)\\r\\n\\t\\tbytes32 digest = keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", DOMAIN_SEPARATOR, hashStruct));\\r\\n\\r\\n\\t\\t// recover the address which signed the message with v, r, s\\r\\n\\t\\taddress signer = ECDSA.recover(digest, v, r, s);\\r\\n\\r\\n\\t\\t// return the signer address derived from the signature\\r\\n\\t\\treturn signer;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Auxiliary function to use/cancel the nonce supplied for a given authorizer:\\r\\n\\t *      1. Verifies the nonce was not used before\\r\\n\\t *      2. Marks the nonce as used\\r\\n\\t *      3. Emits an event that the nonce was used/cancelled\\r\\n\\t *\\r\\n\\t * @dev Set `_cancellation` to false (default) to use nonce,\\r\\n\\t *      set `_cancellation` to true to cancel nonce\\r\\n\\t *\\r\\n\\t * @dev It is expected that the nonce supplied is a randomly\\r\\n\\t *      generated uint256 generated by the client\\r\\n\\t *\\r\\n\\t * @param _authorizer an address to use/cancel nonce for\\r\\n\\t * @param _nonce random nonce to use\\r\\n\\t * @param _cancellation true to emit `AuthorizationCancelled`, false to emit `AuthorizationUsed` event\\r\\n\\t */\\r\\n\\tfunction __useNonce(address _authorizer, bytes32 _nonce, bool _cancellation) private {\\r\\n\\t\\t// verify nonce was not used before\\r\\n\\t\\trequire(!usedNonces[_authorizer][_nonce], \\\"invalid nonce\\\");\\r\\n\\r\\n\\t\\t// update the nonce state to \\\"used\\\" for that particular signer to avoid replay attack\\r\\n\\t\\tusedNonces[_authorizer][_nonce] = true;\\r\\n\\r\\n\\t\\t// depending on the usage type (use/cancel)\\r\\n\\t\\tif(_cancellation) {\\r\\n\\t\\t\\t// emit an event regarding the nonce cancelled\\r\\n\\t\\t\\temit AuthorizationCanceled(_authorizer, _nonce);\\r\\n\\t\\t}\\r\\n\\t\\telse {\\r\\n\\t\\t\\t// emit an event regarding the nonce used\\r\\n\\t\\t\\temit AuthorizationUsed(_authorizer, _nonce);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\r\\n\",\"keccak256\":\"0x517b48f1056cc9083b8f888dab7a1530c0b0680b8bc78861a128d155b2cb0735\",\"license\":\"MIT\"},\"contracts/utils/AccessControl.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/**\\n * @title Access Control List\\n *\\n * @notice Access control smart contract provides an API to check\\n *      if specific operation is permitted globally and/or\\n *      if particular user has a permission to execute it.\\n *\\n * @notice It deals with two main entities: features and roles.\\n *\\n * @notice Features are designed to be used to enable/disable specific\\n *      functions (public functions) of the smart contract for everyone.\\n * @notice User roles are designed to restrict access to specific\\n *      functions (restricted functions) of the smart contract to some users.\\n *\\n * @notice Terms \\\"role\\\", \\\"permissions\\\" and \\\"set of permissions\\\" have equal meaning\\n *      in the documentation text and may be used interchangeably.\\n * @notice Terms \\\"permission\\\", \\\"single permission\\\" implies only one permission bit set.\\n *\\n * @notice Access manager is a special role which allows to grant/revoke other roles.\\n *      Access managers can only grant/revoke permissions which they have themselves.\\n *      As an example, access manager with no other roles set can only grant/revoke its own\\n *      access manager permission and nothing else.\\n *\\n * @notice Access manager permission should be treated carefully, as a super admin permission:\\n *      Access manager with even no other permission can interfere with another account by\\n *      granting own access manager permission to it and effectively creating more powerful\\n *      permission set than its own.\\n *\\n * @dev Both current and OpenZeppelin AccessControl implementations feature a similar API\\n *      to check/know \\\"who is allowed to do this thing\\\".\\n * @dev Zeppelin implementation is more flexible:\\n *      - it allows setting unlimited number of roles, while current is limited to 256 different roles\\n *      - it allows setting an admin for each role, while current allows having only one global admin\\n * @dev Current implementation is more lightweight:\\n *      - it uses only 1 bit per role, while Zeppelin uses 256 bits\\n *      - it allows setting up to 256 roles at once, in a single transaction, while Zeppelin allows\\n *        setting only one role in a single transaction\\n *\\n * @dev This smart contract is designed to be inherited by other\\n *      smart contracts which require access control management capabilities.\\n *\\n * @dev Access manager permission has a bit 255 set.\\n *      This bit must not be used by inheriting contracts for any other permissions/features.\\n *\\n * @author Basil Gorin\\n */\\ncontract AccessControl {\\n\\t/**\\n\\t * @notice Access manager is responsible for assigning the roles to users,\\n\\t *      enabling/disabling global features of the smart contract\\n\\t * @notice Access manager can add, remove and update user roles,\\n\\t *      remove and update global features\\n\\t *\\n\\t * @dev Role ROLE_ACCESS_MANAGER allows modifying user roles and global features\\n\\t * @dev Role ROLE_ACCESS_MANAGER has single bit at position 255 enabled\\n\\t */\\n\\tuint256 public constant ROLE_ACCESS_MANAGER = 0x8000000000000000000000000000000000000000000000000000000000000000;\\n\\n\\t/**\\n\\t * @dev Bitmask representing all the possible permissions (super admin role)\\n\\t * @dev Has all the bits are enabled (2^256 - 1 value)\\n\\t */\\n\\tuint256 private constant FULL_PRIVILEGES_MASK = type(uint256).max; // before 0.8.0: uint256(-1) overflows to 0xFFFF...\\n\\n\\t/**\\n\\t * @notice Privileged addresses with defined roles/permissions\\n\\t * @notice In the context of ERC20/ERC721 tokens these can be permissions to\\n\\t *      allow minting or burning tokens, transferring on behalf and so on\\n\\t *\\n\\t * @dev Maps user address to the permissions bitmask (role), where each bit\\n\\t *      represents a permission\\n\\t * @dev Bitmask 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\\n\\t *      represents all possible permissions\\n\\t * @dev 'This' address mapping represents global features of the smart contract\\n\\t */\\n\\tmapping(address => uint256) public userRoles;\\n\\n\\t/**\\n\\t * @dev Fired in updateRole() and updateFeatures()\\n\\t *\\n\\t * @param _by operator which called the function\\n\\t * @param _to address which was granted/revoked permissions\\n\\t * @param _requested permissions requested\\n\\t * @param _actual permissions effectively set\\n\\t */\\n\\tevent RoleUpdated(address indexed _by, address indexed _to, uint256 _requested, uint256 _actual);\\n\\n\\t/**\\n\\t * @notice Creates an access control instance,\\n\\t *      setting contract creator to have full privileges\\n\\t */\\n\\tconstructor() {\\n\\t\\t// contract creator has full privileges\\n\\t\\tuserRoles[msg.sender] = FULL_PRIVILEGES_MASK;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Retrieves globally set of features enabled\\n\\t *\\n\\t * @dev Effectively reads userRoles role for the contract itself\\n\\t *\\n\\t * @return 256-bit bitmask of the features enabled\\n\\t */\\n\\tfunction features() public view returns(uint256) {\\n\\t\\t// features are stored in 'this' address  mapping of `userRoles` structure\\n\\t\\treturn userRoles[address(this)];\\n\\t}\\n\\n\\t/**\\n\\t * @notice Updates set of the globally enabled features (`features`),\\n\\t *      taking into account sender's permissions\\n\\t *\\n\\t * @dev Requires transaction sender to have `ROLE_ACCESS_MANAGER` permission\\n\\t * @dev Function is left for backward compatibility with older versions\\n\\t *\\n\\t * @param _mask bitmask representing a set of features to enable/disable\\n\\t */\\n\\tfunction updateFeatures(uint256 _mask) public {\\n\\t\\t// delegate call to `updateRole`\\n\\t\\tupdateRole(address(this), _mask);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Updates set of permissions (role) for a given user,\\n\\t *      taking into account sender's permissions.\\n\\t *\\n\\t * @dev Setting role to zero is equivalent to removing an all permissions\\n\\t * @dev Setting role to `FULL_PRIVILEGES_MASK` is equivalent to\\n\\t *      copying senders' permissions (role) to the user\\n\\t * @dev Requires transaction sender to have `ROLE_ACCESS_MANAGER` permission\\n\\t *\\n\\t * @param operator address of a user to alter permissions for or zero\\n\\t *      to alter global features of the smart contract\\n\\t * @param role bitmask representing a set of permissions to\\n\\t *      enable/disable for a user specified\\n\\t */\\n\\tfunction updateRole(address operator, uint256 role) public {\\n\\t\\t// caller must have a permission to update user roles\\n\\t\\trequire(isSenderInRole(ROLE_ACCESS_MANAGER), \\\"access denied\\\");\\n\\n\\t\\t// evaluate the role and reassign it\\n\\t\\tuserRoles[operator] = evaluateBy(msg.sender, userRoles[operator], role);\\n\\n\\t\\t// fire an event\\n\\t\\temit RoleUpdated(msg.sender, operator, role, userRoles[operator]);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Determines the permission bitmask an operator can set on the\\n\\t *      target permission set\\n\\t * @notice Used to calculate the permission bitmask to be set when requested\\n\\t *     in `updateRole` and `updateFeatures` functions\\n\\t *\\n\\t * @dev Calculated based on:\\n\\t *      1) operator's own permission set read from userRoles[operator]\\n\\t *      2) target permission set - what is already set on the target\\n\\t *      3) desired permission set - what do we want set target to\\n\\t *\\n\\t * @dev Corner cases:\\n\\t *      1) Operator is super admin and its permission set is `FULL_PRIVILEGES_MASK`:\\n\\t *        `desired` bitset is returned regardless of the `target` permission set value\\n\\t *        (what operator sets is what they get)\\n\\t *      2) Operator with no permissions (zero bitset):\\n\\t *        `target` bitset is returned regardless of the `desired` value\\n\\t *        (operator has no authority and cannot modify anything)\\n\\t *\\n\\t * @dev Example:\\n\\t *      Consider an operator with the permissions bitmask     00001111\\n\\t *      is about to modify the target permission set          01010101\\n\\t *      Operator wants to set that permission set to          00110011\\n\\t *      Based on their role, an operator has the permissions\\n\\t *      to update only lowest 4 bits on the target, meaning that\\n\\t *      high 4 bits of the target set in this example is left\\n\\t *      unchanged and low 4 bits get changed as desired:      01010011\\n\\t *\\n\\t * @param operator address of the contract operator which is about to set the permissions\\n\\t * @param target input set of permissions to operator is going to modify\\n\\t * @param desired desired set of permissions operator would like to set\\n\\t * @return resulting set of permissions given operator will set\\n\\t */\\n\\tfunction evaluateBy(address operator, uint256 target, uint256 desired) public view returns(uint256) {\\n\\t\\t// read operator's permissions\\n\\t\\tuint256 p = userRoles[operator];\\n\\n\\t\\t// taking into account operator's permissions,\\n\\t\\t// 1) enable the permissions desired on the `target`\\n\\t\\ttarget |= p & desired;\\n\\t\\t// 2) disable the permissions desired on the `target`\\n\\t\\ttarget &= FULL_PRIVILEGES_MASK ^ (p & (FULL_PRIVILEGES_MASK ^ desired));\\n\\n\\t\\t// return calculated result\\n\\t\\treturn target;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Checks if requested set of features is enabled globally on the contract\\n\\t *\\n\\t * @param required set of features to check against\\n\\t * @return true if all the features requested are enabled, false otherwise\\n\\t */\\n\\tfunction isFeatureEnabled(uint256 required) public view returns(bool) {\\n\\t\\t// delegate call to `__hasRole`, passing `features` property\\n\\t\\treturn __hasRole(features(), required);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Checks if transaction sender `msg.sender` has all the permissions required\\n\\t *\\n\\t * @param required set of permissions (role) to check against\\n\\t * @return true if all the permissions requested are enabled, false otherwise\\n\\t */\\n\\tfunction isSenderInRole(uint256 required) public view returns(bool) {\\n\\t\\t// delegate call to `isOperatorInRole`, passing transaction sender\\n\\t\\treturn isOperatorInRole(msg.sender, required);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Checks if operator has all the permissions (role) required\\n\\t *\\n\\t * @param operator address of the user to check role for\\n\\t * @param required set of permissions (role) to check\\n\\t * @return true if all the permissions requested are enabled, false otherwise\\n\\t */\\n\\tfunction isOperatorInRole(address operator, uint256 required) public view returns(bool) {\\n\\t\\t// delegate call to `__hasRole`, passing operator's permissions (role)\\n\\t\\treturn __hasRole(userRoles[operator], required);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Checks if role `actual` contains all the permissions required `required`\\n\\t *\\n\\t * @param actual existent role\\n\\t * @param required required role\\n\\t * @return true if actual has required role (all permissions), false otherwise\\n\\t */\\n\\tfunction __hasRole(uint256 actual, uint256 required) internal pure returns(bool) {\\n\\t\\t// check the bitmask for the role required and return the result\\n\\t\\treturn actual & required == required;\\n\\t}\\n}\\n\",\"keccak256\":\"0x3b216515c25652b94bce7984346b8deee3ce00fd8c2b3b7b8d3015fa349908d3\",\"license\":\"MIT\"}},\"version\":1}",
    "bytecode": "0x60a060405234801561001057600080fd5b5060405161109738038061109783398101604081905261002f9161012a565b33600090815260208181526040808320600019905580518082018252600c81526b4e4654466163746f7279563360a01b9083015280517f8cad95687ba82c2ce50e74f7b754645e5117c3a5bec8151c0726d5857980a866818401527fe4dd1253284dada09e269906dbd6c7a83bb593f8b72a6f87779eb4df2427c5ae818301524660608201523060808083019190915282518083038201815260a0909201909252805192019190912090528190036101225760405162461bcd60e51b81526020600482015260126024820152711a185c9918d85c081a5cc81b9bdd081cd95d60721b604482015260640160405180910390fd5b600255610143565b60006020828403121561013c57600080fd5b5051919050565b608051610f32610165600039600081816101b101526107d00152610f326000f3fe608060405234801561001057600080fd5b50600436106101585760003560e01c8063ae682e2e116100c3578063d5bb7f671161007c578063d5bb7f67146102eb578063d9169487146102fe578063e94a010214610325578063f822d5aa1461035e578063fcc2c07814610371578063ff2642cf1461038457600080fd5b8063ae682e2e14610295578063c4d029c6146102a0578063c688d693146102a8578063c6c3bbe6146102bb578063ce8b3a58146102ce578063d1333c98146102d857600080fd5b806371c582921161011557806371c58292146101fa578063725f36261461020d57806374d5e10014610230578063845ab94f14610250578063a07723c214610263578063ae5b102e1461028257600080fd5b806320606b701461015d5780632b521416146101975780633644e515146101ac57806359a7715a146101d357806359cdd2a3146101dc5780635a049a70146101e5575b600080fd5b6101847f8cad95687ba82c2ce50e74f7b754645e5117c3a5bec8151c0726d5857980a86681565b6040519081526020015b60405180910390f35b30600090815260208190526040902054610184565b6101847f000000000000000000000000000000000000000000000000000000000000000081565b61018460015481565b61018460025481565b6101f86101f3366004610d15565b6103ab565b005b6101f8610208366004610d63565b61047f565b61022061021b366004610d63565b6104ea565b604051901515815260200161018e565b61018461023e366004610d7c565b60006020819052908152604090205481565b6101f861025e366004610d63565b610505565b61026d6202000081565b60405163ffffffff909116815260200161018e565b6101f8610290366004610d97565b610514565b610184600160ff1b81565b61026d600181565b6102206102b6366004610d97565b6105be565b6101f86102c9366004610dc1565b6105e3565b61026d6201000081565b6101f86102e6366004610dfd565b6105f4565b6101f86102f9366004610d63565b610772565b6101847f158b0a9edf7a828aad02f63cd515c68ef2f50ba807396f6d12842833a159742981565b610220610333366004610d97565b6001600160a01b03919091166000908152600360209081526040808320938352929052205460ff1690565b61018461036c366004610e7b565b61077c565b61022061037f366004610d63565b6107a7565b6101847f495835d970a03ff092657fca9abde67d34a0bb73a0bba258a5fa90c4ce4340f681565b604080517f158b0a9edf7a828aad02f63cd515c68ef2f50ba807396f6d12842833a159742960208201526001600160a01b038716918101919091526060810185905260009061040f906080015b6040516020818303038152906040528585856107b3565b9050856001600160a01b0316816001600160a01b03161461046b5760405162461bcd60e51b8152602060048201526011602482015270696e76616c6964207369676e617475726560781b60448201526064015b60405180910390fd5b61047786866001610835565b505050505050565b61048b620200006107a7565b6104a75760405162461bcd60e51b815260040161046290610eae565b600254604080519182526020820183905233917f72262ec80631e7232e7be11294d78cf431aaf58c2a7a1eb27275d9bbb8ed863e910160405180910390a2600255565b30600090815260208190526040812054821682145b92915050565b61051133826001610835565b50565b610521600160ff1b6107a7565b61053d5760405162461bcd60e51b815260040161046290610eae565b6001600160a01b0382166000908152602081905260409020546105629033908361077c565b6001600160a01b03831660008181526020818152604091829020849055815185815290810193909352909133917f5a10526456f5116c0b7b80582c217d666243fd51b6a2d92c8011e601c2462e5f910160405180910390a35050565b6001600160a01b038216600090815260208190526040812054821682145b9392505050565b6105ef33848484610943565b505050565b6105fe60016104ea565b61064a5760405162461bcd60e51b815260206004820152601d60248201527f6d696e74696e67207769746820617574682069732064697361626c65640000006044820152606401610462565b604080517f495835d970a03ff092657fca9abde67d34a0bb73a0bba258a5fa90c4ce4340f660208201526001600160a01b03808c169282019290925290891660608201526080810188905260a0810187905260c0810186905260e081018590526000906106ba90610100016103f8565b905086421161070b5760405162461bcd60e51b815260206004820152601760248201527f7369676e6174757265206e6f74207965742076616c69640000000000000000006044820152606401610462565b85421061074e5760405162461bcd60e51b81526020600482015260116024820152701cda59db985d1d5c9948195e1c1a5c9959607a1b6044820152606401610462565b61075a81866000610835565b610766818b8b8b610943565b50505050505050505050565b6105113082610514565b6001600160a01b03929092166000908152602081905260409020546000198084188216189216171690565b60006104ff33836105be565b835160208086019190912060405161190160f01b928101929092527f00000000000000000000000000000000000000000000000000000000000000006022830152604282018190526000918290606201604051602081830303815290604052805190602001209050600061082982888888610b61565b98975050505050505050565b6001600160a01b038316600090815260036020908152604080832085845290915290205460ff16156108995760405162461bcd60e51b815260206004820152600d60248201526c696e76616c6964206e6f6e636560981b6044820152606401610462565b6001600160a01b03831660009081526003602090815260408083208584529091529020805460ff1916600117905580156109085760405182906001600160a01b038516907f1cdd46ff242716cdaa72d159d339a485b3438398348d68f09d7c8c0a59353d8190600090a3505050565b60405182906001600160a01b038516907f98de503528ee59b575ef0c0a2576a82497bfc029a5685b209e9ec333479b10a590600090a3505050565b61095084620100006105be565b61096c5760405162461bcd60e51b815260040161046290610eae565b6001600160a01b0383166109c25760405162461bcd60e51b815260206004820152601f60248201527f45524337323120696e7374616e63652061646472206973206e6f7420736574006044820152606401610462565b6001600160a01b038216610a185760405162461bcd60e51b815260206004820152601c60248201527f4e46542072656365697665722061646472206973206e6f7420736574000000006044820152606401610462565b80600003610a5e5760405162461bcd60e51b81526020600482015260136024820152721d1bdad95b881251081a5cc81b9bdd081cd95d606a1b6044820152606401610462565b60025460015410610aa35760405162461bcd60e51b815260206004820152600f60248201526e1a185c9918d85c081c995858da1959608a1b6044820152606401610462565b60018054906000610ab383610ed5565b9091555050604051632851206560e21b81526001600160a01b0383811660048301526024820183905284169063a144819490604401600060405180830381600087803b158015610b0257600080fd5b505af1158015610b16573d6000803e3d6000fd5b5050505080826001600160a01b0316846001600160a01b03167f9d228d69b5fdb8d273a2336f8fb8612d039631024ea9bf09c424a9503aa078f060405160405180910390a450505050565b60007f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0821115610bd35760405162461bcd60e51b815260206004820152601b60248201527f696e76616c6964207369676e6174757265202773272076616c756500000000006044820152606401610462565b8360ff16601b1480610be857508360ff16601c145b610c345760405162461bcd60e51b815260206004820152601b60248201527f696e76616c6964207369676e6174757265202776272076616c756500000000006044820152606401610462565b6040805160008082526020820180845288905260ff871692820192909252606081018590526080810184905260019060a0016020604051602081039080840390855afa158015610c88573d6000803e3d6000fd5b5050604051601f1901519150506001600160a01b038116610cdf5760405162461bcd60e51b8152602060048201526011602482015270696e76616c6964207369676e617475726560781b6044820152606401610462565b95945050505050565b80356001600160a01b0381168114610cff57600080fd5b919050565b803560ff81168114610cff57600080fd5b600080600080600060a08688031215610d2d57600080fd5b610d3686610ce8565b945060208601359350610d4b60408701610d04565b94979396509394606081013594506080013592915050565b600060208284031215610d7557600080fd5b5035919050565b600060208284031215610d8e57600080fd5b6105dc82610ce8565b60008060408385031215610daa57600080fd5b610db383610ce8565b946020939093013593505050565b600080600060608486031215610dd657600080fd5b610ddf84610ce8565b9250610ded60208501610ce8565b9150604084013590509250925092565b60008060008060008060008060006101208a8c031215610e1c57600080fd5b610e258a610ce8565b9850610e3360208b01610ce8565b975060408a0135965060608a0135955060808a0135945060a08a01359350610e5d60c08b01610d04565b925060e08a013591506101008a013590509295985092959850929598565b600080600060608486031215610e9057600080fd5b610e9984610ce8565b95602085013595506040909401359392505050565b6020808252600d908201526c1858d8d95cdcc819195b9a5959609a1b604082015260600190565b600060018201610ef557634e487b7160e01b600052601160045260246000fd5b506001019056fea26469706673582212207c4263c50b0fe5c8ac5e62c0dbe76cdb225d08a20de439a8af5ab1e1476e6aa164736f6c634300080f0033",
    "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106101585760003560e01c8063ae682e2e116100c3578063d5bb7f671161007c578063d5bb7f67146102eb578063d9169487146102fe578063e94a010214610325578063f822d5aa1461035e578063fcc2c07814610371578063ff2642cf1461038457600080fd5b8063ae682e2e14610295578063c4d029c6146102a0578063c688d693146102a8578063c6c3bbe6146102bb578063ce8b3a58146102ce578063d1333c98146102d857600080fd5b806371c582921161011557806371c58292146101fa578063725f36261461020d57806374d5e10014610230578063845ab94f14610250578063a07723c214610263578063ae5b102e1461028257600080fd5b806320606b701461015d5780632b521416146101975780633644e515146101ac57806359a7715a146101d357806359cdd2a3146101dc5780635a049a70146101e5575b600080fd5b6101847f8cad95687ba82c2ce50e74f7b754645e5117c3a5bec8151c0726d5857980a86681565b6040519081526020015b60405180910390f35b30600090815260208190526040902054610184565b6101847f000000000000000000000000000000000000000000000000000000000000000081565b61018460015481565b61018460025481565b6101f86101f3366004610d15565b6103ab565b005b6101f8610208366004610d63565b61047f565b61022061021b366004610d63565b6104ea565b604051901515815260200161018e565b61018461023e366004610d7c565b60006020819052908152604090205481565b6101f861025e366004610d63565b610505565b61026d6202000081565b60405163ffffffff909116815260200161018e565b6101f8610290366004610d97565b610514565b610184600160ff1b81565b61026d600181565b6102206102b6366004610d97565b6105be565b6101f86102c9366004610dc1565b6105e3565b61026d6201000081565b6101f86102e6366004610dfd565b6105f4565b6101f86102f9366004610d63565b610772565b6101847f158b0a9edf7a828aad02f63cd515c68ef2f50ba807396f6d12842833a159742981565b610220610333366004610d97565b6001600160a01b03919091166000908152600360209081526040808320938352929052205460ff1690565b61018461036c366004610e7b565b61077c565b61022061037f366004610d63565b6107a7565b6101847f495835d970a03ff092657fca9abde67d34a0bb73a0bba258a5fa90c4ce4340f681565b604080517f158b0a9edf7a828aad02f63cd515c68ef2f50ba807396f6d12842833a159742960208201526001600160a01b038716918101919091526060810185905260009061040f906080015b6040516020818303038152906040528585856107b3565b9050856001600160a01b0316816001600160a01b03161461046b5760405162461bcd60e51b8152602060048201526011602482015270696e76616c6964207369676e617475726560781b60448201526064015b60405180910390fd5b61047786866001610835565b505050505050565b61048b620200006107a7565b6104a75760405162461bcd60e51b815260040161046290610eae565b600254604080519182526020820183905233917f72262ec80631e7232e7be11294d78cf431aaf58c2a7a1eb27275d9bbb8ed863e910160405180910390a2600255565b30600090815260208190526040812054821682145b92915050565b61051133826001610835565b50565b610521600160ff1b6107a7565b61053d5760405162461bcd60e51b815260040161046290610eae565b6001600160a01b0382166000908152602081905260409020546105629033908361077c565b6001600160a01b03831660008181526020818152604091829020849055815185815290810193909352909133917f5a10526456f5116c0b7b80582c217d666243fd51b6a2d92c8011e601c2462e5f910160405180910390a35050565b6001600160a01b038216600090815260208190526040812054821682145b9392505050565b6105ef33848484610943565b505050565b6105fe60016104ea565b61064a5760405162461bcd60e51b815260206004820152601d60248201527f6d696e74696e67207769746820617574682069732064697361626c65640000006044820152606401610462565b604080517f495835d970a03ff092657fca9abde67d34a0bb73a0bba258a5fa90c4ce4340f660208201526001600160a01b03808c169282019290925290891660608201526080810188905260a0810187905260c0810186905260e081018590526000906106ba90610100016103f8565b905086421161070b5760405162461bcd60e51b815260206004820152601760248201527f7369676e6174757265206e6f74207965742076616c69640000000000000000006044820152606401610462565b85421061074e5760405162461bcd60e51b81526020600482015260116024820152701cda59db985d1d5c9948195e1c1a5c9959607a1b6044820152606401610462565b61075a81866000610835565b610766818b8b8b610943565b50505050505050505050565b6105113082610514565b6001600160a01b03929092166000908152602081905260409020546000198084188216189216171690565b60006104ff33836105be565b835160208086019190912060405161190160f01b928101929092527f00000000000000000000000000000000000000000000000000000000000000006022830152604282018190526000918290606201604051602081830303815290604052805190602001209050600061082982888888610b61565b98975050505050505050565b6001600160a01b038316600090815260036020908152604080832085845290915290205460ff16156108995760405162461bcd60e51b815260206004820152600d60248201526c696e76616c6964206e6f6e636560981b6044820152606401610462565b6001600160a01b03831660009081526003602090815260408083208584529091529020805460ff1916600117905580156109085760405182906001600160a01b038516907f1cdd46ff242716cdaa72d159d339a485b3438398348d68f09d7c8c0a59353d8190600090a3505050565b60405182906001600160a01b038516907f98de503528ee59b575ef0c0a2576a82497bfc029a5685b209e9ec333479b10a590600090a3505050565b61095084620100006105be565b61096c5760405162461bcd60e51b815260040161046290610eae565b6001600160a01b0383166109c25760405162461bcd60e51b815260206004820152601f60248201527f45524337323120696e7374616e63652061646472206973206e6f7420736574006044820152606401610462565b6001600160a01b038216610a185760405162461bcd60e51b815260206004820152601c60248201527f4e46542072656365697665722061646472206973206e6f7420736574000000006044820152606401610462565b80600003610a5e5760405162461bcd60e51b81526020600482015260136024820152721d1bdad95b881251081a5cc81b9bdd081cd95d606a1b6044820152606401610462565b60025460015410610aa35760405162461bcd60e51b815260206004820152600f60248201526e1a185c9918d85c081c995858da1959608a1b6044820152606401610462565b60018054906000610ab383610ed5565b9091555050604051632851206560e21b81526001600160a01b0383811660048301526024820183905284169063a144819490604401600060405180830381600087803b158015610b0257600080fd5b505af1158015610b16573d6000803e3d6000fd5b5050505080826001600160a01b0316846001600160a01b03167f9d228d69b5fdb8d273a2336f8fb8612d039631024ea9bf09c424a9503aa078f060405160405180910390a450505050565b60007f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0821115610bd35760405162461bcd60e51b815260206004820152601b60248201527f696e76616c6964207369676e6174757265202773272076616c756500000000006044820152606401610462565b8360ff16601b1480610be857508360ff16601c145b610c345760405162461bcd60e51b815260206004820152601b60248201527f696e76616c6964207369676e6174757265202776272076616c756500000000006044820152606401610462565b6040805160008082526020820180845288905260ff871692820192909252606081018590526080810184905260019060a0016020604051602081039080840390855afa158015610c88573d6000803e3d6000fd5b5050604051601f1901519150506001600160a01b038116610cdf5760405162461bcd60e51b8152602060048201526011602482015270696e76616c6964207369676e617475726560781b6044820152606401610462565b95945050505050565b80356001600160a01b0381168114610cff57600080fd5b919050565b803560ff81168114610cff57600080fd5b600080600080600060a08688031215610d2d57600080fd5b610d3686610ce8565b945060208601359350610d4b60408701610d04565b94979396509394606081013594506080013592915050565b600060208284031215610d7557600080fd5b5035919050565b600060208284031215610d8e57600080fd5b6105dc82610ce8565b60008060408385031215610daa57600080fd5b610db383610ce8565b946020939093013593505050565b600080600060608486031215610dd657600080fd5b610ddf84610ce8565b9250610ded60208501610ce8565b9150604084013590509250925092565b60008060008060008060008060006101208a8c031215610e1c57600080fd5b610e258a610ce8565b9850610e3360208b01610ce8565b975060408a0135965060608a0135955060808a0135945060a08a01359350610e5d60c08b01610d04565b925060e08a013591506101008a013590509295985092959850929598565b600080600060608486031215610e9057600080fd5b610e9984610ce8565b95602085013595506040909401359392505050565b6020808252600d908201526c1858d8d95cdcc819195b9a5959609a1b604082015260600190565b600060018201610ef557634e487b7160e01b600052601160045260246000fd5b506001019056fea26469706673582212207c4263c50b0fe5c8ac5e62c0dbe76cdb225d08a20de439a8af5ab1e1476e6aa164736f6c634300080f0033",
    "devdoc": {
      "details": "The signature is constructed via EIP-712 similar to EIP-2612, or EIP-3009Target ERC721 contract(s) must allow helper to mint the tokens, this should be configured      as part of the deployment or setup processesVersion 3 (NFTFactoryV3) adds total mint limiting feature allowing to set the NFT total     mint hardcap; factory stops minting when total mint of the contract reaches the hardcap",
      "events": {
        "AuthorizationCanceled(address,bytes32)": {
          "details": "Fired whenever the nonce gets cancelled (ex.: `cancelAuthorization`)Both `AuthorizationUsed` and `AuthorizationCanceled` imply the nonce      cannot be longer used, the only difference is that `AuthorizationCanceled`      implies no smart contract state change made (except the nonce marked as cancelled)",
          "params": {
            "authorizer": "an address which has cancelled the nonce",
            "nonce": "the nonce cancelled"
          }
        },
        "AuthorizationUsed(address,bytes32)": {
          "details": "Fired whenever the nonce gets used (ex.: `transferWithAuthorization`, `receiveWithAuthorization`)",
          "params": {
            "authorizer": "an address which has used the nonce",
            "nonce": "the nonce used"
          }
        },
        "Minted(address,address,uint256)": {
          "details": "Fired in mint() and mintWithAuthorization() after an NFT is minted",
          "params": {
            "erc721Address": "ERC721 contract address which was minted",
            "to": "an address NFT was minted to",
            "tokenId": "NFT ID which was minted"
          }
        },
        "TotalMintHardcapUpdated(address,uint256,uint256)": {
          "details": "Fired whenever total mint hardcap is updated (ex.: `updateTotalMintHardcap`)",
          "params": {
            "authorizer": "an address which has updated total mint hardcap",
            "newLimit": "new total mint hardcap",
            "oldLimit": "old total mint hardcap"
          }
        }
      },
      "kind": "dev",
      "methods": {
        "authorizationState(address,bytes32)": {
          "details": "Nonces are expected to be client-side randomly generated 32-byte data      unique to the authorizer's address",
          "params": {
            "_authorizer": "Authorizer's address",
            "_nonce": "Nonce of the authorization"
          },
          "returns": {
            "_0": "true if the nonce is used"
          }
        },
        "cancelAuthorization(address,bytes32,uint8,bytes32,bytes32)": {
          "params": {
            "_authorizer": "transaction authorizer",
            "_nonce": "unique random nonce to cancel (mark as used)",
            "r": "half of the ECDSA signature pair",
            "s": "half of the ECDSA signature pair",
            "v": "the recovery byte of the signature"
          }
        },
        "cancelAuthorization(bytes32)": {
          "params": {
            "_nonce": "unique random nonce to cancel (mark as used)"
          }
        },
        "constructor": {
          "params": {
            "_totalMintHardcap": "NFTFactoryV3 total mint limit, factory stops minting the ERC721      if its total mint (totalMint()) reaches the total mint hardcap (totalMintHardcap())"
          }
        },
        "evaluateBy(address,uint256,uint256)": {
          "details": "Calculated based on:      1) operator's own permission set read from userRoles[operator]      2) target permission set - what is already set on the target      3) desired permission set - what do we want set target toCorner cases:      1) Operator is super admin and its permission set is `FULL_PRIVILEGES_MASK`:        `desired` bitset is returned regardless of the `target` permission set value        (what operator sets is what they get)      2) Operator with no permissions (zero bitset):        `target` bitset is returned regardless of the `desired` value        (operator has no authority and cannot modify anything)Example:      Consider an operator with the permissions bitmask     00001111      is about to modify the target permission set          01010101      Operator wants to set that permission set to          00110011      Based on their role, an operator has the permissions      to update only lowest 4 bits on the target, meaning that      high 4 bits of the target set in this example is left      unchanged and low 4 bits get changed as desired:      01010011",
          "params": {
            "desired": "desired set of permissions operator would like to set",
            "operator": "address of the contract operator which is about to set the permissions",
            "target": "input set of permissions to operator is going to modify"
          },
          "returns": {
            "_0": "resulting set of permissions given operator will set"
          }
        },
        "features()": {
          "details": "Effectively reads userRoles role for the contract itself",
          "returns": {
            "_0": "256-bit bitmask of the features enabled"
          }
        },
        "isFeatureEnabled(uint256)": {
          "params": {
            "required": "set of features to check against"
          },
          "returns": {
            "_0": "true if all the features requested are enabled, false otherwise"
          }
        },
        "isOperatorInRole(address,uint256)": {
          "params": {
            "operator": "address of the user to check role for",
            "required": "set of permissions (role) to check"
          },
          "returns": {
            "_0": "true if all the permissions requested are enabled, false otherwise"
          }
        },
        "isSenderInRole(uint256)": {
          "params": {
            "required": "set of permissions (role) to check against"
          },
          "returns": {
            "_0": "true if all the permissions requested are enabled, false otherwise"
          }
        },
        "mint(address,address,uint256)": {
          "details": "Doesn't allow minting the token with ID zeroRequires an executor to have ROLE_MINTER permissionRequires target ERC721 contract to be mintable (`MintableERC721`)Requires target ERC721 contract instance to allow minting via helper",
          "params": {
            "_targetErc721": "target ERC721 contract instance to mint token on,      compatible with `MintableERC721`",
            "_to": "an address to mint token to",
            "_tokenId": "target ERC721 token ID to mint"
          }
        },
        "mintWithAuthorization(address,address,uint256,uint256,uint256,bytes32,uint8,bytes32,bytes32)": {
          "params": {
            "_nonce": "unique random nonce",
            "_targetErc721": "target ERC721 contract instance to mint token on,      compatible with `MintableERC721`",
            "_to": "an address to mint token to",
            "_tokenId": "target ERC721 token ID to mint",
            "_validAfter": "signature valid after time (unix timestamp)",
            "_validBefore": "signature valid before time (unix timestamp)",
            "r": "half of the ECDSA signature pair",
            "s": "half of the ECDSA signature pair",
            "v": "the recovery byte of the signature"
          }
        },
        "updateFeatures(uint256)": {
          "details": "Requires transaction sender to have `ROLE_ACCESS_MANAGER` permissionFunction is left for backward compatibility with older versions",
          "params": {
            "_mask": "bitmask representing a set of features to enable/disable"
          }
        },
        "updateRole(address,uint256)": {
          "details": "Setting role to zero is equivalent to removing an all permissionsSetting role to `FULL_PRIVILEGES_MASK` is equivalent to      copying senders' permissions (role) to the userRequires transaction sender to have `ROLE_ACCESS_MANAGER` permission",
          "params": {
            "operator": "address of a user to alter permissions for or zero      to alter global features of the smart contract",
            "role": "bitmask representing a set of permissions to      enable/disable for a user specified"
          }
        },
        "updateTotalMintHardcap(uint256)": {
          "details": "Requires transaction sender to have `ROLE_MINT_HARDCAP_MANAGER` permission",
          "params": {
            "_totalMintHardcap": "new NFTFactoryV3 total mint hardcap"
          }
        }
      },
      "stateVariables": {
        "DOMAIN_TYPEHASH": {
          "details": "Note: we do not include version into the domain typehash/separator,      it is implied version is concatenated to the name field, like \"NFTFactoryV2\""
        },
        "FEATURE_MINTING_WITH_AUTH": {
          "details": "Feature FEATURE_MINTING_WITH_AUTH must be enabled in order for      `mintWithAuthorization()` function to succeed"
        },
        "ROLE_FACTORY_MINTER": {
          "details": "Role ROLE_FACTORY_MINTER allows minting tokens      (executing `mint` function)"
        },
        "ROLE_MINT_HARDCAP_MANAGER": {
          "details": "Role ROLE_MINT_HARDCAP_MANAGER allows updating total mint hardcap      (executing `updateTotalMintHardcap` function)"
        },
        "totalMint": {
          "details": "Number of ERC721 token been mint by NFTFactoryV3"
        },
        "totalMintHardcap": {
          "details": "The factory `mint` and `mintWithAuthorization` function throws      if factory `totalMint` value is equal or bigger than `totalMintHardcap`"
        },
        "usedNonces": {
          "details": "A record of used nonces for EIP-712 transactionsA record of used nonces for signing/validating signatures      in `mintWithAuthorization` for every mintMaps authorizer address => nonce => true/false (used unused)"
        }
      },
      "title": "Alethea NFT Factory",
      "version": 1
    },
    "userdoc": {
      "kind": "user",
      "methods": {
        "CANCEL_AUTHORIZATION_TYPEHASH()": {
          "notice": "EIP-712 CancelAuthorization struct typeHash,      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash"
        },
        "DOMAIN_SEPARATOR()": {
          "notice": "EIP-712 contract's domain separator,      see https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator"
        },
        "DOMAIN_TYPEHASH()": {
          "notice": "EIP-712 contract's domain typeHash,      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash"
        },
        "FEATURE_MINTING_WITH_AUTH()": {
          "notice": "Enables meta transaction minting (minting with an authorization      via an EIP712 signature)"
        },
        "MINT_WITH_AUTHORIZATION_TYPEHASH()": {
          "notice": "EIP-712 MintWithAuthorization struct typeHash,      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash"
        },
        "ROLE_ACCESS_MANAGER()": {
          "notice": "Access manager is responsible for assigning the roles to users,      enabling/disabling global features of the smart contractAccess manager can add, remove and update user roles,      remove and update global features"
        },
        "ROLE_FACTORY_MINTER()": {
          "notice": "Factory minter is responsible for creating (minting)      tokens to an arbitrary address"
        },
        "ROLE_MINT_HARDCAP_MANAGER()": {
          "notice": "Mint hardcap manager is responsible for updating      NFTFactoryV3 total mint hardcap"
        },
        "authorizationState(address,bytes32)": {
          "notice": "Returns the state of an authorization, more specifically      if the specified nonce was already used by the address specified"
        },
        "cancelAuthorization(address,bytes32,uint8,bytes32,bytes32)": {
          "notice": "Cancels the authorization (using EIP-712 signature)"
        },
        "cancelAuthorization(bytes32)": {
          "notice": "Cancels the authorization"
        },
        "constructor": {
          "notice": "Deploys the helper contract and initializes DOMAIN_SEPARATOR using the created smart contract address"
        },
        "evaluateBy(address,uint256,uint256)": {
          "notice": "Determines the permission bitmask an operator can set on the      target permission setUsed to calculate the permission bitmask to be set when requested     in `updateRole` and `updateFeatures` functions"
        },
        "features()": {
          "notice": "Retrieves globally set of features enabled"
        },
        "isFeatureEnabled(uint256)": {
          "notice": "Checks if requested set of features is enabled globally on the contract"
        },
        "isOperatorInRole(address,uint256)": {
          "notice": "Checks if operator has all the permissions (role) required"
        },
        "isSenderInRole(uint256)": {
          "notice": "Checks if transaction sender `msg.sender` has all the permissions required"
        },
        "mint(address,address,uint256)": {
          "notice": "Restricted access function to mint an NFT"
        },
        "mintWithAuthorization(address,address,uint256,uint256,uint256,bytes32,uint8,bytes32,bytes32)": {
          "notice": "Executes a mint function with a signed authorization"
        },
        "totalMintHardcap()": {
          "notice": "Total Mint Hardcap affects factory capability to mint: once      factory total mint reaches the hardcap, factory stops minting it"
        },
        "updateFeatures(uint256)": {
          "notice": "Updates set of the globally enabled features (`features`),      taking into account sender's permissions"
        },
        "updateRole(address,uint256)": {
          "notice": "Updates set of permissions (role) for a given user,      taking into account sender's permissions."
        },
        "updateTotalMintHardcap(uint256)": {
          "notice": "Updates total mint hardcap of NFTFactoryV3 contract."
        },
        "userRoles(address)": {
          "notice": "Privileged addresses with defined roles/permissionsIn the context of ERC20/ERC721 tokens these can be permissions to      allow minting or burning tokens, transferring on behalf and so on"
        }
      },
      "notice": "NFT Factory is a helper smart contract responsible for minting arbitrary NFTsIt supports two mechanisms:      - minting delegation: authorized address executes mint function on the helper,        and helper executes minting function on the target ERC721 contract as an internal transaction      - meta transaction minting or minting with an authorization: authorized address signs        the minting authorization message and any address executes mint function on the helperSecond mechanism allows to shift the gas costs for the transaction to any address      (usually this is the NFT beneficiary - an address which receives an NFT)",
      "version": 1
    },
    "storageLayout": {
      "storage": [
        {
          "astId": 919,
          "contract": "contracts/protocol/NFTFactoryV3.sol:NFTFactoryV3",
          "label": "userRoles",
          "offset": 0,
          "slot": "0",
          "type": "t_mapping(t_address,t_uint256)"
        },
        {
          "astId": 437,
          "contract": "contracts/protocol/NFTFactoryV3.sol:NFTFactoryV3",
          "label": "totalMint",
          "offset": 0,
          "slot": "1",
          "type": "t_uint256"
        },
        {
          "astId": 440,
          "contract": "contracts/protocol/NFTFactoryV3.sol:NFTFactoryV3",
          "label": "totalMintHardcap",
          "offset": 0,
          "slot": "2",
          "type": "t_uint256"
        },
        {
          "astId": 447,
          "contract": "contracts/protocol/NFTFactoryV3.sol:NFTFactoryV3",
          "label": "usedNonces",
          "offset": 0,
          "slot": "3",
          "type": "t_mapping(t_address,t_mapping(t_bytes32,t_bool))"
        }
      ],
      "types": {
        "t_address": {
          "encoding": "inplace",
          "label": "address",
          "numberOfBytes": "20"
        },
        "t_bool": {
          "encoding": "inplace",
          "label": "bool",
          "numberOfBytes": "1"
        },
        "t_bytes32": {
          "encoding": "inplace",
          "label": "bytes32",
          "numberOfBytes": "32"
        },
        "t_mapping(t_address,t_mapping(t_bytes32,t_bool))": {
          "encoding": "mapping",
          "key": "t_address",
          "label": "mapping(address => mapping(bytes32 => bool))",
          "numberOfBytes": "32",
          "value": "t_mapping(t_bytes32,t_bool)"
        },
        "t_mapping(t_address,t_uint256)": {
          "encoding": "mapping",
          "key": "t_address",
          "label": "mapping(address => uint256)",
          "numberOfBytes": "32",
          "value": "t_uint256"
        },
        "t_mapping(t_bytes32,t_bool)": {
          "encoding": "mapping",
          "key": "t_bytes32",
          "label": "mapping(bytes32 => bool)",
          "numberOfBytes": "32",
          "value": "t_bool"
        },
        "t_uint256": {
          "encoding": "inplace",
          "label": "uint256",
          "numberOfBytes": "32"
        }
      }
    }
  }