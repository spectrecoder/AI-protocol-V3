{
  "address": "0x77BDD9a3f4A87B1130fAf69C137657C74bdCD560",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_characterErc20ImplAddress",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bool",
          "name": "initialized",
          "type": "bool"
        },
        {
          "indexed": false,
          "internalType": "string",
          "name": "whyNot",
          "type": "string"
        }
      ],
      "name": "CharacterERC20ImplInitialized",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "characterErc20ProxyAddress",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "characterErc20ImplAddress",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "_initialHolder",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_initialSupply",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "string",
          "name": "_name",
          "type": "string"
        },
        {
          "indexed": true,
          "internalType": "string",
          "name": "_symbol",
          "type": "string"
        }
      ],
      "name": "ProxyDeployed",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "characterErc20ImplAddress",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_initialHolder",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_initialSupply",
          "type": "uint256"
        },
        {
          "internalType": "string",
          "name": "_name",
          "type": "string"
        },
        {
          "internalType": "string",
          "name": "_symbol",
          "type": "string"
        }
      ],
      "name": "deployCharacterERC20",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0xcce033f88e70d9c531e793d7cd06b9acd8b7ada20e02ee28ba2e4e32b80b1ffb",
  "receipt": {
    "to": null,
    "from": "0x5F185Da55f7BBD9217E3b3CeE06b180721FA6d34",
    "contractAddress": "0x77BDD9a3f4A87B1130fAf69C137657C74bdCD560",
    "transactionIndex": 8,
    "gasUsed": "597071",
    "logsBloom": "0x00800000010008000000000000000000000000000000000000000000000000000010000000000010000000000000000000000000000000000000000000000000000000100000001000000008000000100000000200000000000000000000000000000000020008000000000000000800000000800000000000000010000200000000000000000000000000000400000000000000000000000000010000000000000040800000000002000000801000000000000000000000010000000000000008000002000000000000000000000000000000040000020000000000800020000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xbf61cd30c4f0ffefbd756f901e3ee724abe269818ba68c3cafce6453bbdd7a1b",
    "transactionHash": "0xcce033f88e70d9c531e793d7cd06b9acd8b7ada20e02ee28ba2e4e32b80b1ffb",
    "logs": [
      {
        "transactionIndex": 8,
        "blockNumber": 29037878,
        "transactionHash": "0xcce033f88e70d9c531e793d7cd06b9acd8b7ada20e02ee28ba2e4e32b80b1ffb",
        "address": "0xD3e2e8C218618c8A842D3e3f84461fcBBA164b6c",
        "topics": [
          "0x5a10526456f5116c0b7b80582c217d666243fd51b6a2d92c8011e601c2462e5f",
          "0x00000000000000000000000077bdd9a3f4a87b1130faf69c137657c74bdcd560",
          "0x000000000000000000000000d3e2e8c218618c8a842d3e3f84461fcbba164b6c"
        ],
        "data": "0x000000000000000000000000000000000000000000000000000000000000ffff000000000000000000000000000000000000000000000000000000000000ffff",
        "logIndex": 17,
        "blockHash": "0xbf61cd30c4f0ffefbd756f901e3ee724abe269818ba68c3cafce6453bbdd7a1b"
      },
      {
        "transactionIndex": 8,
        "blockNumber": 29037878,
        "transactionHash": "0xcce033f88e70d9c531e793d7cd06b9acd8b7ada20e02ee28ba2e4e32b80b1ffb",
        "address": "0xD3e2e8C218618c8A842D3e3f84461fcBBA164b6c",
        "topics": [
          "0x9d228d69b5fdb8d273a2336f8fb8612d039631024ea9bf09c424a9503aa078f0",
          "0x00000000000000000000000077bdd9a3f4a87b1130faf69c137657c74bdcd560",
          "0x000000000000000000000000d3e2e8c218618c8a842d3e3f84461fcbba164b6c"
        ],
        "data": "0x0000000000000000000000000000000000000000000000000000000000000001",
        "logIndex": 18,
        "blockHash": "0xbf61cd30c4f0ffefbd756f901e3ee724abe269818ba68c3cafce6453bbdd7a1b"
      },
      {
        "transactionIndex": 8,
        "blockNumber": 29037878,
        "transactionHash": "0xcce033f88e70d9c531e793d7cd06b9acd8b7ada20e02ee28ba2e4e32b80b1ffb",
        "address": "0xD3e2e8C218618c8A842D3e3f84461fcBBA164b6c",
        "topics": [
          "0xd1398bee19313d6bf672ccb116e51f4a1a947e91c757907f51fbb5b5e56c698f",
          "0x00000000000000000000000077bdd9a3f4a87b1130faf69c137657c74bdcd560",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x000000000000000000000000d3e2e8c218618c8a842d3e3f84461fcbba164b6c"
        ],
        "data": "0x0000000000000000000000000000000000000000000000000000000000000001",
        "logIndex": 19,
        "blockHash": "0xbf61cd30c4f0ffefbd756f901e3ee724abe269818ba68c3cafce6453bbdd7a1b"
      },
      {
        "transactionIndex": 8,
        "blockNumber": 29037878,
        "transactionHash": "0xcce033f88e70d9c531e793d7cd06b9acd8b7ada20e02ee28ba2e4e32b80b1ffb",
        "address": "0xD3e2e8C218618c8A842D3e3f84461fcBBA164b6c",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x000000000000000000000000d3e2e8c218618c8a842d3e3f84461fcbba164b6c"
        ],
        "data": "0x0000000000000000000000000000000000000000000000000000000000000001",
        "logIndex": 20,
        "blockHash": "0xbf61cd30c4f0ffefbd756f901e3ee724abe269818ba68c3cafce6453bbdd7a1b"
      },
      {
        "transactionIndex": 8,
        "blockNumber": 29037878,
        "transactionHash": "0xcce033f88e70d9c531e793d7cd06b9acd8b7ada20e02ee28ba2e4e32b80b1ffb",
        "address": "0x77BDD9a3f4A87B1130fAf69C137657C74bdCD560",
        "topics": [
          "0xc6c73eaf7ba8245f625f757feff8ae2bcd9bd3a4c6f3afddc5113b352cf724c6",
          "0x0000000000000000000000000000000000000000000000000000000000000000"
        ],
        "data": "0x00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000000",
        "logIndex": 21,
        "blockHash": "0xbf61cd30c4f0ffefbd756f901e3ee724abe269818ba68c3cafce6453bbdd7a1b"
      }
    ],
    "blockNumber": 29037878,
    "cumulativeGasUsed": "1507582",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0xD3e2e8C218618c8A842D3e3f84461fcBBA164b6c"
  ],
  "numDeployments": 1,
  "solcInputHash": "fbaa703278c7be1cc960321dfb92ebef",
  "metadata": "{\"compiler\":{\"version\":\"0.8.15+commit.e14f2714\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_characterErc20ImplAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"initialized\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"whyNot\",\"type\":\"string\"}],\"name\":\"CharacterERC20ImplInitialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"characterErc20ProxyAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"characterErc20ImplAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_initialHolder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_initialSupply\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"}],\"name\":\"ProxyDeployed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"characterErc20ImplAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_initialHolder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_initialSupply\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"}],\"name\":\"deployCharacterERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"author\":\"Basil Gorin\",\"details\":\"The deployment is done via EIP-1167 Minimal Proxy Contract      See https://eips.ethereum.org/EIPS/eip-1167\",\"events\":{\"CharacterERC20ImplInitialized(bool,string)\":{\"details\":\"Fired only once on deployment\",\"params\":{\"initialized\":\"if CharacterERC20 impl was successfully initialized\",\"whyNot\":\"empty, or if CharacterERC20 impl was not initialized \\u2013 the reason\"}},\"ProxyDeployed(address,address,address,uint256,string,string)\":{\"details\":\"Fired in deployCharacterERC20\",\"params\":{\"_initialHolder\":\"owner of the initial token supply\",\"_initialSupply\":\"initial token supply\",\"_name\":\"token name to set\",\"_symbol\":\"token symbol to set\",\"characterErc20ImplAddress\":\"CharacterERC20 impl address, always the same\",\"characterErc20ProxyAddress\":\"deployed EIP-1167 clone (proxy) address\"}}},\"kind\":\"dev\",\"methods\":{\"constructor\":{\"details\":\"Deploys a CharacterERC20Deployer instance bound to an already deployed      CharacterERC20 token instance implementation to be used to create EIP-1167 \\\"clones\\\"\"},\"deployCharacterERC20(address,uint256,string,string)\":{\"details\":\"Technically this deploys a tiny proxy pointing to the token impl address `characterErc20ImplAddress`      and initialized it immediately, making the deployment safe and ready for use\",\"params\":{\"_initialHolder\":\"owner of the initial token supply\",\"_initialSupply\":\"initial token supply\",\"_name\":\"token name to set\",\"_symbol\":\"token symbol to set\"}}},\"stateVariables\":{\"characterErc20ImplAddress\":{\"details\":\"The deployed minimalistic proxy always points to this implementation\"}},\"title\":\"Character ERC20 Token Deployer\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"characterErc20ImplAddress()\":{\"notice\":\"An address of already deployed CharacterERC20 token used as an implementation\"},\"deployCharacterERC20(address,uint256,string,string)\":{\"notice\":\"\\\"Deploys\\\" CharacterERC20 token with the specified name, symbol, initial total supply\"}},\"notice\":\"A helper stand-alone contract allowing to \\\"clone\\\" Character ERC20 Token\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/token/CharacterERC20.sol\":\"CharacterERC20Deployer\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() initializer {}\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\\n        // contract may have been reentered.\\n        require(_initializing ? _isConstructor() : !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} modifier, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    function _isConstructor() private view returns (bool) {\\n        return !AddressUpgradeable.isContract(address(this));\\n    }\\n}\\n\",\"keccak256\":\"0x68861bcc80cacbd498efde75aab6c74a486cc48262660d326c8d7530d9752097\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x3f0f878c796dfc7feba6d3c4e3e526c14c7deae8b7bfc71088e3f38fab0d77b3\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/Clones.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/Clones.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\\n * deploying minimal proxy contracts, also known as \\\"clones\\\".\\n *\\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\\n *\\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\\n * deterministic method.\\n *\\n * _Available since v3.4._\\n */\\nlibrary Clones {\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     */\\n    function clone(address implementation) internal returns (address instance) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            instance := create(0, ptr, 0x37)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create failed\\\");\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            instance := create2(0, ptr, 0x37, salt)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create2 failed\\\");\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\\n            mstore(add(ptr, 0x4c), salt)\\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\\n            predicted := keccak256(add(ptr, 0x37), 0x55)\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(address implementation, bytes32 salt)\\n        internal\\n        view\\n        returns (address predicted)\\n    {\\n        return predictDeterministicAddress(implementation, salt, address(this));\\n    }\\n}\\n\",\"keccak256\":\"0x1cc0efb01cbf008b768fd7b334786a6e358809198bb7e67f1c530af4957c6a21\",\"license\":\"MIT\"},\"contracts/interfaces/EIP2612.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/**\\n * @title EIP-2612: permit - 712-signed approvals\\n *\\n * @notice A function permit extending ERC-20 which allows for approvals to be made via secp256k1 signatures.\\n *      This kind of \\u201caccount abstraction for ERC-20\\u201d brings about two main benefits:\\n *        - transactions involving ERC-20 operations can be paid using the token itself rather than ETH,\\n *        - approve and pull operations can happen in a single transaction instead of two consecutive transactions,\\n *        - while adding as little as possible over the existing ERC-20 standard.\\n *\\n * @notice See https://eips.ethereum.org/EIPS/eip-2612#specification\\n */\\ninterface EIP2612 {\\n\\t/**\\n\\t * @notice EIP712 domain separator of the smart contract. It should be unique to the contract\\n\\t *      and chain to prevent replay attacks from other domains, and satisfy the requirements of EIP-712,\\n\\t *      but is otherwise unconstrained.\\n\\t */\\n\\tfunction DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n\\t/**\\n\\t * @notice Counter of the nonces used for the given address; nonce are used sequentially\\n\\t *\\n\\t * @dev To prevent from replay attacks nonce is incremented for each address after a successful `permit` execution\\n\\t *\\n\\t * @param owner an address to query number of used nonces for\\n\\t * @return number of used nonce, nonce number to be used next\\n\\t */\\n\\tfunction nonces(address owner) external view returns (uint);\\n\\n\\t/**\\n\\t * @notice For all addresses owner, spender, uint256s value, deadline and nonce, uint8 v, bytes32 r and s,\\n\\t *      a call to permit(owner, spender, value, deadline, v, r, s) will set approval[owner][spender] to value,\\n\\t *      increment nonces[owner] by 1, and emit a corresponding Approval event,\\n\\t *      if and only if the following conditions are met:\\n\\t *        - The current blocktime is less than or equal to deadline.\\n\\t *        - owner is not the zero address.\\n\\t *        - nonces[owner] (before the state update) is equal to nonce.\\n\\t *        - r, s and v is a valid secp256k1 signature from owner of the message:\\n\\t *\\n\\t * @param owner token owner address, granting an approval to spend its tokens\\n\\t * @param spender an address approved by the owner (token owner)\\n\\t *      to spend some tokens on its behalf\\n\\t * @param value an amount of tokens spender `spender` is allowed to\\n\\t *      transfer on behalf of the token owner\\n\\t * @param v the recovery byte of the signature\\n\\t * @param r half of the ECDSA signature pair\\n\\t * @param s half of the ECDSA signature pair\\n\\t */\\n\\tfunction permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n}\\n\",\"keccak256\":\"0x12067c13c4b7fc54ce717d047f076b6ad4a26c6f9010a8987c5e328a4edfee1e\",\"license\":\"MIT\"},\"contracts/interfaces/EIP3009.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/**\\n * @title EIP-3009: Transfer With Authorization\\n *\\n * @notice A contract interface that enables transferring of fungible assets via a signed authorization.\\n *      See https://eips.ethereum.org/EIPS/eip-3009\\n *      See https://eips.ethereum.org/EIPS/eip-3009#specification\\n */\\ninterface EIP3009 {\\n\\t/**\\n\\t * @dev Fired whenever the nonce gets used (ex.: `transferWithAuthorization`, `receiveWithAuthorization`)\\n\\t *\\n\\t * @param authorizer an address which has used the nonce\\n\\t * @param nonce the nonce used\\n\\t */\\n\\tevent AuthorizationUsed(address indexed authorizer, bytes32 indexed nonce);\\n\\n\\t/**\\n\\t * @dev Fired whenever the nonce gets cancelled (ex.: `cancelAuthorization`)\\n\\t *\\n\\t * @dev Both `AuthorizationUsed` and `AuthorizationCanceled` imply the nonce\\n\\t *      cannot be longer used, the only difference is that `AuthorizationCanceled`\\n\\t *      implies no smart contract state change made (except the nonce marked as cancelled)\\n\\t *\\n\\t * @param authorizer an address which has cancelled the nonce\\n\\t * @param nonce the nonce cancelled\\n\\t */\\n\\tevent AuthorizationCanceled(address indexed authorizer, bytes32 indexed nonce);\\n\\n\\t/**\\n\\t * @notice Returns the state of an authorization, more specifically\\n\\t *      if the specified nonce was already used by the address specified\\n\\t *\\n\\t * @dev Nonces are expected to be client-side randomly generated 32-byte data\\n\\t *      unique to the authorizer's address\\n\\t *\\n\\t * @param authorizer    Authorizer's address\\n\\t * @param nonce         Nonce of the authorization\\n\\t * @return true if the nonce is used\\n\\t */\\n\\tfunction authorizationState(\\n\\t\\taddress authorizer,\\n\\t\\tbytes32 nonce\\n\\t) external view returns (bool);\\n\\n\\t/**\\n\\t * @notice Execute a transfer with a signed authorization\\n\\t *\\n\\t * @param from          Payer's address (Authorizer)\\n\\t * @param to            Payee's address\\n\\t * @param value         Amount to be transferred\\n\\t * @param validAfter    The time after which this is valid (unix time)\\n\\t * @param validBefore   The time before which this is valid (unix time)\\n\\t * @param nonce         Unique nonce\\n\\t * @param v             v of the signature\\n\\t * @param r             r of the signature\\n\\t * @param s             s of the signature\\n\\t */\\n\\tfunction transferWithAuthorization(\\n\\t\\taddress from,\\n\\t\\taddress to,\\n\\t\\tuint256 value,\\n\\t\\tuint256 validAfter,\\n\\t\\tuint256 validBefore,\\n\\t\\tbytes32 nonce,\\n\\t\\tuint8 v,\\n\\t\\tbytes32 r,\\n\\t\\tbytes32 s\\n\\t) external;\\n\\n\\t/**\\n\\t * @notice Receive a transfer with a signed authorization from the payer\\n\\t *\\n\\t * @dev This has an additional check to ensure that the payee's address matches\\n\\t *      the caller of this function to prevent front-running attacks.\\n\\t * @dev See https://eips.ethereum.org/EIPS/eip-3009#security-considerations\\n\\t *\\n\\t * @param from          Payer's address (Authorizer)\\n\\t * @param to            Payee's address\\n\\t * @param value         Amount to be transferred\\n\\t * @param validAfter    The time after which this is valid (unix time)\\n\\t * @param validBefore   The time before which this is valid (unix time)\\n\\t * @param nonce         Unique nonce\\n\\t * @param v             v of the signature\\n\\t * @param r             r of the signature\\n\\t * @param s             s of the signature\\n\\t */\\n\\tfunction receiveWithAuthorization(\\n\\t\\taddress from,\\n\\t\\taddress to,\\n\\t\\tuint256 value,\\n\\t\\tuint256 validAfter,\\n\\t\\tuint256 validBefore,\\n\\t\\tbytes32 nonce,\\n\\t\\tuint8 v,\\n\\t\\tbytes32 r,\\n\\t\\tbytes32 s\\n\\t) external;\\n\\n\\t/**\\n\\t * @notice Attempt to cancel an authorization\\n\\t *\\n\\t * @param authorizer    Authorizer's address\\n\\t * @param nonce         Nonce of the authorization\\n\\t * @param v             v of the signature\\n\\t * @param r             r of the signature\\n\\t * @param s             s of the signature\\n\\t */\\n\\tfunction cancelAuthorization(\\n\\t\\taddress authorizer,\\n\\t\\tbytes32 nonce,\\n\\t\\tuint8 v,\\n\\t\\tbytes32 r,\\n\\t\\tbytes32 s\\n\\t) external;\\n}\\n\",\"keccak256\":\"0xc27bf105cc1138613781011302f0e98144b091f622a662284d4198680d7f35b9\",\"license\":\"MIT\"},\"contracts/interfaces/ERC1363Spec.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"./ERC20Spec.sol\\\";\\nimport \\\"./ERC165Spec.sol\\\";\\n\\n/**\\n * @title ERC1363 Interface\\n *\\n * @dev Interface defining a ERC1363 Payable Token contract.\\n *      Implementing contracts MUST implement the ERC1363 interface as well as the ERC20 and ERC165 interfaces.\\n */\\ninterface ERC1363 is ERC20, ERC165  {\\n\\t/*\\n\\t * Note: the ERC-165 identifier for this interface is 0xb0202a11.\\n\\t * 0xb0202a11 ===\\n\\t *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\\n\\t *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\\n\\t *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\\n\\t *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\\n\\t *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\\n\\t *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\\n\\t */\\n\\n\\t/**\\n\\t * @notice Transfer tokens from `msg.sender` to another address and then call `onTransferReceived` on receiver\\n\\t * @param to address The address which you want to transfer to\\n\\t * @param value uint256 The amount of tokens to be transferred\\n\\t * @return true unless throwing\\n\\t */\\n\\tfunction transferAndCall(address to, uint256 value) external returns (bool);\\n\\n\\t/**\\n\\t * @notice Transfer tokens from `msg.sender` to another address and then call `onTransferReceived` on receiver\\n\\t * @param to address The address which you want to transfer to\\n\\t * @param value uint256 The amount of tokens to be transferred\\n\\t * @param data bytes Additional data with no specified format, sent in call to `to`\\n\\t * @return true unless throwing\\n\\t */\\n\\tfunction transferAndCall(address to, uint256 value, bytes memory data) external returns (bool);\\n\\n\\t/**\\n\\t * @notice Transfer tokens from one address to another and then call `onTransferReceived` on receiver\\n\\t * @param from address The address which you want to send tokens from\\n\\t * @param to address The address which you want to transfer to\\n\\t * @param value uint256 The amount of tokens to be transferred\\n\\t * @return true unless throwing\\n\\t */\\n\\tfunction transferFromAndCall(address from, address to, uint256 value) external returns (bool);\\n\\n\\n\\t/**\\n\\t * @notice Transfer tokens from one address to another and then call `onTransferReceived` on receiver\\n\\t * @param from address The address which you want to send tokens from\\n\\t * @param to address The address which you want to transfer to\\n\\t * @param value uint256 The amount of tokens to be transferred\\n\\t * @param data bytes Additional data with no specified format, sent in call to `to`\\n\\t * @return true unless throwing\\n\\t */\\n\\tfunction transferFromAndCall(address from, address to, uint256 value, bytes memory data) external returns (bool);\\n\\n\\t/**\\n\\t * @notice Approve the passed address to spend the specified amount of tokens on behalf of msg.sender\\n\\t * and then call `onApprovalReceived` on spender.\\n\\t * @param spender address The address which will spend the funds\\n\\t * @param value uint256 The amount of tokens to be spent\\n\\t */\\n\\tfunction approveAndCall(address spender, uint256 value) external returns (bool);\\n\\n\\t/**\\n\\t * @notice Approve the passed address to spend the specified amount of tokens on behalf of msg.sender\\n\\t * and then call `onApprovalReceived` on spender.\\n\\t * @param spender address The address which will spend the funds\\n\\t * @param value uint256 The amount of tokens to be spent\\n\\t * @param data bytes Additional data with no specified format, sent in call to `spender`\\n\\t */\\n\\tfunction approveAndCall(address spender, uint256 value, bytes memory data) external returns (bool);\\n}\\n\\n/**\\n * @title ERC1363Receiver Interface\\n *\\n * @dev Interface for any contract that wants to support `transferAndCall` or `transferFromAndCall`\\n *      from ERC1363 token contracts.\\n */\\ninterface ERC1363Receiver {\\n\\t/*\\n\\t * Note: the ERC-165 identifier for this interface is 0x88a7ca5c.\\n\\t * 0x88a7ca5c === bytes4(keccak256(\\\"onTransferReceived(address,address,uint256,bytes)\\\"))\\n\\t */\\n\\n\\t/**\\n\\t * @notice Handle the receipt of ERC1363 tokens\\n\\t *\\n\\t * @dev Any ERC1363 smart contract calls this function on the recipient\\n\\t *      after a `transfer` or a `transferFrom`. This function MAY throw to revert and reject the\\n\\t *      transfer. Return of other than the magic value MUST result in the\\n\\t *      transaction being reverted.\\n\\t *      Note: the token contract address is always the message sender.\\n\\t *\\n\\t * @param operator address The address which called `transferAndCall` or `transferFromAndCall` function\\n\\t * @param from address The address which are token transferred from\\n\\t * @param value uint256 The amount of tokens transferred\\n\\t * @param data bytes Additional data with no specified format\\n\\t * @return `bytes4(keccak256(\\\"onTransferReceived(address,address,uint256,bytes)\\\"))`\\n\\t *      unless throwing\\n\\t */\\n\\tfunction onTransferReceived(address operator, address from, uint256 value, bytes memory data) external returns (bytes4);\\n}\\n\\n/**\\n * @title ERC1363Spender Interface\\n *\\n * @dev Interface for any contract that wants to support `approveAndCall`\\n *      from ERC1363 token contracts.\\n */\\ninterface ERC1363Spender {\\n\\t/*\\n\\t * Note: the ERC-165 identifier for this interface is 0x7b04a2d0.\\n\\t * 0x7b04a2d0 === bytes4(keccak256(\\\"onApprovalReceived(address,uint256,bytes)\\\"))\\n\\t */\\n\\n\\t/**\\n\\t * @notice Handle the approval of ERC1363 tokens\\n\\t *\\n\\t * @dev Any ERC1363 smart contract calls this function on the recipient\\n\\t *      after an `approve`. This function MAY throw to revert and reject the\\n\\t *      approval. Return of other than the magic value MUST result in the\\n\\t *      transaction being reverted.\\n\\t *      Note: the token contract address is always the message sender.\\n\\t *\\n\\t * @param owner address The address which called `approveAndCall` function\\n\\t * @param value uint256 The amount of tokens to be spent\\n\\t * @param data bytes Additional data with no specified format\\n\\t * @return `bytes4(keccak256(\\\"onApprovalReceived(address,uint256,bytes)\\\"))`\\n\\t *      unless throwing\\n\\t */\\n\\tfunction onApprovalReceived(address owner, uint256 value, bytes memory data) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0x5a9800736f8d59f69ddeb59babcc71ec0ba439150ea1ecac1f4c30d8e4a98d5e\",\"license\":\"MIT\"},\"contracts/interfaces/ERC165Spec.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/**\\n * @title ERC-165 Standard Interface Detection\\n *\\n * @dev Interface of the ERC165 standard, as defined in the\\n *       https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * @dev Implementers can declare support of contract interfaces,\\n *      which can then be queried by others.\\n *\\n * @author Christian Reitwie\\u00dfner, Nick Johnson, Fabian Vogelsteller, Jordi Baylina, Konrad Feldmeier, William Entriken\\n */\\ninterface ERC165 {\\n\\t/**\\n\\t * @notice Query if a contract implements an interface\\n\\t *\\n\\t * @dev Interface identification is specified in ERC-165.\\n\\t *      This function uses less than 30,000 gas.\\n\\t *\\n\\t * @param interfaceID The interface identifier, as specified in ERC-165\\n\\t * @return `true` if the contract implements `interfaceID` and\\n\\t *      `interfaceID` is not 0xffffffff, `false` otherwise\\n\\t */\\n\\tfunction supportsInterface(bytes4 interfaceID) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x9b8e0a0ee2ddff1014108266f62a95dab3f76f08deba2e6177ec2ed251128f9d\",\"license\":\"MIT\"},\"contracts/interfaces/ERC20Spec.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/**\\n * @title EIP-20: ERC-20 Token Standard\\n *\\n * @notice The ERC-20 (Ethereum Request for Comments 20), proposed by Fabian Vogelsteller in November 2015,\\n *      is a Token Standard that implements an API for tokens within Smart Contracts.\\n *\\n * @notice It provides functionalities like to transfer tokens from one account to another,\\n *      to get the current token balance of an account and also the total supply of the token available on the network.\\n *      Besides these it also has some other functionalities like to approve that an amount of\\n *      token from an account can be spent by a third party account.\\n *\\n * @notice If a Smart Contract implements the following methods and events it can be called an ERC-20 Token\\n *      Contract and, once deployed, it will be responsible to keep track of the created tokens on Ethereum.\\n *\\n * @notice See https://ethereum.org/en/developers/docs/standards/tokens/erc-20/\\n * @notice See https://eips.ethereum.org/EIPS/eip-20\\n */\\ninterface ERC20 {\\n\\t/**\\n\\t * @dev Fired in transfer(), transferFrom() to indicate that token transfer happened\\n\\t *\\n\\t * @param from an address tokens were consumed from\\n\\t * @param to an address tokens were sent to\\n\\t * @param value number of tokens transferred\\n\\t */\\n\\tevent Transfer(address indexed from, address indexed to, uint256 value);\\n\\n\\t/**\\n\\t * @dev Fired in approve() to indicate an approval event happened\\n\\t *\\n\\t * @param owner an address which granted a permission to transfer\\n\\t *      tokens on its behalf\\n\\t * @param spender an address which received a permission to transfer\\n\\t *      tokens on behalf of the owner `_owner`\\n\\t * @param value amount of tokens granted to transfer on behalf\\n\\t */\\n\\tevent Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n\\t/**\\n\\t * @return name of the token (ex.: USD Coin)\\n\\t */\\n\\t// OPTIONAL - This method can be used to improve usability,\\n\\t// but interfaces and other contracts MUST NOT expect these values to be present.\\n\\t// function name() external view returns (string memory);\\n\\n\\t/**\\n\\t * @return symbol of the token (ex.: USDC)\\n\\t */\\n\\t// OPTIONAL - This method can be used to improve usability,\\n\\t// but interfaces and other contracts MUST NOT expect these values to be present.\\n\\t// function symbol() external view returns (string memory);\\n\\n\\t/**\\n\\t * @dev Returns the number of decimals used to get its user representation.\\n\\t *      For example, if `decimals` equals `2`, a balance of `505` tokens should\\n\\t *      be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n\\t *\\n\\t * @dev Tokens usually opt for a value of 18, imitating the relationship between\\n\\t *      Ether and Wei. This is the value {ERC20} uses, unless this function is\\n\\t *      overridden;\\n\\t *\\n\\t * @dev NOTE: This information is only used for _display_ purposes: it in\\n\\t *      no way affects any of the arithmetic of the contract, including\\n\\t *      {IERC20-balanceOf} and {IERC20-transfer}.\\n\\t *\\n\\t * @return token decimals\\n\\t */\\n\\t// OPTIONAL - This method can be used to improve usability,\\n\\t// but interfaces and other contracts MUST NOT expect these values to be present.\\n\\t// function decimals() external view returns (uint8);\\n\\n\\t/**\\n\\t * @return the amount of tokens in existence\\n\\t */\\n\\tfunction totalSupply() external view returns (uint256);\\n\\n\\t/**\\n\\t * @notice Gets the balance of a particular address\\n\\t *\\n\\t * @param _owner the address to query the the balance for\\n\\t * @return balance an amount of tokens owned by the address specified\\n\\t */\\n\\tfunction balanceOf(address _owner) external view returns (uint256 balance);\\n\\n\\t/**\\n\\t * @notice Transfers some tokens to an external address or a smart contract\\n\\t *\\n\\t * @dev Called by token owner (an address which has a\\n\\t *      positive token balance tracked by this smart contract)\\n\\t * @dev Throws on any error like\\n\\t *      * insufficient token balance or\\n\\t *      * incorrect `_to` address:\\n\\t *          * zero address or\\n\\t *          * self address or\\n\\t *          * smart contract which doesn't support ERC20\\n\\t *\\n\\t * @param _to an address to transfer tokens to,\\n\\t *      must be either an external address or a smart contract,\\n\\t *      compliant with the ERC20 standard\\n\\t * @param _value amount of tokens to be transferred,, zero\\n\\t *      value is allowed\\n\\t * @return success true on success, throws otherwise\\n\\t */\\n\\tfunction transfer(address _to, uint256 _value) external returns (bool success);\\n\\n\\t/**\\n\\t * @notice Transfers some tokens on behalf of address `_from' (token owner)\\n\\t *      to some other address `_to`\\n\\t *\\n\\t * @dev Called by token owner on his own or approved address,\\n\\t *      an address approved earlier by token owner to\\n\\t *      transfer some amount of tokens on its behalf\\n\\t * @dev Throws on any error like\\n\\t *      * insufficient token balance or\\n\\t *      * incorrect `_to` address:\\n\\t *          * zero address or\\n\\t *          * same as `_from` address (self transfer)\\n\\t *          * smart contract which doesn't support ERC20\\n\\t *\\n\\t * @param _from token owner which approved caller (transaction sender)\\n\\t *      to transfer `_value` of tokens on its behalf\\n\\t * @param _to an address to transfer tokens to,\\n\\t *      must be either an external address or a smart contract,\\n\\t *      compliant with the ERC20 standard\\n\\t * @param _value amount of tokens to be transferred,, zero\\n\\t *      value is allowed\\n\\t * @return success true on success, throws otherwise\\n\\t */\\n\\tfunction transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\\n\\n\\t/**\\n\\t * @notice Approves address called `_spender` to transfer some amount\\n\\t *      of tokens on behalf of the owner (transaction sender)\\n\\t *\\n\\t * @dev Transaction sender must not necessarily own any tokens to grant the permission\\n\\t *\\n\\t * @param _spender an address approved by the caller (token owner)\\n\\t *      to spend some tokens on its behalf\\n\\t * @param _value an amount of tokens spender `_spender` is allowed to\\n\\t *      transfer on behalf of the token owner\\n\\t * @return success true on success, throws otherwise\\n\\t */\\n\\tfunction approve(address _spender, uint256 _value) external returns (bool success);\\n\\n\\t/**\\n\\t * @notice Returns the amount which _spender is still allowed to withdraw from _owner.\\n\\t *\\n\\t * @dev A function to check an amount of tokens owner approved\\n\\t *      to transfer on its behalf by some other address called \\\"spender\\\"\\n\\t *\\n\\t * @param _owner an address which approves transferring some tokens on its behalf\\n\\t * @param _spender an address approved to transfer some tokens on behalf\\n\\t * @return remaining an amount of tokens approved address `_spender` can transfer on behalf\\n\\t *      of token owner `_owner`\\n\\t */\\n\\tfunction allowance(address _owner, address _spender) external view returns (uint256 remaining);\\n}\\n\",\"keccak256\":\"0x8b8f6e1ad3b0c46f8c96743ccb4d2c851321c35d74f52dc903084e970c544b9a\",\"license\":\"MIT\"},\"contracts/lib/AddressUtils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/**\\n * @title Address Utils\\n *\\n * @dev Utility library of inline functions on addresses\\n *\\n * @dev Copy of the Zeppelin's library:\\n *      https://github.com/gnosis/openzeppelin-solidity/blob/master/contracts/AddressUtils.sol\\n */\\nlibrary AddressUtils {\\n\\n\\t/**\\n\\t * @notice Checks if the target address is a contract\\n\\t *\\n\\t * @dev It is unsafe to assume that an address for which this function returns\\n\\t *      false is an externally-owned account (EOA) and not a contract.\\n\\t *\\n\\t * @dev Among others, `isContract` will return false for the following\\n\\t *      types of addresses:\\n\\t *        - an externally-owned account\\n\\t *        - a contract in construction\\n\\t *        - an address where a contract will be created\\n\\t *        - an address where a contract lived, but was destroyed\\n\\t *\\n\\t * @param addr address to check\\n\\t * @return whether the target address is a contract\\n\\t */\\n\\tfunction isContract(address addr) internal view returns (bool) {\\n\\t\\t// a variable to load `extcodesize` to\\n\\t\\tuint256 size = 0;\\n\\n\\t\\t// XXX Currently there is no better way to check if there is a contract in an address\\n\\t\\t// than to check the size of the code at that address.\\n\\t\\t// See https://ethereum.stackexchange.com/a/14016/36603 for more details about how this works.\\n\\t\\t// TODO: Check this again before the Serenity release, because all addresses will be contracts.\\n\\t\\t// solium-disable-next-line security/no-inline-assembly\\n\\t\\tassembly {\\n\\t\\t\\t// retrieve the size of the code at address `addr`\\n\\t\\t\\tsize := extcodesize(addr)\\n\\t\\t}\\n\\n\\t\\t// positive size indicates a smart contract address\\n\\t\\treturn size > 0;\\n\\t}\\n}\\n\",\"keccak256\":\"0xe367faf60d308a5e9a11c8c8df7b39d3656d7cfdf711e083384c72c02302ad65\",\"license\":\"MIT\"},\"contracts/lib/ECDSA.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n *\\n * @dev Copy of the Zeppelin's library:\\n *      https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b0cf6fbb7a70f31527f36579ad644e1cf12fdf4e/contracts/utils/cryptography/ECDSA.sol\\n */\\nlibrary ECDSA {\\n\\t/**\\n\\t * @dev Returns the address that signed a hashed message (`hash`) with\\n\\t * `signature`. This address can then be used for verification purposes.\\n\\t *\\n\\t * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n\\t * this function rejects them by requiring the `s` value to be in the lower\\n\\t * half order, and the `v` value to be either 27 or 28.\\n\\t *\\n\\t * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n\\t * verification to be secure: it is possible to craft signatures that\\n\\t * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n\\t * this is by receiving a hash of the original message (which may otherwise\\n\\t * be too long), and then calling {toEthSignedMessageHash} on it.\\n\\t *\\n\\t * Documentation for signature generation:\\n\\t * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n\\t * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n\\t */\\n\\tfunction recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n\\t\\t// Divide the signature in r, s and v variables\\n\\t\\tbytes32 r;\\n\\t\\tbytes32 s;\\n\\t\\tuint8 v;\\n\\n\\t\\t// Check the signature length\\n\\t\\t// - case 65: r,s,v signature (standard)\\n\\t\\t// - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\\n\\t\\tif (signature.length == 65) {\\n\\t\\t\\t// ecrecover takes the signature parameters, and the only way to get them\\n\\t\\t\\t// currently is to use assembly.\\n\\t\\t\\tassembly {\\n\\t\\t\\t\\tr := mload(add(signature, 0x20))\\n\\t\\t\\t\\ts := mload(add(signature, 0x40))\\n\\t\\t\\t\\tv := byte(0, mload(add(signature, 0x60)))\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if (signature.length == 64) {\\n\\t\\t\\t// ecrecover takes the signature parameters, and the only way to get them\\n\\t\\t\\t// currently is to use assembly.\\n\\t\\t\\tassembly {\\n\\t\\t\\t\\tlet vs := mload(add(signature, 0x40))\\n\\t\\t\\t\\tr := mload(add(signature, 0x20))\\n\\t\\t\\t\\ts := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n\\t\\t\\t\\tv := add(shr(255, vs), 27)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\trevert(\\\"invalid signature length\\\");\\n\\t\\t}\\n\\n\\t\\treturn recover(hash, v, r, s);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Overload of {ECDSA-recover} that receives the `v`,\\n\\t * `r` and `s` signature fields separately.\\n\\t */\\n\\tfunction recover(\\n\\t\\tbytes32 hash,\\n\\t\\tuint8 v,\\n\\t\\tbytes32 r,\\n\\t\\tbytes32 s\\n\\t) internal pure returns (address) {\\n\\t\\t// EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n\\t\\t// unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n\\t\\t// the valid range for s in (281): 0 < s < secp256k1n \\u00f7 2 + 1, and for v in (282): v \\u2208 {27, 28}. Most\\n\\t\\t// signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n\\t\\t//\\n\\t\\t// If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n\\t\\t// with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n\\t\\t// vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n\\t\\t// these malleable signatures as well.\\n\\t\\trequire(\\n\\t\\t\\tuint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0,\\n\\t\\t\\t\\\"invalid signature 's' value\\\"\\n\\t\\t);\\n\\t\\trequire(v == 27 || v == 28, \\\"invalid signature 'v' value\\\");\\n\\n\\t\\t// If the signature is valid (and not malleable), return the signer address\\n\\t\\taddress signer = ecrecover(hash, v, r, s);\\n\\t\\trequire(signer != address(0), \\\"invalid signature\\\");\\n\\n\\t\\treturn signer;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n\\t * produces hash corresponding to the one signed with the\\n\\t * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n\\t * JSON-RPC method as part of EIP-191.\\n\\t *\\n\\t * See {recover}.\\n\\t */\\n\\tfunction toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n\\t\\t// 32 is the length in bytes of hash,\\n\\t\\t// enforced by the type signature above\\n\\t\\treturn keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns an Ethereum Signed Typed Data, created from a\\n\\t * `domainSeparator` and a `structHash`. This produces hash corresponding\\n\\t * to the one signed with the\\n\\t * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n\\t * JSON-RPC method as part of EIP-712.\\n\\t *\\n\\t * See {recover}.\\n\\t */\\n\\tfunction toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n\\t\\treturn keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n\\t}\\n}\\n\",\"keccak256\":\"0xadc0107053170d40a04da6f2da244286cb84a4dab28f8e50c1b4d386fc597f87\",\"license\":\"MIT\"},\"contracts/token/CharacterERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"../interfaces/ERC1363Spec.sol\\\";\\nimport \\\"../interfaces/EIP2612.sol\\\";\\nimport \\\"../interfaces/EIP3009.sol\\\";\\nimport \\\"../utils/AccessControl.sol\\\";\\nimport \\\"../lib/AddressUtils.sol\\\";\\nimport \\\"../lib/ECDSA.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @title Alethea Character Economies ERC20 Token\\n *\\n * @notice Character token is the utility token of the Alethea AI Character Economies Protocol.\\n *      It serves as character economy currency\\n *      Character token powers up the character governance protocol (Character DAO)\\n *\\n * @notice Token Summary:\\n *      - Symbol: <defined on creation>\\n *      - Name: <defined on creation>\\n *      - Decimals: 18\\n *      - Initial/maximum total supply: 10,000,000 Character tokens\\n *      - Initial supply holder (initial holder) address: <defined on creation>\\n *      - Mintable: new tokens may get created\\n *      - Burnable: existing tokens may get destroyed, total supply may decrease\\n *      - DAO Support: supports voting delegation\\n *\\n * @notice Features Summary:\\n *      - Supports atomic allowance modification, resolves well-known ERC20 issue with approve (arXiv:1907.00903)\\n *      - Voting delegation and delegation on behalf via EIP-712 (like in Compound CMP token) - gives the token\\n *        powerful governance capabilities by allowing holders to form voting groups by electing delegates\\n *      - Unlimited approval feature (like in 0x ZRX token) - saves gas for transfers on behalf\\n *        by eliminating the need to update \\u201cunlimited\\u201d allowance value\\n *      - ERC-1363 Payable Token - ERC721-like callback execution mechanism for transfers,\\n *        transfers on behalf and approvals; allows creation of smart contracts capable of executing callbacks\\n *        in response to transfer or approval in a single transaction\\n *      - EIP-2612: permit - 712-signed approvals - improves user experience by allowing to use a token\\n *        without having an ETH to pay gas fees\\n *      - EIP-3009: Transfer With Authorization - improves user experience by allowing to use a token\\n *        without having an ETH to pay gas fees\\n *\\n * @dev Even though smart contract has mint() function which is used to mint initial token supply,\\n *      the function is disabled forever after smart contract deployment by revoking `TOKEN_CREATOR`\\n *      permission from the deployer account\\n *\\n * @dev Token balances and total supply are effectively 192 bits long, meaning that maximum\\n *      possible total supply smart contract is able to track is 2^192 (close to 10^40 tokens)\\n *\\n * @dev Smart contract doesn't use safe math. All arithmetic operations are overflow/underflow safe.\\n *      Additionally, Solidity 0.8.7 enforces overflow/underflow safety.\\n *\\n * @dev Multiple Withdrawal Attack on ERC20 Tokens (arXiv:1907.00903) - resolved\\n *      Related events and functions are marked with \\\"arXiv:1907.00903\\\" tag:\\n *        - event Transfer(address indexed _by, address indexed _from, address indexed _to, uint256 _value)\\n *        - event Approve(address indexed _owner, address indexed _spender, uint256 _oldValue, uint256 _value)\\n *        - function increaseAllowance(address _spender, uint256 _value) public returns (bool)\\n *        - function decreaseAllowance(address _spender, uint256 _value) public returns (bool)\\n *      See: https://arxiv.org/abs/1907.00903v1\\n *           https://ieeexplore.ieee.org/document/8802438\\n *      See: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n *\\n * @dev Reviewed\\n *      ERC-20   - according to https://eips.ethereum.org/EIPS/eip-20\\n *      ERC-1363 - according to https://eips.ethereum.org/EIPS/eip-1363\\n *      EIP-2612 - according to https://eips.ethereum.org/EIPS/eip-2612\\n *      EIP-3009 - according to https://eips.ethereum.org/EIPS/eip-3009\\n *\\n * @dev ERC20: contract has passed\\n *      - OpenZeppelin ERC20 tests\\n *        https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/test/token/ERC20/ERC20.behavior.js\\n *        https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/test/token/ERC20/ERC20.test.js\\n *      - Ref ERC1363 tests\\n *        https://github.com/vittominacori/erc1363-payable-token/blob/master/test/token/ERC1363/ERC1363.behaviour.js\\n *      - OpenZeppelin EIP2612 tests\\n *        https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/test/token/ERC20/extensions/draft-ERC20Permit.test.js\\n *      - Coinbase EIP3009 tests\\n *        https://github.com/CoinbaseStablecoin/eip-3009/blob/master/test/EIP3009.test.ts\\n *      - Compound voting delegation tests\\n *        https://github.com/compound-finance/compound-protocol/blob/master/tests/Governance/CompTest.js\\n *        https://github.com/compound-finance/compound-protocol/blob/master/tests/Utils/EIP712.js\\n *      - OpenZeppelin voting delegation tests\\n *        https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/test/token/ERC20/extensions/ERC20Votes.test.js\\n *      See adopted copies of all the tests in the project test folder\\n *\\n * @dev Compound-like voting delegation functions', public getters', and events' names\\n *      were changed for better code readability (Alethea Name <- Comp/Zeppelin name):\\n *      - votingDelegates           <- delegates\\n *      - votingPowerHistory        <- checkpoints\\n *      - votingPowerHistoryLength  <- numCheckpoints\\n *      - totalSupplyHistory        <- _totalSupplyCheckpoints (private)\\n *      - usedNonces                <- nonces (note: nonces are random instead of sequential)\\n *      - DelegateChanged (unchanged)\\n *      - VotingPowerChanged        <- DelegateVotesChanged\\n *      - votingPowerOf             <- getCurrentVotes\\n *      - votingPowerAt             <- getPriorVotes\\n *      - totalSupplyAt             <- getPriorTotalSupply\\n *      - delegate (unchanged)\\n *      - delegateWithAuthorization <- delegateBySig\\n * @dev Compound-like voting delegation improved to allow the use of random nonces like in EIP-3009,\\n *      instead of sequential; same `usedNonces` EIP-3009 mapping is used to track nonces\\n *\\n * @dev Reference implementations \\\"used\\\":\\n *      - Atomic allowance:    https://github.com/OpenZeppelin/openzeppelin-contracts\\n *      - Unlimited allowance: https://github.com/0xProject/protocol\\n *      - Voting delegation:   https://github.com/compound-finance/compound-protocol\\n *                             https://github.com/OpenZeppelin/openzeppelin-contracts\\n *      - ERC-1363:            https://github.com/vittominacori/erc1363-payable-token\\n *      - EIP-2612:            https://github.com/Uniswap/uniswap-v2-core\\n *      - EIP-3009:            https://github.com/centrehq/centre-tokens\\n *                             https://github.com/CoinbaseStablecoin/eip-3009\\n *      - Meta transactions:   https://github.com/0xProject/protocol\\n *\\n * @dev Includes resolutions for ALI ERC20 Audit by Miguel Palhas, https://hackmd.io/@naps62/alierc20-audit\\n *\\n * @author Basil Gorin\\n */\\ncontract CharacterERC20 is ERC1363, EIP2612, EIP3009, AccessControl, Initializable {\\n\\t/**\\n\\t * @notice Name of the token\\n\\t *\\n\\t * @notice ERC20 name of the token (long name)\\n\\t *\\n\\t * @dev ERC20 `function name() public view returns (string)`\\n\\t *\\n\\t * @dev Field is declared public: getter name() is created when compiled,\\n\\t *      it returns the name of the token.\\n\\t */\\n\\tstring public name;\\n\\n\\t/**\\n\\t * @notice Symbol of the token\\n\\t *\\n\\t * @notice ERC20 symbol of that token (short name)\\n\\t *\\n\\t * @dev ERC20 `function symbol() public view returns (string)`\\n\\t *\\n\\t * @dev Field is declared public: getter symbol() is created when compiled,\\n\\t *      it returns the symbol of the token\\n\\t */\\n\\tstring public symbol;\\n\\n\\t/**\\n\\t * @notice Decimals of the token: 18\\n\\t *\\n\\t * @dev ERC20 `function decimals() public view returns (uint8)`\\n\\t *\\n\\t * @dev Field is declared public: getter decimals() is created when compiled,\\n\\t *      it returns the number of decimals used to get its user representation.\\n\\t *      For example, if `decimals` equals `6`, a balance of `1,500,000` tokens should\\n\\t *      be displayed to a user as `1,5` (`1,500,000 / 10 ** 6`).\\n\\t *\\n\\t * @dev NOTE: This information is only used for _display_ purposes: it in\\n\\t *      no way affects any of the arithmetic of the contract, including balanceOf() and transfer().\\n\\t */\\n\\tuint8 public constant decimals = 18;\\n\\n\\t/**\\n\\t * @notice Total supply of the token: initially 10,000,000,000,\\n\\t *      with the potential to decline over time as some tokens may get burnt but not minted\\n\\t *\\n\\t * @dev ERC20 `function totalSupply() public view returns (uint256)`\\n\\t *\\n\\t * @dev Field is declared public: getter totalSupply() is created when compiled,\\n\\t *      it returns the amount of tokens in existence.\\n\\t */\\n\\tuint256 public override totalSupply; // is set to 10 billion * 10^18 in the constructor\\n\\n\\t/**\\n\\t * @dev A record of all the token balances\\n\\t * @dev This mapping keeps record of all token owners:\\n\\t *      owner => balance\\n\\t */\\n\\tmapping(address => uint256) private tokenBalances;\\n\\n\\t/**\\n\\t * @notice A record of each account's voting delegate\\n\\t *\\n\\t * @dev Auxiliary data structure used to sum up an account's voting power\\n\\t *\\n\\t * @dev This mapping keeps record of all voting power delegations:\\n\\t *      voting delegator (token owner) => voting delegate\\n\\t */\\n\\tmapping(address => address) public votingDelegates;\\n\\n\\t/**\\n\\t * @notice Auxiliary structure to store key-value pair, used to store:\\n\\t *      - voting power record (key: block.timestamp, value: voting power)\\n\\t *      - total supply record (key: block.timestamp, value: total supply)\\n\\t * @notice A voting power record binds voting power of a delegate to a particular\\n\\t *      block when the voting power delegation change happened\\n\\t *         k: block.number when delegation has changed; starting from\\n\\t *            that block voting power value is in effect\\n\\t *         v: cumulative voting power a delegate has obtained starting\\n\\t *            from the block stored in blockNumber\\n\\t * @notice Total supply record binds total token supply to a particular\\n\\t *      block when total supply change happened (due to mint/burn operations)\\n\\t */\\n\\tstruct KV {\\n\\t\\t/*\\n\\t\\t * @dev key, a block number\\n\\t\\t */\\n\\t\\tuint64 k;\\n\\n\\t\\t/*\\n\\t\\t * @dev value, token balance or voting power\\n\\t\\t */\\n\\t\\tuint192 v;\\n\\t}\\n\\n\\t/**\\n\\t * @notice A record of each account's voting power historical data\\n\\t *\\n\\t * @dev Primarily data structure to store voting power for each account.\\n\\t *      Voting power sums up from the account's token balance and delegated\\n\\t *      balances.\\n\\t *\\n\\t * @dev Stores current value and entire history of its changes.\\n\\t *      The changes are stored as an array of checkpoints (key-value pairs).\\n\\t *      Checkpoint is an auxiliary data structure containing voting\\n\\t *      power (number of votes) and block number when the checkpoint is saved\\n\\t *\\n\\t * @dev Maps voting delegate => voting power record\\n\\t */\\n\\tmapping(address => KV[]) public votingPowerHistory;\\n\\n\\t/**\\n\\t * @notice A record of total token supply historical data\\n\\t *\\n\\t * @dev Primarily data structure to store total token supply.\\n\\t *\\n\\t * @dev Stores current value and entire history of its changes.\\n\\t *      The changes are stored as an array of checkpoints (key-value pairs).\\n\\t *      Checkpoint is an auxiliary data structure containing total\\n\\t *      token supply and block number when the checkpoint is saved\\n\\t */\\n\\tKV[] public totalSupplyHistory;\\n\\n\\t/**\\n\\t * @dev A record of nonces for signing/validating signatures in EIP-2612 `permit`\\n\\t *\\n\\t * @dev Note: EIP2612 doesn't imply a possibility for nonce randomization like in EIP-3009\\n\\t *\\n\\t * @dev Maps delegate address => delegate nonce\\n\\t */\\n\\tmapping(address => uint256) public override nonces;\\n\\n\\t/**\\n\\t * @dev A record of used nonces for EIP-3009 transactions\\n\\t *\\n\\t * @dev A record of used nonces for signing/validating signatures\\n\\t *      in `delegateWithAuthorization` for every delegate\\n\\t *\\n\\t * @dev Maps authorizer address => nonce => true/false (used unused)\\n\\t */\\n\\tmapping(address => mapping(bytes32 => bool)) private usedNonces;\\n\\n\\t/**\\n\\t * @notice A record of all the allowances to spend tokens on behalf\\n\\t * @dev Maps token owner address to an address approved to spend\\n\\t *      some tokens on behalf, maps approved address to that amount\\n\\t * @dev owner => spender => value\\n\\t */\\n\\tmapping(address => mapping(address => uint256)) private transferAllowances;\\n\\n\\t/**\\n\\t * @notice Enables ERC20 transfers of the tokens\\n\\t *      (transfer by the token owner himself)\\n\\t * @dev Feature FEATURE_TRANSFERS must be enabled in order for\\n\\t *      `transfer()` function to succeed\\n\\t */\\n\\tuint32 public constant FEATURE_TRANSFERS = 0x0000_0001;\\n\\n\\t/**\\n\\t * @notice Enables ERC20 transfers on behalf\\n\\t *      (transfer by someone else on behalf of token owner)\\n\\t * @dev Feature FEATURE_TRANSFERS_ON_BEHALF must be enabled in order for\\n\\t *      `transferFrom()` function to succeed\\n\\t * @dev Token owner must call `approve()` first to authorize\\n\\t *      the transfer on behalf\\n\\t */\\n\\tuint32 public constant FEATURE_TRANSFERS_ON_BEHALF = 0x0000_0002;\\n\\n\\t/**\\n\\t * @dev Defines if the default behavior of `transfer` and `transferFrom`\\n\\t *      checks if the receiver smart contract supports ERC20 tokens\\n\\t * @dev When feature FEATURE_UNSAFE_TRANSFERS is enabled the transfers do not\\n\\t *      check if the receiver smart contract supports ERC20 tokens,\\n\\t *      i.e. `transfer` and `transferFrom` behave like `unsafeTransferFrom`\\n\\t * @dev When feature FEATURE_UNSAFE_TRANSFERS is disabled (default) the transfers\\n\\t *      check if the receiver smart contract supports ERC20 tokens,\\n\\t *      i.e. `transfer` and `transferFrom` behave like `transferFromAndCall`\\n\\t */\\n\\tuint32 public constant FEATURE_UNSAFE_TRANSFERS = 0x0000_0004;\\n\\n\\t/**\\n\\t * @notice Enables token owners to burn their own tokens\\n\\t *\\n\\t * @dev Feature FEATURE_OWN_BURNS must be enabled in order for\\n\\t *      `burn()` function to succeed when called by token owner\\n\\t */\\n\\tuint32 public constant FEATURE_OWN_BURNS = 0x0000_0008;\\n\\n\\t/**\\n\\t * @notice Enables approved operators to burn tokens on behalf of their owners\\n\\t *\\n\\t * @dev Feature FEATURE_BURNS_ON_BEHALF must be enabled in order for\\n\\t *      `burn()` function to succeed when called by approved operator\\n\\t */\\n\\tuint32 public constant FEATURE_BURNS_ON_BEHALF = 0x0000_0010;\\n\\n\\t/**\\n\\t * @notice Enables delegators to elect delegates\\n\\t * @dev Feature FEATURE_DELEGATIONS must be enabled in order for\\n\\t *      `delegate()` function to succeed\\n\\t */\\n\\tuint32 public constant FEATURE_DELEGATIONS = 0x0000_0020;\\n\\n\\t/**\\n\\t * @notice Enables delegators to elect delegates on behalf\\n\\t *      (via an EIP712 signature)\\n\\t * @dev Feature FEATURE_DELEGATIONS_ON_BEHALF must be enabled in order for\\n\\t *      `delegateWithAuthorization()` function to succeed\\n\\t */\\n\\tuint32 public constant FEATURE_DELEGATIONS_ON_BEHALF = 0x0000_0040;\\n\\n\\t/**\\n\\t * @notice Enables ERC-1363 transfers with callback\\n\\t * @dev Feature FEATURE_ERC1363_TRANSFERS must be enabled in order for\\n\\t *      ERC-1363 `transferFromAndCall` functions to succeed\\n\\t */\\n\\tuint32 public constant FEATURE_ERC1363_TRANSFERS = 0x0000_0080;\\n\\n\\t/**\\n\\t * @notice Enables ERC-1363 approvals with callback\\n\\t * @dev Feature FEATURE_ERC1363_APPROVALS must be enabled in order for\\n\\t *      ERC-1363 `approveAndCall` functions to succeed\\n\\t */\\n\\tuint32 public constant FEATURE_ERC1363_APPROVALS = 0x0000_0100;\\n\\n\\t/**\\n\\t * @notice Enables approvals on behalf (EIP2612 permits\\n\\t *      via an EIP712 signature)\\n\\t * @dev Feature FEATURE_EIP2612_PERMITS must be enabled in order for\\n\\t *      `permit()` function to succeed\\n\\t */\\n\\tuint32 public constant FEATURE_EIP2612_PERMITS = 0x0000_0200;\\n\\n\\t/**\\n\\t * @notice Enables meta transfers on behalf (EIP3009 transfers\\n\\t *      via an EIP712 signature)\\n\\t * @dev Feature FEATURE_EIP3009_TRANSFERS must be enabled in order for\\n\\t *      `transferWithAuthorization()` function to succeed\\n\\t */\\n\\tuint32 public constant FEATURE_EIP3009_TRANSFERS = 0x0000_0400;\\n\\n\\t/**\\n\\t * @notice Enables meta transfers on behalf (EIP3009 transfers\\n\\t *      via an EIP712 signature)\\n\\t * @dev Feature FEATURE_EIP3009_RECEPTIONS must be enabled in order for\\n\\t *      `receiveWithAuthorization()` function to succeed\\n\\t */\\n\\tuint32 public constant FEATURE_EIP3009_RECEPTIONS = 0x0000_0800;\\n\\n\\t/**\\n\\t * @notice Token creator is responsible for creating (minting)\\n\\t *      tokens to an arbitrary address\\n\\t * @dev Role ROLE_TOKEN_CREATOR allows minting tokens\\n\\t *      (calling `mint` function)\\n\\t */\\n\\tuint32 public constant ROLE_TOKEN_CREATOR = 0x0001_0000;\\n\\n\\t/**\\n\\t * @notice Token destroyer is responsible for destroying (burning)\\n\\t *      tokens owned by an arbitrary address\\n\\t * @dev Role ROLE_TOKEN_DESTROYER allows burning tokens\\n\\t *      (calling `burn` function)\\n\\t */\\n\\tuint32 public constant ROLE_TOKEN_DESTROYER = 0x0002_0000;\\n\\n\\t/**\\n\\t * @notice ERC20 receivers are allowed to receive tokens without ERC20 safety checks,\\n\\t *      which may be useful to simplify tokens transfers into \\\"legacy\\\" smart contracts\\n\\t * @dev When `FEATURE_UNSAFE_TRANSFERS` is not enabled addresses having\\n\\t *      `ROLE_ERC20_RECEIVER` permission are allowed to receive tokens\\n\\t *      via `transfer` and `transferFrom` functions in the same way they\\n\\t *      would via `unsafeTransferFrom` function\\n\\t * @dev When `FEATURE_UNSAFE_TRANSFERS` is enabled `ROLE_ERC20_RECEIVER` permission\\n\\t *      doesn't affect the transfer behaviour since\\n\\t *      `transfer` and `transferFrom` behave like `unsafeTransferFrom` for any receiver\\n\\t * @dev ROLE_ERC20_RECEIVER is a shortening for ROLE_UNSAFE_ERC20_RECEIVER\\n\\t */\\n\\tuint32 public constant ROLE_ERC20_RECEIVER = 0x0004_0000;\\n\\n\\t/**\\n\\t * @notice ERC20 senders are allowed to send tokens without ERC20 safety checks,\\n\\t *      which may be useful to simplify tokens transfers into \\\"legacy\\\" smart contracts\\n\\t * @dev When `FEATURE_UNSAFE_TRANSFERS` is not enabled senders having\\n\\t *      `ROLE_ERC20_SENDER` permission are allowed to send tokens\\n\\t *      via `transfer` and `transferFrom` functions in the same way they\\n\\t *      would via `unsafeTransferFrom` function\\n\\t * @dev When `FEATURE_UNSAFE_TRANSFERS` is enabled `ROLE_ERC20_SENDER` permission\\n\\t *      doesn't affect the transfer behaviour since\\n\\t *      `transfer` and `transferFrom` behave like `unsafeTransferFrom` for any receiver\\n\\t * @dev ROLE_ERC20_SENDER is a shortening for ROLE_UNSAFE_ERC20_SENDER\\n\\t */\\n\\tuint32 public constant ROLE_ERC20_SENDER = 0x0008_0000;\\n\\n\\t/**\\n\\t * @notice Metadata editor is responsible for setting/updating\\n\\t * \\t\\tname and symbol of the token\\n\\t * @dev Role ROLE_METADATA_EDITOR allows updating token metadata\\n\\t *      (calling `updateTokenMetadata` function)\\n\\t */\\n\\tuint32 public constant ROLE_METADATA_EDITOR = 0x0010_0000;\\n\\n\\t/**\\n\\t * @notice EIP-712 contract's domain typeHash,\\n\\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\\n\\t *\\n\\t * @dev Note: we do not include version into the domain typehash/separator,\\n\\t *      it is implied version is concatenated to the name field, like \\\"CharacterERC20\\\"\\n\\t */\\n\\t// keccak256(\\\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\\\")\\n\\tbytes32 public constant DOMAIN_TYPEHASH = 0x8cad95687ba82c2ce50e74f7b754645e5117c3a5bec8151c0726d5857980a866;\\n\\n\\t/**\\n\\t * @notice EIP-712 contract's domain separator,\\n\\t *      see https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator\\n\\t */\\n\\tbytes32 public override DOMAIN_SEPARATOR;\\n\\n\\t/**\\n\\t * @notice EIP-712 delegation struct typeHash,\\n\\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\\n\\t */\\n\\t// keccak256(\\\"Delegation(address delegate,uint256 nonce,uint256 expiry)\\\")\\n\\tbytes32 public constant DELEGATION_TYPEHASH = 0xff41620983935eb4d4a3c7384a066ca8c1d10cef9a5eca9eb97ca735cd14a755;\\n\\n\\t/**\\n\\t * @notice EIP-712 permit (EIP-2612) struct typeHash,\\n\\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\\n\\t */\\n\\t// keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\")\\n\\tbytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\n\\n\\t/**\\n\\t * @notice EIP-712 TransferWithAuthorization (EIP-3009) struct typeHash,\\n\\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\\n\\t */\\n\\t// keccak256(\\\"TransferWithAuthorization(address from,address to,uint256 value,uint256 validAfter,uint256 validBefore,bytes32 nonce)\\\")\\n\\tbytes32 public constant TRANSFER_WITH_AUTHORIZATION_TYPEHASH = 0x7c7c6cdb67a18743f49ec6fa9b35f50d52ed05cbed4cc592e13b44501c1a2267;\\n\\n\\t/**\\n\\t * @notice EIP-712 ReceiveWithAuthorization (EIP-3009) struct typeHash,\\n\\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\\n\\t */\\n\\t// keccak256(\\\"ReceiveWithAuthorization(address from,address to,uint256 value,uint256 validAfter,uint256 validBefore,bytes32 nonce)\\\")\\n\\tbytes32 public constant RECEIVE_WITH_AUTHORIZATION_TYPEHASH = 0xd099cc98ef71107a616c4f0f941f04c322d8e254fe26b3c6668db87aae413de8;\\n\\n\\t/**\\n\\t * @notice EIP-712 CancelAuthorization (EIP-3009) struct typeHash,\\n\\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\\n\\t */\\n\\t// keccak256(\\\"CancelAuthorization(address authorizer,bytes32 nonce)\\\")\\n\\tbytes32 public constant CANCEL_AUTHORIZATION_TYPEHASH = 0x158b0a9edf7a828aad02f63cd515c68ef2f50ba807396f6d12842833a1597429;\\n\\n\\t/**\\n\\t * @dev Fired in mint() function\\n\\t *\\n\\t * @param by an address which minted some tokens (transaction sender)\\n\\t * @param to an address the tokens were minted to\\n\\t * @param value an amount of tokens minted\\n\\t */\\n\\tevent Minted(address indexed by, address indexed to, uint256 value);\\n\\n\\t/**\\n\\t * @dev Fired in burn() function\\n\\t *\\n\\t * @param by an address which burned some tokens (transaction sender)\\n\\t * @param from an address the tokens were burnt from\\n\\t * @param value an amount of tokens burnt\\n\\t */\\n\\tevent Burnt(address indexed by, address indexed from, uint256 value);\\n\\n\\t/**\\n\\t * @dev Resolution for the Multiple Withdrawal Attack on ERC20 Tokens (arXiv:1907.00903)\\n\\t *\\n\\t * @dev Similar to ERC20 Transfer event, but also logs an address which executed transfer\\n\\t *\\n\\t * @dev Fired in transfer(), transferFrom() and some other (non-ERC20) functions\\n\\t *\\n\\t * @param by an address which performed the transfer\\n\\t * @param from an address tokens were consumed from\\n\\t * @param to an address tokens were sent to\\n\\t * @param value number of tokens transferred\\n\\t */\\n\\tevent Transfer(address indexed by, address indexed from, address indexed to, uint256 value);\\n\\n\\t/**\\n\\t * @dev Resolution for the Multiple Withdrawal Attack on ERC20 Tokens (arXiv:1907.00903)\\n\\t *\\n\\t * @dev Similar to ERC20 Approve event, but also logs old approval value\\n\\t *\\n\\t * @dev Fired in approve(), increaseAllowance(), decreaseAllowance() functions,\\n\\t *      may get fired in transfer functions\\n\\t *\\n\\t * @param owner an address which granted a permission to transfer\\n\\t *      tokens on its behalf\\n\\t * @param spender an address which received a permission to transfer\\n\\t *      tokens on behalf of the owner `_owner`\\n\\t * @param oldValue previously granted amount of tokens to transfer on behalf\\n\\t * @param value new granted amount of tokens to transfer on behalf\\n\\t */\\n\\tevent Approval(address indexed owner, address indexed spender, uint256 oldValue, uint256 value);\\n\\n\\t/**\\n\\t * @dev Notifies that a key-value pair in `votingDelegates` mapping has changed,\\n\\t *      i.e. a delegator address has changed its delegate address\\n\\t *\\n\\t * @param source delegator address, a token owner, effectively transaction sender (`by`)\\n\\t * @param from old delegate, an address which delegate right is revoked\\n\\t * @param to new delegate, an address which received the voting power\\n\\t */\\n\\tevent DelegateChanged(address indexed source, address indexed from, address indexed to);\\n\\n\\t/**\\n\\t * @dev Notifies that a key-value pair in `votingPowerHistory` mapping has changed,\\n\\t *      i.e. a delegate's voting power has changed.\\n\\t *\\n\\t * @param by an address which executed delegate, mint, burn, or transfer operation\\n\\t *      which had led to delegate voting power change\\n\\t * @param target delegate whose voting power has changed\\n\\t * @param fromVal previous number of votes delegate had\\n\\t * @param toVal new number of votes delegate has\\n\\t */\\n\\tevent VotingPowerChanged(address indexed by, address indexed target, uint256 fromVal, uint256 toVal);\\n\\n\\t/**\\n\\t * @dev Fired in updateTokenMetadata() function\\n\\t *\\n\\t * @param by an address which updated token name and symbol (transaction sender)\\n\\t * @param prevName old token name value\\n\\t * @param prevSymbol old token symbol value\\n\\t * @param newName new token name value\\n\\t * @param newSymbol new token symbol value\\n\\t */\\n\\tevent TokenMetadataUpdated(address indexed by, string prevName, string prevSymbol, string newName, string newSymbol);\\n\\n\\t/**\\n\\t * @dev \\\"Constructor replacement\\\" for a smart contract with a delayed initialization (post-deployment initialization)\\n\\t *\\n\\t * @param _initialHolder owner of the initial token supply\\n\\t * @param _initialSupply initial token supply\\n\\t * @param _name token name to set\\n\\t * @param _symbol token symbol to set\\n\\t */\\n\\tfunction postConstruct(address _initialHolder, uint256 _initialSupply, string memory _name, string memory _symbol) public initializer {\\n\\t\\t// verify initial holder address non-zero (is set)\\n\\t\\trequire(_initialHolder != address(0), \\\"_initialHolder not set (zero address)\\\");\\n\\n\\t\\t// build the EIP-712 contract domain separator, see https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator\\n\\t\\t// note: we specify contract version in its name\\n\\t\\tDOMAIN_SEPARATOR = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(\\\"CharacterERC20\\\")), block.chainid, address(this)));\\n\\n\\t\\t// assign token name\\n\\t\\tname = _name;\\n\\n\\t\\t// assign token symbol\\n\\t\\tsymbol = _symbol;\\n\\n\\t\\t// contract initializer has full privileges\\n\\t\\tuserRoles[msg.sender] = type(uint256).max;\\n\\n\\t\\t// enables all features\\n\\t\\tupdateFeatures(0x0000_FFFF);\\n\\n\\t\\t// mint initial supply\\n\\t\\tmint(_initialHolder, _initialSupply);\\n\\t}\\n\\n\\t/**\\n\\t * @inheritdoc ERC165\\n\\t */\\n\\tfunction supportsInterface(bytes4 interfaceId) public pure override returns (bool) {\\n\\t\\t// reconstruct from current interface(s) and super interface(s) (if any)\\n\\t\\treturn interfaceId == type(ERC165).interfaceId\\n\\t\\t    || interfaceId == type(ERC20).interfaceId\\n\\t\\t    || interfaceId == type(ERC1363).interfaceId\\n\\t\\t    || interfaceId == type(EIP2612).interfaceId\\n\\t\\t    || interfaceId == type(EIP3009).interfaceId;\\n\\t}\\n\\n\\t// ===== Start: ERC-1363 functions =====\\n\\n\\t/**\\n\\t * @notice Transfers some tokens and then executes `onTransferReceived` callback on the receiver\\n\\t *\\n\\t * @inheritdoc ERC1363\\n\\t *\\n\\t * @dev Called by token owner (an address which has a\\n\\t *      positive token balance tracked by this smart contract)\\n\\t * @dev Throws on any error like\\n\\t *      * insufficient token balance or\\n\\t *      * incorrect `_to` address:\\n\\t *          * zero address or\\n\\t *          * same as `_from` address (self transfer)\\n\\t *          * EOA or smart contract which doesn't support ERC1363Receiver interface\\n\\t * @dev Returns true on success, throws otherwise\\n\\t *\\n\\t * @param _to an address to transfer tokens to,\\n\\t *      must be a smart contract, implementing ERC1363Receiver\\n\\t * @param _value amount of tokens to be transferred,, zero\\n\\t *      value is allowed\\n\\t * @return true unless throwing\\n\\t */\\n\\tfunction transferAndCall(address _to, uint256 _value) public override returns (bool) {\\n\\t\\t// delegate to `transferFromAndCall` passing `msg.sender` as `_from`\\n\\t\\treturn transferFromAndCall(msg.sender, _to, _value);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Transfers some tokens and then executes `onTransferReceived` callback on the receiver\\n\\t *\\n\\t * @inheritdoc ERC1363\\n\\t *\\n\\t * @dev Called by token owner (an address which has a\\n\\t *      positive token balance tracked by this smart contract)\\n\\t * @dev Throws on any error like\\n\\t *      * insufficient token balance or\\n\\t *      * incorrect `_to` address:\\n\\t *          * zero address or\\n\\t *          * same as `_from` address (self transfer)\\n\\t *          * EOA or smart contract which doesn't support ERC1363Receiver interface\\n\\t * @dev Returns true on success, throws otherwise\\n\\t *\\n\\t * @param _to an address to transfer tokens to,\\n\\t *      must be a smart contract, implementing ERC1363Receiver\\n\\t * @param _value amount of tokens to be transferred,, zero\\n\\t *      value is allowed\\n\\t * @param _data [optional] additional data with no specified format,\\n\\t *      sent in onTransferReceived call to `_to`\\n\\t * @return true unless throwing\\n\\t */\\n\\tfunction transferAndCall(address _to, uint256 _value, bytes memory _data) public override returns (bool) {\\n\\t\\t// delegate to `transferFromAndCall` passing `msg.sender` as `_from`\\n\\t\\treturn transferFromAndCall(msg.sender, _to, _value, _data);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Transfers some tokens on behalf of address `_from' (token owner)\\n\\t *      to some other address `_to` and then executes `onTransferReceived` callback on the receiver\\n\\t *\\n\\t * @inheritdoc ERC1363\\n\\t *\\n\\t * @dev Called by token owner on his own or approved address,\\n\\t *      an address approved earlier by token owner to\\n\\t *      transfer some amount of tokens on its behalf\\n\\t * @dev Throws on any error like\\n\\t *      * insufficient token balance or\\n\\t *      * incorrect `_to` address:\\n\\t *          * zero address or\\n\\t *          * same as `_from` address (self transfer)\\n\\t *          * EOA or smart contract which doesn't support ERC1363Receiver interface\\n\\t * @dev Returns true on success, throws otherwise\\n\\t *\\n\\t * @param _from token owner which approved caller (transaction sender)\\n\\t *      to transfer `_value` of tokens on its behalf\\n\\t * @param _to an address to transfer tokens to,\\n\\t *      must be a smart contract, implementing ERC1363Receiver\\n\\t * @param _value amount of tokens to be transferred,, zero\\n\\t *      value is allowed\\n\\t * @return true unless throwing\\n\\t */\\n\\tfunction transferFromAndCall(address _from, address _to, uint256 _value) public override returns (bool) {\\n\\t\\t// delegate to `transferFromAndCall` passing empty data param\\n\\t\\treturn transferFromAndCall(_from, _to, _value, \\\"\\\");\\n\\t}\\n\\n\\t/**\\n\\t * @notice Transfers some tokens on behalf of address `_from' (token owner)\\n\\t *      to some other address `_to` and then executes a `onTransferReceived` callback on the receiver\\n\\t *\\n\\t * @inheritdoc ERC1363\\n\\t *\\n\\t * @dev Called by token owner on his own or approved address,\\n\\t *      an address approved earlier by token owner to\\n\\t *      transfer some amount of tokens on its behalf\\n\\t * @dev Throws on any error like\\n\\t *      * insufficient token balance or\\n\\t *      * incorrect `_to` address:\\n\\t *          * zero address or\\n\\t *          * same as `_from` address (self transfer)\\n\\t *          * EOA or smart contract which doesn't support ERC1363Receiver interface\\n\\t * @dev Returns true on success, throws otherwise\\n\\t *\\n\\t * @param _from token owner which approved caller (transaction sender)\\n\\t *      to transfer `_value` of tokens on its behalf\\n\\t * @param _to an address to transfer tokens to,\\n\\t *      must be a smart contract, implementing ERC1363Receiver\\n\\t * @param _value amount of tokens to be transferred,, zero\\n\\t *      value is allowed\\n\\t * @param _data [optional] additional data with no specified format,\\n\\t *      sent in onTransferReceived call to `_to`\\n\\t * @return true unless throwing\\n\\t */\\n\\tfunction transferFromAndCall(address _from, address _to, uint256 _value, bytes memory _data) public override returns (bool) {\\n\\t\\t// ensure ERC-1363 transfers are enabled\\n\\t\\trequire(isFeatureEnabled(FEATURE_ERC1363_TRANSFERS), \\\"ERC1363 transfers are disabled\\\");\\n\\n\\t\\t// first delegate call to `unsafeTransferFrom` to perform the unsafe token(s) transfer\\n\\t\\tunsafeTransferFrom(_from, _to, _value);\\n\\n\\t\\t// after the successful transfer - check if receiver supports\\n\\t\\t// ERC1363Receiver and execute a callback handler `onTransferReceived`,\\n\\t\\t// reverting whole transaction on any error\\n\\t\\t_notifyTransferred(_from, _to, _value, _data, false);\\n\\n\\t\\t// function throws on any error, so if we're here - it means operation successful, just return true\\n\\t\\treturn true;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Approves address called `_spender` to transfer some amount\\n\\t *      of tokens on behalf of the owner, then executes a `onApprovalReceived` callback on `_spender`\\n\\t *\\n\\t * @inheritdoc ERC1363\\n\\t *\\n\\t * @dev Caller must not necessarily own any tokens to grant the permission\\n\\t *\\n\\t * @dev Throws if `_spender` is an EOA or a smart contract which doesn't support ERC1363Spender interface\\n\\t *\\n\\t * @param _spender an address approved by the caller (token owner)\\n\\t *      to spend some tokens on its behalf\\n\\t * @param _value an amount of tokens spender `_spender` is allowed to\\n\\t *      transfer on behalf of the token owner\\n\\t * @return success true on success, throws otherwise\\n\\t */\\n\\tfunction approveAndCall(address _spender, uint256 _value) public override returns (bool) {\\n\\t\\t// delegate to `approveAndCall` passing empty data\\n\\t\\treturn approveAndCall(_spender, _value, \\\"\\\");\\n\\t}\\n\\n\\t/**\\n\\t * @notice Approves address called `_spender` to transfer some amount\\n\\t *      of tokens on behalf of the owner, then executes a callback on `_spender`\\n\\t *\\n\\t * @inheritdoc ERC1363\\n\\t *\\n\\t * @dev Caller must not necessarily own any tokens to grant the permission\\n\\t *\\n\\t * @param _spender an address approved by the caller (token owner)\\n\\t *      to spend some tokens on its behalf\\n\\t * @param _value an amount of tokens spender `_spender` is allowed to\\n\\t *      transfer on behalf of the token owner\\n\\t * @param _data [optional] additional data with no specified format,\\n\\t *      sent in onApprovalReceived call to `_spender`\\n\\t * @return success true on success, throws otherwise\\n\\t */\\n\\tfunction approveAndCall(address _spender, uint256 _value, bytes memory _data) public override returns (bool) {\\n\\t\\t// ensure ERC-1363 approvals are enabled\\n\\t\\trequire(isFeatureEnabled(FEATURE_ERC1363_APPROVALS), \\\"ERC1363 approvals are disabled\\\");\\n\\n\\t\\t// execute regular ERC20 approve - delegate to `approve`\\n\\t\\tapprove(_spender, _value);\\n\\n\\t\\t// after the successful approve - check if receiver supports\\n\\t\\t// ERC1363Spender and execute a callback handler `onApprovalReceived`,\\n\\t\\t// reverting whole transaction on any error\\n\\t\\t_notifyApproved(_spender, _value, _data);\\n\\n\\t\\t// function throws on any error, so if we're here - it means operation successful, just return true\\n\\t\\treturn true;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Auxiliary function to invoke `onTransferReceived` on a target address\\n\\t *      The call is not executed if the target address is not a contract; in such\\n\\t *      a case function throws if `allowEoa` is set to false, succeeds if it's true\\n\\t *\\n\\t * @dev Throws on any error; returns silently on success\\n\\t *\\n\\t * @param _from representing the previous owner of the given token value\\n\\t * @param _to target address that will receive the tokens\\n\\t * @param _value the amount mount of tokens to be transferred\\n\\t * @param _data [optional] data to send along with the call\\n\\t * @param allowEoa indicates if function should fail if `_to` is an EOA\\n\\t */\\n\\tfunction _notifyTransferred(address _from, address _to, uint256 _value, bytes memory _data, bool allowEoa) private {\\n\\t\\t// if recipient `_to` is EOA\\n\\t\\tif (!AddressUtils.isContract(_to)) {\\n\\t\\t\\t// ensure EOA recipient is allowed\\n\\t\\t\\trequire(allowEoa, \\\"EOA recipient\\\");\\n\\n\\t\\t\\t// exit if successful\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// otherwise - if `_to` is a contract - execute onTransferReceived\\n\\t\\tbytes4 response = ERC1363Receiver(_to).onTransferReceived(msg.sender, _from, _value, _data);\\n\\n\\t\\t// expected response is ERC1363Receiver(_to).onTransferReceived.selector\\n\\t\\t// bytes4(keccak256(\\\"onTransferReceived(address,address,uint256,bytes)\\\"))\\n\\t\\trequire(response == ERC1363Receiver(_to).onTransferReceived.selector, \\\"invalid onTransferReceived response\\\");\\n\\t}\\n\\n\\t/**\\n\\t * @dev Auxiliary function to invoke `onApprovalReceived` on a target address\\n\\t *      The call is not executed if the target address is not a contract; in such\\n\\t *      a case function throws if `allowEoa` is set to false, succeeds if it's true\\n\\t *\\n\\t * @dev Throws on any error; returns silently on success\\n\\t *\\n\\t * @param _spender the address which will spend the funds\\n\\t * @param _value the amount of tokens to be spent\\n\\t * @param _data [optional] data to send along with the call\\n\\t */\\n\\tfunction _notifyApproved(address _spender, uint256 _value, bytes memory _data) private {\\n\\t\\t// ensure recipient is not EOA\\n\\t\\trequire(AddressUtils.isContract(_spender), \\\"EOA spender\\\");\\n\\n\\t\\t// otherwise - if `_to` is a contract - execute onApprovalReceived\\n\\t\\tbytes4 response = ERC1363Spender(_spender).onApprovalReceived(msg.sender, _value, _data);\\n\\n\\t\\t// expected response is ERC1363Spender(_to).onApprovalReceived.selector\\n\\t\\t// bytes4(keccak256(\\\"onApprovalReceived(address,uint256,bytes)\\\"))\\n\\t\\trequire(response == ERC1363Spender(_spender).onApprovalReceived.selector, \\\"invalid onApprovalReceived response\\\");\\n\\t}\\n\\t// ===== End: ERC-1363 functions =====\\n\\n\\t// ===== Start: ERC20 functions =====\\n\\n\\t/**\\n\\t * @notice Gets the balance of a particular address\\n\\t *\\n\\t * @inheritdoc ERC20\\n\\t *\\n\\t * @param _owner the address to query the the balance for\\n\\t * @return balance an amount of tokens owned by the address specified\\n\\t */\\n\\tfunction balanceOf(address _owner) public view override returns (uint256 balance) {\\n\\t\\t// read the balance and return\\n\\t\\treturn tokenBalances[_owner];\\n\\t}\\n\\n\\t/**\\n\\t * @notice Transfers some tokens to an external address or a smart contract\\n\\t *\\n\\t * @inheritdoc ERC20\\n\\t *\\n\\t * @dev Called by token owner (an address which has a\\n\\t *      positive token balance tracked by this smart contract)\\n\\t * @dev Throws on any error like\\n\\t *      * insufficient token balance or\\n\\t *      * incorrect `_to` address:\\n\\t *          * zero address or\\n\\t *          * self address or\\n\\t *          * smart contract which doesn't support ERC20\\n\\t *\\n\\t * @param _to an address to transfer tokens to,\\n\\t *      must be either an external address or a smart contract,\\n\\t *      compliant with the ERC20 standard\\n\\t * @param _value amount of tokens to be transferred,, zero\\n\\t *      value is allowed\\n\\t * @return success true on success, throws otherwise\\n\\t */\\n\\tfunction transfer(address _to, uint256 _value) public override returns (bool success) {\\n\\t\\t// just delegate call to `transferFrom`,\\n\\t\\t// `FEATURE_TRANSFERS` is verified inside it\\n\\t\\treturn transferFrom(msg.sender, _to, _value);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Transfers some tokens on behalf of address `_from' (token owner)\\n\\t *      to some other address `_to`\\n\\t *\\n\\t * @inheritdoc ERC20\\n\\t *\\n\\t * @dev Called by token owner on his own or approved address,\\n\\t *      an address approved earlier by token owner to\\n\\t *      transfer some amount of tokens on its behalf\\n\\t * @dev Throws on any error like\\n\\t *      * insufficient token balance or\\n\\t *      * incorrect `_to` address:\\n\\t *          * zero address or\\n\\t *          * same as `_from` address (self transfer)\\n\\t *          * smart contract which doesn't support ERC20\\n\\t *\\n\\t * @param _from token owner which approved caller (transaction sender)\\n\\t *      to transfer `_value` of tokens on its behalf\\n\\t * @param _to an address to transfer tokens to,\\n\\t *      must be either an external address or a smart contract,\\n\\t *      compliant with the ERC20 standard\\n\\t * @param _value amount of tokens to be transferred,, zero\\n\\t *      value is allowed\\n\\t * @return success true on success, throws otherwise\\n\\t */\\n\\tfunction transferFrom(address _from, address _to, uint256 _value) public override returns (bool success) {\\n\\t\\t// depending on `FEATURE_UNSAFE_TRANSFERS` we execute either safe (default)\\n\\t\\t// or unsafe transfer\\n\\t\\t// if `FEATURE_UNSAFE_TRANSFERS` is enabled\\n\\t\\t// or receiver has `ROLE_ERC20_RECEIVER` permission\\n\\t\\t// or sender has `ROLE_ERC20_SENDER` permission\\n\\t\\tif(isFeatureEnabled(FEATURE_UNSAFE_TRANSFERS)\\n\\t\\t\\t|| isOperatorInRole(_to, ROLE_ERC20_RECEIVER)\\n\\t\\t\\t|| isSenderInRole(ROLE_ERC20_SENDER)) {\\n\\t\\t\\t// we execute unsafe transfer - delegate call to `unsafeTransferFrom`,\\n\\t\\t\\t// `FEATURE_TRANSFERS` is verified inside it\\n\\t\\t\\tunsafeTransferFrom(_from, _to, _value);\\n\\t\\t}\\n\\t\\t// otherwise - if `FEATURE_UNSAFE_TRANSFERS` is disabled\\n\\t\\t// and receiver doesn't have `ROLE_ERC20_RECEIVER` permission\\n\\t\\telse {\\n\\t\\t\\t// we execute safe transfer - delegate call to `safeTransferFrom`, passing empty `_data`,\\n\\t\\t\\t// `FEATURE_TRANSFERS` is verified inside it\\n\\t\\t\\tsafeTransferFrom(_from, _to, _value, \\\"\\\");\\n\\t\\t}\\n\\n\\t\\t// both `unsafeTransferFrom` and `safeTransferFrom` throw on any error, so\\n\\t\\t// if we're here - it means operation successful,\\n\\t\\t// just return true\\n\\t\\treturn true;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Transfers some tokens on behalf of address `_from' (token owner)\\n\\t *      to some other address `_to` and then executes `onTransferReceived` callback\\n\\t *      on the receiver if it is a smart contract (not an EOA)\\n\\t *\\n\\t * @dev Called by token owner on his own or approved address,\\n\\t *      an address approved earlier by token owner to\\n\\t *      transfer some amount of tokens on its behalf\\n\\t * @dev Throws on any error like\\n\\t *      * insufficient token balance or\\n\\t *      * incorrect `_to` address:\\n\\t *          * zero address or\\n\\t *          * same as `_from` address (self transfer)\\n\\t *          * smart contract which doesn't support ERC1363Receiver interface\\n\\t * @dev Returns true on success, throws otherwise\\n\\t *\\n\\t * @param _from token owner which approved caller (transaction sender)\\n\\t *      to transfer `_value` of tokens on its behalf\\n\\t * @param _to an address to transfer tokens to,\\n\\t *      must be either an external address or a smart contract,\\n\\t *      implementing ERC1363Receiver\\n\\t * @param _value amount of tokens to be transferred,, zero\\n\\t *      value is allowed\\n\\t * @param _data [optional] additional data with no specified format,\\n\\t *      sent in onTransferReceived call to `_to` in case if its a smart contract\\n\\t * @return true unless throwing\\n\\t */\\n\\tfunction safeTransferFrom(address _from, address _to, uint256 _value, bytes memory _data) public returns (bool) {\\n\\t\\t// first delegate call to `unsafeTransferFrom` to perform the unsafe token(s) transfer\\n\\t\\tunsafeTransferFrom(_from, _to, _value);\\n\\n\\t\\t// after the successful transfer - check if receiver supports\\n\\t\\t// ERC1363Receiver and execute a callback handler `onTransferReceived`,\\n\\t\\t// reverting whole transaction on any error\\n\\t\\t_notifyTransferred(_from, _to, _value, _data, true);\\n\\n\\t\\t// function throws on any error, so if we're here - it means operation successful, just return true\\n\\t\\treturn true;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Transfers some tokens on behalf of address `_from' (token owner)\\n\\t *      to some other address `_to`\\n\\t *\\n\\t * @dev In contrast to `transferFromAndCall` doesn't check recipient\\n\\t *      smart contract to support ERC20 tokens (ERC1363Receiver)\\n\\t * @dev Designed to be used by developers when the receiver is known\\n\\t *      to support ERC20 tokens but doesn't implement ERC1363Receiver interface\\n\\t * @dev Called by token owner on his own or approved address,\\n\\t *      an address approved earlier by token owner to\\n\\t *      transfer some amount of tokens on its behalf\\n\\t * @dev Throws on any error like\\n\\t *      * insufficient token balance or\\n\\t *      * incorrect `_to` address:\\n\\t *          * zero address or\\n\\t *          * same as `_from` address (self transfer)\\n\\t * @dev Returns silently on success, throws otherwise\\n\\t *\\n\\t * @param _from token sender, token owner which approved caller (transaction sender)\\n\\t *      to transfer `_value` of tokens on its behalf\\n\\t * @param _to token receiver, an address to transfer tokens to\\n\\t * @param _value amount of tokens to be transferred,, zero\\n\\t *      value is allowed\\n\\t */\\n\\tfunction unsafeTransferFrom(address _from, address _to, uint256 _value) public {\\n\\t\\t// make an internal transferFrom - delegate to `__transferFrom`\\n\\t\\t__transferFrom(msg.sender, _from, _to, _value);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Powers the meta transactions for `unsafeTransferFrom` - EIP-3009 `transferWithAuthorization`\\n\\t *      and `receiveWithAuthorization`\\n\\t *\\n\\t * @dev See `unsafeTransferFrom` and `transferFrom` soldoc for details\\n\\t *\\n\\t * @param _by an address executing the transfer, it can be token owner itself,\\n\\t *      or an operator previously approved with `approve()`\\n\\t * @param _from token sender, token owner which approved caller (transaction sender)\\n\\t *      to transfer `_value` of tokens on its behalf\\n\\t * @param _to token receiver, an address to transfer tokens to\\n\\t * @param _value amount of tokens to be transferred,, zero\\n\\t *      value is allowed\\n\\t */\\n\\tfunction __transferFrom(address _by, address _from, address _to, uint256 _value) private {\\n\\t\\t// if `_from` is equal to sender, require transfers feature to be enabled\\n\\t\\t// otherwise require transfers on behalf feature to be enabled\\n\\t\\trequire(_from == _by && isFeatureEnabled(FEATURE_TRANSFERS)\\n\\t\\t     || _from != _by && isFeatureEnabled(FEATURE_TRANSFERS_ON_BEHALF),\\n\\t\\t        _from == _by? \\\"transfers are disabled\\\": \\\"transfers on behalf are disabled\\\");\\n\\n\\t\\t// non-zero source address check - Zeppelin\\n\\t\\t// obviously, zero source address is a client mistake\\n\\t\\t// it's not part of ERC20 standard but it's reasonable to fail fast\\n\\t\\t// since for zero value transfer transaction succeeds otherwise\\n\\t\\trequire(_from != address(0), \\\"transfer from the zero address\\\");\\n\\n\\t\\t// non-zero recipient address check\\n\\t\\trequire(_to != address(0), \\\"transfer to the zero address\\\");\\n\\n\\t\\t// sender and recipient cannot be the same\\n\\t\\trequire(_from != _to, \\\"sender and recipient are the same (_from = _to)\\\");\\n\\n\\t\\t// sending tokens to the token smart contract itself is a client mistake\\n\\t\\trequire(_to != address(this), \\\"invalid recipient (transfer to the token smart contract itself)\\\");\\n\\n\\t\\t// according to ERC-20 Token Standard, https://eips.ethereum.org/EIPS/eip-20\\n\\t\\t// \\\"Transfers of 0 values MUST be treated as normal transfers and fire the Transfer event.\\\"\\n\\t\\tif(_value == 0) {\\n\\t\\t\\t// emit an ERC20 transfer event\\n\\t\\t\\temit Transfer(_from, _to, _value);\\n\\n\\t\\t\\t// don't forget to return - we're done\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// no need to make arithmetic overflow check on the _value - by design of mint()\\n\\n\\t\\t// in case of transfer on behalf\\n\\t\\tif(_from != _by) {\\n\\t\\t\\t// read allowance value - the amount of tokens allowed to transfer - into the stack\\n\\t\\t\\tuint256 _allowance = transferAllowances[_from][_by];\\n\\n\\t\\t\\t// verify sender has an allowance to transfer amount of tokens requested\\n\\t\\t\\trequire(_allowance >= _value, \\\"transfer amount exceeds allowance\\\");\\n\\n\\t\\t\\t// we treat max uint256 allowance value as an \\\"unlimited\\\" and\\n\\t\\t\\t// do not decrease allowance when it is set to \\\"unlimited\\\" value\\n\\t\\t\\tif(_allowance < type(uint256).max) {\\n\\t\\t\\t\\t// update allowance value on the stack\\n\\t\\t\\t\\t_allowance -= _value;\\n\\n\\t\\t\\t\\t// update the allowance value in storage\\n\\t\\t\\t\\ttransferAllowances[_from][_by] = _allowance;\\n\\n\\t\\t\\t\\t// emit an improved atomic approve event\\n\\t\\t\\t\\temit Approval(_from, _by, _allowance + _value, _allowance);\\n\\n\\t\\t\\t\\t// emit an ERC20 approval event to reflect the decrease\\n\\t\\t\\t\\temit Approval(_from, _by, _allowance);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// verify sender has enough tokens to transfer on behalf\\n\\t\\trequire(tokenBalances[_from] >= _value, \\\"transfer amount exceeds balance\\\");\\n\\n\\t\\t// perform the transfer:\\n\\t\\t// decrease token owner (sender) balance\\n\\t\\ttokenBalances[_from] -= _value;\\n\\n\\t\\t// increase `_to` address (receiver) balance\\n\\t\\ttokenBalances[_to] += _value;\\n\\n\\t\\t// move voting power associated with the tokens transferred\\n\\t\\t__moveVotingPower(_by, votingDelegates[_from], votingDelegates[_to], _value);\\n\\n\\t\\t// emit an improved transfer event (arXiv:1907.00903)\\n\\t\\temit Transfer(_by, _from, _to, _value);\\n\\n\\t\\t// emit an ERC20 transfer event\\n\\t\\temit Transfer(_from, _to, _value);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Approves address called `_spender` to transfer some amount\\n\\t *      of tokens on behalf of the owner (transaction sender)\\n\\t *\\n\\t * @inheritdoc ERC20\\n\\t *\\n\\t * @dev Transaction sender must not necessarily own any tokens to grant the permission\\n\\t *\\n\\t * @param _spender an address approved by the caller (token owner)\\n\\t *      to spend some tokens on its behalf\\n\\t * @param _value an amount of tokens spender `_spender` is allowed to\\n\\t *      transfer on behalf of the token owner\\n\\t * @return success true on success, throws otherwise\\n\\t */\\n\\tfunction approve(address _spender, uint256 _value) public override returns (bool success) {\\n\\t\\t// make an internal approve - delegate to `__approve`\\n\\t\\t__approve(msg.sender, _spender, _value);\\n\\n\\t\\t// operation successful, return true\\n\\t\\treturn true;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Powers the meta transaction for `approve` - EIP-2612 `permit`\\n\\t *\\n\\t * @dev Approves address called `_spender` to transfer some amount\\n\\t *      of tokens on behalf of the `_owner`\\n\\t *\\n\\t * @dev `_owner` must not necessarily own any tokens to grant the permission\\n\\t * @dev Throws if `_spender` is a zero address\\n\\t *\\n\\t * @param _owner owner of the tokens to set approval on behalf of\\n\\t * @param _spender an address approved by the token owner\\n\\t *      to spend some tokens on its behalf\\n\\t * @param _value an amount of tokens spender `_spender` is allowed to\\n\\t *      transfer on behalf of the token owner\\n\\t */\\n\\tfunction __approve(address _owner, address _spender, uint256 _value) private {\\n\\t\\t// non-zero spender address check - Zeppelin\\n\\t\\t// obviously, zero spender address is a client mistake\\n\\t\\t// it's not part of ERC20 standard but it's reasonable to fail fast\\n\\t\\trequire(_spender != address(0), \\\"approve to the zero address\\\");\\n\\n\\t\\t// read old approval value to emmit an improved event (arXiv:1907.00903)\\n\\t\\tuint256 _oldValue = transferAllowances[_owner][_spender];\\n\\n\\t\\t// perform an operation: write value requested into the storage\\n\\t\\ttransferAllowances[_owner][_spender] = _value;\\n\\n\\t\\t// emit an improved atomic approve event (arXiv:1907.00903)\\n\\t\\temit Approval(_owner, _spender, _oldValue, _value);\\n\\n\\t\\t// emit an ERC20 approval event\\n\\t\\temit Approval(_owner, _spender, _value);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Returns the amount which _spender is still allowed to withdraw from _owner.\\n\\t *\\n\\t * @inheritdoc ERC20\\n\\t *\\n\\t * @dev A function to check an amount of tokens owner approved\\n\\t *      to transfer on its behalf by some other address called \\\"spender\\\"\\n\\t *\\n\\t * @param _owner an address which approves transferring some tokens on its behalf\\n\\t * @param _spender an address approved to transfer some tokens on behalf\\n\\t * @return remaining an amount of tokens approved address `_spender` can transfer on behalf\\n\\t *      of token owner `_owner`\\n\\t */\\n\\tfunction allowance(address _owner, address _spender) public view override returns (uint256 remaining) {\\n\\t\\t// read the value from storage and return\\n\\t\\treturn transferAllowances[_owner][_spender];\\n\\t}\\n\\n\\t// ===== End: ERC20 functions =====\\n\\n\\t// ===== Start: Resolution for the Multiple Withdrawal Attack on ERC20 Tokens (arXiv:1907.00903) =====\\n\\n\\t/**\\n\\t * @notice Increases the allowance granted to `spender` by the transaction sender\\n\\t *\\n\\t * @dev Resolution for the Multiple Withdrawal Attack on ERC20 Tokens (arXiv:1907.00903)\\n\\t *\\n\\t * @dev Throws if value to increase by is zero or too big and causes arithmetic overflow\\n\\t *\\n\\t * @param _spender an address approved by the caller (token owner)\\n\\t *      to spend some tokens on its behalf\\n\\t * @param _value an amount of tokens to increase by\\n\\t * @return success true on success, throws otherwise\\n\\t */\\n\\tfunction increaseAllowance(address _spender, uint256 _value) public returns (bool) {\\n\\t\\t// read current allowance value\\n\\t\\tuint256 currentVal = transferAllowances[msg.sender][_spender];\\n\\n\\t\\t// non-zero _value and arithmetic overflow check on the allowance\\n\\t\\tunchecked {\\n\\t\\t\\t// put operation into unchecked block to display user-friendly overflow error message for Solidity 0.8+\\n\\t\\t\\trequire(currentVal + _value > currentVal, \\\"zero value approval increase or arithmetic overflow\\\");\\n\\t\\t}\\n\\n\\t\\t// delegate call to `approve` with the new value\\n\\t\\treturn approve(_spender, currentVal + _value);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Decreases the allowance granted to `spender` by the caller.\\n\\t *\\n\\t * @dev Resolution for the Multiple Withdrawal Attack on ERC20 Tokens (arXiv:1907.00903)\\n\\t *\\n\\t * @dev Throws if value to decrease by is zero or is greater than currently allowed value\\n\\t *\\n\\t * @param _spender an address approved by the caller (token owner)\\n\\t *      to spend some tokens on its behalf\\n\\t * @param _value an amount of tokens to decrease by\\n\\t * @return success true on success, throws otherwise\\n\\t */\\n\\tfunction decreaseAllowance(address _spender, uint256 _value) public returns (bool) {\\n\\t\\t// read current allowance value\\n\\t\\tuint256 currentVal = transferAllowances[msg.sender][_spender];\\n\\n\\t\\t// non-zero _value check on the allowance\\n\\t\\trequire(_value > 0, \\\"zero value approval decrease\\\");\\n\\n\\t\\t// verify allowance decrease doesn't underflow\\n\\t\\trequire(currentVal >= _value, \\\"ERC20: decreased allowance below zero\\\");\\n\\n\\t\\t// delegate call to `approve` with the new value\\n\\t\\treturn approve(_spender, currentVal - _value);\\n\\t}\\n\\n\\t// ===== End: Resolution for the Multiple Withdrawal Attack on ERC20 Tokens (arXiv:1907.00903) =====\\n\\n\\t// ===== Start: Minting/burning extension =====\\n\\n\\t/**\\n\\t * @dev Mints (creates) some tokens to address specified\\n\\t * @dev The value specified is treated as is without taking\\n\\t *      into account what `decimals` value is\\n\\t *\\n\\t * @dev Requires executor to have `ROLE_TOKEN_CREATOR` permission\\n\\t *\\n\\t * @dev Throws on overflow, if totalSupply + _value doesn't fit into uint256\\n\\t *\\n\\t * @param _to an address to mint tokens to\\n\\t * @param _value an amount of tokens to mint (create)\\n\\t */\\n\\tfunction mint(address _to, uint256 _value) public {\\n\\t\\t// check if caller has sufficient permissions to mint tokens\\n\\t\\trequire(isSenderInRole(ROLE_TOKEN_CREATOR), \\\"access denied\\\");\\n\\n\\t\\t// non-zero recipient address check\\n\\t\\trequire(_to != address(0), \\\"zero address\\\");\\n\\n\\t\\t// non-zero _value and arithmetic overflow check on the total supply\\n\\t\\t// this check automatically secures arithmetic overflow on the individual balance\\n\\t\\tunchecked {\\n\\t\\t\\t// put operation into unchecked block to display user-friendly overflow error message for Solidity 0.8+\\n\\t\\t\\trequire(totalSupply + _value > totalSupply, \\\"zero value or arithmetic overflow\\\");\\n\\t\\t}\\n\\n\\t\\t// uint192 overflow check (required by voting delegation)\\n\\t\\trequire(totalSupply + _value <= type(uint192).max, \\\"total supply overflow (uint192)\\\");\\n\\n\\t\\t// perform mint:\\n\\t\\t// increase total amount of tokens value\\n\\t\\ttotalSupply += _value;\\n\\n\\t\\t// increase `_to` address balance\\n\\t\\ttokenBalances[_to] += _value;\\n\\n\\t\\t// update total token supply history\\n\\t\\t__updateHistory(totalSupplyHistory, add, _value);\\n\\n\\t\\t// create voting power associated with the tokens minted\\n\\t\\t__moveVotingPower(msg.sender, address(0), votingDelegates[_to], _value);\\n\\n\\t\\t// fire a minted event\\n\\t\\temit Minted(msg.sender, _to, _value);\\n\\n\\t\\t// emit an improved transfer event (arXiv:1907.00903)\\n\\t\\temit Transfer(msg.sender, address(0), _to, _value);\\n\\n\\t\\t// fire ERC20 compliant transfer event\\n\\t\\temit Transfer(address(0), _to, _value);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Burns (destroys) some tokens from the address specified\\n\\t *\\n\\t * @dev The value specified is treated as is without taking\\n\\t *      into account what `decimals` value is\\n\\t *\\n\\t * @dev Requires executor to have `ROLE_TOKEN_DESTROYER` permission\\n\\t *      or FEATURE_OWN_BURNS/FEATURE_BURNS_ON_BEHALF features to be enabled\\n\\t *\\n\\t * @dev Can be disabled by the contract creator forever by disabling\\n\\t *      FEATURE_OWN_BURNS/FEATURE_BURNS_ON_BEHALF features and then revoking\\n\\t *      its own roles to burn tokens and to enable burning features\\n\\t *\\n\\t * @param _from an address to burn some tokens from\\n\\t * @param _value an amount of tokens to burn (destroy)\\n\\t */\\n\\tfunction burn(address _from, uint256 _value) public {\\n\\t\\t// check if caller has sufficient permissions to burn tokens\\n\\t\\t// and if not - check for possibility to burn own tokens or to burn on behalf\\n\\t\\tif(!isSenderInRole(ROLE_TOKEN_DESTROYER)) {\\n\\t\\t\\t// if `_from` is equal to sender, require own burns feature to be enabled\\n\\t\\t\\t// otherwise require burns on behalf feature to be enabled\\n\\t\\t\\trequire(_from == msg.sender && isFeatureEnabled(FEATURE_OWN_BURNS)\\n\\t\\t\\t     || _from != msg.sender && isFeatureEnabled(FEATURE_BURNS_ON_BEHALF),\\n\\t\\t\\t        _from == msg.sender? \\\"burns are disabled\\\": \\\"burns on behalf are disabled\\\");\\n\\n\\t\\t\\t// in case of burn on behalf\\n\\t\\t\\tif(_from != msg.sender) {\\n\\t\\t\\t\\t// read allowance value - the amount of tokens allowed to be burnt - into the stack\\n\\t\\t\\t\\tuint256 _allowance = transferAllowances[_from][msg.sender];\\n\\n\\t\\t\\t\\t// verify sender has an allowance to burn amount of tokens requested\\n\\t\\t\\t\\trequire(_allowance >= _value, \\\"burn amount exceeds allowance\\\");\\n\\n\\t\\t\\t\\t// we treat max uint256 allowance value as an \\\"unlimited\\\" and\\n\\t\\t\\t\\t// do not decrease allowance when it is set to \\\"unlimited\\\" value\\n\\t\\t\\t\\tif(_allowance < type(uint256).max) {\\n\\t\\t\\t\\t\\t// update allowance value on the stack\\n\\t\\t\\t\\t\\t_allowance -= _value;\\n\\n\\t\\t\\t\\t\\t// update the allowance value in storage\\n\\t\\t\\t\\t\\ttransferAllowances[_from][msg.sender] = _allowance;\\n\\n\\t\\t\\t\\t\\t// emit an improved atomic approve event (arXiv:1907.00903)\\n\\t\\t\\t\\t\\temit Approval(msg.sender, _from, _allowance + _value, _allowance);\\n\\n\\t\\t\\t\\t\\t// emit an ERC20 approval event to reflect the decrease\\n\\t\\t\\t\\t\\temit Approval(_from, msg.sender, _allowance);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// at this point we know that either sender is ROLE_TOKEN_DESTROYER or\\n\\t\\t// we burn own tokens or on behalf (in latest case we already checked and updated allowances)\\n\\t\\t// we have left to execute balance checks and burning logic itself\\n\\n\\t\\t// non-zero burn value check\\n\\t\\trequire(_value != 0, \\\"zero value burn\\\");\\n\\n\\t\\t// non-zero source address check - Zeppelin\\n\\t\\trequire(_from != address(0), \\\"burn from the zero address\\\");\\n\\n\\t\\t// verify `_from` address has enough tokens to destroy\\n\\t\\t// (basically this is a arithmetic overflow check)\\n\\t\\trequire(tokenBalances[_from] >= _value, \\\"burn amount exceeds balance\\\");\\n\\n\\t\\t// perform burn:\\n\\t\\t// decrease `_from` address balance\\n\\t\\ttokenBalances[_from] -= _value;\\n\\n\\t\\t// decrease total amount of tokens value\\n\\t\\ttotalSupply -= _value;\\n\\n\\t\\t// update total token supply history\\n\\t\\t__updateHistory(totalSupplyHistory, sub, _value);\\n\\n\\t\\t// destroy voting power associated with the tokens burnt\\n\\t\\t__moveVotingPower(msg.sender, votingDelegates[_from], address(0), _value);\\n\\n\\t\\t// fire a burnt event\\n\\t\\temit Burnt(msg.sender, _from, _value);\\n\\n\\t\\t// emit an improved transfer event (arXiv:1907.00903)\\n\\t\\temit Transfer(msg.sender, _from, address(0), _value);\\n\\n\\t\\t// fire ERC20 compliant transfer event\\n\\t\\temit Transfer(_from, address(0), _value);\\n\\t}\\n\\n\\t// ===== End: Minting/burning extension =====\\n\\n\\t// ===== Start: Metadata extension =====\\n\\t\\n\\t/**\\n\\t * @dev Updates name and symbol of CharacterERC20\\n\\t * \\n\\t * @dev Requires executor to have `ROLE_METADATA_EDITOR` permission\\n\\t * \\n\\t * @param _name new token name to set\\n\\t * @param _symbol new token symbol to set\\n\\t */\\n\\tfunction updateTokenMetadata(string memory _name, string memory _symbol) public {\\n\\t\\t// check if caller has sufficient permissions to edit token metadata\\n\\t\\trequire(isSenderInRole(ROLE_METADATA_EDITOR), \\\"access denied\\\");\\n\\n\\t\\t// fire a metadata update event\\n\\t\\temit TokenMetadataUpdated(msg.sender, name, symbol, _name, _symbol);\\n\\n\\t\\t// update token name\\n\\t\\tname = _name;\\n\\n\\t\\t// update token symbol\\n\\t\\tsymbol = _symbol;\\n\\t}\\n\\n\\t// ===== End: Metadata extension =====\\n\\n\\t// ===== Start: EIP-2612 functions =====\\n\\n\\t/**\\n\\t * @inheritdoc EIP2612\\n\\t *\\n\\t * @dev Executes approve(_spender, _value) on behalf of the owner who EIP-712\\n\\t *      signed the transaction, i.e. as if transaction sender is the EIP712 signer\\n\\t *\\n\\t * @dev Sets the `_value` as the allowance of `_spender` over `_owner` tokens,\\n\\t *      given `_owner` EIP-712 signed approval\\n\\t *\\n\\t * @dev Inherits the Multiple Withdrawal Attack on ERC20 Tokens (arXiv:1907.00903)\\n\\t *      vulnerability in the same way as ERC20 `approve`, use standard ERC20 workaround\\n\\t *      if this might become an issue:\\n\\t *      https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit\\n\\t *\\n\\t * @dev Emits `Approval` event(s) in the same way as `approve` does\\n\\t *\\n\\t * @dev Requires:\\n\\t *     - `_spender` to be non-zero address\\n\\t *     - `_exp` to be a timestamp in the future\\n\\t *     - `v`, `r` and `s` to be a valid `secp256k1` signature from `_owner`\\n\\t *        over the EIP712-formatted function arguments.\\n\\t *     - the signature to use `_owner` current nonce (see `nonces`).\\n\\t *\\n\\t * @dev For more information on the signature format, see the\\n\\t *      https://eips.ethereum.org/EIPS/eip-2612#specification\\n\\t *\\n\\t * @param _owner owner of the tokens to set approval on behalf of,\\n\\t *      an address which signed the EIP-712 message\\n\\t * @param _spender an address approved by the token owner\\n\\t *      to spend some tokens on its behalf\\n\\t * @param _value an amount of tokens spender `_spender` is allowed to\\n\\t *      transfer on behalf of the token owner\\n\\t * @param _exp signature expiration time (unix timestamp)\\n\\t * @param v the recovery byte of the signature\\n\\t * @param r half of the ECDSA signature pair\\n\\t * @param s half of the ECDSA signature pair\\n\\t */\\n\\tfunction permit(address _owner, address _spender, uint256 _value, uint256 _exp, uint8 v, bytes32 r, bytes32 s) public override {\\n\\t\\t// verify permits are enabled\\n\\t\\trequire(isFeatureEnabled(FEATURE_EIP2612_PERMITS), \\\"EIP2612 permits are disabled\\\");\\n\\n\\t\\t// derive signer of the EIP712 Permit message, and\\n\\t\\t// update the nonce for that particular signer to avoid replay attack!!! --------->>> \\u2193\\u2193\\u2193\\u2193\\u2193\\u2193\\u2193\\u2193\\u2193\\u2193\\u2193\\u2193\\u2193\\u2193\\u2193\\u2193\\n\\t\\taddress signer = __deriveSigner(abi.encode(PERMIT_TYPEHASH, _owner, _spender, _value, nonces[_owner]++, _exp), v, r, s);\\n\\n\\t\\t// perform message integrity and security validations\\n\\t\\trequire(signer == _owner, \\\"invalid signature\\\");\\n\\t\\trequire(block.timestamp < _exp, \\\"signature expired\\\");\\n\\n\\t\\t// delegate call to `__approve` - execute the logic required\\n\\t\\t__approve(_owner, _spender, _value);\\n\\t}\\n\\n\\t// ===== End: EIP-2612 functions =====\\n\\n\\t// ===== Start: EIP-3009 functions =====\\n\\n\\t/**\\n\\t * @inheritdoc EIP3009\\n\\t *\\n\\t * @notice Checks if specified nonce was already used\\n\\t *\\n\\t * @dev Nonces are expected to be client-side randomly generated 32-byte values\\n\\t *      unique to the authorizer's address\\n\\t *\\n\\t * @dev Alias for usedNonces(authorizer, nonce)\\n\\t *\\n\\t * @param _authorizer an address to check nonce for\\n\\t * @param _nonce a nonce to check\\n\\t * @return true if the nonce was used, false otherwise\\n\\t */\\n\\tfunction authorizationState(address _authorizer, bytes32 _nonce) public override view returns (bool) {\\n\\t\\t// simply return the value from the mapping\\n\\t\\treturn usedNonces[_authorizer][_nonce];\\n\\t}\\n\\n\\t/**\\n\\t * @inheritdoc EIP3009\\n\\t *\\n\\t * @notice Execute a transfer with a signed authorization\\n\\t *\\n\\t * @param _from token sender and transaction authorizer\\n\\t * @param _to token receiver\\n\\t * @param _value amount to be transferred\\n\\t * @param _validAfter signature valid after time (unix timestamp)\\n\\t * @param _validBefore signature valid before time (unix timestamp)\\n\\t * @param _nonce unique random nonce\\n\\t * @param v the recovery byte of the signature\\n\\t * @param r half of the ECDSA signature pair\\n\\t * @param s half of the ECDSA signature pair\\n\\t */\\n\\tfunction transferWithAuthorization(\\n\\t\\taddress _from,\\n\\t\\taddress _to,\\n\\t\\tuint256 _value,\\n\\t\\tuint256 _validAfter,\\n\\t\\tuint256 _validBefore,\\n\\t\\tbytes32 _nonce,\\n\\t\\tuint8 v,\\n\\t\\tbytes32 r,\\n\\t\\tbytes32 s\\n\\t) public override {\\n\\t\\t// ensure EIP-3009 transfers are enabled\\n\\t\\trequire(isFeatureEnabled(FEATURE_EIP3009_TRANSFERS), \\\"EIP3009 transfers are disabled\\\");\\n\\n\\t\\t// derive signer of the EIP712 TransferWithAuthorization message\\n\\t\\taddress signer = __deriveSigner(abi.encode(TRANSFER_WITH_AUTHORIZATION_TYPEHASH, _from, _to, _value, _validAfter, _validBefore, _nonce), v, r, s);\\n\\n\\t\\t// perform message integrity and security validations\\n\\t\\trequire(signer == _from, \\\"invalid signature\\\");\\n\\t\\trequire(block.timestamp > _validAfter, \\\"signature not yet valid\\\");\\n\\t\\trequire(block.timestamp < _validBefore, \\\"signature expired\\\");\\n\\n\\t\\t// use the nonce supplied (verify, mark as used, emit event)\\n\\t\\t__useNonce(_from, _nonce, false);\\n\\n\\t\\t// delegate call to `__transferFrom` - execute the logic required\\n\\t\\t__transferFrom(signer, _from, _to, _value);\\n\\t}\\n\\n\\t/**\\n\\t * @inheritdoc EIP3009\\n\\t *\\n\\t * @notice Receive a transfer with a signed authorization from the payer\\n\\t *\\n\\t * @dev This has an additional check to ensure that the payee's address\\n\\t *      matches the caller of this function to prevent front-running attacks.\\n\\t *\\n\\t * @param _from token sender and transaction authorizer\\n\\t * @param _to token receiver\\n\\t * @param _value amount to be transferred\\n\\t * @param _validAfter signature valid after time (unix timestamp)\\n\\t * @param _validBefore signature valid before time (unix timestamp)\\n\\t * @param _nonce unique random nonce\\n\\t * @param v the recovery byte of the signature\\n\\t * @param r half of the ECDSA signature pair\\n\\t * @param s half of the ECDSA signature pair\\n\\t */\\n\\tfunction receiveWithAuthorization(\\n\\t\\taddress _from,\\n\\t\\taddress _to,\\n\\t\\tuint256 _value,\\n\\t\\tuint256 _validAfter,\\n\\t\\tuint256 _validBefore,\\n\\t\\tbytes32 _nonce,\\n\\t\\tuint8 v,\\n\\t\\tbytes32 r,\\n\\t\\tbytes32 s\\n\\t) public override {\\n\\t\\t// verify EIP3009 receptions are enabled\\n\\t\\trequire(isFeatureEnabled(FEATURE_EIP3009_RECEPTIONS), \\\"EIP3009 receptions are disabled\\\");\\n\\n\\t\\t// derive signer of the EIP712 ReceiveWithAuthorization message\\n\\t\\taddress signer = __deriveSigner(abi.encode(RECEIVE_WITH_AUTHORIZATION_TYPEHASH, _from, _to, _value, _validAfter, _validBefore, _nonce), v, r, s);\\n\\n\\t\\t// perform message integrity and security validations\\n\\t\\trequire(signer == _from, \\\"invalid signature\\\");\\n\\t\\trequire(block.timestamp > _validAfter, \\\"signature not yet valid\\\");\\n\\t\\trequire(block.timestamp < _validBefore, \\\"signature expired\\\");\\n\\t\\trequire(_to == msg.sender, \\\"access denied\\\");\\n\\n\\t\\t// use the nonce supplied (verify, mark as used, emit event)\\n\\t\\t__useNonce(_from, _nonce, false);\\n\\n\\t\\t// delegate call to `__transferFrom` - execute the logic required\\n\\t\\t__transferFrom(signer, _from, _to, _value);\\n\\t}\\n\\n\\t/**\\n\\t * @inheritdoc EIP3009\\n\\t *\\n\\t * @notice Attempt to cancel an authorization\\n\\t *\\n\\t * @param _authorizer transaction authorizer\\n\\t * @param _nonce unique random nonce to cancel (mark as used)\\n\\t * @param v the recovery byte of the signature\\n\\t * @param r half of the ECDSA signature pair\\n\\t * @param s half of the ECDSA signature pair\\n\\t */\\n\\tfunction cancelAuthorization(\\n\\t\\taddress _authorizer,\\n\\t\\tbytes32 _nonce,\\n\\t\\tuint8 v,\\n\\t\\tbytes32 r,\\n\\t\\tbytes32 s\\n\\t) public override {\\n\\t\\t// derive signer of the EIP712 ReceiveWithAuthorization message\\n\\t\\taddress signer = __deriveSigner(abi.encode(CANCEL_AUTHORIZATION_TYPEHASH, _authorizer, _nonce), v, r, s);\\n\\n\\t\\t// perform message integrity and security validations\\n\\t\\trequire(signer == _authorizer, \\\"invalid signature\\\");\\n\\n\\t\\t// cancel the nonce supplied (verify, mark as used, emit event)\\n\\t\\t__useNonce(_authorizer, _nonce, true);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Auxiliary function to verify structured EIP712 message signature and derive its signer\\n\\t *\\n\\t * @param abiEncodedTypehash abi.encode of the message typehash together with all its parameters\\n\\t * @param v the recovery byte of the signature\\n\\t * @param r half of the ECDSA signature pair\\n\\t * @param s half of the ECDSA signature pair\\n\\t */\\n\\tfunction __deriveSigner(bytes memory abiEncodedTypehash, uint8 v, bytes32 r, bytes32 s) private view returns(address) {\\n\\t\\t// build the EIP-712 hashStruct of the message\\n\\t\\tbytes32 hashStruct = keccak256(abiEncodedTypehash);\\n\\n\\t\\t// calculate the EIP-712 digest \\\"\\\\x19\\\\x01\\\" \\u2016 domainSeparator \\u2016 hashStruct(message)\\n\\t\\tbytes32 digest = keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", DOMAIN_SEPARATOR, hashStruct));\\n\\n\\t\\t// recover the address which signed the message with v, r, s\\n\\t\\taddress signer = ECDSA.recover(digest, v, r, s);\\n\\n\\t\\t// return the signer address derived from the signature\\n\\t\\treturn signer;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Auxiliary function to use/cancel the nonce supplied for a given authorizer:\\n\\t *      1. Verifies the nonce was not used before\\n\\t *      2. Marks the nonce as used\\n\\t *      3. Emits an event that the nonce was used/cancelled\\n\\t *\\n\\t * @dev Set `_cancellation` to false (default) to use nonce,\\n\\t *      set `_cancellation` to true to cancel nonce\\n\\t *\\n\\t * @dev It is expected that the nonce supplied is a randomly\\n\\t *      generated uint256 generated by the client\\n\\t *\\n\\t * @param _authorizer an address to use/cancel nonce for\\n\\t * @param _nonce random nonce to use\\n\\t * @param _cancellation true to emit `AuthorizationCancelled`, false to emit `AuthorizationUsed` event\\n\\t */\\n\\tfunction __useNonce(address _authorizer, bytes32 _nonce, bool _cancellation) private {\\n\\t\\t// verify nonce was not used before\\n\\t\\trequire(!usedNonces[_authorizer][_nonce], \\\"invalid nonce\\\");\\n\\n\\t\\t// update the nonce state to \\\"used\\\" for that particular signer to avoid replay attack\\n\\t\\tusedNonces[_authorizer][_nonce] = true;\\n\\n\\t\\t// depending on the usage type (use/cancel)\\n\\t\\tif(_cancellation) {\\n\\t\\t\\t// emit an event regarding the nonce cancelled\\n\\t\\t\\temit AuthorizationCanceled(_authorizer, _nonce);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\t// emit an event regarding the nonce used\\n\\t\\t\\temit AuthorizationUsed(_authorizer, _nonce);\\n\\t\\t}\\n\\t}\\n\\n\\t// ===== End: EIP-3009 functions =====\\n\\n\\t// ===== Start: DAO Support (Compound-like voting delegation) =====\\n\\n\\t/**\\n\\t * @notice Gets current voting power of the account `_of`\\n\\t *\\n\\t * @param _of the address of account to get voting power of\\n\\t * @return current cumulative voting power of the account,\\n\\t *      sum of token balances of all its voting delegators\\n\\t */\\n\\tfunction votingPowerOf(address _of) public view returns (uint256) {\\n\\t\\t// get a link to an array of voting power history records for an address specified\\n\\t\\tKV[] storage history = votingPowerHistory[_of];\\n\\n\\t\\t// lookup the history and return latest element\\n\\t\\treturn history.length == 0? 0: history[history.length - 1].v;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Gets past voting power of the account `_of` at some block `_blockNum`\\n\\t *\\n\\t * @dev Throws if `_blockNum` is not in the past (not the finalized block)\\n\\t *\\n\\t * @param _of the address of account to get voting power of\\n\\t * @param _blockNum block number to get the voting power at\\n\\t * @return past cumulative voting power of the account,\\n\\t *      sum of token balances of all its voting delegators at block number `_blockNum`\\n\\t */\\n\\tfunction votingPowerAt(address _of, uint256 _blockNum) public view returns (uint256) {\\n\\t\\t// make sure block number is not in the past (not the finalized block)\\n\\t\\trequire(_blockNum < block.number, \\\"block not yet mined\\\"); // Compound msg not yet determined\\n\\n\\t\\t// `votingPowerHistory[_of]` is an array ordered by `blockNumber`, ascending;\\n\\t\\t// apply binary search on `votingPowerHistory[_of]` to find such an entry number `i`, that\\n\\t\\t// `votingPowerHistory[_of][i].k <= _blockNum`, but in the same time\\n\\t\\t// `votingPowerHistory[_of][i + 1].k > _blockNum`\\n\\t\\t// return the result - voting power found at index `i`\\n\\t\\treturn __binaryLookup(votingPowerHistory[_of], _blockNum);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Reads an entire voting power history array for the delegate specified\\n\\t *\\n\\t * @param _of delegate to query voting power history for\\n\\t * @return voting power history array for the delegate of interest\\n\\t */\\n\\tfunction votingPowerHistoryOf(address _of) public view returns(KV[] memory) {\\n\\t\\t// return an entire array as memory\\n\\t\\treturn votingPowerHistory[_of];\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns length of the voting power history array for the delegate specified;\\n\\t *      useful since reading an entire array just to get its length is expensive (gas cost)\\n\\t *\\n\\t * @param _of delegate to query voting power history length for\\n\\t * @return voting power history array length for the delegate of interest\\n\\t */\\n\\tfunction votingPowerHistoryLength(address _of) public view returns(uint256) {\\n\\t\\t// read array length and return\\n\\t\\treturn votingPowerHistory[_of].length;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Gets past total token supply value at some block `_blockNum`\\n\\t *\\n\\t * @dev Throws if `_blockNum` is not in the past (not the finalized block)\\n\\t *\\n\\t * @param _blockNum block number to get the total token supply at\\n\\t * @return past total token supply at block number `_blockNum`\\n\\t */\\n\\tfunction totalSupplyAt(uint256 _blockNum) public view returns(uint256) {\\n\\t\\t// make sure block number is not in the past (not the finalized block)\\n\\t\\trequire(_blockNum < block.number, \\\"block not yet mined\\\");\\n\\n\\t\\t// `totalSupplyHistory` is an array ordered by `k`, ascending;\\n\\t\\t// apply binary search on `totalSupplyHistory` to find such an entry number `i`, that\\n\\t\\t// `totalSupplyHistory[i].k <= _blockNum`, but in the same time\\n\\t\\t// `totalSupplyHistory[i + 1].k > _blockNum`\\n\\t\\t// return the result - value `totalSupplyHistory[i].v` found at index `i`\\n\\t\\treturn __binaryLookup(totalSupplyHistory, _blockNum);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Reads an entire total token supply history array\\n\\t *\\n\\t * @return total token supply history array, a key-value pair array,\\n\\t *      where key is a block number and value is total token supply at that block\\n\\t */\\n\\tfunction entireSupplyHistory() public view returns(KV[] memory) {\\n\\t\\t// return an entire array as memory\\n\\t\\treturn totalSupplyHistory;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns length of the total token supply history array;\\n\\t *      useful since reading an entire array just to get its length is expensive (gas cost)\\n\\t *\\n\\t * @return total token supply history array\\n\\t */\\n\\tfunction totalSupplyHistoryLength() public view returns(uint256) {\\n\\t\\t// read array length and return\\n\\t\\treturn totalSupplyHistory.length;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Delegates voting power of the delegator `msg.sender` to the delegate `_to`\\n\\t *\\n\\t * @dev Accepts zero value address to delegate voting power to, effectively\\n\\t *      removing the delegate in that case\\n\\t *\\n\\t * @param _to address to delegate voting power to\\n\\t */\\n\\tfunction delegate(address _to) public {\\n\\t\\t// verify delegations are enabled\\n\\t\\trequire(isFeatureEnabled(FEATURE_DELEGATIONS), \\\"delegations are disabled\\\");\\n\\t\\t// delegate call to `__delegate`\\n\\t\\t__delegate(msg.sender, _to);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Powers the meta transaction for `delegate` - `delegateWithAuthorization`\\n\\t *\\n\\t * @dev Auxiliary function to delegate delegator's `_from` voting power to the delegate `_to`\\n\\t * @dev Writes to `votingDelegates` and `votingPowerHistory` mappings\\n\\t *\\n\\t * @param _from delegator who delegates his voting power\\n\\t * @param _to delegate who receives the voting power\\n\\t */\\n\\tfunction __delegate(address _from, address _to) private {\\n\\t\\t// read current delegate to be replaced by a new one\\n\\t\\taddress _fromDelegate = votingDelegates[_from];\\n\\n\\t\\t// read current voting power (it is equal to token balance)\\n\\t\\tuint256 _value = tokenBalances[_from];\\n\\n\\t\\t// reassign voting delegate to `_to`\\n\\t\\tvotingDelegates[_from] = _to;\\n\\n\\t\\t// update voting power for `_fromDelegate` and `_to`\\n\\t\\t__moveVotingPower(_from, _fromDelegate, _to, _value);\\n\\n\\t\\t// emit an event\\n\\t\\temit DelegateChanged(_from, _fromDelegate, _to);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Delegates voting power of the delegator (represented by its signature) to the delegate `_to`\\n\\t *\\n\\t * @dev Accepts zero value address to delegate voting power to, effectively\\n\\t *      removing the delegate in that case\\n\\t *\\n\\t * @dev Compliant with EIP-712: Ethereum typed structured data hashing and signing,\\n\\t *      see https://eips.ethereum.org/EIPS/eip-712\\n\\t *\\n\\t * @param _to address to delegate voting power to\\n\\t * @param _nonce nonce used to construct the signature, and used to validate it;\\n\\t *      nonce is increased by one after successful signature validation and vote delegation\\n\\t * @param _exp signature expiration time\\n\\t * @param v the recovery byte of the signature\\n\\t * @param r half of the ECDSA signature pair\\n\\t * @param s half of the ECDSA signature pair\\n\\t */\\n\\tfunction delegateWithAuthorization(address _to, bytes32 _nonce, uint256 _exp, uint8 v, bytes32 r, bytes32 s) public {\\n\\t\\t// verify delegations on behalf are enabled\\n\\t\\trequire(isFeatureEnabled(FEATURE_DELEGATIONS_ON_BEHALF), \\\"delegations on behalf are disabled\\\");\\n\\n\\t\\t// derive signer of the EIP712 Delegation message\\n\\t\\taddress signer = __deriveSigner(abi.encode(DELEGATION_TYPEHASH, _to, _nonce, _exp), v, r, s);\\n\\n\\t\\t// perform message integrity and security validations\\n\\t\\trequire(block.timestamp < _exp, \\\"signature expired\\\"); // Compound msg\\n\\n\\t\\t// use the nonce supplied (verify, mark as used, emit event)\\n\\t\\t__useNonce(signer, _nonce, false);\\n\\n\\t\\t// delegate call to `__delegate` - execute the logic required\\n\\t\\t__delegate(signer, _to);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Auxiliary function to move voting power `_value`\\n\\t *      from delegate `_from` to the delegate `_to`\\n\\t *\\n\\t * @dev Doesn't have any effect if `_from == _to`, or if `_value == 0`\\n\\t *\\n\\t * @param _by an address which executed delegate, mint, burn, or transfer operation\\n\\t *      which had led to delegate voting power change\\n\\t * @param _from delegate to move voting power from\\n\\t * @param _to delegate to move voting power to\\n\\t * @param _value voting power to move from `_from` to `_to`\\n\\t */\\n\\tfunction __moveVotingPower(address _by, address _from, address _to, uint256 _value) private {\\n\\t\\t// if there is no move (`_from == _to`) or there is nothing to move (`_value == 0`)\\n\\t\\tif(_from == _to || _value == 0) {\\n\\t\\t\\t// return silently with no action\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// if source address is not zero - decrease its voting power\\n\\t\\tif(_from != address(0)) {\\n\\t\\t\\t// get a link to an array of voting power history records for an address specified\\n\\t\\t\\tKV[] storage _h = votingPowerHistory[_from];\\n\\n\\t\\t\\t// update source voting power: decrease by `_value`\\n\\t\\t\\t(uint256 _fromVal, uint256 _toVal) = __updateHistory(_h, sub, _value);\\n\\n\\t\\t\\t// emit an event\\n\\t\\t\\temit VotingPowerChanged(_by, _from, _fromVal, _toVal);\\n\\t\\t}\\n\\n\\t\\t// if destination address is not zero - increase its voting power\\n\\t\\tif(_to != address(0)) {\\n\\t\\t\\t// get a link to an array of voting power history records for an address specified\\n\\t\\t\\tKV[] storage _h = votingPowerHistory[_to];\\n\\n\\t\\t\\t// update destination voting power: increase by `_value`\\n\\t\\t\\t(uint256 _fromVal, uint256 _toVal) = __updateHistory(_h, add, _value);\\n\\n\\t\\t\\t// emit an event\\n\\t\\t\\temit VotingPowerChanged(_by, _to, _fromVal, _toVal);\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * @dev Auxiliary function to append key-value pair to an array,\\n\\t *      sets the key to the current block number and\\n\\t *      value as derived\\n\\t *\\n\\t * @param _h array of key-value pairs to append to\\n\\t * @param op a function (add/subtract) to apply\\n\\t * @param _delta the value for a key-value pair to add/subtract\\n\\t */\\n\\tfunction __updateHistory(\\n\\t\\tKV[] storage _h,\\n\\t\\tfunction(uint256,uint256) pure returns(uint256) op,\\n\\t\\tuint256 _delta\\n\\t) private returns(uint256 _fromVal, uint256 _toVal) {\\n\\t\\t// init the old value - value of the last pair of the array\\n\\t\\t_fromVal = _h.length == 0? 0: _h[_h.length - 1].v;\\n\\t\\t// init the new value - result of the operation on the old value\\n\\t\\t_toVal = op(_fromVal, _delta);\\n\\n\\t\\t// if there is an existing voting power value stored for current block\\n\\t\\tif(_h.length != 0 && _h[_h.length - 1].k == block.number) {\\n\\t\\t\\t// update voting power which is already stored in the current block\\n\\t\\t\\t_h[_h.length - 1].v = uint192(_toVal);\\n\\t\\t}\\n\\t\\t// otherwise - if there is no value stored for current block\\n\\t\\telse {\\n\\t\\t\\t// add new element into array representing the value for current block\\n\\t\\t\\t_h.push(KV(uint64(block.number), uint192(_toVal)));\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * @dev Auxiliary function to lookup for a value in a sorted by key (ascending)\\n\\t *      array of key-value pairs\\n\\t *\\n\\t * @dev This function finds a key-value pair element in an array with the closest key\\n\\t *      to the key of interest (not exceeding that key) and returns the value\\n\\t *      of the key-value pair element found\\n\\t *\\n\\t * @dev An array to search in is a KV[] key-value pair array ordered by key `k`,\\n\\t *      it is sorted in ascending order (`k` increases as array index increases)\\n\\t *\\n\\t * @dev Returns zero for an empty array input regardless of the key input\\n\\t *\\n\\t * @param _h an array of key-value pair elements to search in\\n\\t * @param _k key of interest to look the value for\\n\\t * @return the value of the key-value pair of the key-value pair element with the closest\\n\\t *      key to the key of interest (not exceeding that key)\\n\\t */\\n\\tfunction __binaryLookup(KV[] storage _h, uint256 _k) private view returns(uint256) {\\n\\t\\t// if an array is empty, there is nothing to lookup in\\n\\t\\tif(_h.length == 0) {\\n\\t\\t\\t// by documented agreement, fall back to a zero result\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\t// check last key-value pair key:\\n\\t\\t// if the key is smaller than the key of interest\\n\\t\\tif(_h[_h.length - 1].k <= _k) {\\n\\t\\t\\t// we're done - return the value from the last element\\n\\t\\t\\treturn _h[_h.length - 1].v;\\n\\t\\t}\\n\\n\\t\\t// check first voting power history record block number:\\n\\t\\t// if history was never updated before the block of interest\\n\\t\\tif(_h[0].k > _k) {\\n\\t\\t\\t// we're done - voting power at the block num of interest was zero\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\t// left bound of the search interval, originally start of the array\\n\\t\\tuint256 i = 0;\\n\\n\\t\\t// right bound of the search interval, originally end of the array\\n\\t\\tuint256 j = _h.length - 1;\\n\\n\\t\\t// the iteration process narrows down the bounds by\\n\\t\\t// splitting the interval in a half oce per each iteration\\n\\t\\twhile(j > i) {\\n\\t\\t\\t// get an index in the middle of the interval [i, j]\\n\\t\\t\\tuint256 k = j - (j - i) / 2;\\n\\n\\t\\t\\t// read an element to compare it with the value of interest\\n\\t\\t\\tKV memory kv = _h[k];\\n\\n\\t\\t\\t// if we've got a strict equal - we're lucky and done\\n\\t\\t\\tif(kv.k == _k) {\\n\\t\\t\\t\\t// just return the result - pair value at index `k`\\n\\t\\t\\t\\treturn kv.v;\\n\\t\\t\\t}\\n\\t\\t\\t// if the value of interest is larger - move left bound to the middle\\n\\t\\t\\telse if (kv.k < _k) {\\n\\t\\t\\t\\t// move left bound `i` to the middle position `k`\\n\\t\\t\\t\\ti = k;\\n\\t\\t\\t}\\n\\t\\t\\t// otherwise, when the value of interest is smaller - move right bound to the middle\\n\\t\\t\\telse {\\n\\t\\t\\t\\t// move right bound `j` to the middle position `k - 1`:\\n\\t\\t\\t\\t// element at position `k` is greater and cannot be the result\\n\\t\\t\\t\\tj = k - 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// reaching that point means no exact match found\\n\\t\\t// since we're interested in the element which is not larger than the\\n\\t\\t// element of interest, we return the lower bound `i`\\n\\t\\treturn _h[i].v;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Adds a + b\\n\\t *      Function is used as a parameter for other functions\\n\\t *\\n\\t * @param a addition term 1\\n\\t * @param b addition term 2\\n\\t * @return a + b\\n\\t */\\n\\tfunction add(uint256 a, uint256 b) private pure returns(uint256) {\\n\\t\\t// add `a` to `b` and return\\n\\t\\treturn a + b;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Subtracts a - b\\n\\t *      Function is used as a parameter for other functions\\n\\t *\\n\\t * @dev Requires a \\u2265 b\\n\\t *\\n\\t * @param a subtraction term 1\\n\\t * @param b subtraction term 2, b \\u2264 a\\n\\t * @return a - b\\n\\t */\\n\\tfunction sub(uint256 a, uint256 b) private pure returns(uint256) {\\n\\t\\t// subtract `b` from `a` and return\\n\\t\\treturn a - b;\\n\\t}\\n\\n\\t// ===== End: DAO Support (Compound-like voting delegation) =====\\n\\n}\\n\\nimport \\\"@openzeppelin/contracts/proxy/Clones.sol\\\";\\n\\n/**\\n * @title Character ERC20 Token Deployer\\n *\\n * @notice A helper stand-alone contract allowing to \\\"clone\\\" Character ERC20 Token\\n *\\n * @dev The deployment is done via EIP-1167 Minimal Proxy Contract\\n *      See https://eips.ethereum.org/EIPS/eip-1167\\n *\\n * @author Basil Gorin\\n */\\ncontract CharacterERC20Deployer {\\n\\t/**\\n\\t * @notice An address of already deployed CharacterERC20 token used as an implementation\\n\\t *\\n\\t * @dev The deployed minimalistic proxy always points to this implementation\\n\\t */\\n\\taddress public immutable characterErc20ImplAddress;\\n\\n\\t/**\\n\\t * @dev Fired only once on deployment\\n\\t *\\n\\t * @param initialized if CharacterERC20 impl was successfully initialized\\n\\t * @param whyNot empty, or if CharacterERC20 impl was not initialized \\u2013 the reason\\n\\t */\\n\\tevent CharacterERC20ImplInitialized(bool indexed initialized, string whyNot);\\n\\n\\t/**\\n\\t * @dev Fired in deployCharacterERC20\\n\\t *\\n\\t * @param characterErc20ProxyAddress deployed EIP-1167 clone (proxy) address\\n\\t * @param characterErc20ImplAddress CharacterERC20 impl address, always the same\\n\\t * @param _initialHolder owner of the initial token supply\\n\\t * @param _initialSupply initial token supply\\n\\t * @param _name token name to set\\n\\t * @param _symbol token symbol to set\\n\\t */\\n\\tevent ProxyDeployed(\\n\\t\\taddress indexed characterErc20ProxyAddress,\\n\\t\\taddress characterErc20ImplAddress,\\n\\t\\taddress _initialHolder,\\n\\t\\tuint256 _initialSupply,\\n\\t\\tstring _name,\\n\\t\\tstring indexed _symbol\\n\\t);\\n\\n\\t/**\\n\\t * @dev Deploys a CharacterERC20Deployer instance bound to an already deployed\\n\\t *      CharacterERC20 token instance implementation to be used to create EIP-1167 \\\"clones\\\"\\n\\t */\\n\\tconstructor(address _characterErc20ImplAddress) {\\n\\t\\t// verify the address is set\\n\\t\\trequire(_characterErc20ImplAddress != address(0), \\\"zero address\\\");\\n\\n\\t\\t// set the address\\n\\t\\tcharacterErc20ImplAddress = _characterErc20ImplAddress;\\n\\n\\t\\t// try to initialize the impl with some dummy values\\n\\t\\t// this is an extra safety measure: it is not recommended to leave \\\"initializable\\\" contracts uninitialized\\n\\t\\ttry CharacterERC20(_characterErc20ImplAddress).postConstruct(\\n\\t\\t\\t_characterErc20ImplAddress,\\n\\t\\t\\t1,\\n\\t\\t\\t\\\"Character Economies Token\\\",\\n\\t\\t\\t\\\"CET\\\"\\n\\t\\t) {\\n\\t\\t\\t// emit successful event\\n\\t\\t\\temit CharacterERC20ImplInitialized(false, \\\"\\\");\\n\\t\\t}\\n\\t\\t// if contract is already initialized it throws and we basically want to ignore that\\n\\t\\tcatch Error (string memory reason) {\\n\\t\\t\\t// emit a failure event and failure reason\\n\\t\\t\\temit CharacterERC20ImplInitialized(true, reason);\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * @notice \\\"Deploys\\\" CharacterERC20 token with the specified name, symbol, initial total supply\\n\\t *\\n\\t * @dev Technically this deploys a tiny proxy pointing to the token impl address `characterErc20ImplAddress`\\n\\t *      and initialized it immediately, making the deployment safe and ready for use\\n\\t *\\n\\t * @param _initialHolder owner of the initial token supply\\n\\t * @param _initialSupply initial token supply\\n\\t * @param _name token name to set\\n\\t * @param _symbol token symbol to set\\n\\t */\\n\\tfunction deployCharacterERC20(\\n\\t\\taddress _initialHolder,\\n\\t\\tuint256 _initialSupply,\\n\\t\\tstring memory _name,\\n\\t\\tstring memory _symbol\\n\\t) public {\\n\\t\\t// \\\"clone\\\" the impl (deploy a proxy)\\n\\t\\taddress characterErc20ProxyAddress = Clones.clone(characterErc20ImplAddress);\\n\\n\\t\\t// initialize a proxy by invoking the postConstruct\\n\\t\\t// this also sets all the permissions to a CharacterERC20Deployer\\n\\t\\tCharacterERC20(characterErc20ProxyAddress).postConstruct(_initialHolder, _initialSupply, _name, _symbol);\\n\\n\\t\\t// move all the permission to the executor:\\n\\t\\t// 1) set the msg.sender's permissions to full\\n\\t\\tAccessControl(characterErc20ProxyAddress).updateRole(msg.sender, type(uint256).max);\\n\\t\\t// 2) revoke own permissions\\n\\t\\tAccessControl(characterErc20ProxyAddress).updateRole(address(this), 0);\\n\\n\\t\\t// emit an event\\n\\t\\temit ProxyDeployed(\\n\\t\\t\\tcharacterErc20ProxyAddress,\\n\\t\\t\\tcharacterErc20ImplAddress,\\n\\t\\t\\t_initialHolder,\\n\\t\\t\\t_initialSupply,\\n\\t\\t\\t_name,\\n\\t\\t\\t_symbol\\n\\t\\t);\\n\\t}\\n}\\n\",\"keccak256\":\"0x502377196e791693970fcebd8d8e369182559f4621c8427da6422219cc7d6e02\",\"license\":\"MIT\"},\"contracts/utils/AccessControl.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/**\\n * @title Access Control List\\n *\\n * @notice Access control smart contract provides an API to check\\n *      if specific operation is permitted globally and/or\\n *      if particular user has a permission to execute it.\\n *\\n * @notice It deals with two main entities: features and roles.\\n *\\n * @notice Features are designed to be used to enable/disable specific\\n *      functions (public functions) of the smart contract for everyone.\\n * @notice User roles are designed to restrict access to specific\\n *      functions (restricted functions) of the smart contract to some users.\\n *\\n * @notice Terms \\\"role\\\", \\\"permissions\\\" and \\\"set of permissions\\\" have equal meaning\\n *      in the documentation text and may be used interchangeably.\\n * @notice Terms \\\"permission\\\", \\\"single permission\\\" implies only one permission bit set.\\n *\\n * @notice Access manager is a special role which allows to grant/revoke other roles.\\n *      Access managers can only grant/revoke permissions which they have themselves.\\n *      As an example, access manager with no other roles set can only grant/revoke its own\\n *      access manager permission and nothing else.\\n *\\n * @notice Access manager permission should be treated carefully, as a super admin permission:\\n *      Access manager with even no other permission can interfere with another account by\\n *      granting own access manager permission to it and effectively creating more powerful\\n *      permission set than its own.\\n *\\n * @dev Both current and OpenZeppelin AccessControl implementations feature a similar API\\n *      to check/know \\\"who is allowed to do this thing\\\".\\n * @dev Zeppelin implementation is more flexible:\\n *      - it allows setting unlimited number of roles, while current is limited to 256 different roles\\n *      - it allows setting an admin for each role, while current allows having only one global admin\\n * @dev Current implementation is more lightweight:\\n *      - it uses only 1 bit per role, while Zeppelin uses 256 bits\\n *      - it allows setting up to 256 roles at once, in a single transaction, while Zeppelin allows\\n *        setting only one role in a single transaction\\n *\\n * @dev This smart contract is designed to be inherited by other\\n *      smart contracts which require access control management capabilities.\\n *\\n * @dev Access manager permission has a bit 255 set.\\n *      This bit must not be used by inheriting contracts for any other permissions/features.\\n *\\n * @author Basil Gorin\\n */\\ncontract AccessControl {\\n\\t/**\\n\\t * @notice Access manager is responsible for assigning the roles to users,\\n\\t *      enabling/disabling global features of the smart contract\\n\\t * @notice Access manager can add, remove and update user roles,\\n\\t *      remove and update global features\\n\\t *\\n\\t * @dev Role ROLE_ACCESS_MANAGER allows modifying user roles and global features\\n\\t * @dev Role ROLE_ACCESS_MANAGER has single bit at position 255 enabled\\n\\t */\\n\\tuint256 public constant ROLE_ACCESS_MANAGER = 0x8000000000000000000000000000000000000000000000000000000000000000;\\n\\n\\t/**\\n\\t * @dev Bitmask representing all the possible permissions (super admin role)\\n\\t * @dev Has all the bits are enabled (2^256 - 1 value)\\n\\t */\\n\\tuint256 private constant FULL_PRIVILEGES_MASK = type(uint256).max; // before 0.8.0: uint256(-1) overflows to 0xFFFF...\\n\\n\\t/**\\n\\t * @notice Privileged addresses with defined roles/permissions\\n\\t * @notice In the context of ERC20/ERC721 tokens these can be permissions to\\n\\t *      allow minting or burning tokens, transferring on behalf and so on\\n\\t *\\n\\t * @dev Maps user address to the permissions bitmask (role), where each bit\\n\\t *      represents a permission\\n\\t * @dev Bitmask 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\\n\\t *      represents all possible permissions\\n\\t * @dev 'This' address mapping represents global features of the smart contract\\n\\t */\\n\\tmapping(address => uint256) public userRoles;\\n\\n\\t/**\\n\\t * @dev Fired in updateRole() and updateFeatures()\\n\\t *\\n\\t * @param _by operator which called the function\\n\\t * @param _to address which was granted/revoked permissions\\n\\t * @param _requested permissions requested\\n\\t * @param _actual permissions effectively set\\n\\t */\\n\\tevent RoleUpdated(address indexed _by, address indexed _to, uint256 _requested, uint256 _actual);\\n\\n\\t/**\\n\\t * @notice Creates an access control instance,\\n\\t *      setting contract creator to have full privileges\\n\\t */\\n\\tconstructor() {\\n\\t\\t// contract creator has full privileges\\n\\t\\tuserRoles[msg.sender] = FULL_PRIVILEGES_MASK;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Retrieves globally set of features enabled\\n\\t *\\n\\t * @dev Effectively reads userRoles role for the contract itself\\n\\t *\\n\\t * @return 256-bit bitmask of the features enabled\\n\\t */\\n\\tfunction features() public view returns(uint256) {\\n\\t\\t// features are stored in 'this' address  mapping of `userRoles` structure\\n\\t\\treturn userRoles[address(this)];\\n\\t}\\n\\n\\t/**\\n\\t * @notice Updates set of the globally enabled features (`features`),\\n\\t *      taking into account sender's permissions\\n\\t *\\n\\t * @dev Requires transaction sender to have `ROLE_ACCESS_MANAGER` permission\\n\\t * @dev Function is left for backward compatibility with older versions\\n\\t *\\n\\t * @param _mask bitmask representing a set of features to enable/disable\\n\\t */\\n\\tfunction updateFeatures(uint256 _mask) public {\\n\\t\\t// delegate call to `updateRole`\\n\\t\\tupdateRole(address(this), _mask);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Updates set of permissions (role) for a given user,\\n\\t *      taking into account sender's permissions.\\n\\t *\\n\\t * @dev Setting role to zero is equivalent to removing an all permissions\\n\\t * @dev Setting role to `FULL_PRIVILEGES_MASK` is equivalent to\\n\\t *      copying senders' permissions (role) to the user\\n\\t * @dev Requires transaction sender to have `ROLE_ACCESS_MANAGER` permission\\n\\t *\\n\\t * @param operator address of a user to alter permissions for or zero\\n\\t *      to alter global features of the smart contract\\n\\t * @param role bitmask representing a set of permissions to\\n\\t *      enable/disable for a user specified\\n\\t */\\n\\tfunction updateRole(address operator, uint256 role) public {\\n\\t\\t// caller must have a permission to update user roles\\n\\t\\trequire(isSenderInRole(ROLE_ACCESS_MANAGER), \\\"access denied\\\");\\n\\n\\t\\t// evaluate the role and reassign it\\n\\t\\tuserRoles[operator] = evaluateBy(msg.sender, userRoles[operator], role);\\n\\n\\t\\t// fire an event\\n\\t\\temit RoleUpdated(msg.sender, operator, role, userRoles[operator]);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Determines the permission bitmask an operator can set on the\\n\\t *      target permission set\\n\\t * @notice Used to calculate the permission bitmask to be set when requested\\n\\t *     in `updateRole` and `updateFeatures` functions\\n\\t *\\n\\t * @dev Calculated based on:\\n\\t *      1) operator's own permission set read from userRoles[operator]\\n\\t *      2) target permission set - what is already set on the target\\n\\t *      3) desired permission set - what do we want set target to\\n\\t *\\n\\t * @dev Corner cases:\\n\\t *      1) Operator is super admin and its permission set is `FULL_PRIVILEGES_MASK`:\\n\\t *        `desired` bitset is returned regardless of the `target` permission set value\\n\\t *        (what operator sets is what they get)\\n\\t *      2) Operator with no permissions (zero bitset):\\n\\t *        `target` bitset is returned regardless of the `desired` value\\n\\t *        (operator has no authority and cannot modify anything)\\n\\t *\\n\\t * @dev Example:\\n\\t *      Consider an operator with the permissions bitmask     00001111\\n\\t *      is about to modify the target permission set          01010101\\n\\t *      Operator wants to set that permission set to          00110011\\n\\t *      Based on their role, an operator has the permissions\\n\\t *      to update only lowest 4 bits on the target, meaning that\\n\\t *      high 4 bits of the target set in this example is left\\n\\t *      unchanged and low 4 bits get changed as desired:      01010011\\n\\t *\\n\\t * @param operator address of the contract operator which is about to set the permissions\\n\\t * @param target input set of permissions to operator is going to modify\\n\\t * @param desired desired set of permissions operator would like to set\\n\\t * @return resulting set of permissions given operator will set\\n\\t */\\n\\tfunction evaluateBy(address operator, uint256 target, uint256 desired) public view returns(uint256) {\\n\\t\\t// read operator's permissions\\n\\t\\tuint256 p = userRoles[operator];\\n\\n\\t\\t// taking into account operator's permissions,\\n\\t\\t// 1) enable the permissions desired on the `target`\\n\\t\\ttarget |= p & desired;\\n\\t\\t// 2) disable the permissions desired on the `target`\\n\\t\\ttarget &= FULL_PRIVILEGES_MASK ^ (p & (FULL_PRIVILEGES_MASK ^ desired));\\n\\n\\t\\t// return calculated result\\n\\t\\treturn target;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Checks if requested set of features is enabled globally on the contract\\n\\t *\\n\\t * @param required set of features to check against\\n\\t * @return true if all the features requested are enabled, false otherwise\\n\\t */\\n\\tfunction isFeatureEnabled(uint256 required) public view returns(bool) {\\n\\t\\t// delegate call to `__hasRole`, passing `features` property\\n\\t\\treturn __hasRole(features(), required);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Checks if transaction sender `msg.sender` has all the permissions required\\n\\t *\\n\\t * @param required set of permissions (role) to check against\\n\\t * @return true if all the permissions requested are enabled, false otherwise\\n\\t */\\n\\tfunction isSenderInRole(uint256 required) public view returns(bool) {\\n\\t\\t// delegate call to `isOperatorInRole`, passing transaction sender\\n\\t\\treturn isOperatorInRole(msg.sender, required);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Checks if operator has all the permissions (role) required\\n\\t *\\n\\t * @param operator address of the user to check role for\\n\\t * @param required set of permissions (role) to check\\n\\t * @return true if all the permissions requested are enabled, false otherwise\\n\\t */\\n\\tfunction isOperatorInRole(address operator, uint256 required) public view returns(bool) {\\n\\t\\t// delegate call to `__hasRole`, passing operator's permissions (role)\\n\\t\\treturn __hasRole(userRoles[operator], required);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Checks if role `actual` contains all the permissions required `required`\\n\\t *\\n\\t * @param actual existent role\\n\\t * @param required required role\\n\\t * @return true if actual has required role (all permissions), false otherwise\\n\\t */\\n\\tfunction __hasRole(uint256 actual, uint256 required) internal pure returns(bool) {\\n\\t\\t// check the bitmask for the role required and return the result\\n\\t\\treturn actual & required == required;\\n\\t}\\n}\\n\",\"keccak256\":\"0x3b216515c25652b94bce7984346b8deee3ce00fd8c2b3b7b8d3015fa349908d3\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60a060405234801561001057600080fd5b506040516108d23803806108d283398101604081905261002f916101be565b6001600160a01b0381166100785760405162461bcd60e51b815260206004820152600c60248201526b7a65726f206164647265737360a01b604482015260640160405180910390fd5b6001600160a01b0381166080818152604051633782991960e11b815260048101839052600160248201526044810191909152601960848201527f4368617261637465722045636f6e6f6d69657320546f6b656e0000000000000060a482015260c06064820152600360c48201526210d15560ea1b60e4820152636f0532329061010401600060405180830381600087803b15801561011557600080fd5b505af1925050508015610126575060015b61018c576101326101ee565b806308c379a0036101805750610146610244565b806101515750610182565b600115156000805160206108b28339815191528260405161017291906102cd565b60405180910390a2506101b8565b505b3d6000803e3d6000fd5b6040805160208082526000908201819052916000805160206108b2833981519152910160405180910390a25b50610322565b6000602082840312156101d057600080fd5b81516001600160a01b03811681146101e757600080fd5b9392505050565b600060033d11156102075760046000803e5060005160e01c5b90565b601f8201601f191681016001600160401b038111828210171561023d57634e487b7160e01b600052604160045260246000fd5b6040525050565b600060443d10156102525790565b6040516003193d81016004833e81513d6001600160401b03808311602484018310171561028157505050505090565b82850191508151818111156102995750505050505090565b843d87010160208285010111156102b35750505050505090565b6102c26020828601018761020a565b509095945050505050565b600060208083528351808285015260005b818110156102fa578581018301518582016040015282016102de565b8181111561030c576000604083870101525b50601f01601f1916929092016040019392505050565b60805161056961034960003960008181604001528181609a015261022901526105696000f3fe608060405234801561001057600080fd5b50600436106100365760003560e01c806365cd5c841461003b5780639d1adb591461007e575b600080fd5b6100627f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b03909116815260200160405180910390f35b61009161008c3660046103ae565b610093565b005b60006100be7f000000000000000000000000000000000000000000000000000000000000000061026a565b604051633782991960e11b81529091506001600160a01b03821690636f053232906100f3908890889088908890600401610496565b600060405180830381600087803b15801561010d57600080fd5b505af1158015610121573d6000803e3d6000fd5b505060405163572d881760e11b815233600482015260001960248201526001600160a01b038416925063ae5b102e9150604401600060405180830381600087803b15801561016e57600080fd5b505af1158015610182573d6000803e3d6000fd5b505060405163572d881760e11b8152306004820152600060248201526001600160a01b038416925063ae5b102e9150604401600060405180830381600087803b1580156101ce57600080fd5b505af11580156101e2573d6000803e3d6000fd5b50505050816040516101f491906104da565b6040518091039020816001600160a01b03167f83c29fc733f6e4dbd392b5aabe4e0439f457b50747fb1581021b9ae19e98fcdd7f000000000000000000000000000000000000000000000000000000000000000088888860405161025b94939291906104f6565b60405180910390a35050505050565b6000604051733d602d80600a3d3981f3363d3d373d3d3d363d7360601b81528260601b60148201526e5af43d82803e903d91602b57fd5bf360881b60288201526037816000f09150506001600160a01b0381166103065760405162461bcd60e51b8152602060048201526016602482015275115490cc4c4d8dce8818dc99585d194819985a5b195960521b604482015260640160405180910390fd5b919050565b634e487b7160e01b600052604160045260246000fd5b600082601f83011261033257600080fd5b813567ffffffffffffffff8082111561034d5761034d61030b565b604051601f8301601f19908116603f011681019082821181831017156103755761037561030b565b8160405283815286602085880101111561038e57600080fd5b836020870160208301376000602085830101528094505050505092915050565b600080600080608085870312156103c457600080fd5b84356001600160a01b03811681146103db57600080fd5b935060208501359250604085013567ffffffffffffffff808211156103ff57600080fd5b61040b88838901610321565b9350606087013591508082111561042157600080fd5b5061042e87828801610321565b91505092959194509250565b60005b8381101561045557818101518382015260200161043d565b83811115610464576000848401525b50505050565b6000815180845261048281602086016020860161043a565b601f01601f19169290920160200192915050565b60018060a01b03851681528360208201526080604082015260006104bd608083018561046a565b82810360608401526104cf818561046a565b979650505050505050565b600082516104ec81846020870161043a565b9190910192915050565b6001600160a01b03858116825284166020820152604081018390526080606082018190526000906105299083018461046a565b969550505050505056fea264697066735822122018187abcd0f3b5fc9a1a6ebf276d3417038a1e4d9dda295257808027636d48f964736f6c634300080f0033c6c73eaf7ba8245f625f757feff8ae2bcd9bd3a4c6f3afddc5113b352cf724c6",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100365760003560e01c806365cd5c841461003b5780639d1adb591461007e575b600080fd5b6100627f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b03909116815260200160405180910390f35b61009161008c3660046103ae565b610093565b005b60006100be7f000000000000000000000000000000000000000000000000000000000000000061026a565b604051633782991960e11b81529091506001600160a01b03821690636f053232906100f3908890889088908890600401610496565b600060405180830381600087803b15801561010d57600080fd5b505af1158015610121573d6000803e3d6000fd5b505060405163572d881760e11b815233600482015260001960248201526001600160a01b038416925063ae5b102e9150604401600060405180830381600087803b15801561016e57600080fd5b505af1158015610182573d6000803e3d6000fd5b505060405163572d881760e11b8152306004820152600060248201526001600160a01b038416925063ae5b102e9150604401600060405180830381600087803b1580156101ce57600080fd5b505af11580156101e2573d6000803e3d6000fd5b50505050816040516101f491906104da565b6040518091039020816001600160a01b03167f83c29fc733f6e4dbd392b5aabe4e0439f457b50747fb1581021b9ae19e98fcdd7f000000000000000000000000000000000000000000000000000000000000000088888860405161025b94939291906104f6565b60405180910390a35050505050565b6000604051733d602d80600a3d3981f3363d3d373d3d3d363d7360601b81528260601b60148201526e5af43d82803e903d91602b57fd5bf360881b60288201526037816000f09150506001600160a01b0381166103065760405162461bcd60e51b8152602060048201526016602482015275115490cc4c4d8dce8818dc99585d194819985a5b195960521b604482015260640160405180910390fd5b919050565b634e487b7160e01b600052604160045260246000fd5b600082601f83011261033257600080fd5b813567ffffffffffffffff8082111561034d5761034d61030b565b604051601f8301601f19908116603f011681019082821181831017156103755761037561030b565b8160405283815286602085880101111561038e57600080fd5b836020870160208301376000602085830101528094505050505092915050565b600080600080608085870312156103c457600080fd5b84356001600160a01b03811681146103db57600080fd5b935060208501359250604085013567ffffffffffffffff808211156103ff57600080fd5b61040b88838901610321565b9350606087013591508082111561042157600080fd5b5061042e87828801610321565b91505092959194509250565b60005b8381101561045557818101518382015260200161043d565b83811115610464576000848401525b50505050565b6000815180845261048281602086016020860161043a565b601f01601f19169290920160200192915050565b60018060a01b03851681528360208201526080604082015260006104bd608083018561046a565b82810360608401526104cf818561046a565b979650505050505050565b600082516104ec81846020870161043a565b9190910192915050565b6001600160a01b03858116825284166020820152604081018390526080606082018190526000906105299083018461046a565b969550505050505056fea264697066735822122018187abcd0f3b5fc9a1a6ebf276d3417038a1e4d9dda295257808027636d48f964736f6c634300080f0033",
  "devdoc": {
    "author": "Basil Gorin",
    "details": "The deployment is done via EIP-1167 Minimal Proxy Contract      See https://eips.ethereum.org/EIPS/eip-1167",
    "events": {
      "CharacterERC20ImplInitialized(bool,string)": {
        "details": "Fired only once on deployment",
        "params": {
          "initialized": "if CharacterERC20 impl was successfully initialized",
          "whyNot": "empty, or if CharacterERC20 impl was not initialized – the reason"
        }
      },
      "ProxyDeployed(address,address,address,uint256,string,string)": {
        "details": "Fired in deployCharacterERC20",
        "params": {
          "_initialHolder": "owner of the initial token supply",
          "_initialSupply": "initial token supply",
          "_name": "token name to set",
          "_symbol": "token symbol to set",
          "characterErc20ImplAddress": "CharacterERC20 impl address, always the same",
          "characterErc20ProxyAddress": "deployed EIP-1167 clone (proxy) address"
        }
      }
    },
    "kind": "dev",
    "methods": {
      "constructor": {
        "details": "Deploys a CharacterERC20Deployer instance bound to an already deployed      CharacterERC20 token instance implementation to be used to create EIP-1167 \"clones\""
      },
      "deployCharacterERC20(address,uint256,string,string)": {
        "details": "Technically this deploys a tiny proxy pointing to the token impl address `characterErc20ImplAddress`      and initialized it immediately, making the deployment safe and ready for use",
        "params": {
          "_initialHolder": "owner of the initial token supply",
          "_initialSupply": "initial token supply",
          "_name": "token name to set",
          "_symbol": "token symbol to set"
        }
      }
    },
    "stateVariables": {
      "characterErc20ImplAddress": {
        "details": "The deployed minimalistic proxy always points to this implementation"
      }
    },
    "title": "Character ERC20 Token Deployer",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "characterErc20ImplAddress()": {
        "notice": "An address of already deployed CharacterERC20 token used as an implementation"
      },
      "deployCharacterERC20(address,uint256,string,string)": {
        "notice": "\"Deploys\" CharacterERC20 token with the specified name, symbol, initial total supply"
      }
    },
    "notice": "A helper stand-alone contract allowing to \"clone\" Character ERC20 Token",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}