{
  "language": "Solidity",
  "sources": {
    "contracts/protocol/NFTFactoryV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ERC721Spec.sol\";\nimport \"../interfaces/ERC721SpecExt.sol\";\nimport \"../utils/AccessControl.sol\";\nimport \"../lib/ECDSA.sol\";\n\n/**\n * @title Alethea NFT Factory\n *\n * @notice NFT Factory is a helper smart contract responsible for minting arbitrary NFTs\n *\n * @notice It supports two mechanisms:\n *      - minting delegation: authorized address executes mint function on the helper,\n *        and helper executes minting function on the target ERC721 contract as an internal transaction\n *      - meta transaction minting or minting with an authorization: authorized address signs\n *        the minting authorization message and any address executes mint function on the helper\n *\n * @notice Second mechanism allows to shift the gas costs for the transaction to any address\n *      (usually this is the NFT beneficiary - an address which receives an NFT)\n *\n * @dev The signature is constructed via EIP-712 similar to EIP-2612, or EIP-3009\n *\n * @dev Target ERC721 contract(s) must allow helper to mint the tokens, this should be configured\n *      as part of the deployment or setup processes\n *\n * @dev Version 2 (NFTFactoryV2) adds total supply limiting feature allowing to set the NFT total\n *     supply hardcap; factory stops minting when total supply of the ERC721 to mint reaches the hardcap\n *\n * @author Basil Gorin\n */\ncontract NFTFactoryV2 is AccessControl {\n\t/**\n\t * @notice Total Supply Hardcap affects factory capability to mint: once\n\t *      target ERC721 total supply reaches the hardcap, factory stops minting it\n\t *\n\t * @dev The factory `mint` and `mintWithAuthorization` function throws\n\t *      if target ERC721 `totalSupply` value is equal or bigger than `totalSupplyHardcap`\n\t */\n\tuint256 public immutable totalSupplyHardcap;\n\n\t/**\n\t * @dev A record of used nonces for EIP-712 transactions\n\t *\n\t * @dev A record of used nonces for signing/validating signatures\n\t *      in `mintWithAuthorization` for every mint\n\t *\n\t * @dev Maps authorizer address => nonce => true/false (used unused)\n\t */\n\tmapping(address => mapping(bytes32 => bool)) private usedNonces;\n\n\t/**\n\t * @notice EIP-712 contract's domain separator,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator\n\t */\n\tbytes32 public immutable DOMAIN_SEPARATOR;\n\n\t/**\n\t * @notice EIP-712 contract's domain typeHash,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\n\t *\n\t * @dev Note: we do not include version into the domain typehash/separator,\n\t *      it is implied version is concatenated to the name field, like \"NFTFactoryV2\"\n\t */\n\t// keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\")\n\tbytes32 public constant DOMAIN_TYPEHASH = 0x8cad95687ba82c2ce50e74f7b754645e5117c3a5bec8151c0726d5857980a866;\n\n\t/**\n\t * @notice EIP-712 MintWithAuthorization struct typeHash,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\n\t */\n\t// keccak256(\"MintWithAuthorization(address contract,address to,uint256 tokenId,uint256 validAfter,uint256 validBefore,bytes32 nonce)\")\n\tbytes32 public constant MINT_WITH_AUTHORIZATION_TYPEHASH = 0x495835d970a03ff092657fca9abde67d34a0bb73a0bba258a5fa90c4ce4340f6;\n\n\t/**\n\t * @notice EIP-712 CancelAuthorization struct typeHash,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\n\t */\n\t// keccak256(\"CancelAuthorization(address authorizer,bytes32 nonce)\")\n\tbytes32 public constant CANCEL_AUTHORIZATION_TYPEHASH = 0x158b0a9edf7a828aad02f63cd515c68ef2f50ba807396f6d12842833a1597429;\n\n\t/**\n\t * @notice Enables meta transaction minting (minting with an authorization\n\t *      via an EIP712 signature)\n\t * @dev Feature FEATURE_MINTING_WITH_AUTH must be enabled in order for\n\t *      `mintWithAuthorization()` function to succeed\n\t */\n\tuint32 public constant FEATURE_MINTING_WITH_AUTH = 0x0000_0001;\n\n\t/**\n\t * @notice Factory minter is responsible for creating (minting)\n\t *      tokens to an arbitrary address\n\t * @dev Role ROLE_FACTORY_MINTER allows minting tokens\n\t *      (executing `mint` function)\n\t */\n\tuint32 public constant ROLE_FACTORY_MINTER = 0x0001_0000;\n\n\t/**\n\t * @dev Fired in mint() and mintWithAuthorization() after an NFT is minted\n\t *\n\t * @param erc721Address ERC721 contract address which was minted\n\t * @param to an address NFT was minted to\n\t * @param tokenId NFT ID which was minted\n\t */\n\tevent Minted(address indexed erc721Address, address indexed to, uint256 indexed tokenId);\n\n\t/**\n\t * @dev Fired whenever the nonce gets used (ex.: `transferWithAuthorization`, `receiveWithAuthorization`)\n\t *\n\t * @param authorizer an address which has used the nonce\n\t * @param nonce the nonce used\n\t */\n\tevent AuthorizationUsed(address indexed authorizer, bytes32 indexed nonce);\n\n\t/**\n\t * @dev Fired whenever the nonce gets cancelled (ex.: `cancelAuthorization`)\n\t *\n\t * @dev Both `AuthorizationUsed` and `AuthorizationCanceled` imply the nonce\n\t *      cannot be longer used, the only difference is that `AuthorizationCanceled`\n\t *      implies no smart contract state change made (except the nonce marked as cancelled)\n\t *\n\t * @param authorizer an address which has cancelled the nonce\n\t * @param nonce the nonce cancelled\n\t */\n\tevent AuthorizationCanceled(address indexed authorizer, bytes32 indexed nonce);\n\n\t/**\n\t * Deploys the helper contract and initializes DOMAIN_SEPARATOR using the created smart contract address\n\t *\n\t * @param _totalSupplyHardcap ERC721 total supply limit, factory stops minting the ERC721\n\t *      if its total supply (ERC721.totalSupply()) reaches the total supply had cap\n\t */\n\tconstructor(uint256 _totalSupplyHardcap) {\n\t\t// build the EIP-712 contract domain separator, see https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator\n\t\t// note: we specify contract version in its name\n\t\tDOMAIN_SEPARATOR = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(\"NFTFactoryV2\")), block.chainid, address(this)));\n\n\t\t// verify the hardcap is set\n\t\trequire(_totalSupplyHardcap != 0, \"hardcap is not set\");\n\n\t\t// set the total supply hardcap\n\t\ttotalSupplyHardcap = _totalSupplyHardcap;\n\t}\n\n\t/**\n\t * @notice Restricted access function to mint an NFT\n\t *\n\t * @dev Doesn't allow minting the token with ID zero\n\t * @dev Requires an executor to have ROLE_MINTER permission\n\t * @dev Requires target ERC721 contract to be mintable (`MintableERC721`)\n\t * @dev Requires target ERC721 contract instance to allow minting via helper\n\t *\n\t * @param _targetErc721 target ERC721 contract instance to mint token on,\n\t *      compatible with `MintableERC721`\n\t * @param _to an address to mint token to\n\t * @param _tokenId target ERC721 token ID to mint\n\t */\n\tfunction mint(address _targetErc721, address _to, uint256 _tokenId) public {\n\t\t// delegate to _mint()\n\t\t__mint(msg.sender, _targetErc721, _to, _tokenId);\n\t}\n\n\t/**\n\t * @dev Auxiliary internally used function to mint an NFT\n\t *\n\t * @dev Unsafe: doesn't verify real tx executor (msg.sender) permissions, but the permissions of\n\t *      the address specified as an executor, must be kept private at all times\n\t *\n\t * @dev Doesn't allow minting the token with ID zero\n\t * @dev Requires an executor to have ROLE_MINTER permission\n\t * @dev Requires target ERC721 contract to be mintable (`MintableERC721`)\n\t * @dev Requires target ERC721 contract instance to allow minting via helper\n\t *\n\t * @param _executor an address on which behalf the operation is executed,\n\t *      this is usually `msg.sender` but this can be different address for\n\t *      the EIP-712 like transactions (mint with authorization)\n\t * @param _targetErc721 target ERC721 contract instance to mint token on,\n\t *      compatible with `MintableERC721`\n\t * @param _to an address to mint token to\n\t * @param _tokenId target ERC721 token ID to mint\n\t */\n\tfunction __mint(address _executor, address _targetErc721, address _to, uint256 _tokenId) private {\n\t\t// verify the access permission\n\t\trequire(isOperatorInRole(_executor, ROLE_FACTORY_MINTER), \"access denied\");\n\n\t\t// verify the inputs\n\t\trequire(_targetErc721 != address(0), \"ERC721 instance addr is not set\");\n\t\trequire(_to != address(0), \"NFT receiver addr is not set\");\n\t\trequire(_tokenId != 0, \"token ID is not set\");\n\n\t\t// verify if total supply hardcap is reached\n\t\trequire(ERC721Enumerable(_targetErc721).totalSupply() < totalSupplyHardcap, \"hardcap reached\");\n\n\t\t// delegate to the target ERC721 contract\n\t\tMintableERC721(_targetErc721).safeMint(_to, _tokenId);\n\n\t\t// emit an event\n\t\temit Minted(_targetErc721, _to, _tokenId);\n\t}\n\n\t/**\n\t * @notice Executes a mint function with a signed authorization\n\t *\n\t * @param _targetErc721 target ERC721 contract instance to mint token on,\n\t *      compatible with `MintableERC721`\n\t * @param _to an address to mint token to\n\t * @param _tokenId target ERC721 token ID to mint\n\t * @param _validAfter signature valid after time (unix timestamp)\n\t * @param _validBefore signature valid before time (unix timestamp)\n\t * @param _nonce unique random nonce\n\t * @param v the recovery byte of the signature\n\t * @param r half of the ECDSA signature pair\n\t * @param s half of the ECDSA signature pair\n\t */\n\tfunction mintWithAuthorization(\n\t\taddress _targetErc721,\n\t\taddress _to,\n\t\tuint256 _tokenId,\n\t\tuint256 _validAfter,\n\t\tuint256 _validBefore,\n\t\tbytes32 _nonce,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) public {\n\t\t// ensure EIP-712 minting with authorization is enabled\n\t\trequire(isFeatureEnabled(FEATURE_MINTING_WITH_AUTH), \"minting with auth is disabled\");\n\n\t\t// derive signer of the EIP712 MintWithAuthorization message\n\t\taddress signer = __deriveSigner(\n\t\t\tabi.encode(MINT_WITH_AUTHORIZATION_TYPEHASH, _targetErc721, _to, _tokenId, _validAfter, _validBefore, _nonce),\n\t\t\tv,\n\t\t\tr,\n\t\t\ts\n\t\t);\n\n\t\t// perform message integrity and security validations\n\t\trequire(block.timestamp > _validAfter, \"signature not yet valid\");\n\t\trequire(block.timestamp < _validBefore, \"signature expired\");\n\n\t\t// use the nonce supplied (verify, mark as used, emit event)\n\t\t__useNonce(signer, _nonce, false);\n\n\t\t// delegate call to `_mint` - execute the logic required\n\t\t__mint(signer, _targetErc721, _to, _tokenId);\n\t}\n\n\t/**\n\t * @notice Returns the state of an authorization, more specifically\n\t *      if the specified nonce was already used by the address specified\n\t *\n\t * @dev Nonces are expected to be client-side randomly generated 32-byte data\n\t *      unique to the authorizer's address\n\t *\n\t * @param _authorizer Authorizer's address\n\t * @param _nonce Nonce of the authorization\n\t * @return true if the nonce is used\n\t */\n\tfunction authorizationState(\n\t\taddress _authorizer,\n\t\tbytes32 _nonce\n\t) external view returns (bool) {\n\t\t// simply return the value from the mapping\n\t\treturn usedNonces[_authorizer][_nonce];\n\t}\n\n\t/**\n\t * @notice Cancels the authorization (using EIP-712 signature)\n\t *\n\t * @param _authorizer transaction authorizer\n\t * @param _nonce unique random nonce to cancel (mark as used)\n\t * @param v the recovery byte of the signature\n\t * @param r half of the ECDSA signature pair\n\t * @param s half of the ECDSA signature pair\n\t */\n\tfunction cancelAuthorization(\n\t\taddress _authorizer,\n\t\tbytes32 _nonce,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) public {\n\t\t// derive signer of the EIP712 ReceiveWithAuthorization message\n\t\taddress signer = __deriveSigner(abi.encode(CANCEL_AUTHORIZATION_TYPEHASH, _authorizer, _nonce), v, r, s);\n\n\t\t// perform message integrity and security validations\n\t\trequire(signer == _authorizer, \"invalid signature\");\n\n\t\t// cancel the nonce supplied (verify, mark as used, emit event)\n\t\t__useNonce(_authorizer, _nonce, true);\n\t}\n\n\t/**\n\t * @notice Cancels the authorization\n\t *\n\t * @param _nonce unique random nonce to cancel (mark as used)\n\t */\n\tfunction cancelAuthorization(bytes32 _nonce) public {\n\t\t// cancel the nonce supplied (verify, mark as used, emit event)\n\t\t__useNonce(msg.sender, _nonce, true);\n\t}\n\n\t/**\n\t * @dev Auxiliary function to verify structured EIP712 message signature and derive its signer\n\t *\n\t * @param abiEncodedTypehash abi.encode of the message typehash together with all its parameters\n\t * @param v the recovery byte of the signature\n\t * @param r half of the ECDSA signature pair\n\t * @param s half of the ECDSA signature pair\n\t */\n\tfunction __deriveSigner(bytes memory abiEncodedTypehash, uint8 v, bytes32 r, bytes32 s) private view returns(address) {\n\t\t// build the EIP-712 hashStruct of the message\n\t\tbytes32 hashStruct = keccak256(abiEncodedTypehash);\n\n\t\t// calculate the EIP-712 digest \"\\x19\\x01\" ‖ domainSeparator ‖ hashStruct(message)\n\t\tbytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR, hashStruct));\n\n\t\t// recover the address which signed the message with v, r, s\n\t\taddress signer = ECDSA.recover(digest, v, r, s);\n\n\t\t// return the signer address derived from the signature\n\t\treturn signer;\n\t}\n\n\t/**\n\t * @dev Auxiliary function to use/cancel the nonce supplied for a given authorizer:\n\t *      1. Verifies the nonce was not used before\n\t *      2. Marks the nonce as used\n\t *      3. Emits an event that the nonce was used/cancelled\n\t *\n\t * @dev Set `_cancellation` to false (default) to use nonce,\n\t *      set `_cancellation` to true to cancel nonce\n\t *\n\t * @dev It is expected that the nonce supplied is a randomly\n\t *      generated uint256 generated by the client\n\t *\n\t * @param _authorizer an address to use/cancel nonce for\n\t * @param _nonce random nonce to use\n\t * @param _cancellation true to emit `AuthorizationCancelled`, false to emit `AuthorizationUsed` event\n\t */\n\tfunction __useNonce(address _authorizer, bytes32 _nonce, bool _cancellation) private {\n\t\t// verify nonce was not used before\n\t\trequire(!usedNonces[_authorizer][_nonce], \"invalid nonce\");\n\n\t\t// update the nonce state to \"used\" for that particular signer to avoid replay attack\n\t\tusedNonces[_authorizer][_nonce] = true;\n\n\t\t// depending on the usage type (use/cancel)\n\t\tif(_cancellation) {\n\t\t\t// emit an event regarding the nonce cancelled\n\t\t\temit AuthorizationCanceled(_authorizer, _nonce);\n\t\t}\n\t\telse {\n\t\t\t// emit an event regarding the nonce used\n\t\t\temit AuthorizationUsed(_authorizer, _nonce);\n\t\t}\n\t}\n}\n"
    },
    "contracts/interfaces/ERC721Spec.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./ERC165Spec.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard\n *\n * @notice See https://eips.ethereum.org/EIPS/eip-721\n *\n * @dev Solidity issue #3412: The ERC721 interfaces include explicit mutability guarantees for each function.\n *      Mutability guarantees are, in order weak to strong: payable, implicit nonpayable, view, and pure.\n *      Implementation MUST meet the mutability guarantee in this interface and MAY meet a stronger guarantee.\n *      For example, a payable function in this interface may be implemented as nonpayable\n *      (no state mutability specified) in implementing contract.\n *      It is expected a later Solidity release will allow stricter contract to inherit from this interface,\n *      but current workaround is that we edit this interface to add stricter mutability before inheriting:\n *      we have removed all \"payable\" modifiers.\n *\n * @dev The ERC-165 identifier for this interface is 0x80ac58cd.\n *\n * @author William Entriken, Dieter Shirley, Jacob Evans, Nastassia Sachs\n */\ninterface ERC721 is ERC165 {\n\t/// @dev This emits when ownership of any NFT changes by any mechanism.\n\t///  This event emits when NFTs are created (`from` == 0) and destroyed\n\t///  (`to` == 0). Exception: during contract creation, any number of NFTs\n\t///  may be created and assigned without emitting Transfer. At the time of\n\t///  any transfer, the approved address for that NFT (if any) is reset to none.\n\tevent Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\n\n\t/// @dev This emits when the approved address for an NFT is changed or\n\t///  reaffirmed. The zero address indicates there is no approved address.\n\t///  When a Transfer event emits, this also indicates that the approved\n\t///  address for that NFT (if any) is reset to none.\n\tevent Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\n\n\t/// @dev This emits when an operator is enabled or disabled for an owner.\n\t///  The operator can manage all NFTs of the owner.\n\tevent ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n\n\t/// @notice Count all NFTs assigned to an owner\n\t/// @dev NFTs assigned to the zero address are considered invalid, and this\n\t///  function throws for queries about the zero address.\n\t/// @param _owner An address for whom to query the balance\n\t/// @return The number of NFTs owned by `_owner`, possibly zero\n\tfunction balanceOf(address _owner) external view returns (uint256);\n\n\t/// @notice Find the owner of an NFT\n\t/// @dev NFTs assigned to zero address are considered invalid, and queries\n\t///  about them do throw.\n\t/// @param _tokenId The identifier for an NFT\n\t/// @return The address of the owner of the NFT\n\tfunction ownerOf(uint256 _tokenId) external view returns (address);\n\n\t/// @notice Transfers the ownership of an NFT from one address to another address\n\t/// @dev Throws unless `msg.sender` is the current owner, an authorized\n\t///  operator, or the approved address for this NFT. Throws if `_from` is\n\t///  not the current owner. Throws if `_to` is the zero address. Throws if\n\t///  `_tokenId` is not a valid NFT. When transfer is complete, this function\n\t///  checks if `_to` is a smart contract (code size > 0). If so, it calls\n\t///  `onERC721Received` on `_to` and throws if the return value is not\n\t///  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n\t/// @param _from The current owner of the NFT\n\t/// @param _to The new owner\n\t/// @param _tokenId The NFT to transfer\n\t/// @param _data Additional data with no specified format, sent in call to `_to`\n\tfunction safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external /*payable*/;\n\n\t/// @notice Transfers the ownership of an NFT from one address to another address\n\t/// @dev This works identically to the other function with an extra data parameter,\n\t///  except this function just sets data to \"\".\n\t/// @param _from The current owner of the NFT\n\t/// @param _to The new owner\n\t/// @param _tokenId The NFT to transfer\n\tfunction safeTransferFrom(address _from, address _to, uint256 _tokenId) external /*payable*/;\n\n\t/// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\n\t///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\n\t///  THEY MAY BE PERMANENTLY LOST\n\t/// @dev Throws unless `msg.sender` is the current owner, an authorized\n\t///  operator, or the approved address for this NFT. Throws if `_from` is\n\t///  not the current owner. Throws if `_to` is the zero address. Throws if\n\t///  `_tokenId` is not a valid NFT.\n\t/// @param _from The current owner of the NFT\n\t/// @param _to The new owner\n\t/// @param _tokenId The NFT to transfer\n\tfunction transferFrom(address _from, address _to, uint256 _tokenId) external /*payable*/;\n\n\t/// @notice Change or reaffirm the approved address for an NFT\n\t/// @dev The zero address indicates there is no approved address.\n\t///  Throws unless `msg.sender` is the current NFT owner, or an authorized\n\t///  operator of the current owner.\n\t/// @param _approved The new approved NFT controller\n\t/// @param _tokenId The NFT to approve\n\tfunction approve(address _approved, uint256 _tokenId) external /*payable*/;\n\n\t/// @notice Enable or disable approval for a third party (\"operator\") to manage\n\t///  all of `msg.sender`'s assets\n\t/// @dev Emits the ApprovalForAll event. The contract MUST allow\n\t///  multiple operators per owner.\n\t/// @param _operator Address to add to the set of authorized operators\n\t/// @param _approved True if the operator is approved, false to revoke approval\n\tfunction setApprovalForAll(address _operator, bool _approved) external;\n\n\t/// @notice Get the approved address for a single NFT\n\t/// @dev Throws if `_tokenId` is not a valid NFT.\n\t/// @param _tokenId The NFT to find the approved address for\n\t/// @return The approved address for this NFT, or the zero address if there is none\n\tfunction getApproved(uint256 _tokenId) external view returns (address);\n\n\t/// @notice Query if an address is an authorized operator for another address\n\t/// @param _owner The address that owns the NFTs\n\t/// @param _operator The address that acts on behalf of the owner\n\t/// @return True if `_operator` is an approved operator for `_owner`, false otherwise\n\tfunction isApprovedForAll(address _owner, address _operator) external view returns (bool);\n}\n\n/// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.\ninterface ERC721TokenReceiver {\n\t/// @notice Handle the receipt of an NFT\n\t/// @dev The ERC721 smart contract calls this function on the recipient\n\t///  after a `transfer`. This function MAY throw to revert and reject the\n\t///  transfer. Return of other than the magic value MUST result in the\n\t///  transaction being reverted.\n\t///  Note: the contract address is always the message sender.\n\t/// @param _operator The address which called `safeTransferFrom` function\n\t/// @param _from The address which previously owned the token\n\t/// @param _tokenId The NFT identifier which is being transferred\n\t/// @param _data Additional data with no specified format\n\t/// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n\t///  unless throwing\n\tfunction onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4);\n}\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n *\n * @notice See https://eips.ethereum.org/EIPS/eip-721\n *\n * @dev The ERC-165 identifier for this interface is 0x5b5e139f.\n *\n * @author William Entriken, Dieter Shirley, Jacob Evans, Nastassia Sachs\n */\ninterface ERC721Metadata is ERC721 {\n\t/// @notice A descriptive name for a collection of NFTs in this contract\n\tfunction name() external view returns (string memory _name);\n\n\t/// @notice An abbreviated name for NFTs in this contract\n\tfunction symbol() external view returns (string memory _symbol);\n\n\t/// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\n\t/// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\n\t///  3986. The URI may point to a JSON file that conforms to the \"ERC721\n\t///  Metadata JSON Schema\".\n\tfunction tokenURI(uint256 _tokenId) external view returns (string memory);\n}\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n *\n * @notice See https://eips.ethereum.org/EIPS/eip-721\n *\n * @dev The ERC-165 identifier for this interface is 0x780e9d63.\n *\n * @author William Entriken, Dieter Shirley, Jacob Evans, Nastassia Sachs\n */\ninterface ERC721Enumerable is ERC721 {\n\t/// @notice Count NFTs tracked by this contract\n\t/// @return A count of valid NFTs tracked by this contract, where each one of\n\t///  them has an assigned and queryable owner not equal to the zero address\n\tfunction totalSupply() external view returns (uint256);\n\n\t/// @notice Enumerate valid NFTs\n\t/// @dev Throws if `_index` >= `totalSupply()`.\n\t/// @param _index A counter less than `totalSupply()`\n\t/// @return The token identifier for the `_index`th NFT,\n\t///  (sort order not specified)\n\tfunction tokenByIndex(uint256 _index) external view returns (uint256);\n\n\t/// @notice Enumerate NFTs assigned to an owner\n\t/// @dev Throws if `_index` >= `balanceOf(_owner)` or if\n\t///  `_owner` is the zero address, representing invalid NFTs.\n\t/// @param _owner An address where we are interested in NFTs owned by them\n\t/// @param _index A counter less than `balanceOf(_owner)`\n\t/// @return The token identifier for the `_index`th NFT assigned to `_owner`,\n\t///   (sort order not specified)\n\tfunction tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/ERC721SpecExt.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title Mintable ERC721\n *\n * @notice Defines mint capabilities for Alethea ERC721 tokens.\n *      This interface should be treated as a definition of what mintable means for ERC721\n *\n * @author Basil Gorin\n */\ninterface MintableERC721 {\n\t/**\n\t * @notice Checks if specified token exists\n\t *\n\t * @dev Returns whether the specified token ID has an ownership\n\t *      information associated with it\n\t *\n\t * @param _tokenId ID of the token to query existence for\n\t * @return whether the token exists (true - exists, false - doesn't exist)\n\t */\n\tfunction exists(uint256 _tokenId) external view returns(bool);\n\n\t/**\n\t * @dev Creates new token with token ID specified\n\t *      and assigns an ownership `_to` for this token\n\t *\n\t * @dev Unsafe: doesn't execute `onERC721Received` on the receiver.\n\t *      Prefer the use of `saveMint` instead of `mint`.\n\t *\n\t * @dev Should have a restricted access handled by the implementation\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId ID of the token to mint\n\t */\n\tfunction mint(address _to, uint256 _tokenId) external;\n\n\t/**\n\t * @dev Creates new tokens starting with token ID specified\n\t *      and assigns an ownership `_to` for these tokens\n\t *\n\t * @dev Token IDs to be minted: [_tokenId, _tokenId + n)\n\t *\n\t * @dev n must be greater or equal 2: `n > 1`\n\t *\n\t * @dev Unsafe: doesn't execute `onERC721Received` on the receiver.\n\t *      Prefer the use of `saveMintBatch` instead of `mintBatch`.\n\t *\n\t * @dev Should have a restricted access handled by the implementation\n\t *\n\t * @param _to an address to mint tokens to\n\t * @param _tokenId ID of the first token to mint\n\t * @param n how many tokens to mint, sequentially increasing the _tokenId\n\t */\n\tfunction mintBatch(address _to, uint256 _tokenId, uint256 n) external;\n\n\t/**\n\t * @dev Creates new token with token ID specified\n\t *      and assigns an ownership `_to` for this token\n\t *\n\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\n\t *      `onERC721Received` on `_to` and throws if the return value is not\n\t *      `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n\t *\n\t * @dev Should have a restricted access handled by the implementation\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId ID of the token to mint\n\t */\n\tfunction safeMint(address _to, uint256 _tokenId) external;\n\n\t/**\n\t * @dev Creates new token with token ID specified\n\t *      and assigns an ownership `_to` for this token\n\t *\n\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\n\t *      `onERC721Received` on `_to` and throws if the return value is not\n\t *      `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n\t *\n\t * @dev Should have a restricted access handled by the implementation\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId ID of the token to mint\n\t * @param _data additional data with no specified format, sent in call to `_to`\n\t */\n\tfunction safeMint(address _to, uint256 _tokenId, bytes memory _data) external;\n\n\t/**\n\t * @dev Creates new tokens starting with token ID specified\n\t *      and assigns an ownership `_to` for these tokens\n\t *\n\t * @dev Token IDs to be minted: [_tokenId, _tokenId + n)\n\t *\n\t * @dev n must be greater or equal 2: `n > 1`\n\t *\n\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\n\t *      `onERC721Received` on `_to` and throws if the return value is not\n\t *      `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n\t *\n\t * @dev Should have a restricted access handled by the implementation\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId ID of the token to mint\n\t * @param n how many tokens to mint, sequentially increasing the _tokenId\n\t */\n\tfunction safeMintBatch(address _to, uint256 _tokenId, uint256 n) external;\n\n\t/**\n\t * @dev Creates new tokens starting with token ID specified\n\t *      and assigns an ownership `_to` for these tokens\n\t *\n\t * @dev Token IDs to be minted: [_tokenId, _tokenId + n)\n\t *\n\t * @dev n must be greater or equal 2: `n > 1`\n\t *\n\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\n\t *      `onERC721Received` on `_to` and throws if the return value is not\n\t *      `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n\t *\n\t * @dev Should have a restricted access handled by the implementation\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId ID of the token to mint\n\t * @param n how many tokens to mint, sequentially increasing the _tokenId\n\t * @param _data additional data with no specified format, sent in call to `_to`\n\t */\n\tfunction safeMintBatch(address _to, uint256 _tokenId, uint256 n, bytes memory _data) external;\n}\n\n/**\n * @title Alethea Burnable ERC721\n *\n * @notice Defines burn capabilities for Alethea ERC721 tokens.\n *      This interface should be treated as a definition of what burnable means for ERC721\n *\n * @author Basil Gorin\n */\ninterface BurnableERC721 {\n\t/**\n\t * @notice Destroys the token with token ID specified\n\t *\n\t * @dev Should be accessible publicly by token owners.\n\t *      May have a restricted access handled by the implementation\n\t *\n\t * @param _tokenId ID of the token to burn\n\t */\n\tfunction burn(uint256 _tokenId) external;\n}\n\n/**\n * @title With Base URI\n *\n * @notice A marker interface for the contracts having the baseURI() function\n *      or public string variable named baseURI\n *      NFT implementations like TinyERC721, or ShortERC721 are example of such smart contracts\n *\n * @author Basil Gorin\n */\ninterface WithBaseURI {\n\t/**\n\t * @dev Usually used in NFT implementations to construct ERC721Metadata.tokenURI as\n\t *      `base URI + token ID` if token URI is not set (not present in `_tokenURIs` mapping)\n\t *\n\t * @dev For example, if base URI is https://api.com/token/, then token #1\n\t *      will have an URI https://api.com/token/1\n\t */\n\tfunction baseURI() external view returns(string memory);\n}\n"
    },
    "contracts/utils/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title Access Control List\n *\n * @notice Access control smart contract provides an API to check\n *      if specific operation is permitted globally and/or\n *      if particular user has a permission to execute it.\n *\n * @notice It deals with two main entities: features and roles.\n *\n * @notice Features are designed to be used to enable/disable specific\n *      functions (public functions) of the smart contract for everyone.\n * @notice User roles are designed to restrict access to specific\n *      functions (restricted functions) of the smart contract to some users.\n *\n * @notice Terms \"role\", \"permissions\" and \"set of permissions\" have equal meaning\n *      in the documentation text and may be used interchangeably.\n * @notice Terms \"permission\", \"single permission\" implies only one permission bit set.\n *\n * @notice Access manager is a special role which allows to grant/revoke other roles.\n *      Access managers can only grant/revoke permissions which they have themselves.\n *      As an example, access manager with no other roles set can only grant/revoke its own\n *      access manager permission and nothing else.\n *\n * @notice Access manager permission should be treated carefully, as a super admin permission:\n *      Access manager with even no other permission can interfere with another account by\n *      granting own access manager permission to it and effectively creating more powerful\n *      permission set than its own.\n *\n * @dev Both current and OpenZeppelin AccessControl implementations feature a similar API\n *      to check/know \"who is allowed to do this thing\".\n * @dev Zeppelin implementation is more flexible:\n *      - it allows setting unlimited number of roles, while current is limited to 256 different roles\n *      - it allows setting an admin for each role, while current allows having only one global admin\n * @dev Current implementation is more lightweight:\n *      - it uses only 1 bit per role, while Zeppelin uses 256 bits\n *      - it allows setting up to 256 roles at once, in a single transaction, while Zeppelin allows\n *        setting only one role in a single transaction\n *\n * @dev This smart contract is designed to be inherited by other\n *      smart contracts which require access control management capabilities.\n *\n * @dev Access manager permission has a bit 255 set.\n *      This bit must not be used by inheriting contracts for any other permissions/features.\n *\n * @author Basil Gorin\n */\ncontract AccessControl {\n\t/**\n\t * @notice Access manager is responsible for assigning the roles to users,\n\t *      enabling/disabling global features of the smart contract\n\t * @notice Access manager can add, remove and update user roles,\n\t *      remove and update global features\n\t *\n\t * @dev Role ROLE_ACCESS_MANAGER allows modifying user roles and global features\n\t * @dev Role ROLE_ACCESS_MANAGER has single bit at position 255 enabled\n\t */\n\tuint256 public constant ROLE_ACCESS_MANAGER = 0x8000000000000000000000000000000000000000000000000000000000000000;\n\n\t/**\n\t * @dev Bitmask representing all the possible permissions (super admin role)\n\t * @dev Has all the bits are enabled (2^256 - 1 value)\n\t */\n\tuint256 private constant FULL_PRIVILEGES_MASK = type(uint256).max; // before 0.8.0: uint256(-1) overflows to 0xFFFF...\n\n\t/**\n\t * @notice Privileged addresses with defined roles/permissions\n\t * @notice In the context of ERC20/ERC721 tokens these can be permissions to\n\t *      allow minting or burning tokens, transferring on behalf and so on\n\t *\n\t * @dev Maps user address to the permissions bitmask (role), where each bit\n\t *      represents a permission\n\t * @dev Bitmask 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n\t *      represents all possible permissions\n\t * @dev 'This' address mapping represents global features of the smart contract\n\t */\n\tmapping(address => uint256) public userRoles;\n\n\t/**\n\t * @dev Fired in updateRole() and updateFeatures()\n\t *\n\t * @param _by operator which called the function\n\t * @param _to address which was granted/revoked permissions\n\t * @param _requested permissions requested\n\t * @param _actual permissions effectively set\n\t */\n\tevent RoleUpdated(address indexed _by, address indexed _to, uint256 _requested, uint256 _actual);\n\n\t/**\n\t * @notice Creates an access control instance,\n\t *      setting contract creator to have full privileges\n\t */\n\tconstructor() {\n\t\t// contract creator has full privileges\n\t\tuserRoles[msg.sender] = FULL_PRIVILEGES_MASK;\n\t}\n\n\t/**\n\t * @notice Retrieves globally set of features enabled\n\t *\n\t * @dev Effectively reads userRoles role for the contract itself\n\t *\n\t * @return 256-bit bitmask of the features enabled\n\t */\n\tfunction features() public view returns(uint256) {\n\t\t// features are stored in 'this' address  mapping of `userRoles` structure\n\t\treturn userRoles[address(this)];\n\t}\n\n\t/**\n\t * @notice Updates set of the globally enabled features (`features`),\n\t *      taking into account sender's permissions\n\t *\n\t * @dev Requires transaction sender to have `ROLE_ACCESS_MANAGER` permission\n\t * @dev Function is left for backward compatibility with older versions\n\t *\n\t * @param _mask bitmask representing a set of features to enable/disable\n\t */\n\tfunction updateFeatures(uint256 _mask) public {\n\t\t// delegate call to `updateRole`\n\t\tupdateRole(address(this), _mask);\n\t}\n\n\t/**\n\t * @notice Updates set of permissions (role) for a given user,\n\t *      taking into account sender's permissions.\n\t *\n\t * @dev Setting role to zero is equivalent to removing an all permissions\n\t * @dev Setting role to `FULL_PRIVILEGES_MASK` is equivalent to\n\t *      copying senders' permissions (role) to the user\n\t * @dev Requires transaction sender to have `ROLE_ACCESS_MANAGER` permission\n\t *\n\t * @param operator address of a user to alter permissions for or zero\n\t *      to alter global features of the smart contract\n\t * @param role bitmask representing a set of permissions to\n\t *      enable/disable for a user specified\n\t */\n\tfunction updateRole(address operator, uint256 role) public {\n\t\t// caller must have a permission to update user roles\n\t\trequire(isSenderInRole(ROLE_ACCESS_MANAGER), \"access denied\");\n\n\t\t// evaluate the role and reassign it\n\t\tuserRoles[operator] = evaluateBy(msg.sender, userRoles[operator], role);\n\n\t\t// fire an event\n\t\temit RoleUpdated(msg.sender, operator, role, userRoles[operator]);\n\t}\n\n\t/**\n\t * @notice Determines the permission bitmask an operator can set on the\n\t *      target permission set\n\t * @notice Used to calculate the permission bitmask to be set when requested\n\t *     in `updateRole` and `updateFeatures` functions\n\t *\n\t * @dev Calculated based on:\n\t *      1) operator's own permission set read from userRoles[operator]\n\t *      2) target permission set - what is already set on the target\n\t *      3) desired permission set - what do we want set target to\n\t *\n\t * @dev Corner cases:\n\t *      1) Operator is super admin and its permission set is `FULL_PRIVILEGES_MASK`:\n\t *        `desired` bitset is returned regardless of the `target` permission set value\n\t *        (what operator sets is what they get)\n\t *      2) Operator with no permissions (zero bitset):\n\t *        `target` bitset is returned regardless of the `desired` value\n\t *        (operator has no authority and cannot modify anything)\n\t *\n\t * @dev Example:\n\t *      Consider an operator with the permissions bitmask     00001111\n\t *      is about to modify the target permission set          01010101\n\t *      Operator wants to set that permission set to          00110011\n\t *      Based on their role, an operator has the permissions\n\t *      to update only lowest 4 bits on the target, meaning that\n\t *      high 4 bits of the target set in this example is left\n\t *      unchanged and low 4 bits get changed as desired:      01010011\n\t *\n\t * @param operator address of the contract operator which is about to set the permissions\n\t * @param target input set of permissions to operator is going to modify\n\t * @param desired desired set of permissions operator would like to set\n\t * @return resulting set of permissions given operator will set\n\t */\n\tfunction evaluateBy(address operator, uint256 target, uint256 desired) public view returns(uint256) {\n\t\t// read operator's permissions\n\t\tuint256 p = userRoles[operator];\n\n\t\t// taking into account operator's permissions,\n\t\t// 1) enable the permissions desired on the `target`\n\t\ttarget |= p & desired;\n\t\t// 2) disable the permissions desired on the `target`\n\t\ttarget &= FULL_PRIVILEGES_MASK ^ (p & (FULL_PRIVILEGES_MASK ^ desired));\n\n\t\t// return calculated result\n\t\treturn target;\n\t}\n\n\t/**\n\t * @notice Checks if requested set of features is enabled globally on the contract\n\t *\n\t * @param required set of features to check against\n\t * @return true if all the features requested are enabled, false otherwise\n\t */\n\tfunction isFeatureEnabled(uint256 required) public view returns(bool) {\n\t\t// delegate call to `__hasRole`, passing `features` property\n\t\treturn __hasRole(features(), required);\n\t}\n\n\t/**\n\t * @notice Checks if transaction sender `msg.sender` has all the permissions required\n\t *\n\t * @param required set of permissions (role) to check against\n\t * @return true if all the permissions requested are enabled, false otherwise\n\t */\n\tfunction isSenderInRole(uint256 required) public view returns(bool) {\n\t\t// delegate call to `isOperatorInRole`, passing transaction sender\n\t\treturn isOperatorInRole(msg.sender, required);\n\t}\n\n\t/**\n\t * @notice Checks if operator has all the permissions (role) required\n\t *\n\t * @param operator address of the user to check role for\n\t * @param required set of permissions (role) to check\n\t * @return true if all the permissions requested are enabled, false otherwise\n\t */\n\tfunction isOperatorInRole(address operator, uint256 required) public view returns(bool) {\n\t\t// delegate call to `__hasRole`, passing operator's permissions (role)\n\t\treturn __hasRole(userRoles[operator], required);\n\t}\n\n\t/**\n\t * @dev Checks if role `actual` contains all the permissions required `required`\n\t *\n\t * @param actual existent role\n\t * @param required required role\n\t * @return true if actual has required role (all permissions), false otherwise\n\t */\n\tfunction __hasRole(uint256 actual, uint256 required) internal pure returns(bool) {\n\t\t// check the bitmask for the role required and return the result\n\t\treturn actual & required == required;\n\t}\n}\n"
    },
    "contracts/lib/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n *\n * @dev Copy of the Zeppelin's library:\n *      https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b0cf6fbb7a70f31527f36579ad644e1cf12fdf4e/contracts/utils/cryptography/ECDSA.sol\n */\nlibrary ECDSA {\n\t/**\n\t * @dev Returns the address that signed a hashed message (`hash`) with\n\t * `signature`. This address can then be used for verification purposes.\n\t *\n\t * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n\t * this function rejects them by requiring the `s` value to be in the lower\n\t * half order, and the `v` value to be either 27 or 28.\n\t *\n\t * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n\t * verification to be secure: it is possible to craft signatures that\n\t * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n\t * this is by receiving a hash of the original message (which may otherwise\n\t * be too long), and then calling {toEthSignedMessageHash} on it.\n\t *\n\t * Documentation for signature generation:\n\t * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n\t * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n\t */\n\tfunction recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n\t\t// Divide the signature in r, s and v variables\n\t\tbytes32 r;\n\t\tbytes32 s;\n\t\tuint8 v;\n\n\t\t// Check the signature length\n\t\t// - case 65: r,s,v signature (standard)\n\t\t// - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n\t\tif (signature.length == 65) {\n\t\t\t// ecrecover takes the signature parameters, and the only way to get them\n\t\t\t// currently is to use assembly.\n\t\t\tassembly {\n\t\t\t\tr := mload(add(signature, 0x20))\n\t\t\t\ts := mload(add(signature, 0x40))\n\t\t\t\tv := byte(0, mload(add(signature, 0x60)))\n\t\t\t}\n\t\t}\n\t\telse if (signature.length == 64) {\n\t\t\t// ecrecover takes the signature parameters, and the only way to get them\n\t\t\t// currently is to use assembly.\n\t\t\tassembly {\n\t\t\t\tlet vs := mload(add(signature, 0x40))\n\t\t\t\tr := mload(add(signature, 0x20))\n\t\t\t\ts := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n\t\t\t\tv := add(shr(255, vs), 27)\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\trevert(\"invalid signature length\");\n\t\t}\n\n\t\treturn recover(hash, v, r, s);\n\t}\n\n\t/**\n\t * @dev Overload of {ECDSA-recover} that receives the `v`,\n\t * `r` and `s` signature fields separately.\n\t */\n\tfunction recover(\n\t\tbytes32 hash,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) internal pure returns (address) {\n\t\t// EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n\t\t// unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n\t\t// the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\n\t\t// signatures from current libraries generate a unique signature with an s-value in the lower half order.\n\t\t//\n\t\t// If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n\t\t// with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n\t\t// vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n\t\t// these malleable signatures as well.\n\t\trequire(\n\t\t\tuint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0,\n\t\t\t\"invalid signature 's' value\"\n\t\t);\n\t\trequire(v == 27 || v == 28, \"invalid signature 'v' value\");\n\n\t\t// If the signature is valid (and not malleable), return the signer address\n\t\taddress signer = ecrecover(hash, v, r, s);\n\t\trequire(signer != address(0), \"invalid signature\");\n\n\t\treturn signer;\n\t}\n\n\t/**\n\t * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n\t * produces hash corresponding to the one signed with the\n\t * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n\t * JSON-RPC method as part of EIP-191.\n\t *\n\t * See {recover}.\n\t */\n\tfunction toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n\t\t// 32 is the length in bytes of hash,\n\t\t// enforced by the type signature above\n\t\treturn keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n\t}\n\n\t/**\n\t * @dev Returns an Ethereum Signed Typed Data, created from a\n\t * `domainSeparator` and a `structHash`. This produces hash corresponding\n\t * to the one signed with the\n\t * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n\t * JSON-RPC method as part of EIP-712.\n\t *\n\t * See {recover}.\n\t */\n\tfunction toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n\t\treturn keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n\t}\n}\n"
    },
    "contracts/interfaces/ERC165Spec.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title ERC-165 Standard Interface Detection\n *\n * @dev Interface of the ERC165 standard, as defined in the\n *       https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * @dev Implementers can declare support of contract interfaces,\n *      which can then be queried by others.\n *\n * @author Christian Reitwießner, Nick Johnson, Fabian Vogelsteller, Jordi Baylina, Konrad Feldmeier, William Entriken\n */\ninterface ERC165 {\n\t/**\n\t * @notice Query if a contract implements an interface\n\t *\n\t * @dev Interface identification is specified in ERC-165.\n\t *      This function uses less than 30,000 gas.\n\t *\n\t * @param interfaceID The interface identifier, as specified in ERC-165\n\t * @return `true` if the contract implements `interfaceID` and\n\t *      `interfaceID` is not 0xffffffff, `false` otherwise\n\t */\n\tfunction supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}