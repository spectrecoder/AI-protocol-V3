{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-upgradeable/proxy/beacon/IBeaconUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeaconUpgradeable {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeaconUpgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/StorageSlotUpgradeable.sol\";\nimport \"../utils/Initializable.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967UpgradeUpgradeable is Initializable {\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n        __ERC1967Upgrade_init_unchained();\n    }\n\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            _functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallSecure(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        address oldImplementation = _getImplementation();\n\n        // Initial upgrade and setup call\n        _setImplementation(newImplementation);\n        if (data.length > 0 || forceCall) {\n            _functionDelegateCall(newImplementation, data);\n        }\n\n        // Perform rollback test if not already in progress\n        StorageSlotUpgradeable.BooleanSlot storage rollbackTesting = StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT);\n        if (!rollbackTesting.value) {\n            // Trigger rollback using upgradeTo from the new implementation\n            rollbackTesting.value = true;\n            _functionDelegateCall(\n                newImplementation,\n                abi.encodeWithSignature(\"upgradeTo(address)\", oldImplementation)\n            );\n            rollbackTesting.value = false;\n            // Check rollback was effective\n            require(oldImplementation == _getImplementation(), \"ERC1967Upgrade: upgrade breaks further upgrades\");\n            // Finally reset to the new implementation and log the upgrade\n            _upgradeTo(newImplementation);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            _functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function _functionDelegateCall(address target, bytes memory data) private returns (bytes memory) {\n        require(AddressUpgradeable.isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return AddressUpgradeable.verifyCallResult(success, returndata, \"Address: low-level delegate call failed\");\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() initializer {}\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\n        // contract may have been reentered.\n        require(_initializing ? _isConstructor() : !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} modifier, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/utils/UUPSUpgradeable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1967/ERC1967UpgradeUpgradeable.sol\";\nimport \"./Initializable.sol\";\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n *\n * _Available since v4.1._\n */\nabstract contract UUPSUpgradeable is Initializable, ERC1967UpgradeUpgradeable {\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n        __ERC1967Upgrade_init_unchained();\n        __UUPSUpgradeable_init_unchained();\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n    address private immutable __self = address(this);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        require(address(this) != __self, \"Function must be called through delegatecall\");\n        require(_getImplementation() == __self, \"Function must be called through active proxy\");\n        _;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeTo(address newImplementation) external virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallSecure(newImplementation, new bytes(0), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallSecure(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeTo} and {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlotUpgradeable {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "contracts/interfaces/ERC20Spec.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title EIP-20: ERC-20 Token Standard\n *\n * @notice The ERC-20 (Ethereum Request for Comments 20), proposed by Fabian Vogelsteller in November 2015,\n *      is a Token Standard that implements an API for tokens within Smart Contracts.\n *\n * @notice It provides functionalities like to transfer tokens from one account to another,\n *      to get the current token balance of an account and also the total supply of the token available on the network.\n *      Besides these it also has some other functionalities like to approve that an amount of\n *      token from an account can be spent by a third party account.\n *\n * @notice If a Smart Contract implements the following methods and events it can be called an ERC-20 Token\n *      Contract and, once deployed, it will be responsible to keep track of the created tokens on Ethereum.\n *\n * @notice See https://ethereum.org/en/developers/docs/standards/tokens/erc-20/\n * @notice See https://eips.ethereum.org/EIPS/eip-20\n */\ninterface ERC20 {\n\t/**\n\t * @dev Fired in transfer(), transferFrom() to indicate that token transfer happened\n\t *\n\t * @param from an address tokens were consumed from\n\t * @param to an address tokens were sent to\n\t * @param value number of tokens transferred\n\t */\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n\n\t/**\n\t * @dev Fired in approve() to indicate an approval event happened\n\t *\n\t * @param owner an address which granted a permission to transfer\n\t *      tokens on its behalf\n\t * @param spender an address which received a permission to transfer\n\t *      tokens on behalf of the owner `_owner`\n\t * @param value amount of tokens granted to transfer on behalf\n\t */\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\n\n\t/**\n\t * @return name of the token (ex.: USD Coin)\n\t */\n\t// OPTIONAL - This method can be used to improve usability,\n\t// but interfaces and other contracts MUST NOT expect these values to be present.\n\t// function name() external view returns (string memory);\n\n\t/**\n\t * @return symbol of the token (ex.: USDC)\n\t */\n\t// OPTIONAL - This method can be used to improve usability,\n\t// but interfaces and other contracts MUST NOT expect these values to be present.\n\t// function symbol() external view returns (string memory);\n\n\t/**\n\t * @dev Returns the number of decimals used to get its user representation.\n\t *      For example, if `decimals` equals `2`, a balance of `505` tokens should\n\t *      be displayed to a user as `5,05` (`505 / 10 ** 2`).\n\t *\n\t * @dev Tokens usually opt for a value of 18, imitating the relationship between\n\t *      Ether and Wei. This is the value {ERC20} uses, unless this function is\n\t *      overridden;\n\t *\n\t * @dev NOTE: This information is only used for _display_ purposes: it in\n\t *      no way affects any of the arithmetic of the contract, including\n\t *      {IERC20-balanceOf} and {IERC20-transfer}.\n\t *\n\t * @return token decimals\n\t */\n\t// OPTIONAL - This method can be used to improve usability,\n\t// but interfaces and other contracts MUST NOT expect these values to be present.\n\t// function decimals() external view returns (uint8);\n\n\t/**\n\t * @return the amount of tokens in existence\n\t */\n\tfunction totalSupply() external view returns (uint256);\n\n\t/**\n\t * @notice Gets the balance of a particular address\n\t *\n\t * @param _owner the address to query the the balance for\n\t * @return balance an amount of tokens owned by the address specified\n\t */\n\tfunction balanceOf(address _owner) external view returns (uint256 balance);\n\n\t/**\n\t * @notice Transfers some tokens to an external address or a smart contract\n\t *\n\t * @dev Called by token owner (an address which has a\n\t *      positive token balance tracked by this smart contract)\n\t * @dev Throws on any error like\n\t *      * insufficient token balance or\n\t *      * incorrect `_to` address:\n\t *          * zero address or\n\t *          * self address or\n\t *          * smart contract which doesn't support ERC20\n\t *\n\t * @param _to an address to transfer tokens to,\n\t *      must be either an external address or a smart contract,\n\t *      compliant with the ERC20 standard\n\t * @param _value amount of tokens to be transferred,, zero\n\t *      value is allowed\n\t * @return success true on success, throws otherwise\n\t */\n\tfunction transfer(address _to, uint256 _value) external returns (bool success);\n\n\t/**\n\t * @notice Transfers some tokens on behalf of address `_from' (token owner)\n\t *      to some other address `_to`\n\t *\n\t * @dev Called by token owner on his own or approved address,\n\t *      an address approved earlier by token owner to\n\t *      transfer some amount of tokens on its behalf\n\t * @dev Throws on any error like\n\t *      * insufficient token balance or\n\t *      * incorrect `_to` address:\n\t *          * zero address or\n\t *          * same as `_from` address (self transfer)\n\t *          * smart contract which doesn't support ERC20\n\t *\n\t * @param _from token owner which approved caller (transaction sender)\n\t *      to transfer `_value` of tokens on its behalf\n\t * @param _to an address to transfer tokens to,\n\t *      must be either an external address or a smart contract,\n\t *      compliant with the ERC20 standard\n\t * @param _value amount of tokens to be transferred,, zero\n\t *      value is allowed\n\t * @return success true on success, throws otherwise\n\t */\n\tfunction transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n\n\t/**\n\t * @notice Approves address called `_spender` to transfer some amount\n\t *      of tokens on behalf of the owner (transaction sender)\n\t *\n\t * @dev Transaction sender must not necessarily own any tokens to grant the permission\n\t *\n\t * @param _spender an address approved by the caller (token owner)\n\t *      to spend some tokens on its behalf\n\t * @param _value an amount of tokens spender `_spender` is allowed to\n\t *      transfer on behalf of the token owner\n\t * @return success true on success, throws otherwise\n\t */\n\tfunction approve(address _spender, uint256 _value) external returns (bool success);\n\n\t/**\n\t * @notice Returns the amount which _spender is still allowed to withdraw from _owner.\n\t *\n\t * @dev A function to check an amount of tokens owner approved\n\t *      to transfer on its behalf by some other address called \"spender\"\n\t *\n\t * @param _owner an address which approves transferring some tokens on its behalf\n\t * @param _spender an address approved to transfer some tokens on behalf\n\t * @return remaining an amount of tokens approved address `_spender` can transfer on behalf\n\t *      of token owner `_owner`\n\t */\n\tfunction allowance(address _owner, address _spender) external view returns (uint256 remaining);\n}\n\n/**\n * @title Mintable/burnable ERC20 Extension\n *\n * @notice Adds mint/burn functions to ERC20 interface, these functions\n *      are usually present in ERC20 implementations, but these become\n *      a must for the bridged tokens in L2 since the bridge on L2\n *      needs to have a way to mint tokens deposited from L1 to L2\n *      and to burn tokens to be withdrawn from L2 to L1\n */\ninterface MintableBurnableERC20 is ERC20 {\n\t/**\n\t * @dev Mints (creates) some tokens to address specified\n\t * @dev The value specified is treated as is without taking\n\t *      into account what `decimals` value is\n\t *\n\t * @param _to an address to mint tokens to\n\t * @param _value an amount of tokens to mint (create)\n\t */\n\tfunction mint(address _to, uint256 _value) external;\n\n\t/**\n\t * @dev Burns (destroys) some tokens from the address specified\n\t *\n\t * @dev The value specified is treated as is without taking\n\t *      into account what `decimals` value is\n\t *\n\t * @param _from an address to burn some tokens from\n\t * @param _value an amount of tokens to burn (destroy)\n\t */\n\tfunction burn(address _from, uint256 _value) external;\n}\n"
    },
    "contracts/interfaces/layer_zero/ILayerZeroEndpoint.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.4;\n\nimport \"./ILayerZeroUserApplicationConfig.sol\";\n\n/**\n * @author LayerZero, https://layerzero.network/\n */\ninterface ILayerZeroEndpoint is ILayerZeroUserApplicationConfig {\n\t// @notice send a LayerZero message to the specified address at a LayerZero endpoint.\n\t// @param _dstChainId - the destination chain identifier\n\t// @param _destination - the address on destination chain (in bytes). address length/format may vary by chains\n\t// @param _payload - a custom bytes payload to send to the destination contract\n\t// @param _refundAddress - if the source transaction is cheaper than the amount of value passed, refund the additional amount to this address\n\t// @param _zroPaymentAddress - the address of the ZRO token holder who would pay for the transaction\n\t// @param _adapterParams - parameters for custom functionality. e.g. receive airdropped native gas from the relayer on destination\n\tfunction send(uint16 _dstChainId, bytes calldata _destination, bytes calldata _payload, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) external payable;\n\n\t// @notice used by the messaging library to publish verified payload\n\t// @param _srcChainId - the source chain identifier\n\t// @param _srcAddress - the source contract (as bytes) at the source chain\n\t// @param _dstAddress - the address on destination chain\n\t// @param _nonce - the unbound message ordering nonce\n\t// @param _gasLimit - the gas limit for external contract execution\n\t// @param _payload - verified payload to send to the destination contract\n\tfunction receivePayload(uint16 _srcChainId, bytes calldata _srcAddress, address _dstAddress, uint64 _nonce, uint _gasLimit, bytes calldata _payload) external;\n\n\t// @notice get the inboundNonce of a receiver from a source chain which could be EVM or non-EVM chain\n\t// @param _srcChainId - the source chain identifier\n\t// @param _srcAddress - the source chain contract address\n\tfunction getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (uint64);\n\n\t// @notice get the outboundNonce from this source chain which, consequently, is always an EVM\n\t// @param _srcAddress - the source chain contract address\n\tfunction getOutboundNonce(uint16 _dstChainId, address _srcAddress) external view returns (uint64);\n\n\t// @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\n\t// @param _dstChainId - the destination chain identifier\n\t// @param _userApplication - the user app address on this EVM chain\n\t// @param _payload - the custom message to send over LayerZero\n\t// @param _payInZRO - if false, user app pays the protocol fee in native token\n\t// @param _adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain\n\tfunction estimateFees(uint16 _dstChainId, address _userApplication, bytes calldata _payload, bool _payInZRO, bytes calldata _adapterParam) external view returns (uint nativeFee, uint zroFee);\n\n\t// @notice get this Endpoint's immutable source identifier\n\tfunction getChainId() external view returns (uint16);\n\n\t// @notice the interface to retry failed message on this Endpoint destination\n\t// @param _srcChainId - the source chain identifier\n\t// @param _srcAddress - the source chain contract address\n\t// @param _payload - the payload to be retried\n\tfunction retryPayload(uint16 _srcChainId, bytes calldata _srcAddress, bytes calldata _payload) external;\n\n\t// @notice query if any STORED payload (message blocking) at the endpoint.\n\t// @param _srcChainId - the source chain identifier\n\t// @param _srcAddress - the source chain contract address\n\tfunction hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool);\n\n\t// @notice query if the _libraryAddress is valid for sending msgs.\n\t// @param _userApplication - the user app address on this EVM chain\n\tfunction getSendLibraryAddress(address _userApplication) external view returns (address);\n\n\t// @notice query if the _libraryAddress is valid for receiving msgs.\n\t// @param _userApplication - the user app address on this EVM chain\n\tfunction getReceiveLibraryAddress(address _userApplication) external view returns (address);\n\n\t// @notice query if the non-reentrancy guard for send() is on\n\t// @return true if the guard is on. false otherwise\n\tfunction isSendingPayload() external view returns (bool);\n\n\t// @notice query if the non-reentrancy guard for receive() is on\n\t// @return true if the guard is on. false otherwise\n\tfunction isReceivingPayload() external view returns (bool);\n\n\t// @notice get the configuration of the LayerZero messaging library of the specified version\n\t// @param _version - messaging library version\n\t// @param _chainId - the chainId for the pending config change\n\t// @param _userApplication - the contract address of the user application\n\t// @param _configType - type of configuration. every messaging library has its own convention.\n\tfunction getConfig(uint16 _version, uint16 _chainId, address _userApplication, uint _configType) external view returns (bytes memory);\n\n\t// @notice get the send() LayerZero messaging library version\n\t// @param _userApplication - the contract address of the user application\n\tfunction getSendVersion(address _userApplication) external view returns (uint16);\n\n\t// @notice get the lzReceive() LayerZero messaging library version\n\t// @param _userApplication - the contract address of the user application\n\tfunction getReceiveVersion(address _userApplication) external view returns (uint16);\n}\n"
    },
    "contracts/interfaces/layer_zero/ILayerZeroMessagingLibrary.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.4;\n\nimport \"./ILayerZeroUserApplicationConfig.sol\";\n\n/**\n * @author LayerZero, https://layerzero.network/\n */\ninterface ILayerZeroMessagingLibrary {\n\t// send(), messages will be inflight.\n\tfunction send(address _userApplication, uint64 _lastNonce, uint16 _chainId, bytes calldata _destination, bytes calldata _payload, address payable refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) external payable;\n\n\t// estimate native fee at the send side\n\tfunction estimateFees(uint16 _chainId, address _userApplication, bytes calldata _payload, bool _payInZRO, bytes calldata _adapterParam) external view returns (uint nativeFee, uint zroFee);\n\n\t//---------------------------------------------------------------------------\n\t// setConfig / getConfig are User Application (UA) functions to specify Oracle, Relayer, blockConfirmations, libraryVersion\n\tfunction setConfig(uint16 _chainId, address _userApplication, uint _configType, bytes calldata _config) external;\n\n\tfunction getConfig(uint16 _chainId, address _userApplication, uint _configType) external view returns (bytes memory);\n}\n"
    },
    "contracts/interfaces/layer_zero/ILayerZeroMessagingLibraryV2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.4;\n\nimport \"./ILayerZeroUserApplicationConfig.sol\";\nimport \"./ILayerZeroMessagingLibrary.sol\";\n\n/**\n * @author LayerZero, https://layerzero.network/\n */\ninterface ILayerZeroMessagingLibraryV2 is ILayerZeroMessagingLibrary {\n\tfunction getOutboundNonce(uint16 _chainId, bytes calldata _path) external view returns (uint64);\n}\n"
    },
    "contracts/interfaces/layer_zero/ILayerZeroOracle.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.4;\n\n/**\n * @author LayerZero, https://layerzero.network/\n */\ninterface ILayerZeroOracle {\n\t// @notice query the oracle price for relaying block information to the destination chain\n\t// @param _dstChainId the destination endpoint identifier\n\t// @param _outboundProofType the proof type identifier to specify the data to be relayed\n\tfunction getPrice(uint16 _dstChainId, uint16 _outboundProofType) external view returns (uint price);\n\n\t// @notice Ultra-Light Node notifies the Oracle of a new block information relaying request\n\t// @param _dstChainId the destination endpoint identifier\n\t// @param _outboundProofType the proof type identifier to specify the data to be relayed\n\t// @param _outboundBlockConfirmations the number of source chain block confirmation needed\n\tfunction notifyOracle(uint16 _dstChainId, uint16 _outboundProofType, uint64 _outboundBlockConfirmations) external;\n\n\t// @notice query if the address is an approved actor for privileges like data submission and fee withdrawal etc.\n\t// @param _address the address to be checked\n\tfunction isApproved(address _address) external view returns (bool approved);\n}\n"
    },
    "contracts/interfaces/layer_zero/ILayerZeroOracleV2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.4;\n\n/**\n * @author LayerZero, https://layerzero.network/\n */\ninterface ILayerZeroOracleV2 {\n\t// @notice query price and assign jobs at the same time\n\t// @param _dstChainId - the destination endpoint identifier\n\t// @param _outboundProofType - the proof type identifier to specify proof to be relayed\n\t// @param _outboundBlockConfirmation - block confirmation delay before relaying blocks\n\t// @param _userApplication - the source sending contract address\n\tfunction assignJob(uint16 _dstChainId, uint16 _outboundProofType, uint64 _outboundBlockConfirmation, address _userApplication) external returns (uint price);\n\n\t// @notice query the oracle price for relaying block information to the destination chain\n\t// @param _dstChainId the destination endpoint identifier\n\t// @param _outboundProofType the proof type identifier to specify the data to be relayed\n\t// @param _outboundBlockConfirmation - block confirmation delay before relaying blocks\n\t// @param _userApplication - the source sending contract address\n\tfunction getFee(uint16 _dstChainId, uint16 _outboundProofType, uint64 _outboundBlockConfirmation, address _userApplication) external view returns (uint price);\n\n\t// @notice withdraw the accrued fee in ultra light node\n\t// @param _to - the fee receiver\n\t// @param _amount - the withdrawal amount\n\tfunction withdrawFee(address payable _to, uint _amount) external;\n}\n"
    },
    "contracts/interfaces/layer_zero/ILayerZeroReceiver.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.4;\n\n/**\n * @author LayerZero, https://layerzero.network/\n */\ninterface ILayerZeroReceiver {\n\t// @notice LayerZero endpoint will invoke this function to deliver the message on the destination\n\t// @param _srcChainId - the source endpoint identifier\n\t// @param _srcAddress - the source sending contract address from the source chain\n\t// @param _nonce - the ordered message nonce\n\t// @param _payload - the signed payload is the UA bytes has encoded to be sent\n\tfunction lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) external;\n}\n"
    },
    "contracts/interfaces/layer_zero/ILayerZeroRelayer.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.4;\n\n/**\n * @author LayerZero, https://layerzero.network/\n */\ninterface ILayerZeroRelayer {\n\t// @notice query the relayer price for relaying the payload and its proof to the destination chain\n\t// @param _dstChainId - the destination endpoint identifier\n\t// @param _outboundProofType - the proof type identifier to specify proof to be relayed\n\t// @param _userApplication - the source sending contract address. relayers may apply price discrimination to user apps\n\t// @param _payloadSize - the length of the payload. it is an indicator of gas usage for relaying cross-chain messages\n\t// @param _adapterParams - optional parameters for extra service plugins, e.g. sending dust tokens at the destination chain\n\tfunction getPrice(uint16 _dstChainId, uint16 _outboundProofType, address _userApplication, uint _payloadSize, bytes calldata _adapterParams) external view returns (uint price);\n\n\t// @notice Ultra-Light Node notifies the Oracle of a new block information relaying request\n\t// @param _dstChainId - the destination endpoint identifier\n\t// @param _outboundProofType - the proof type identifier to specify the data to be relayed\n\t// @param _adapterParams - optional parameters for extra service plugins, e.g. sending dust tokens at the destination chain\n\tfunction notifyRelayer(uint16 _dstChainId, uint16 _outboundProofType, bytes calldata _adapterParams) external;\n\n\t// @notice query if the address is an approved actor for privileges like data submission and fee withdrawal etc.\n\t// @param _address - the address to be checked\n\tfunction isApproved(address _address) external view returns (bool approved);\n}\n"
    },
    "contracts/interfaces/layer_zero/ILayerZeroRelayerV2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.4;\n\n/**\n * @author LayerZero, https://layerzero.network/\n */\ninterface ILayerZeroRelayerV2 {\n\t// @notice query price and assign jobs at the same time\n\t// @param _dstChainId - the destination endpoint identifier\n\t// @param _outboundProofType - the proof type identifier to specify proof to be relayed\n\t// @param _userApplication - the source sending contract address. relayers may apply price discrimination to user apps\n\t// @param _payloadSize - the length of the payload. it is an indicator of gas usage for relaying cross-chain messages\n\t// @param _adapterParams - optional parameters for extra service plugins, e.g. sending dust tokens at the destination chain\n\tfunction assignJob(uint16 _dstChainId, uint16 _outboundProofType, address _userApplication, uint _payloadSize, bytes calldata _adapterParams) external returns (uint price);\n\n\t// @notice query the relayer price for relaying the payload and its proof to the destination chain\n\t// @param _dstChainId - the destination endpoint identifier\n\t// @param _outboundProofType - the proof type identifier to specify proof to be relayed\n\t// @param _userApplication - the source sending contract address. relayers may apply price discrimination to user apps\n\t// @param _payloadSize - the length of the payload. it is an indicator of gas usage for relaying cross-chain messages\n\t// @param _adapterParams - optional parameters for extra service plugins, e.g. sending dust tokens at the destination chain\n\tfunction getFee(uint16 _dstChainId, uint16 _outboundProofType, address _userApplication, uint _payloadSize, bytes calldata _adapterParams) external view returns (uint price);\n\n\t// @notice withdraw the accrued fee in ultra light node\n\t// @param _to - the fee receiver\n\t// @param _amount - the withdrawal amount\n\tfunction withdrawFee(address payable _to, uint _amount) external;\n}\n"
    },
    "contracts/interfaces/layer_zero/ILayerZeroTreasury.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.4;\n\n/**\n * @author LayerZero, https://layerzero.network/\n */\ninterface ILayerZeroTreasury {\n\tfunction getFees(bool payInZro, uint relayerFee, uint oracleFee) external view returns (uint);\n}\n"
    },
    "contracts/interfaces/layer_zero/ILayerZeroUltraLightNodeV1.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.4;\n\n/**\n * @author LayerZero, https://layerzero.network/\n */\ninterface ILayerZeroUltraLightNodeV1 {\n\t// a Relayer can execute the validateTransactionProof()\n\tfunction validateTransactionProof(uint16 _srcChainId, address _dstAddress, uint _gasLimit, bytes32 _lookupHash, bytes calldata _transactionProof) external;\n\n\t// an Oracle delivers the block data using updateHash()\n\tfunction updateHash(uint16 _remoteChainId, bytes32 _lookupHash, uint _confirmations, bytes32 _data) external;\n\n\t// can only withdraw the receivable of the msg.sender\n\tfunction withdrawNative(uint8 _type, address _owner, address payable _to, uint _amount) external;\n\n\tfunction withdrawZRO(address _to, uint _amount) external;\n\n\t// view functions\n\tfunction oracleQuotedAmount(address _oracle) external view returns (uint);\n\n\tfunction relayerQuotedAmount(address _relayer) external view returns (uint);\n}\n"
    },
    "contracts/interfaces/layer_zero/ILayerZeroUltraLightNodeV2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.4;\n\n/**\n * @author LayerZero, https://layerzero.network/\n */\ninterface ILayerZeroUltraLightNodeV2 {\n\t// Relayer functions\n\tfunction validateTransactionProof(uint16 _srcChainId, address _dstAddress, uint _gasLimit, bytes32 _lookupHash, bytes32 _blockData, bytes calldata _transactionProof) external;\n\n\t// an Oracle delivers the block data using updateHash()\n\tfunction updateHash(uint16 _srcChainId, bytes32 _lookupHash, uint _confirmations, bytes32 _blockData) external;\n\n\t// can only withdraw the receivable of the msg.sender\n\tfunction withdrawNative(address payable _to, uint _amount) external;\n\n\tfunction withdrawZRO(address _to, uint _amount) external;\n\n\t// view functions\n\tfunction getAppConfig(uint16 _remoteChainId, address _userApplicationAddress) external view returns (ApplicationConfiguration memory);\n\n\tfunction accruedNativeFee(address _address) external view returns (uint);\n\n\tstruct ApplicationConfiguration {\n\t\tuint16 inboundProofLibraryVersion;\n\t\tuint64 inboundBlockConfirmations;\n\t\taddress relayer;\n\t\tuint16 outboundProofType;\n\t\tuint64 outboundBlockConfirmations;\n\t\taddress oracle;\n\t}\n\n\tevent HashReceived(uint16 indexed srcChainId, address indexed oracle, bytes32 lookupHash, bytes32 blockData, uint confirmations);\n\tevent RelayerParams(bytes adapterParams, uint16 outboundProofType);\n\tevent Packet(bytes payload);\n\tevent InvalidDst(uint16 indexed srcChainId, bytes srcAddress, address indexed dstAddress, uint64 nonce, bytes32 payloadHash);\n\tevent PacketReceived(uint16 indexed srcChainId, bytes srcAddress, address indexed dstAddress, uint64 nonce, bytes32 payloadHash);\n\tevent AppConfigUpdated(address indexed userApplication, uint indexed configType, bytes newConfig);\n\tevent AddInboundProofLibraryForChain(uint16 indexed chainId, address lib);\n\tevent EnableSupportedOutboundProof(uint16 indexed chainId, uint16 proofType);\n\tevent SetChainAddressSize(uint16 indexed chainId, uint size);\n\tevent SetDefaultConfigForChainId(uint16 indexed chainId, uint16 inboundProofLib, uint64 inboundBlockConfirm, address relayer, uint16 outboundProofType, uint64 outboundBlockConfirm, address oracle);\n\tevent SetDefaultAdapterParamsForChainId(uint16 indexed chainId, uint16 indexed proofType, bytes adapterParams);\n\tevent SetLayerZeroToken(address indexed tokenAddress);\n\tevent SetRemoteUln(uint16 indexed chainId, bytes32 uln);\n\tevent SetTreasury(address indexed treasuryAddress);\n\tevent WithdrawZRO(address indexed msgSender, address indexed to, uint amount);\n\tevent WithdrawNative(address indexed msgSender, address indexed to, uint amount);\n}\n"
    },
    "contracts/interfaces/layer_zero/ILayerZeroUserApplicationConfig.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.4;\n\n/**\n * @author LayerZero, https://layerzero.network/\n */\ninterface ILayerZeroUserApplicationConfig {\n\t// @notice set the configuration of the LayerZero messaging library of the specified version\n\t// @param _version - messaging library version\n\t// @param _chainId - the chainId for the pending config change\n\t// @param _configType - type of configuration. every messaging library has its own convention.\n\t// @param _config - configuration in the bytes. can encode arbitrary content.\n\tfunction setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external;\n\n\t// @notice set the send() LayerZero messaging library version to _version\n\t// @param _version - new messaging library version\n\tfunction setSendVersion(uint16 _version) external;\n\n\t// @notice set the lzReceive() LayerZero messaging library version to _version\n\t// @param _version - new messaging library version\n\tfunction setReceiveVersion(uint16 _version) external;\n\n\t// @notice Only when the UA needs to resume the message flow in blocking mode and clear the stored payload\n\t// @param _srcChainId - the chainId of the source chain\n\t// @param _srcAddress - the contract address of the source contract at the source chain\n\tfunction forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external;\n}\n"
    },
    "contracts/layer_zero/LzERC20ChildTunnelV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/layer_zero/ILayerZeroEndpoint.sol\";\nimport \"../interfaces/layer_zero/ILayerZeroReceiver.sol\";\n\nimport \"../interfaces/ERC20Spec.sol\";\nimport \"../utils/UpgradeableAccessControl.sol\";\n\n/**\n * @title LayerZero ERC20 Child Tunnel\n *\n * @notice Non-Ethereum network (child chain - L2) exit of the ERC20 tunnel,\n *      can be used for Non-Ethereum mainnet and testnet networks (ex. Polygon/Mumbai)\n *\n * @notice The tunnel is used to bridge specific ERC20 token between L1/L2;\n *      we call L1 -> L2 bridging a \"deposit\", L2 -> L1 a \"withdrawal\"\n *\n * @notice The tunnel has two entrances and two exits:\n *       LzERC20RootTunnel contains Root/L1 entrance and exit,\n *       and LzERC20ChildTunnel contains Child/L2 entrance and exit\n *\n * @notice All exits and child entrance are always open, while root entrance\n *      may get paused or even closed permanently\n *\n * @notice Deposit flow:\n *      1. The user initiates a deposit on the L1 entrance by executing the deposit function\n *         `LzERC20RootTunnel.deposit` or `LzERC20RootTunnel.depositTo`\n *      2. LayerZero messaging system picks up the event emitted by the `deposit` call\n *         and delivers it to L2 chain\n *      3. The deposit completes on the L2 exit when LayerZero messaging system executes\n *         the `LzERC20ChildTunnel.lzReceive` function\n *      Note: overall, the user executes only one function and then just waits for the bridge\n *         operation to complete\n *\n * @notice Withdrawal flow:\n *      1. The user initiates a withdrawal on the L2 entrance by executing the withdraw function\n *         `LzERC20ChildTunnel.withdraw` or `LzERC20ChildTunnel.withdrawTo`\n *      2. LayerZero messaging system picks up the event emitted by the `withdraw` call\n *         and delivers it to L1 chain\n *      3. The withdrawal completes on the L1 exit when LayerZero messaging system executes\n *         the `LzERC20RootTunnel.lzReceive` function\n *      Note: overall, the user executes only one function and then just waits for the bridge\n *         operation to complete\n *\n * @dev see https://github.com/LayerZero-Labs/LayerZero\n * @dev see https://github.com/LayerZero-Labs/solidity-examples\n *\n * @author Basil Gorin\n */\ncontract LzERC20ChildTunnelV1 is ILayerZeroReceiver, ILayerZeroUserApplicationConfig, UpgradeableAccessControl {\n\t/**\n\t * @notice The tunnel is strictly bound to the LayerZero Endpoint\n\t *\n\t * @dev LayerZero Endpoint cannot be changed in the current implementation\n\t */\n\tILayerZeroEndpoint public /*immutable*/ lzEndpoint;\n\n\t/**\n\t * @notice Child tunnel is strictly bound to the child ERC20 token\n\t */\n\tMintableBurnableERC20 public /*immutable*/ childToken;\n\n\t/**\n\t * @notice LayerZero specific chainId where the LzERC20RootTunnel is deployed\n\t *\n\t * @dev Incoming messages must specify this chainId in order to be accepted\n\t *      see https://layerzero.gitbook.io/docs/technical-reference/mainnet/supported-chain-ids\n\t *      see https://layerzero.gitbook.io/docs/technical-reference/testnet/testnet-addresses\n\t */\n\tuint16 public rootTunnelChainId;\n\n\t/**\n\t * @notice The address of the deployed LzERC20RootTunnel which is bound to this LzERC20ChildTunnel\n\t *\n\t * @dev Incoming messages must specify this LzERC20RootTunnel address in order to be accepted\n\t */\n\taddress public rootTunnelAddress;\n\n\t/**\n\t * @dev Used nonces storage. We use bitmap map (uint256 => uint256)\n\t *      instead of (uint256 => bool) map to save on storage\n\t *\n\t * @dev The bit corresponding to nonce `i` is located at the position `i % 256` in the slot number i / 256\n\t */\n\tmapping(uint256 => uint256) private usedNoncesBitmap;\n\n\t/**\n\t * @notice People do mistakes and may send tokens by mistake\n\t *\n\t * @notice Rescue manager is responsible for \"rescuing\" ERC20/ERC721 tokens\n\t *      accidentally sent to the smart contract\n\t *\n\t * @dev Role ROLE_RESCUE_MANAGER allows withdrawing non-bridged ERC20/ERC721\n\t *      tokens stored on the smart contract balance via `rescueTokens` function\n\t */\n\tuint32 public constant ROLE_RESCUE_MANAGER = 0x0001_0000;\n\n\t/**\n\t * @notice Config manager is responsible for tunnel configuration, manager is\n\t *      allowed to access LZ Endpoint configuration functions via the tunnel\n\t *\n\t * @dev Role ROLE_CONFIG_MANAGER allows accessing LZ Endpoint configuration related\n\t *      functions: `setConfig`, `setSendVersion`, `setReceiveVersion`, and `forceResumeReceive`\n\t */\n\tuint32 public constant ROLE_CONFIG_MANAGER = 0x0002_0000;\n\n\t/**\n\t * @dev Fired in `lzReceive` when token deposit completes successfully\n\t *\n\t * @param stateId unique tx identifier submitted from the root chain (L1)\n\t * @param from token sender address in the root chain (L1)\n\t * @param to token receiver address in the child chain (L2)\n\t * @param value amount of tokens deposited\n\t */\n\tevent DepositComplete(uint256 indexed stateId, address indexed from, address indexed to, uint256 value);\n\n\t/**\n\t * @dev Fired in `lzReceive` if incoming message cannot be accepted\n\t *      due to any revert-like exception thrown (deposit doesn't complete successfully)\n\t *\n\t * @param chainId chainId as delivered by the LayerZero endpoint\n\t * @param srcAddress srcAddress (root|child tunnel addr) as delivered by the LayerZero endpoint\n\t * @param nonce nonce as delivered by the LayerZero endpoint\n\t * @param payload payload as delivered by the LayerZero endpoint\n\t * @param error failure error reason, can be also empty\n\t */\n\tevent LzReceiveError(uint16 chainId, bytes srcAddress, uint64 nonce, bytes payload, string error);\n\n\t/**\n\t * @dev Fired in `lzReceive` if incoming message cannot be accepted\n\t *      due to any assert-like exception thrown (deposit doesn't complete successfully)\n\t *\n\t * @param chainId chainId as delivered by the LayerZero endpoint\n\t * @param srcAddress srcAddress (root|child tunnel addr) as delivered by the LayerZero endpoint\n\t * @param nonce nonce as delivered by the LayerZero endpoint\n\t * @param payload payload as delivered by the LayerZero endpoint\n\t * @param error failure error reason, can be also empty\n\t */\n\tevent LzReceiveError(uint16 chainId, bytes srcAddress, uint64 nonce, bytes payload, bytes error);\n\n\t/**\n\t * @dev Fired in `withdraw` and `withdrawTo`\n\t *\n\t * @param from token sender address in the child chain (L2)\n\t * @param to token receiver address in the root chain (L1)\n\t * @param value amount of tokens withdrawn\n\t */\n\tevent WithdrawalInitiated(address indexed from, address indexed to, uint256 value);\n\n\t/**\n\t * @dev \"Constructor replacement\" for upgradeable, must be execute immediately after deployment\n\t *      see https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#initializers\n\t *\n\t * @dev Initializes an Non-Ethereum network (L2) exit bound to\n\t *      LayerZero Endpoint, and child ERC20 token\n\t * @dev LayerZero Endpoint is a helper contract providing\n\t *      L1/L2 messaging infrastructure, managed by the LayerZero\n\t *\n\t * @param _lzEndpoint LayerZero Endpoint contract address (maintained by LayerZero)\n\t * @param _childToken child ERC20 token address\n\t */\n\tfunction postConstruct(address _lzEndpoint, address _childToken) public initializer {\n\t\t// verify the inputs are set\n\t\trequire(_lzEndpoint != address(0), \"LZ endpoint not set\");\n\t\trequire(_childToken != address(0), \"child token not set\");\n\n\t\t// initialize contract internal state\n\t\tlzEndpoint = ILayerZeroEndpoint(_lzEndpoint);\n\t\tchildToken = MintableBurnableERC20(_childToken);\n\n\t\t// execute all parent initializers in cascade\n\t\tUpgradeableAccessControl._postConstruct(msg.sender);\n\t}\n\n\t/**\n\t * @dev Sets the rootTunnel if it is not yet set\n\t *\n\t * @param _rootTunnelChainId root tunnel chain ID to set\n\t * @param _rootTunnelAddress root tunnel address to set\n\t */\n\tfunction setRootTunnel(uint16 _rootTunnelChainId, address _rootTunnelAddress) public {\n\t\t// `setRootTunnel` must be executed during the deployment process by\n\t\t// the same account which is making a deployment (full admin)\n\t\trequire(isSenderInRole(type(uint256).max), \"access denied\");\n\n\t\t// verify the chain ID is set (not zero)\n\t\trequire(_rootTunnelChainId != 0, \"zero chain ID\");\n\t\t// verify the address is set (not zero)\n\t\trequire(_rootTunnelAddress != address(0), \"zero address\");\n\n\t\t// verify the address is not yet set on the contract\n\t\trequire(rootTunnelChainId == 0 && rootTunnelAddress == address(0), \"root tunnel already set\");\n\n\t\t// set the tunnel\n\t\trootTunnelChainId = _rootTunnelChainId;\n\t\trootTunnelAddress = _rootTunnelAddress;\n\t}\n\n\t/**\n\t * @notice L2 Tunnel Exit.\n\t *      L2 Tunnel is always open in both directions.\n\t *\n\t * @inheritdoc ILayerZeroReceiver\n\t */\n\tfunction lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) public override {\n\t\t// verify the message comes from the expected endpoint\n\t\trequire(msg.sender == address(lzEndpoint), \"unexpected endpoint\");\n\n\t\t// throwing an error would prevent the LZ endpoint from sending\n\t\t// new transactions with new nonces\n\t\t// therefore we extract the logic which may throw an exception and log the error if any\n\t\ttry LzERC20ChildTunnelV1(this).__lzReceive(_srcChainId, _srcAddress, _nonce, _payload) {}\n\t\t// catch revert like errors\n\t\tcatch Error(string memory reason) {\n\t\t\t// log the input params and error\n\t\t\temit LzReceiveError(_srcChainId, _srcAddress, _nonce, _payload, reason);\n\t\t}\n\t\t// catch assert like errors\n\t\tcatch(bytes memory reason) {\n\t\t\t// log the input params and error\n\t\t\temit LzReceiveError(_srcChainId, _srcAddress, _nonce, _payload, reason);\n\t\t}\n\t}\n\n\t/**\n\t * @dev Auxiliary function which can be executed only within the smart contract itself\n\t *      Effectively private (internal) as it is not callable by other contracts or EOAs\n\t *\n\t * @dev Wrapped by the ILayerZeroReceiver lzReceive catching any error and logging it\n\t *      See `ILayerZeroReceiver.lzReceive`\n\t */\n\tfunction __lzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes calldata _payload) external {\n\t\t// verify the message comes from the contract itself (from the try...catch call)\n\t\trequire(msg.sender == address(this), \"access denied\");\n\t\t// verify the message comes from the expected network\n\t\trequire(_srcChainId == rootTunnelChainId, \"unexpected root network\");\n\n\t\t// decode source/destination tunnel information\n\t\t// since _srcAddress is abi.encodePacked(_rootTunnel, _childTunnel)\n\t\t// this cannot be unpacked with abi.decode, but only with assembly\n\t\taddress _rootTunnel;\n\t\taddress _childTunnel;\n\t\tassembly {\n\t\t\t// see https://ethereum.stackexchange.com/questions/143522/how-to-decode-encodepacked-data\n\t\t\t_rootTunnel := mload(add(_srcAddress, 20))\n\t\t\t_childTunnel := mload(add(_srcAddress, 40))\n\t\t}\n\n\t\t// verify the message comes from the expected root tunnel\n\t\trequire(_rootTunnel == rootTunnelAddress, \"unexpected root tunnel\");\n\t\t// verify the message is intended for the expected child tunnel\n\t\trequire(_childTunnel == address(this), \"unexpected child tunnel\");\n\n\t\t// verify same nonce is not used twice and marked nonce as used\n\t\t__useNonce(_nonce);\n\n\t\t// decode the message from the root\n\t\t// format: sender, recipient, amount\n\t\t(address _from, address _to, uint256 _value) = abi.decode(_payload, (address, address, uint256));\n\n\t\t// mint the requested amount of tokens in the child chain\n\t\tchildToken.mint(_to, _value);\n\n\t\t// emit an event\n\t\temit DepositComplete(_nonce, _from, _to, _value);\n\t}\n\n\t/**\n\t * @dev Auxiliary function to verify if nonce wasn't yet used and marks it as used\n\t *\n\t * @param _nonce unique nonce to verify/mark as used\n\t */\n\tfunction __useNonce(uint64 _nonce) private {\n\t\t// verify the nonce is not yet used\n\t\trequire(usedNoncesBitmap[_nonce / 256] & 1 << _nonce % 256 == 0, \"nonce already used\");\n\n\t\t// mark the nonce as used\n\t\tusedNoncesBitmap[_nonce / 256] |= 1 << _nonce % 256;\n\t}\n\n\t/**\n\t * @notice L2 Tunnel Entrance.\n\t *      L2 Tunnel is always open in both directions.\n\t *\n\t * @notice Initiates the withdrawal from the child chain (L2) into the root chain (L1)\n\t *      to the same address which initiated the withdrawal process\n\t *\n\t * @notice The process is finalized in the root chain (L1) via the\n\t *      `LzERC20RootTunnel.lzReceive` without the user/initiator participation\n\t *\n\t * @notice User pays for the withdrawal message delivery in native currency.\n\t *      The amount to be payed can be estimated with `estimateWithdrawalFee`\n\t *\n\t * @notice Specified amount of tokens is burnt from the sender,\n\t *      user may need to make sure this amount is approved for transfer/burning\n\t *\n\t * @param _value amount of tokens to withdraw\n\t */\n\tfunction withdraw(uint256 _value) public payable {\n\t\t// delegate to `withdrawTo`\n\t\twithdrawTo(msg.sender, _value);\n\t}\n\n\t/**\n\t * @notice L2 Tunnel Entrance.\n\t *      L2 Tunnel is always open in both directions.\n\t *\n\t * @notice Initiates the withdrawal from the child chain (L2) into the root chain (L1)\n\t *\n\t * @notice The process is finalized in the root chain (L1) via the\n\t *      `LzERC20RootTunnel.lzReceive` without the user/initiator participation\n\t *\n\t * @notice User pays for the withdrawal message delivery in native currency.\n\t *      The amount to be payed can be estimated with `estimateWithdrawalFee`\n\t *\n\t * @notice Specified amount of tokens is burnt from the sender,\n\t *      user may need to make sure this amount is approved for transfer/burning\n\t *\n\t * @param _to token recipient in the root chain (L1)\n\t * @param _value amount of tokens to withdraw\n\t */\n\tfunction withdrawTo(address _to, uint256 _value) public payable {\n\t\t// burn the requested amount of tokens in the child chain\n\t\tchildToken.burn(msg.sender, _value);\n\n\t\t// notify the L1 about the withdrawal\n\t\t__withdrawalNotify(msg.sender, _to, _value);\n\t}\n\n\t/**\n\t * @dev Notifies the L1 about the initiated withdrawal\n\t *\n\t * @dev Unsafe: doesn't verify the executor (msg.sender) permissions,\n\t *      must be kept private at all times\n\t *\n\t * @param _from token sender in the child chain (in L2)\n\t * @param _to token recipient in the root chain (in L1)\n\t * @param _value amount of tokens withdrawn\n\t */\n\tfunction __withdrawalNotify(address _from, address _to, uint256 _value) private {\n\t\t// send message to the root to unlock equal amount of tokens in the root chain\n\t\t// format: sender, recipient, amount\n\t\t__sendMessageToRoot(abi.encode(_from, _to, _value));\n\n\t\t// emit an event\n\t\temit WithdrawalInitiated(_from, _to, _value);\n\t}\n\n\t/**\n\t * @notice Estimates the token transfer fee from L2 to L1; this should be supplied\n\t *      as a transaction value into withdraw/withdrawTo\n\t *\n\t * @param _from token sender in the child chain (in L2)\n\t * @param _to token recipient in the root chain (in L1)\n\t * @param _value amount of tokens withdrawn\n\t * @return token transfer fee in wei\n\t */\n\tfunction estimateWithdrawalFee(address _from, address _to, uint256 _value) public view returns (uint256) {\n\t\t// delegate to `__estimateMessageFee`\n\t\treturn __estimateMessageFee(abi.encode(_from, _to, _value));\n\t}\n\n\t/**\n\t * @dev Estimates the message transfer fee from L2 to L1; this should be supplied\n\t *      as a transaction value into withdraw/withdrawTo\n\t *\n\t * @param message to deliver from the child chain (L2) into the root chain (L1)\n\t * @return message transfer fee in wei\n\t */\n\tfunction __estimateMessageFee(bytes memory message) private view returns (uint256) {\n\t\t// estimate fee based on the message input\n\t\t(uint256 fee,) = lzEndpoint.estimateFees(\n\t\t\trootTunnelChainId,\n\t\t\taddress(this),\n\t\t\tmessage,\n\t\t\tfalse, // set _payInZRO to false\n\t\t\tbytes(\"\")\n\t\t);\n\t\t// return the result\n\t\treturn fee;\n\t}\n\n\t/**\n\t * @dev Auxiliary function to send the token transfer message from\n\t *      the child chain (L2) into the root chain (L1)\n\t *\n\t * @dev Evaluates the message transfer fee and tries to supply this fee\n\t *      Throws if sender didn't supply enough value to cover the fee\n\t *      Returns any excess of the funds sent back to sender\n\t */\n\tfunction __sendMessageToRoot(bytes memory message) private {\n\t\t// estimate message fee\n\t\tuint256 fee = __estimateMessageFee(message);\n\n\t\t// make sure the message sending is paid\n\t\trequire(msg.value >= fee, \"send underpriced\");\n\n\t\t// send the message\n\t\tlzEndpoint.send{value: fee}(\n\t\t\trootTunnelChainId,\n\t\t\tabi.encodePacked(rootTunnelAddress, address(this)),\n\t\t\tmessage,\n\t\t\tpayable(msg.sender),\n\t\t\taddress(0),\n\t\t\tbytes(\"\")\n\t\t);\n\n\t\t// if sender sent more than required\n\t\tif(msg.value > fee) {\n\t\t\t// send the delta back to sender\n\t\t\tpayable(msg.sender).transfer(msg.value - fee);\n\t\t}\n\t}\n\n\t/**\n\t * @inheritdoc ILayerZeroUserApplicationConfig\n\t *\n\t * @notice Restricted access function to execute `setConfig` function on the LZ Endpoint\n\t *      set the configuration of the LayerZero messaging library of the specified version\n\t *\n\t * @dev Requires sender to have ROLE_CONFIG_MANAGER permission\n\t *\n\t * @param _version - messaging library version\n\t * @param _chainId - the chainId for the pending config change\n\t * @param _configType - type of configuration. every messaging library has its own convention.\n\t * @param _config - configuration in the bytes. can encode arbitrary content.\n\t */\n\tfunction setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) public override {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_CONFIG_MANAGER), \"access denied\");\n\n\t\t// delegate to `setConfig`\n\t\tlzEndpoint.setConfig(_version, _chainId, _configType, _config);\n\t}\n\n\t/**\n\t * @inheritdoc ILayerZeroUserApplicationConfig\n\t *\n\t * @notice Restricted access function to execute `setSendVersion` function on the LZ Endpoint\n\t *      set the send() LayerZero messaging library version to _version\n\t *\n\t * @dev Requires sender to have ROLE_CONFIG_MANAGER permission\n\t *\n\t * @param _version - new messaging library version\n\t */\n\tfunction setSendVersion(uint16 _version) public override {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_CONFIG_MANAGER), \"access denied\");\n\n\t\t// delegate to `setSendVersion`\n\t\tlzEndpoint.setSendVersion(_version);\n\t}\n\n\t/**\n\t * @inheritdoc ILayerZeroUserApplicationConfig\n\t *\n\t * @notice Restricted access function to execute `setReceiveVersion` function on the LZ Endpoint\n\t *      set the lzReceive() LayerZero messaging library version to _version\n\t *\n\t * @dev Requires sender to have ROLE_CONFIG_MANAGER permission\n\t *\n\t * @param _version - new messaging library version\n\t */\n\tfunction setReceiveVersion(uint16 _version) public override {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_CONFIG_MANAGER), \"access denied\");\n\n\t\t// delegate to `setReceiveVersion`\n\t\tlzEndpoint.setReceiveVersion(_version);\n\t}\n\n\t/**\n\t * @inheritdoc ILayerZeroUserApplicationConfig\n\t *\n\t * @notice Restricted access function to execute `forceResumeReceive` function on the LZ Endpoint\n\t *      Only when the UA needs to resume the message flow in blocking mode and clear the stored payload\n\t *\n\t * @dev Requires sender to have ROLE_CONFIG_MANAGER permission\n\t *\n\t * @param _srcChainId - the chainId of the source chain\n\t * @param _srcAddress - the contract address of the source contract at the source chain\n\t */\n\tfunction forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) public override {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_CONFIG_MANAGER), \"access denied\");\n\n\t\t// delegate to `forceResumeReceive`\n\t\tlzEndpoint.forceResumeReceive(_srcChainId, _srcAddress);\n\t}\n\n\t/**\n\t * @dev Restricted access function to rescue accidentally sent tokens,\n\t *      the tokens are rescued via `transferFrom` function call on the\n\t *      contract address specified and with the parameters specified:\n\t *      `_contract.transferFrom(this, _to, _value)`\n\t *\n\t * @dev Requires executor to have `ROLE_RESCUE_MANAGER` permission\n\t *\n\t * @param _contract smart contract address to execute `transfer` function on\n\t * @param _to to address in `transferFrom(this, _to, _value)`\n\t * @param _value value to transfer in `transferFrom(this, _to, _value)`;\n\t *      this can also be a tokenId for ERC721 transfer\n\t */\n\tfunction rescueToken(address _contract, address _to, uint256 _value) public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_RESCUE_MANAGER), \"access denied\");\n\n\t\t// perform the transfer as requested, without any checks\n\t\trequire(ERC20(_contract).transferFrom(address(this), _to, _value));\n\t}\n}\n"
    },
    "contracts/layer_zero/LzERC20RootTunnelV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/layer_zero/ILayerZeroEndpoint.sol\";\nimport \"../interfaces/layer_zero/ILayerZeroReceiver.sol\";\n\nimport \"../interfaces/ERC20Spec.sol\";\nimport \"../utils/UpgradeableAccessControl.sol\";\n\n/**\n * @title LayerZero ERC20 Root Tunnel\n *\n * @notice Ethereum network (root chain - L1) exit of the ERC20 tunnel,\n *      can be used for Ethereum mainnet and Goerli testnet networks\n *\n * @notice The tunnel is used to bridge specific ERC20 token between L1/L2;\n *      we call L1 -> L2 bridging a \"deposit\", L2 -> L1 a \"withdrawal\"\n *\n * @notice The tunnel has two entrances and two exits:\n *       LzERC20RootTunnel contains Root/L1 entrance and exit,\n *       and LzERC20ChildTunnel contains Child/L2 entrance and exit\n *\n * @notice All exits and child entrance are always open, while root entrance\n *      may get paused or even closed permanently\n *\n * @notice Deposit flow:\n *      1. The user initiates a deposit on the L1 entrance by executing the deposit function\n *         `LzERC20RootTunnel.deposit` or `LzERC20RootTunnel.depositTo`\n *      2. LayerZero messaging system picks up the event emitted by the `deposit` call\n *         and delivers it to L2 chain\n *      3. The deposit completes on the L2 exit when LayerZero messaging system executes\n *         the `LzERC20ChildTunnel.lzReceive` function\n *      Note: overall, the user executes only one function and then just waits for the bridge\n *         operation to complete\n *\n * @notice Withdrawal flow:\n *      1. The user initiates a withdrawal on the L2 entrance by executing the withdraw function\n *         `LzERC20ChildTunnel.withdraw` or `LzERC20ChildTunnel.withdrawTo`\n *      2. LayerZero messaging system picks up the event emitted by the `withdraw` call\n *         and delivers it to L1 chain\n *      3. The withdrawal completes on the L1 exit when LayerZero messaging system executes\n *         the `LzERC20RootTunnel.lzReceive` function\n *      Note: overall, the user executes only one function and then just waits for the bridge\n *         operation to complete\n *\n * @dev see https://github.com/LayerZero-Labs/LayerZero\n * @dev see https://github.com/LayerZero-Labs/solidity-examples\n *\n * @author Basil Gorin\n */\ncontract LzERC20RootTunnelV1 is ILayerZeroReceiver, ILayerZeroUserApplicationConfig, UpgradeableAccessControl {\n\t/**\n\t * @notice The tunnel is strictly bound to the LayerZero Endpoint\n\t *\n\t * @dev LayerZero Endpoint cannot be changed in the current implementation\n\t */\n\tILayerZeroEndpoint public /*immutable*/ lzEndpoint;\n\n\t/**\n\t * @notice Root tunnel is strictly bound to the root ERC20 token\n\t *\n\t * @dev Root token MUST be an ERC20 implementation throwing on non-successful transfers\n\t */\n\tERC20 public /*immutable*/ rootToken;\n\n\t/**\n\t * @notice LayerZero specific chainId where the LzERC20ChildTunnel is deployed\n\t *\n\t * @dev Incoming messages must specify this chainId in order to be accepted\n\t *      see https://layerzero.gitbook.io/docs/technical-reference/mainnet/supported-chain-ids\n\t *      see https://layerzero.gitbook.io/docs/technical-reference/testnet/testnet-addresses\n\t */\n\tuint16 public childTunnelChainId;\n\n\t/**\n\t * @notice The address of the deployed LzERC20ChildTunnel which is bound to this LzERC20RootTunnel\n\t *\n\t * @dev Incoming messages must specify this LzERC20ChildTunnel address in order to be accepted\n\t */\n\taddress public childTunnelAddress;\n\n\t/**\n\t * @dev Used nonces storage. We use bitmap map (uint256 => uint256)\n\t *      instead of (uint256 => bool) map to save on storage\n\t *\n\t * @dev The bit corresponding to nonce `i` is located at the position `i % 256` in the slot number i / 256\n\t */\n\tmapping(uint256 => uint256) private usedNoncesBitmap;\n\n\t/**\n\t * @notice Counter of the amount of tokens locked in the tunnel\n\t *\n\t * @dev This is used to locate accidentally sent tokens which weren't bridged\n\t */\n\tuint256 public lockedInTunnel;\n\n\t/**\n\t * @notice Enables deposits on the tunnel (tunnel entrance)\n\t *      note: withdrawals are always enabled and cannot be disabled\n\t *\n\t * @dev Feature FEATURE_ENTRANCE_OPEN must be enabled in order for\n\t *      deposit functions (`deposit` and `depositTo`) to succeed\n\t */\n\tuint32 public constant FEATURE_ENTRANCE_OPEN = 0x0000_0001;\n\n\t/**\n\t * @notice People do mistakes and may send tokens by mistake\n\t *\n\t * @notice Rescue manager is responsible for \"rescuing\" ERC20/ERC721 tokens\n\t *      accidentally sent to the smart contract\n\t *\n\t * @dev Role ROLE_RESCUE_MANAGER allows withdrawing non-bridged ERC20/ERC721\n\t *      tokens stored on the smart contract balance via `rescueTokens` function\n\t */\n\tuint32 public constant ROLE_RESCUE_MANAGER = 0x0001_0000;\n\n\t/**\n\t * @notice LZ Config Manager is responsible for tunnel configuration, manager is\n\t *      allowed to access LZ Endpoint configuration functions via the tunnel\n\t *\n\t * @dev Role ROLE_LZ_CONFIG_MANAGER allows accessing LZ Endpoint configuration related\n\t *      functions: `setConfig`, `setSendVersion`, `setReceiveVersion`, and `forceResumeReceive`\n\t */\n\tuint32 public constant ROLE_LZ_CONFIG_MANAGER = 0x0002_0000;\n\n\t/**\n\t * @dev Fired in `lzReceive` when token withdrawal completes successfully\n\t *\n\t * @param stateId unique tx identifier submitted from the child chain (L2)\n\t * @param from token sender address in the child chain (L2)\n\t * @param to token receiver address in the root chain (L1)\n\t * @param value amount of tokens withdrawn\n\t */\n\tevent WithdrawalComplete(uint256 indexed stateId, address indexed from, address indexed to, uint256 value);\n\n\t/**\n\t * @dev Fired in `lzReceive` if incoming message cannot be accepted\n\t *      due to any revert-like exception thrown (withdrawal doesn't complete successfully)\n\t *\n\t * @param chainId chainId as delivered by the LayerZero endpoint\n\t * @param srcAddress srcAddress (child|root tunnel addr) as delivered by the LayerZero endpoint\n\t * @param nonce nonce as delivered by the LayerZero endpoint\n\t * @param payload payload as delivered by the LayerZero endpoint\n\t * @param error failure error reason, can be also empty\n\t */\n\tevent LzReceiveError(uint16 chainId, bytes srcAddress, uint64 nonce, bytes payload, string error);\n\n\t/**\n\t * @dev Fired in `lzReceive` if incoming message cannot be accepted\n\t *      due to any assert-like exception thrown (withdrawal doesn't complete successfully)\n\t *\n\t * @param chainId chainId as delivered by the LayerZero endpoint\n\t * @param srcAddress srcAddress (child|root tunnel addr) as delivered by the LayerZero endpoint\n\t * @param nonce nonce as delivered by the LayerZero endpoint\n\t * @param payload payload as delivered by the LayerZero endpoint\n\t * @param error failure error reason, can be also empty\n\t */\n\tevent LzReceiveError(uint16 chainId, bytes srcAddress, uint64 nonce, bytes payload, bytes error);\n\n\t/**\n\t * @dev Fired in `deposit` and `depositTo`\n\t *\n\t * @param from token sender address in the root chain (L1)\n\t * @param to token receiver address in the child chain (L2)\n\t * @param value amount of tokens deposited\n\t */\n\tevent DepositInitiated(address indexed from, address indexed to, uint256 value);\n\n\t/**\n\t * @dev \"Constructor replacement\" for upgradeable, must be execute immediately after deployment\n\t *      see https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#initializers\n\t *\n\t * @dev Initializes an Ethereum network (L1) exit bound to\n\t *      LayerZero Endpoint, and root ERC20 token\n\t * @dev LayerZero Endpoint is a helper contract providing\n\t *      L1/L2 messaging infrastructure, managed by the LayerZero\n\t *\n\t * @param _lzEndpoint LayerZero Endpoint contract address (maintained by LayerZero)\n\t * @param _rootToken root ERC20 token address\n\t */\n\tfunction postConstruct(address _lzEndpoint, address _rootToken) public initializer {\n\t\t// verify the inputs are set\n\t\trequire(_lzEndpoint != address(0), \"LZ endpoint not set\");\n\t\trequire(_rootToken != address(0), \"root token not set\");\n\n\t\t// initialize contract internal state\n\t\tlzEndpoint = ILayerZeroEndpoint(_lzEndpoint);\n\t\trootToken = ERC20(_rootToken);\n\n\t\t// execute all parent initializers in cascade\n\t\tUpgradeableAccessControl._postConstruct(msg.sender);\n\t}\n\n\t/**\n\t * @dev Sets the childTunnel if it is not yet set\n\t *\n\t * @param _childTunnelChainId child tunnel chain ID to set\n\t * @param _childTunnelAddress child tunnel address to set\n\t */\n\tfunction setChildTunnel(uint16 _childTunnelChainId, address _childTunnelAddress) public {\n\t\t// `setChildTunnel` must be executed during the deployment process by\n\t\t// the same account which is making a deployment (full admin)\n\t\trequire(isSenderInRole(type(uint256).max), \"access denied\");\n\n\t\t// verify the chain ID is set (not zero)\n\t\trequire(_childTunnelChainId != 0, \"zero chain ID\");\n\t\t// verify the address is set (not zero)\n\t\trequire(_childTunnelAddress != address(0), \"zero address\");\n\n\t\t// verify the address is not yet set on the contract\n\t\trequire(childTunnelChainId == 0 && childTunnelAddress == address(0), \"child tunnel already set\");\n\n\t\t// set the tunnel\n\t\tchildTunnelChainId = _childTunnelChainId;\n\t\tchildTunnelAddress = _childTunnelAddress;\n\t}\n\n\t/**\n\t * @notice L1 Tunnel Exit.\n\t *      Exit is always open.\n\t *\n\t * @inheritdoc ILayerZeroReceiver\n\t */\n\tfunction lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) public override {\n\t\t// verify the message comes from the correct child tunnel\n\t\trequire(msg.sender == address(lzEndpoint), \"unexpected endpoint\");\n\n\t\t// throwing an error would prevent the LZ endpoint from sending\n\t\t// new transactions with new nonces\n\t\t// therefore we extract the logic which may throw an exception and log the error if any\n\t\ttry LzERC20RootTunnelV1(this).__lzReceive(_srcChainId, _srcAddress, _nonce, _payload) {}\n\t\t// catch revert like errors\n\t\tcatch Error(string memory reason) {\n\t\t\t// log the input params and error\n\t\t\temit LzReceiveError(_srcChainId, _srcAddress, _nonce, _payload, reason);\n\t\t}\n\t\t// catch assert like errors\n\t\tcatch(bytes memory reason) {\n\t\t\t// log the input params and error\n\t\t\temit LzReceiveError(_srcChainId, _srcAddress, _nonce, _payload, reason);\n\t\t}\n\t}\n\n\t/**\n\t * @dev Auxiliary function which can be executed only within the smart contract itself\n\t *      Effectively private (internal) as it is not callable by other contracts or EOAs\n\t *\n\t * @dev Wrapped by the ILayerZeroReceiver lzReceive catching any error and logging it\n\t *      See `ILayerZeroReceiver.lzReceive`\n\t */\n\tfunction __lzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes calldata _payload) external {\n\t\t// verify the message comes from the contract itself (from the try...catch call)\n\t\trequire(msg.sender == address(this), \"access denied\");\n\t\t// verify the message comes from the expected network\n\t\trequire(_srcChainId == childTunnelChainId, \"unexpected child network\");\n\n\t\t// decode source/destination tunnel information\n\t\t// since _srcAddress is abi.encodePacked(_rootTunnel, _childTunnel)\n\t\t// this cannot be unpacked with abi.decode, but only with assembly\n\t\taddress _childTunnel;\n\t\taddress _rootTunnel;\n\t\tassembly {\n\t\t// see https://ethereum.stackexchange.com/questions/143522/how-to-decode-encodepacked-data\n\t\t\t_childTunnel := mload(add(_srcAddress, 20))\n\t\t\t_rootTunnel := mload(add(_srcAddress, 40))\n\t\t}\n\n\t\t// verify the message comes from the expected root tunnel\n\t\trequire(_childTunnel == childTunnelAddress, \"unexpected child tunnel\");\n\t\t// verify the message is intended for the expected child tunnel\n\t\trequire(_rootTunnel == address(this), \"unexpected root tunnel\");\n\n\t\t// verify same nonce is not used twice and marked nonce as used\n\t\t__useNonce(_nonce);\n\n\t\t// decode the message from the child\n\t\t// format: sender, recipient, amount\n\t\t(address _from, address _to, uint256 _value) = abi.decode(_payload, (address, address, uint256));\n\n\t\t// unlock the tokens from the contract by transferring them to the recipient\n\t\trootToken.transfer(_to, _value);\n\n\t\t// update locked tokens counter\n\t\tlockedInTunnel -= _value;\n\n\t\t// emit an event\n\t\temit WithdrawalComplete(_nonce, _from, _to, _value);\n\t}\n\n\t/**\n\t * @dev Auxiliary function to verify if nonce wasn't yet used and marks it as used\n\t *\n\t * @param _nonce unique nonce to verify/mark as used\n\t */\n\tfunction __useNonce(uint64 _nonce) private {\n\t\t// verify the nonce is not yet used\n\t\trequire(usedNoncesBitmap[_nonce / 256] & 1 << _nonce % 256 == 0, \"nonce already used\");\n\n\t\t// mark the nonce as used\n\t\tusedNoncesBitmap[_nonce / 256] |= 1 << _nonce % 256;\n\t}\n\n\t/**\n\t * @notice L1 Tunnel Entrance.\n\t *      Entrance can be closed/opened by the tunnel manager.\n\t *\n\t * @notice Initiates the deposit from the root chain (L1) to the child chain (L2)\n\t *      to the same address which initiated the deposit process\n\t *\n\t * @notice The process is finalized in the child chain (L2) via the\n\t *      `ERC20ChildTunnel.lzReceive` without the user/initiator participation\n\t *\n\t * @notice User pays for the deposit message delivery in native currency.\n\t *      The amount to be payed can be estimated with `estimateDepositFee`\n\t *\n\t * @notice Specified amount of tokens is transferred into the tunnel and locked,\n\t *      user needs to make sure this amount is approved for transfer\n\t *\n\t * @param _value amount of tokens to deposit\n\t */\n\tfunction deposit(uint256 _value) public payable {\n\t\t// delegate to `depositTo`\n\t\tdepositTo(msg.sender, _value);\n\t}\n\n\t/**\n\t * @notice L1 Tunnel Entrance.\n\t *      Entrance can be closed/opened by the tunnel manager.\n\t *\n\t * @notice Initiates the deposit from L1 to L2\n\t *\n\t * @notice The process is finalized in the child chain (L2) via the\n\t *      `ERC20ChildTunnel.lzReceive` without user/initiator participation\n\t *\n\t * @notice User pays for the deposit message delivery in native currency.\n\t *      The amount to be payed can be estimated with `estimateDepositFee`\n\t *\n\t * @notice Specified amount of tokens is transferred into the tunnel and locked,\n\t *      user needs to make sure this amount is approved for transfer\n\t *\n\t * @param _to token recipient in the child chain (in L2)\n\t * @param _value amount of tokens to deposit\n\t */\n\tfunction depositTo(address _to, uint256 _value) public payable {\n\t\t// verify tunnel entrance is open\n\t\trequire(isFeatureEnabled(FEATURE_ENTRANCE_OPEN), \"entrance closed\");\n\n\t\t// lock the tokens in the contract by transferring them from sender\n\t\t// in general one should check the return value of ERC20 transfer\n\t\t// we work here only with ERC20 implementations throwing on any error\n\t\trootToken.transferFrom(msg.sender, address(this), _value);\n\n\t\t// notify the L2 about the deposit\n\t\t__depositNotify(msg.sender, _to, _value);\n\t}\n\n\t/**\n\t * @dev Notifies the L2 about the initiated deposit\n\t *\n\t * @dev Unsafe: doesn't verify the executor (msg.sender) permissions,\n\t *      must be kept private at all times\n\t *\n\t * @param _from token sender in the root chain (in L1)\n\t * @param _to token recipient in the child chain (in L2)\n\t * @param _value amount of tokens deposited\n\t */\n\tfunction __depositNotify(address _from, address _to, uint256 _value) private {\n\t\t// update locked tokens counter\n\t\tlockedInTunnel += _value;\n\n\t\t// send a message to the child tunnel about the deposit made\n\t\t// format: sender, recipient, amount\n\t\t__sendMessageToChild(abi.encode(_from, _to, _value));\n\n\t\t// emit an event\n\t\temit DepositInitiated(_from, _to, _value);\n\t}\n\n\t/**\n\t * @notice Estimates the token transfer fee from L1 to L2; this should be supplied\n\t *      as a transaction value into deposit/depositTo\n\t *\n\t * @param _from token sender in the root chain (in L1)\n\t * @param _to token recipient in the child chain (in L2)\n\t * @param _value amount of tokens withdrawn\n\t * @return token transfer fee in wei\n\t */\n\tfunction estimateDepositFee(address _from, address _to, uint256 _value) public view returns (uint256) {\n\t\t// delegate to `__estimateMessageFee`\n\t\treturn __estimateMessageFee(abi.encode(_from, _to, _value));\n\t}\n\n\t/**\n\t * @dev Estimates the message transfer fee from L1 to L2; this should be supplied\n\t *      as a transaction value into deposit/depositTo\n\t *\n\t * @param message to deliver from the root chain (L1) into the child chain (L2)\n\t * @return message transfer fee in wei\n\t */\n\tfunction __estimateMessageFee(bytes memory message) private view returns (uint256) {\n\t\t// estimate fee based on the message input\n\t\t(uint256 fee,) = lzEndpoint.estimateFees(\n\t\t\tchildTunnelChainId,\n\t\t\taddress(this),\n\t\t\tmessage,\n\t\t\tfalse, // set _payInZRO to false\n\t\t\tbytes(\"\")\n\t\t);\n\t\t// return the result\n\t\treturn fee;\n\t}\n\n\t/**\n\t * @dev Auxiliary function to send the token transfer message from\n\t *      the root chain (L1) into the child chain (L2)\n\t *\n\t * @dev Evaluates the message transfer fee and tries to supply this fee\n\t *      Throws if sender didn't supply enough value to cover the fee\n\t *      Returns any excess of the funds sent back to sender\n\t */\n\tfunction __sendMessageToChild(bytes memory message) private {\n\t\t// estimate message fee\n\t\tuint256 fee = __estimateMessageFee(message);\n\n\t\t// make sure the message sending is paid\n\t\trequire(msg.value >= fee, \"send underpriced\");\n\n\t\t// send the message\n\t\tlzEndpoint.send{value: fee}(\n\t\t\tchildTunnelChainId,\n\t\t\tabi.encodePacked(childTunnelAddress, address(this)),\n\t\t\tmessage,\n\t\t\tpayable(msg.sender),\n\t\t\taddress(0),\n\t\t\tbytes(\"\")\n\t\t);\n\n\t\t// if sender sent more than required\n\t\tif(msg.value > fee) {\n\t\t\t// send the delta back to sender\n\t\t\tpayable(msg.sender).transfer(msg.value - fee);\n\t\t}\n\t}\n\n\t/**\n\t * @inheritdoc ILayerZeroUserApplicationConfig\n\t *\n\t * @notice Restricted access function to execute `setConfig` function on the LZ Endpoint\n\t *      set the configuration of the LayerZero messaging library of the specified version\n\t *\n\t * @dev Requires sender to have ROLE_LZ_CONFIG_MANAGER permission\n\t *\n\t * @param _version - messaging library version\n\t * @param _chainId - the chainId for the pending config change\n\t * @param _configType - type of configuration. every messaging library has its own convention.\n\t * @param _config - configuration in the bytes. can encode arbitrary content.\n\t */\n\tfunction setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) public override {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_LZ_CONFIG_MANAGER), \"access denied\");\n\n\t\t// delegate to `setConfig`\n\t\tlzEndpoint.setConfig(_version, _chainId, _configType, _config);\n\t}\n\n\t/**\n\t * @inheritdoc ILayerZeroUserApplicationConfig\n\t *\n\t * @notice Restricted access function to execute `setSendVersion` function on the LZ Endpoint\n\t *      set the send() LayerZero messaging library version to _version\n\t *\n\t * @dev Requires sender to have ROLE_LZ_CONFIG_MANAGER permission\n\t *\n\t * @param _version - new messaging library version\n\t */\n\tfunction setSendVersion(uint16 _version) public override {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_LZ_CONFIG_MANAGER), \"access denied\");\n\n\t\t// delegate to `setSendVersion`\n\t\tlzEndpoint.setSendVersion(_version);\n\t}\n\n\t/**\n\t * @inheritdoc ILayerZeroUserApplicationConfig\n\t *\n\t * @notice Restricted access function to execute `setReceiveVersion` function on the LZ Endpoint\n\t *      set the lzReceive() LayerZero messaging library version to _version\n\t *\n\t * @dev Requires sender to have ROLE_LZ_CONFIG_MANAGER permission\n\t *\n\t * @param _version - new messaging library version\n\t */\n\tfunction setReceiveVersion(uint16 _version) public override {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_LZ_CONFIG_MANAGER), \"access denied\");\n\n\t\t// delegate to `setReceiveVersion`\n\t\tlzEndpoint.setReceiveVersion(_version);\n\t}\n\n\t/**\n\t * @inheritdoc ILayerZeroUserApplicationConfig\n\t *\n\t * @notice Restricted access function to execute `forceResumeReceive` function on the LZ Endpoint\n\t *      Only when the UA needs to resume the message flow in blocking mode and clear the stored payload\n\t *\n\t * @dev Requires sender to have ROLE_LZ_CONFIG_MANAGER permission\n\t *\n\t * @param _srcChainId - the chainId of the source chain\n\t * @param _srcAddress - the contract address of the source contract at the source chain\n\t */\n\tfunction forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) public override {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_LZ_CONFIG_MANAGER), \"access denied\");\n\n\t\t// delegate to `forceResumeReceive`\n\t\tlzEndpoint.forceResumeReceive(_srcChainId, _srcAddress);\n\t}\n\n\t/**\n\t * @dev Restricted access function to rescue accidentally sent tokens,\n\t *      the tokens are rescued via `transferFrom` function call on the\n\t *      contract address specified and with the parameters specified:\n\t *      `_contract.transferFrom(this, _to, _value)`\n\t *\n\t * @dev Requires executor to have `ROLE_RESCUE_MANAGER` permission\n\t *\n\t * @param _contract smart contract address to execute `transfer` function on\n\t * @param _to to address in `transferFrom(this, _to, _value)`\n\t * @param _value value to transfer in `transferFrom(this, _to, _value)`;\n\t *      this can also be a tokenId for ERC721 transfer\n\t */\n\tfunction rescueToken(address _contract, address _to, uint256 _value) public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_RESCUE_MANAGER), \"access denied\");\n\n\t\t// verify tokens are not locked in tunnel\n\t\trequire(\n\t\t\t_contract != address(rootToken) || _value + lockedInTunnel <= rootToken.balanceOf(address(this)),\n\t\t\t\"locked in tunnel\"\n\t\t);\n\n\t\t// perform the transfer as requested, without any checks\n\t\trequire(ERC20(_contract).transferFrom(address(this), _to, _value));\n\t}\n}\n"
    },
    "contracts/mocks/LzEndpointMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/layer_zero/ILayerZeroEndpoint.sol\";\n\ncontract LzEndpointMock is ILayerZeroEndpoint {\n\t// ILayerZeroUserApplicationConfig events\n\tevent ConfigSet(uint16 _version, uint16 _chainId, uint _configType, bytes _config);\n\tevent SendVersionSet(uint16 _version);\n\tevent ReceiveVersionSet(uint16 _version);\n\tevent ForceResumeReceived(uint16 _srcChainId, bytes _srcAddress);\n\n\t// ILayerZeroEndpoint events\n\tevent MessageSent(uint16 _dstChainId, bytes _destination, bytes _payload, address payable _refundAddress, address _zroPaymentAddress, bytes _adapterParams);\n\tevent PayloadReceived(uint16 _srcChainId, bytes _srcAddress, address _dstAddress, uint64 _nonce, uint _gasLimit, bytes _payload);\n\tevent PayloadRetried(uint16 _srcChainId, bytes _srcAddress, bytes _payload);\n\n\t/**\n\t * @inheritdoc ILayerZeroUserApplicationConfig\n\t */\n\tfunction setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) public {\n\t\temit ConfigSet(_version, _chainId, _configType, _config);\n\t}\n\n\t/**\n\t * @inheritdoc ILayerZeroUserApplicationConfig\n\t */\n\tfunction setSendVersion(uint16 _version) public {\n\t\temit SendVersionSet(_version);\n\t}\n\n\t/**\n\t * @inheritdoc ILayerZeroUserApplicationConfig\n\t */\n\tfunction setReceiveVersion(uint16 _version) public {\n\t\temit ReceiveVersionSet(_version);\n\t}\n\n\t/**\n\t * @inheritdoc ILayerZeroUserApplicationConfig\n\t */\n\tfunction forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) public {\n\t\temit ForceResumeReceived(_srcChainId, _srcAddress);\n\t}\n\n\t/**\n\t * @inheritdoc ILayerZeroEndpoint\n\t */\n\tfunction send(uint16 _dstChainId, bytes calldata _destination, bytes calldata _payload, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) public payable {\n\t\temit MessageSent(_dstChainId, _destination, _payload, _refundAddress, _zroPaymentAddress, _adapterParams);\n\t}\n\n\t/**\n\t * @inheritdoc ILayerZeroEndpoint\n\t */\n\tfunction receivePayload(uint16 _srcChainId, bytes calldata _srcAddress, address _dstAddress, uint64 _nonce, uint _gasLimit, bytes calldata _payload) public {\n\t\temit PayloadReceived(_srcChainId, _srcAddress, _dstAddress, _nonce, _gasLimit, _payload);\n\t}\n\n\t/**\n\t * @inheritdoc ILayerZeroEndpoint\n\t */\n\tfunction getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress) public view returns (uint64) {\n\t\treturn 1;\n\t}\n\n\t/**\n\t * @inheritdoc ILayerZeroEndpoint\n\t */\n\tfunction getOutboundNonce(uint16 _dstChainId, address _srcAddress) public view returns (uint64) {\n\t\treturn 1;\n\t}\n\n\t/**\n\t * @inheritdoc ILayerZeroEndpoint\n\t */\n\tfunction estimateFees(uint16 _dstChainId, address _userApplication, bytes calldata _payload, bool _payInZRO, bytes calldata _adapterParam) public view returns (uint nativeFee, uint zroFee) {\n\t\treturn (1 gwei, 2 gwei);\n\t}\n\n\t/**\n\t * @inheritdoc ILayerZeroEndpoint\n\t */\n\tfunction getChainId() public view returns (uint16) {\n\t\treturn 101;\n\t}\n\n\t/**\n\t * @inheritdoc ILayerZeroEndpoint\n\t */\n\tfunction retryPayload(uint16 _srcChainId, bytes calldata _srcAddress, bytes calldata _payload) public {\n\t\temit PayloadRetried(_srcChainId, _srcAddress, _payload);\n\t}\n\n\t/**\n\t * @inheritdoc ILayerZeroEndpoint\n\t */\n\tfunction hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) public view returns (bool) {\n\t\treturn true;\n\t}\n\n\t/**\n\t * @inheritdoc ILayerZeroEndpoint\n\t */\n\tfunction getSendLibraryAddress(address _userApplication) public view returns (address) {\n\t\treturn address(1);\n\t}\n\n\t/**\n\t * @inheritdoc ILayerZeroEndpoint\n\t */\n\tfunction getReceiveLibraryAddress(address _userApplication) public view returns (address) {\n\t\treturn address(2);\n\t}\n\n\t/**\n\t * @inheritdoc ILayerZeroEndpoint\n\t */\n\tfunction isSendingPayload() public view returns (bool) {\n\t\treturn true;\n\t}\n\n\t/**\n\t * @inheritdoc ILayerZeroEndpoint\n\t */\n\tfunction isReceivingPayload() public view returns (bool) {\n\t\treturn true;\n\t}\n\n\t/**\n\t * @inheritdoc ILayerZeroEndpoint\n\t */\n\tfunction getConfig(uint16 _version, uint16 _chainId, address _userApplication, uint _configType) public view returns (bytes memory) {\n\t\treturn bytes(\"\");\n\t}\n\n\t/**\n\t * @inheritdoc ILayerZeroEndpoint\n\t */\n\tfunction getSendVersion(address _userApplication) public view returns (uint16) {\n\t\treturn 1;\n\t}\n\n\t/**\n\t * @inheritdoc ILayerZeroEndpoint\n\t */\n\tfunction getReceiveVersion(address _userApplication) public view returns (uint16) {\n\t\treturn 1;\n\t}\n}\n"
    },
    "contracts/mocks/LzERC20RootTunnelV1Mock.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"../layer_zero/LzERC20RootTunnelV1.sol\";\n\ncontract LzERC20RootTunnelV1Mock is LzERC20RootTunnelV1 {\n\tfunction setLzEndpoint(address _lzEndpoint) public {\n\t\tlzEndpoint = ILayerZeroEndpoint(_lzEndpoint);\n\t}\n}\n"
    },
    "contracts/utils/UpgradeableAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\n/**\n * @title Upgradeable Access Control List // ERC1967Proxy\n *\n * @notice Access control smart contract provides an API to check\n *      if a specific operation is permitted globally and/or\n *      if a particular user has a permission to execute it.\n *\n * @notice It deals with two main entities: features and roles.\n *\n * @notice Features are designed to be used to enable/disable public functions\n *      of the smart contract (used by a wide audience).\n * @notice User roles are designed to control the access to restricted functions\n *      of the smart contract (used by a limited set of maintainers).\n *\n * @notice Terms \"role\", \"permissions\" and \"set of permissions\" have equal meaning\n *      in the documentation text and may be used interchangeably.\n * @notice Terms \"permission\", \"single permission\" implies only one permission bit set.\n *\n * @notice Access manager is a special role which allows to grant/revoke other roles.\n *      Access managers can only grant/revoke permissions which they have themselves.\n *      As an example, access manager with no other roles set can only grant/revoke its own\n *      access manager permission and nothing else.\n *\n * @notice Access manager permission should be treated carefully, as a super admin permission:\n *      Access manager with even no other permission can interfere with another account by\n *      granting own access manager permission to it and effectively creating more powerful\n *      permission set than its own.\n *\n * @dev Both current and OpenZeppelin AccessControl implementations feature a similar API\n *      to check/know \"who is allowed to do this thing\".\n * @dev Zeppelin implementation is more flexible:\n *      - it allows setting unlimited number of roles, while current is limited to 256 different roles\n *      - it allows setting an admin for each role, while current allows having only one global admin\n * @dev Current implementation is more lightweight:\n *      - it uses only 1 bit per role, while Zeppelin uses 256 bits\n *      - it allows setting up to 256 roles at once, in a single transaction, while Zeppelin allows\n *        setting only one role in a single transaction\n *\n * @dev This smart contract is designed to be inherited by other\n *      smart contracts which require access control management capabilities.\n *\n * @dev Access manager permission has a bit 255 set.\n *      This bit must not be used by inheriting contracts for any other permissions/features.\n *\n * @dev This is an upgradeable version of the ACL, based on Zeppelin implementation for ERC1967,\n *      see https://docs.openzeppelin.com/contracts/4.x/upgradeable\n *      see https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable\n *      see https://forum.openzeppelin.com/t/uups-proxies-tutorial-solidity-javascript/7786\n *\n * @author Basil Gorin\n */\nabstract contract UpgradeableAccessControl is UUPSUpgradeable {\n\t/**\n\t * @notice Privileged addresses with defined roles/permissions\n\t * @notice In the context of ERC20/ERC721 tokens these can be permissions to\n\t *      allow minting or burning tokens, transferring on behalf and so on\n\t *\n\t * @dev Maps user address to the permissions bitmask (role), where each bit\n\t *      represents a permission\n\t * @dev Bitmask 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n\t *      represents all possible permissions\n\t * @dev 'This' address mapping represents global features of the smart contract\n\t */\n\tmapping(address => uint256) public userRoles;\n\n\t/**\n\t * @dev Empty reserved space in storage. The size of the __gap array is calculated so that\n\t *      the amount of storage used by a contract always adds up to the 50.\n\t *      See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n\t */\n\tuint256[49] private __gap;\n\n\t/**\n\t * @notice Access manager is responsible for assigning the roles to users,\n\t *      enabling/disabling global features of the smart contract\n\t * @notice Access manager can add, remove and update user roles,\n\t *      remove and update global features\n\t *\n\t * @dev Role ROLE_ACCESS_MANAGER allows modifying user roles and global features\n\t * @dev Role ROLE_ACCESS_MANAGER has single bit at position 255 enabled\n\t */\n\tuint256 public constant ROLE_ACCESS_MANAGER = 0x8000000000000000000000000000000000000000000000000000000000000000;\n\n\t/**\n\t * @notice Upgrade manager is responsible for smart contract upgrades,\n\t *      see https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable\n\t *      see https://docs.openzeppelin.com/contracts/4.x/upgradeable\n\t *\n\t * @dev Role ROLE_UPGRADE_MANAGER allows passing the _authorizeUpgrade() check\n\t * @dev Role ROLE_UPGRADE_MANAGER has single bit at position 254 enabled\n\t */\n\tuint256 public constant ROLE_UPGRADE_MANAGER = 0x4000000000000000000000000000000000000000000000000000000000000000;\n\n\t/**\n\t * @dev Bitmask representing all the possible permissions (super admin role)\n\t * @dev Has all the bits are enabled (2^256 - 1 value)\n\t */\n\tuint256 private constant FULL_PRIVILEGES_MASK = type(uint256).max; // before 0.8.0: uint256(-1) overflows to 0xFFFF...\n\n\t/**\n\t * @dev Fired in updateRole() and updateFeatures()\n\t *\n\t * @param _by operator which called the function\n\t * @param _to address which was granted/revoked permissions\n\t * @param _requested permissions requested\n\t * @param _actual permissions effectively set\n\t */\n\tevent RoleUpdated(address indexed _by, address indexed _to, uint256 _requested, uint256 _actual);\n\n\t/**\n\t * @dev UUPS initializer, sets the contract owner to have full privileges\n\t *\n\t * @dev Can be executed only in constructor during deployment,\n\t *      reverts when executed in already deployed contract\n\t *\n\t * @dev IMPORTANT:\n\t *      this function MUST be executed during proxy deployment (in proxy constructor),\n\t *      otherwise it renders useless and cannot be executed at all,\n\t *      resulting in no admin control over the proxy and no possibility to do future upgrades\n\t *\n\t * @param _owner smart contract owner having full privileges\n\t */\n\tfunction _postConstruct(address _owner) internal virtual initializer {\n\t\t// ensure this function is execute only in constructor\n\t\trequire(!AddressUpgradeable.isContract(address(this)), \"invalid context\");\n\n\t\t// grant owner full privileges\n\t\tuserRoles[_owner] = FULL_PRIVILEGES_MASK;\n\n\t\t// fire an event\n\t\temit RoleUpdated(msg.sender, _owner, FULL_PRIVILEGES_MASK, FULL_PRIVILEGES_MASK);\n\t}\n\n\t/**\n\t * @notice Returns an address of the implementation smart contract,\n\t *      see ERC1967Upgrade._getImplementation()\n\t *\n\t * @return the current implementation address\n\t */\n\tfunction getImplementation() public view virtual returns (address) {\n\t\t// delegate to `ERC1967Upgrade._getImplementation()`\n\t\treturn _getImplementation();\n\t}\n\n\t/**\n\t * @notice Retrieves globally set of features enabled\n\t *\n\t * @dev Effectively reads userRoles role for the contract itself\n\t *\n\t * @return 256-bit bitmask of the features enabled\n\t */\n\tfunction features() public view returns (uint256) {\n\t\t// features are stored in 'this' address  mapping of `userRoles` structure\n\t\treturn userRoles[address(this)];\n\t}\n\n\t/**\n\t * @notice Updates set of the globally enabled features (`features`),\n\t *      taking into account sender's permissions\n\t *\n\t * @dev Requires transaction sender to have `ROLE_ACCESS_MANAGER` permission\n\t * @dev Function is left for backward compatibility with older versions\n\t *\n\t * @param _mask bitmask representing a set of features to enable/disable\n\t */\n\tfunction updateFeatures(uint256 _mask) public {\n\t\t// delegate call to `updateRole`\n\t\tupdateRole(address(this), _mask);\n\t}\n\n\t/**\n\t * @notice Updates set of permissions (role) for a given user,\n\t *      taking into account sender's permissions.\n\t *\n\t * @dev Setting role to zero is equivalent to removing an all permissions\n\t * @dev Setting role to `FULL_PRIVILEGES_MASK` is equivalent to\n\t *      copying senders' permissions (role) to the user\n\t * @dev Requires transaction sender to have `ROLE_ACCESS_MANAGER` permission\n\t *\n\t * @param operator address of a user to alter permissions for or zero\n\t *      to alter global features of the smart contract\n\t * @param role bitmask representing a set of permissions to\n\t *      enable/disable for a user specified\n\t */\n\tfunction updateRole(address operator, uint256 role) public {\n\t\t// caller must have a permission to update user roles\n\t\trequire(isSenderInRole(ROLE_ACCESS_MANAGER), \"access denied\");\n\n\t\t// evaluate the role and reassign it\n\t\tuserRoles[operator] = evaluateBy(msg.sender, userRoles[operator], role);\n\n\t\t// fire an event\n\t\temit RoleUpdated(msg.sender, operator, role, userRoles[operator]);\n\t}\n\n\t/**\n\t * @notice Determines the permission bitmask an operator can set on the\n\t *      target permission set\n\t * @notice Used to calculate the permission bitmask to be set when requested\n\t *     in `updateRole` and `updateFeatures` functions\n\t *\n\t * @dev Calculated based on:\n\t *      1) operator's own permission set read from userRoles[operator]\n\t *      2) target permission set - what is already set on the target\n\t *      3) desired permission set - what do we want set target to\n\t *\n\t * @dev Corner cases:\n\t *      1) Operator is super admin and its permission set is `FULL_PRIVILEGES_MASK`:\n\t *        `desired` bitset is returned regardless of the `target` permission set value\n\t *        (what operator sets is what they get)\n\t *      2) Operator with no permissions (zero bitset):\n\t *        `target` bitset is returned regardless of the `desired` value\n\t *        (operator has no authority and cannot modify anything)\n\t *\n\t * @dev Example:\n\t *      Consider an operator with the permissions bitmask     00001111\n\t *      is about to modify the target permission set          01010101\n\t *      Operator wants to set that permission set to          00110011\n\t *      Based on their role, an operator has the permissions\n\t *      to update only lowest 4 bits on the target, meaning that\n\t *      high 4 bits of the target set in this example is left\n\t *      unchanged and low 4 bits get changed as desired:      01010011\n\t *\n\t * @param operator address of the contract operator which is about to set the permissions\n\t * @param target input set of permissions to operator is going to modify\n\t * @param desired desired set of permissions operator would like to set\n\t * @return resulting set of permissions given operator will set\n\t */\n\tfunction evaluateBy(address operator, uint256 target, uint256 desired) public view returns (uint256) {\n\t\t// read operator's permissions\n\t\tuint256 p = userRoles[operator];\n\n\t\t// taking into account operator's permissions,\n\t\t// 1) enable the permissions desired on the `target`\n\t\ttarget |= p & desired;\n\t\t// 2) disable the permissions desired on the `target`\n\t\ttarget &= FULL_PRIVILEGES_MASK ^ (p & (FULL_PRIVILEGES_MASK ^ desired));\n\n\t\t// return calculated result\n\t\treturn target;\n\t}\n\n\t/**\n\t * @notice Checks if requested set of features is enabled globally on the contract\n\t *\n\t * @param required set of features to check against\n\t * @return true if all the features requested are enabled, false otherwise\n\t */\n\tfunction isFeatureEnabled(uint256 required) public view returns (bool) {\n\t\t// delegate call to `__hasRole`, passing `features` property\n\t\treturn __hasRole(features(), required);\n\t}\n\n\t/**\n\t * @notice Checks if transaction sender `msg.sender` has all the permissions required\n\t *\n\t * @param required set of permissions (role) to check against\n\t * @return true if all the permissions requested are enabled, false otherwise\n\t */\n\tfunction isSenderInRole(uint256 required) public view returns (bool) {\n\t\t// delegate call to `isOperatorInRole`, passing transaction sender\n\t\treturn isOperatorInRole(msg.sender, required);\n\t}\n\n\t/**\n\t * @notice Checks if operator has all the permissions (role) required\n\t *\n\t * @param operator address of the user to check role for\n\t * @param required set of permissions (role) to check\n\t * @return true if all the permissions requested are enabled, false otherwise\n\t */\n\tfunction isOperatorInRole(address operator, uint256 required) public view returns (bool) {\n\t\t// delegate call to `__hasRole`, passing operator's permissions (role)\n\t\treturn __hasRole(userRoles[operator], required);\n\t}\n\n\t/**\n\t * @dev Checks if role `actual` contains all the permissions required `required`\n\t *\n\t * @param actual existent role\n\t * @param required required role\n\t * @return true if actual has required role (all permissions), false otherwise\n\t */\n\tfunction __hasRole(uint256 actual, uint256 required) internal pure returns (bool) {\n\t\t// check the bitmask for the role required and return the result\n\t\treturn actual & required == required;\n\t}\n\n\t/**\n\t * @inheritdoc UUPSUpgradeable\n\t */\n\tfunction _authorizeUpgrade(address) internal virtual override {\n\t\t// caller must have a permission to upgrade the contract\n\t\trequire(isSenderInRole(ROLE_UPGRADE_MANAGER), \"access denied\");\n\t}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}