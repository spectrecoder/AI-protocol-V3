{
  "language": "Solidity",
  "sources": {
    "contracts/hardhat-dependency-compiler/@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport '@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol';\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Proxy.sol\";\nimport \"./ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializating the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overriden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallSecure(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        address oldImplementation = _getImplementation();\n\n        // Initial upgrade and setup call\n        _setImplementation(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n\n        // Perform rollback test if not already in progress\n        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);\n        if (!rollbackTesting.value) {\n            // Trigger rollback using upgradeTo from the new implementation\n            rollbackTesting.value = true;\n            Address.functionDelegateCall(\n                newImplementation,\n                abi.encodeWithSignature(\"upgradeTo(address)\", oldImplementation)\n            );\n            rollbackTesting.value = false;\n            // Check rollback was effective\n            require(oldImplementation == _getImplementation(), \"ERC1967Upgrade: upgrade breaks further upgrades\");\n            // Finally reset to the new implementation and log the upgrade\n            _upgradeTo(newImplementation);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overriden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits a {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/ERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\nimport \"./IERC721Enumerable.sol\";\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n */\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721Enumerable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n}\n"
    },
    "contracts/mocks/ZeppelinERC721Mock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ERC721SpecExt.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\";\n\n/**\n * @title Zeppelin ERC721 Mock\n *\n * @notice Zeppelin ERC721 Mock simulates an NFT token, used for testing purposes;\n *      it has unrestricted access to the mint() function and can be used to be bound to an iNFT\n *\n * @author Basil Gorin\n */\ncontract ZeppelinERC721Mock is ERC721Enumerable, ERC721URIStorage, MintableERC721, BurnableERC721 {\n\t/**\n\t * @dev Creates/deploys an NFT Mock instance\n\t *\n\t * @param _name asset name (ERC721Metadata)\n\t * @param _symbol asset symbol (ERC721Metadata)\n\t */\n\tconstructor(string memory _name, string memory _symbol) ERC721(_name, _symbol) {}\n\n\t/**\n\t * @inheritdoc MintableERC721\n\t */\n\tfunction exists(uint256 _tokenId) public override view returns(bool) {\n\t\t// delegate to `_exists`\n\t\treturn _exists(_tokenId);\n\t}\n\n\t/**\n\t * @inheritdoc MintableERC721\n\t */\n\tfunction mint(address _to, uint256 _tokenId) public override {\n\t\t// mint token - delegate to `_mint`\n\t\t_mint(_to, _tokenId);\n\t}\n\n\t/**\n\t * @inheritdoc MintableERC721\n\t */\n\tfunction safeMint(address _to, uint256 _tokenId) public override {\n\t\t// mint token safely - delegate to `_safeMint`\n\t\t_safeMint(_to, _tokenId);\n\t}\n\n\t/**\n\t * @inheritdoc MintableERC721\n\t */\n\tfunction safeMint(address _to, uint256 _tokenId, bytes memory _data) public override {\n\t\t// mint token safely - delegate to `_safeMint`\n\t\t_safeMint(_to, _tokenId, _data);\n\t}\n\n\t/**\n\t * @inheritdoc BurnableERC721\n\t */\n\tfunction burn(uint256 _tokenId) public override {\n\t\t// burn token - delegate to `_burn`\n\t\t_burn(_tokenId);\n\t}\n\n\t/**\n\t * @inheritdoc ERC721\n\t */\n\tfunction _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual override(ERC721, ERC721Enumerable) {\n\t\tERC721Enumerable._beforeTokenTransfer(from, to, tokenId);\n\t}\n\n\t/**\n\t * @inheritdoc ERC721\n\t */\n\tfunction _burn(uint256 tokenId) internal virtual override(ERC721, ERC721URIStorage) {\n\t\tERC721URIStorage._burn(tokenId);\n\t}\n\n\t/**\n\t * @inheritdoc ERC721\n\t */\n\tfunction supportsInterface(bytes4 interfaceId) public view virtual override(ERC721, ERC721Enumerable) returns (bool) {\n\t\treturn ERC721Enumerable.supportsInterface(interfaceId)\n\t\t\t|| interfaceId == type(MintableERC721).interfaceId\n\t\t\t|| interfaceId == type(BurnableERC721).interfaceId;\n\t}\n\n\t/**\n\t * @inheritdoc ERC721\n\t */\n\tfunction tokenURI(uint256 tokenId) public view virtual override(ERC721, ERC721URIStorage) returns (string memory) {\n\t\treturn ERC721URIStorage.tokenURI(tokenId);\n\t}\n\n\t/**\n\t * @inheritdoc MintableERC721\n\t */\n\tfunction mintBatch(address _to, uint256 _tokenId, uint256 n) public override {\n\t\t// straightforward: mint one by one\n\t\tfor(uint256 i = 0; i < n; i++) {\n\t\t\t// delegate to `mint`\n\t\t\tmint(_to, _tokenId + i);\n\t\t}\n\t}\n\n\t/**\n\t * @inheritdoc MintableERC721\n\t */\n\tfunction safeMintBatch(address _to, uint256 _tokenId, uint256 n) public override {\n\t\t// delegate to `safeMint` with empty data\n\t\tsafeMintBatch(_to, _tokenId, n, \"\");\n\t}\n\n\t/**\n\t * @inheritdoc MintableERC721\n\t */\n\tfunction safeMintBatch(address _to, uint256 _tokenId, uint256 n, bytes memory _data) public override {\n\t\t// straightforward: mint one by one\n\t\tfor(uint256 i = 0; i < n; i++) {\n\t\t\t// delegate to `safeMint`\n\t\t\tsafeMint(_to, _tokenId + i, _data);\n\t\t}\n\t}\n}\n"
    },
    "contracts/interfaces/ERC721SpecExt.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title Mintable ERC721\n *\n * @notice Defines mint capabilities for Alethea ERC721 tokens.\n *      This interface should be treated as a definition of what mintable means for ERC721\n *\n * @author Basil Gorin\n */\ninterface MintableERC721 {\n\t/**\n\t * @notice Checks if specified token exists\n\t *\n\t * @dev Returns whether the specified token ID has an ownership\n\t *      information associated with it\n\t *\n\t * @param _tokenId ID of the token to query existence for\n\t * @return whether the token exists (true - exists, false - doesn't exist)\n\t */\n\tfunction exists(uint256 _tokenId) external view returns(bool);\n\n\t/**\n\t * @dev Creates new token with token ID specified\n\t *      and assigns an ownership `_to` for this token\n\t *\n\t * @dev Unsafe: doesn't execute `onERC721Received` on the receiver.\n\t *      Prefer the use of `saveMint` instead of `mint`.\n\t *\n\t * @dev Should have a restricted access handled by the implementation\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId ID of the token to mint\n\t */\n\tfunction mint(address _to, uint256 _tokenId) external;\n\n\t/**\n\t * @dev Creates new tokens starting with token ID specified\n\t *      and assigns an ownership `_to` for these tokens\n\t *\n\t * @dev Token IDs to be minted: [_tokenId, _tokenId + n)\n\t *\n\t * @dev n must be greater or equal 2: `n > 1`\n\t *\n\t * @dev Unsafe: doesn't execute `onERC721Received` on the receiver.\n\t *      Prefer the use of `saveMintBatch` instead of `mintBatch`.\n\t *\n\t * @dev Should have a restricted access handled by the implementation\n\t *\n\t * @param _to an address to mint tokens to\n\t * @param _tokenId ID of the first token to mint\n\t * @param n how many tokens to mint, sequentially increasing the _tokenId\n\t */\n\tfunction mintBatch(address _to, uint256 _tokenId, uint256 n) external;\n\n\t/**\n\t * @dev Creates new token with token ID specified\n\t *      and assigns an ownership `_to` for this token\n\t *\n\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\n\t *      `onERC721Received` on `_to` and throws if the return value is not\n\t *      `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n\t *\n\t * @dev Should have a restricted access handled by the implementation\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId ID of the token to mint\n\t */\n\tfunction safeMint(address _to, uint256 _tokenId) external;\n\n\t/**\n\t * @dev Creates new token with token ID specified\n\t *      and assigns an ownership `_to` for this token\n\t *\n\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\n\t *      `onERC721Received` on `_to` and throws if the return value is not\n\t *      `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n\t *\n\t * @dev Should have a restricted access handled by the implementation\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId ID of the token to mint\n\t * @param _data additional data with no specified format, sent in call to `_to`\n\t */\n\tfunction safeMint(address _to, uint256 _tokenId, bytes memory _data) external;\n\n\t/**\n\t * @dev Creates new tokens starting with token ID specified\n\t *      and assigns an ownership `_to` for these tokens\n\t *\n\t * @dev Token IDs to be minted: [_tokenId, _tokenId + n)\n\t *\n\t * @dev n must be greater or equal 2: `n > 1`\n\t *\n\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\n\t *      `onERC721Received` on `_to` and throws if the return value is not\n\t *      `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n\t *\n\t * @dev Should have a restricted access handled by the implementation\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId ID of the token to mint\n\t * @param n how many tokens to mint, sequentially increasing the _tokenId\n\t */\n\tfunction safeMintBatch(address _to, uint256 _tokenId, uint256 n) external;\n\n\t/**\n\t * @dev Creates new tokens starting with token ID specified\n\t *      and assigns an ownership `_to` for these tokens\n\t *\n\t * @dev Token IDs to be minted: [_tokenId, _tokenId + n)\n\t *\n\t * @dev n must be greater or equal 2: `n > 1`\n\t *\n\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\n\t *      `onERC721Received` on `_to` and throws if the return value is not\n\t *      `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n\t *\n\t * @dev Should have a restricted access handled by the implementation\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId ID of the token to mint\n\t * @param n how many tokens to mint, sequentially increasing the _tokenId\n\t * @param _data additional data with no specified format, sent in call to `_to`\n\t */\n\tfunction safeMintBatch(address _to, uint256 _tokenId, uint256 n, bytes memory _data) external;\n}\n\n/**\n * @title Alethea Burnable ERC721\n *\n * @notice Defines burn capabilities for Alethea ERC721 tokens.\n *      This interface should be treated as a definition of what burnable means for ERC721\n *\n * @author Basil Gorin\n */\ninterface BurnableERC721 {\n\t/**\n\t * @notice Destroys the token with token ID specified\n\t *\n\t * @dev Should be accessible publicly by token owners.\n\t *      May have a restricted access handled by the implementation\n\t *\n\t * @param _tokenId ID of the token to burn\n\t */\n\tfunction burn(uint256 _tokenId) external;\n}\n\n/**\n * @title With Base URI\n *\n * @notice A marker interface for the contracts having the baseURI() function\n *      or public string variable named baseURI\n *      NFT implementations like TinyERC721, or ShortERC721 are example of such smart contracts\n *\n * @author Basil Gorin\n */\ninterface WithBaseURI {\n\t/**\n\t * @dev Usually used in NFT implementations to construct ERC721Metadata.tokenURI as\n\t *      `base URI + token ID` if token URI is not set (not present in `_tokenURIs` mapping)\n\t *\n\t * @dev For example, if base URI is https://api.com/token/, then token #1\n\t *      will have an URI https://api.com/token/1\n\t */\n\tfunction baseURI() external view returns(string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/ERC721URIStorage.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\n\n/**\n * @dev ERC721 token with storage based token URI management.\n */\nabstract contract ERC721URIStorage is ERC721 {\n    using Strings for uint256;\n\n    // Optional mapping for token URIs\n    mapping(uint256 => string) private _tokenURIs;\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721URIStorage: URI query for nonexistent token\");\n\n        string memory _tokenURI = _tokenURIs[tokenId];\n        string memory base = _baseURI();\n\n        // If there is no base URI, return the token URI.\n        if (bytes(base).length == 0) {\n            return _tokenURI;\n        }\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\n        if (bytes(_tokenURI).length > 0) {\n            return string(abi.encodePacked(base, _tokenURI));\n        }\n\n        return super.tokenURI(tokenId);\n    }\n\n    /**\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n        require(_exists(tokenId), \"ERC721URIStorage: URI set of nonexistent token\");\n        _tokenURIs[tokenId] = _tokenURI;\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual override {\n        super._burn(tokenId);\n\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n    }\n}\n"
    },
    "contracts/token/TinyERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ERC721Spec.sol\";\nimport \"../interfaces/ERC721SpecExt.sol\";\nimport \"../lib/AddressUtils.sol\";\nimport \"../lib/ArrayUtils.sol\";\nimport \"../lib/StringUtils.sol\";\nimport \"../lib/ECDSA.sol\";\nimport \"../utils/AccessControl.sol\";\n\n/**\n * @title Tiny ERC721\n *\n * @notice Tiny ERC721 defines an NFT with a very small (up to 32 bits) ID space.\n *      ERC721 enumeration support requires additional writes to the storage:\n *      - when transferring a token in order to update the NFT collections of\n *        the previous and next owners,\n *      - when minting/burning a token in order to update global NFT collection\n *\n * @notice Reducing NFT ID space to 32 bits allows\n *      - to eliminate the need to have and to write to two additional storage mappings\n *        (also achievable with the 48 bits ID space)\n *      - for batch minting optimization by writing 8 tokens instead of 5 at once into\n *        global/local collections\n *\n * @notice This smart contract is designed to be inherited by concrete implementations,\n *      which are expected to define token metadata, auxiliary functions to access the metadata,\n *      and explicitly define token minting interface, which should be built on top\n *      of current smart contract internal interface\n *\n * @notice Fully ERC721-compatible with all optional interfaces implemented (metadata, enumeration),\n *      see https://eips.ethereum.org/EIPS/eip-721\n *\n * @dev ERC721: contract has passed adopted OpenZeppelin ERC721 tests\n *        https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/test/token/ERC721/ERC721.behavior.js\n *        https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/test/token/ERC721/extensions/ERC721URIStorage.test.js\n *\n * @dev A note on token URI: there are major differences on how token URI behaves comparing to Zeppelin impl:\n *      1. A token URI can be set for non-existing token for pre-allocation purposes,\n *         still the URI will be deleted once token is burnt\n *      2. If token URI is set, base URI has no affect on the token URI, the two are not concatenated,\n *         base URI is used to construct the token URI only if the latter was not explicitly set\n *\n * @dev Supports EIP-712 powered permits - permit() - approve() with signature.\n *      Supports EIP-712 powered operator permits - permitForAll() - setApprovalForAll() with signature.\n *\n * @dev EIP712 Domain:\n *      name: AliERC721v1\n *      version: not in use, omitted (name already contains version)\n *      chainId: EIP-155 chain id\n *      verifyingContract: deployed contract address\n *      salt: permitNonces[owner], where owner is an address which allows operation on their tokens\n *\n * @dev Permit type:\n *      owner: address\n *      operator: address\n *      tokenId: uint256\n *      nonce: uint256\n *      deadline: uint256\n *\n * @dev Permit typeHash:\n *        keccak256(\"Permit(address owner,address operator,uint256 tokenId,uint256 nonce,uint256 deadline)\")\n *\n * @dev PermitForAll type:\n *      owner: address\n *      operator: address\n *      approved: bool\n *      nonce: uint256\n *      deadline: uint256\n *\n * @dev PermitForAll typeHash:\n *        keccak256(\"PermitForAll(address owner,address operator,bool approved,uint256 nonce,uint256 deadline)\")\n *\n * @dev See https://eips.ethereum.org/EIPS/eip-712\n * @dev See usage examples in tests: erc721_permits.js\n *\n * @author Basil Gorin\n */\nabstract contract TinyERC721 is ERC721Enumerable, ERC721Metadata, WithBaseURI, MintableERC721, BurnableERC721, AccessControl {\n\t// enable push32 optimization for uint32[]\n\tusing ArrayUtils for uint32[];\n\n\t/**\n\t * @dev Smart contract unique identifier, a random number\n\t *\n\t * @dev Should be regenerated each time smart contact source code is changed\n\t *      and changes smart contract itself is to be redeployed\n\t *\n\t * @dev Generated using https://www.random.org/bytes/\n\t * @dev Example value: 0xdbdd2b4ff38a8516da0b8e7ae93288b5e2fed0c92fb051cee90ccf4e4ec9736e\n\t */\n\tfunction TOKEN_UID() external view virtual returns(uint256);\n\n\t/**\n\t * @notice ERC-20 compatible descriptive name for a collection of NFTs in this contract\n\t *\n\t * @inheritdoc ERC721Metadata\n\t */\n\tstring public override name;\n\n\t/**\n\t * @notice ERC-20 compatible abbreviated name for a collection of NFTs in this contract\n\t *\n\t * @inheritdoc ERC721Metadata\n\t */\n\tstring public override symbol;\n\n\t/**\n\t * @notice Current implementation includes a function `decimals` that returns uint8(0)\n\t *      to be more compatible with ERC-20\n\t *\n\t * @dev ERC20 compliant token decimals is equal to zero since ERC721 token is non-fungible\n\t *      and therefore non-divisible\n\t */\n\tuint8 public constant decimals = 0;\n\n\t/**\n\t * @notice Ownership information for all the tokens in existence\n\t *\n\t * @dev Maps `Token ID => Token ID Global Index | Token ID Local Index | Token Owner Address`, where\n\t *      - Token ID Global Index denotes Token ID index in the array of all the tokens,\n\t *      - Token ID Local Index denotes Token ID index in the array of all the tokens owned by the owner,\n\t *      - Token ID indexes are 32 bits long,\n\t *      - `|` denotes bitwise concatenation of the values\n\t * @dev Token Owner Address for a given Token ID is lower 160 bits of the mapping value\n\t */\n\tmapping(uint256 => uint256) internal tokens;\n\n\t/**\n\t * @notice Enumerated collections of the tokens owned by particular owners\n\t *\n\t * @dev We call these collections \"Local\" token collections\n\t *\n\t * @dev Maps `Token Owner Address => Owned Token IDs Array`\n\t *\n\t * @dev Token owner balance is the length of their token collection:\n\t *      `balanceOf(owner) = collections[owner].length`\n\t */\n\tmapping(address => uint32[]) internal collections;\n\n\t/**\n\t * @notice An array of all the tokens in existence\n\t *\n\t * @dev We call this collection \"Global\" token collection\n\t *\n\t * @dev Array with all Token IDs, used for enumeration\n\t *\n\t * @dev Total token supply `tokenSupply` is the length of this collection:\n\t *      `totalSupply() = allTokens.length`\n\t */\n\tuint32[] internal allTokens;\n\n\t/**\n\t * @notice Addresses approved by token owners to transfer their tokens\n\t *\n\t * @dev `Maps Token ID => Approved Address`, where\n\t *      Approved Address is an address allowed transfer ownership for the token\n\t *      defined by Token ID\n\t */\n\tmapping(uint256 => address) internal approvals;\n\n\t/**\n\t * @notice Addresses approved by token owners to transfer all their tokens\n\t *\n\t * @dev Maps `Token Owner Address => Operator Address => Approval State` - true/false (approved/not), where\n\t *      - Token Owner Address is any address which may own tokens or not,\n\t *      - Operator Address is any other address which may own tokens or not,\n\t *      - Approval State is a flag indicating if Operator Address is allowed to\n\t *        transfer tokens owned by Token Owner Address o their behalf\n\t */\n\tmapping(address => mapping(address => bool)) internal approvedOperators;\n\n\t/**\n\t * @dev A record of nonces for signing/validating signatures in EIP-712 based\n\t *      `permit` and `permitForAll` functions\n\t *\n\t * @dev Each time the nonce is used, it is increased by one, meaning reordering\n\t *      of the EIP-712 transactions is not possible\n\t *\n\t * @dev Inspired by EIP-2612 extension for ERC20 token standard\n\t *\n\t * @dev Maps token owner address => token owner nonce\n\t */\n\tmapping(address => uint256) public permitNonces;\n\n\t/**\n\t * @dev Base URI is used to construct ERC721Metadata.tokenURI as\n\t *      `base URI + token ID` if token URI is not set (not present in `_tokenURIs` mapping)\n\t *\n\t * @dev For example, if base URI is https://api.com/token/, then token #1\n\t *      will have an URI https://api.com/token/1\n\t *\n\t * @dev If token URI is set with `setTokenURI()` it will be returned as is via `tokenURI()`\n\t */\n\tstring public override baseURI = \"\";\n\n\t/**\n\t * @dev Optional mapping for token URIs to be returned as is when `tokenURI()`\n\t *      is called; if mapping doesn't exist for token, the URI is constructed\n\t *      as `base URI + token ID`, where plus (+) denotes string concatenation\n\t */\n\tmapping(uint256 => string) internal _tokenURIs;\n\n\t/**\n\t * @dev 32 bit token ID space is optimal for batch minting in batches of size 8\n\t *      8 * 32 = 256 - single storage slot in global/local collection(s)\n\t */\n\tuint8 public constant BATCH_SIZE_MULTIPLIER = 8;\n\n\t/**\n\t * @notice Enables ERC721 transfers of the tokens\n\t *      (transfer by the token owner himself)\n\t * @dev Feature FEATURE_TRANSFERS must be enabled in order for\n\t *      `transferFrom()` function to succeed when executed by token owner\n\t */\n\tuint32 public constant FEATURE_TRANSFERS = 0x0000_0001;\n\n\t/**\n\t * @notice Enables ERC721 transfers on behalf\n\t *      (transfer by someone else on behalf of token owner)\n\t * @dev Feature FEATURE_TRANSFERS_ON_BEHALF must be enabled in order for\n\t *      `transferFrom()` function to succeed whe executed by approved operator\n\t * @dev Token owner must call `approve()` or `setApprovalForAll()`\n\t *      first to authorize the transfer on behalf\n\t */\n\tuint32 public constant FEATURE_TRANSFERS_ON_BEHALF = 0x0000_0002;\n\n\t/**\n\t * @notice Enables token owners to burn their own tokens\n\t *\n\t * @dev Feature FEATURE_OWN_BURNS must be enabled in order for\n\t *      `burn()` function to succeed when called by token owner\n\t */\n\tuint32 public constant FEATURE_OWN_BURNS = 0x0000_0008;\n\n\t/**\n\t * @notice Enables approved operators to burn tokens on behalf of their owners\n\t *\n\t * @dev Feature FEATURE_BURNS_ON_BEHALF must be enabled in order for\n\t *      `burn()` function to succeed when called by approved operator\n\t */\n\tuint32 public constant FEATURE_BURNS_ON_BEHALF = 0x0000_0010;\n\n\t/**\n\t * @notice Enables approvals on behalf (permits via an EIP712 signature)\n\t * @dev Feature FEATURE_PERMITS must be enabled in order for\n\t *      `permit()` function to succeed\n\t */\n\tuint32 public constant FEATURE_PERMITS = 0x0000_0200;\n\n\t/**\n\t * @notice Enables operator approvals on behalf (permits for all via an EIP712 signature)\n\t * @dev Feature FEATURE_OPERATOR_PERMITS must be enabled in order for\n\t *      `permitForAll()` function to succeed\n\t */\n\tuint32 public constant FEATURE_OPERATOR_PERMITS = 0x0000_0400;\n\n\t/**\n\t * @notice Token creator is responsible for creating (minting)\n\t *      tokens to an arbitrary address\n\t * @dev Role ROLE_TOKEN_CREATOR allows minting tokens\n\t *      (calling `mint` function)\n\t */\n\tuint32 public constant ROLE_TOKEN_CREATOR = 0x0001_0000;\n\n\t/**\n\t * @notice Token destroyer is responsible for destroying (burning)\n\t *      tokens owned by an arbitrary address\n\t * @dev Role ROLE_TOKEN_DESTROYER allows burning tokens\n\t *      (calling `burn` function)\n\t */\n\tuint32 public constant ROLE_TOKEN_DESTROYER = 0x0002_0000;\n\n\t/**\n\t * @notice URI manager is responsible for managing base URI\n\t *      part of the token URI ERC721Metadata interface\n\t *\n\t * @dev Role ROLE_URI_MANAGER allows updating the base URI\n\t *      (executing `setBaseURI` function)\n\t */\n\tuint32 public constant ROLE_URI_MANAGER = 0x0010_0000;\n\n\t/**\n\t * @notice EIP-712 contract's domain typeHash,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\n\t *\n\t * @dev Note: we do not include version into the domain typehash/separator,\n\t *      it is implied version is concatenated to the name field, like \"AliERC721v1\"\n\t */\n\t// keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\")\n\tbytes32 public constant DOMAIN_TYPEHASH = 0x8cad95687ba82c2ce50e74f7b754645e5117c3a5bec8151c0726d5857980a866;\n\n\t/**\n\t * @notice EIP-712 contract's domain separator,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator\n\t */\n\tbytes32 public immutable DOMAIN_SEPARATOR;\n\n\t/**\n\t * @notice EIP-712 permit (EIP-2612) struct typeHash,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\n\t */\n\t// keccak256(\"Permit(address owner,address operator,uint256 tokenId,uint256 nonce,uint256 deadline)\")\n\tbytes32 public constant PERMIT_TYPEHASH = 0xee2282d7affd5a432b221a559e429129347b0c19a3f102179a5fb1859eef3d29;\n\n\t/**\n\t * @notice EIP-712 permitForAll (EIP-2612) struct typeHash,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\n\t */\n\t// keccak256(\"PermitForAll(address owner,address operator,bool approved,uint256 nonce,uint256 deadline)\")\n\tbytes32 public constant PERMIT_FOR_ALL_TYPEHASH = 0x47ab88482c90e4bb94b82a947ae78fa91fb25de1469ab491f4c15b9a0a2677ee;\n\n\t/**\n\t * @dev Fired in setBaseURI()\n\t *\n\t * @param _by an address which executed update\n\t * @param _oldVal old _baseURI value\n\t * @param _newVal new _baseURI value\n\t */\n\tevent BaseURIUpdated(address indexed _by, string _oldVal, string _newVal);\n\n\t/**\n\t * @dev Fired in setTokenURI()\n\t *\n\t * @param _by an address which executed update\n\t * @param _tokenId token ID which URI was updated\n\t * @param _oldVal old _baseURI value\n\t * @param _newVal new _baseURI value\n\t */\n\tevent TokenURIUpdated(address indexed _by, uint256 _tokenId, string _oldVal, string _newVal);\n\n\t/**\n\t * @dev Constructs/deploys ERC721 instance with the name and symbol specified\n\t *\n\t * @param _name name of the token to be accessible as `name()`,\n\t *      ERC-20 compatible descriptive name for a collection of NFTs in this contract\n\t * @param _symbol token symbol to be accessible as `symbol()`,\n\t *      ERC-20 compatible descriptive name for a collection of NFTs in this contract\n\t */\n\tconstructor(string memory _name, string memory _symbol) {\n\t\t// set the name\n\t\tname = _name;\n\n\t\t// set the symbol\n\t\tsymbol = _symbol;\n\n\t\t// build the EIP-712 contract domain separator, see https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator\n\t\t// note: we specify contract version in its name\n\t\tDOMAIN_SEPARATOR = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(\"AliERC721v1\")), block.chainid, address(this)));\n\t}\n\n\t/**\n\t * @dev Verifies if token is transferable (i.e. can change ownership, allowed to be transferred);\n\t *      The default behaviour is to always allow transfer if token exists\n\t *\n\t * @dev Implementations may modify the default behaviour based on token metadata\n\t *      if required\n\t *\n\t * @param _tokenId ID of the token to check if it's transferable\n\t * @return true if token is transferable, false otherwise\n\t */\n\tfunction isTransferable(uint256 _tokenId) public view virtual returns(bool) {\n\t\t// validate token existence\n\t\trequire(exists(_tokenId), \"token doesn't exist\");\n\n\t\t// generic implementation returns true if token exists\n\t\treturn true;\n\t}\n\n\t/**\n\t * @notice Checks if specified token exists\n\t *\n\t * @dev Returns whether the specified token ID has an ownership\n\t *      information associated with it\n\t *\n\t * @inheritdoc MintableERC721\n\t *\n\t * @param _tokenId ID of the token to query existence for\n\t * @return whether the token exists (true - exists, false - doesn't exist)\n\t */\n\tfunction exists(uint256 _tokenId) public override view returns(bool) {\n\t\t// read ownership information and return a check if it's not zero (set)\n\t\treturn tokens[_tokenId] != 0;\n\t}\n\n\t/**\n\t * @inheritdoc ERC165\n\t */\n\tfunction supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n\t\t// construct the interface support from required and optional ERC721 interfaces\n\t\treturn interfaceId == type(ERC165).interfaceId\n\t\t\t|| interfaceId == type(ERC721).interfaceId\n\t\t\t|| interfaceId == type(ERC721Metadata).interfaceId\n\t\t\t|| interfaceId == type(ERC721Enumerable).interfaceId\n\t\t\t|| interfaceId == type(MintableERC721).interfaceId\n\t\t\t|| interfaceId == type(BurnableERC721).interfaceId;\n\t}\n\n\t// ===== Start: ERC721 Metadata =====\n\n\t/**\n\t * @dev Restricted access function which updates base URI used to construct\n\t *      ERC721Metadata.tokenURI\n\t *\n\t * @dev Requires executor to have ROLE_URI_MANAGER permission\n\t *\n\t * @param _baseURI new base URI to set\n\t */\n\tfunction setBaseURI(string memory _baseURI) public virtual {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_URI_MANAGER), \"access denied\");\n\n\t\t// emit an event first - to log both old and new values\n\t\temit BaseURIUpdated(msg.sender, baseURI, _baseURI);\n\n\t\t// and update base URI\n\t\tbaseURI = _baseURI;\n\t}\n\n\t/**\n\t * @dev Returns token URI if it was previously set with `setTokenURI`,\n\t *      otherwise constructs it as base URI + token ID\n\t *\n\t * @inheritdoc ERC721Metadata\n\t */\n\tfunction tokenURI(uint256 _tokenId) public view override returns (string memory) {\n\t\t// verify token exists\n\t\trequire(exists(_tokenId), \"token doesn't exist\");\n\n\t\t// read the token URI for the token specified\n\t\tstring memory _tokenURI = _tokenURIs[_tokenId];\n\n\t\t// if token URI is set\n\t\tif(bytes(_tokenURI).length > 0) {\n\t\t\t// just return it\n\t\t\treturn _tokenURI;\n\t\t}\n\n\t\t// if base URI is not set\n\t\tif(bytes(baseURI).length == 0) {\n\t\t\t// return an empty string\n\t\t\treturn \"\";\n\t\t}\n\n\t\t// otherwise concatenate base URI + token ID\n\t\treturn StringUtils.concat(baseURI, StringUtils.itoa(_tokenId, 10));\n\t}\n\n\t/**\n\t * @dev Sets the token URI for the token defined by its ID\n\t *\n\t * @param _tokenId an ID of the token to set URI for\n\t * @param _tokenURI token URI to set\n\t */\n\tfunction setTokenURI(uint256 _tokenId, string memory _tokenURI) public virtual {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_URI_MANAGER), \"access denied\");\n\n\t\t// we do not verify token existence: we want to be able to\n\t\t// preallocate token URIs before tokens are actually minted\n\n\t\t// emit an event first - to log both old and new values\n\t\temit TokenURIUpdated(msg.sender, _tokenId, _tokenURIs[_tokenId], _tokenURI);\n\n\t\t// and update token URI\n\t\t_tokenURIs[_tokenId] = _tokenURI;\n\t}\n\n\t// ===== End: ERC721 Metadata =====\n\n\t// ===== Start: ERC721, ERC721Enumerable Getters (view functions) =====\n\n\t/**\n\t * @inheritdoc ERC721\n\t */\n\tfunction balanceOf(address _owner) public view override returns (uint256) {\n\t\t// check `_owner` address is set\n\t\trequire(_owner != address(0), \"zero address\");\n\n\t\t// derive owner balance for the their owned tokens collection\n\t\t// as the length of that collection\n\t\treturn collections[_owner].length;\n\t}\n\n\t/**\n\t * @inheritdoc ERC721\n\t */\n\tfunction ownerOf(uint256 _tokenId) public view override returns (address) {\n\t\t// derive ownership information of the token from the ownership mapping\n\t\t// by extracting lower 160 bits of the mapping value as an address\n\t\taddress owner = address(uint160(tokens[_tokenId]));\n\n\t\t// verify owner/token exists\n\t\trequire(owner != address(0), \"token doesn't exist\");\n\n\t\t// return owner address\n\t\treturn owner;\n\t}\n\n\t/**\n\t * @inheritdoc ERC721Enumerable\n\t */\n\tfunction totalSupply() public view override returns (uint256) {\n\t\t// derive total supply value from the array of all existing tokens\n\t\t// as the length of this array\n\t\treturn allTokens.length;\n\t}\n\n\t/**\n\t * @inheritdoc ERC721Enumerable\n\t */\n\tfunction tokenByIndex(uint256 _index) public view override returns (uint256) {\n\t\t// index out of bounds check\n\t\trequire(_index < totalSupply(), \"index out of bounds\");\n\n\t\t// find the token ID requested and return\n\t\treturn allTokens[_index];\n\t}\n\n\t/**\n\t * @inheritdoc ERC721Enumerable\n\t */\n\tfunction tokenOfOwnerByIndex(address _owner, uint256 _index) public view override returns (uint256) {\n\t\t// index out of bounds check\n\t\trequire(_index < balanceOf(_owner), \"index out of bounds\");\n\n\t\t// find the token ID requested and return\n\t\treturn collections[_owner][_index];\n\t}\n\n\t/**\n\t * @inheritdoc ERC721\n\t */\n\tfunction getApproved(uint256 _tokenId) public view override returns (address) {\n\t\t// verify token specified exists\n\t\trequire(exists(_tokenId), \"token doesn't exist\");\n\n\t\t// read the approval value and return\n\t\treturn approvals[_tokenId];\n\t}\n\n\t/**\n\t * @inheritdoc ERC721\n\t */\n\tfunction isApprovedForAll(address _owner, address _operator) public view override returns (bool) {\n\t\t// read the approval state value and return\n\t\treturn approvedOperators[_owner][_operator];\n\t}\n\n\t// ===== End: ERC721, ERC721Enumerable Getters (view functions) =====\n\n\t// ===== Start: ERC721 mutative functions (transfers, approvals) =====\n\n\t/**\n\t * @inheritdoc ERC721\n\t */\n\tfunction safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory _data) public override {\n\t\t// delegate call to unsafe transfer on behalf `transferFrom()`\n\t\ttransferFrom(_from, _to, _tokenId);\n\n\t\t// if receiver `_to` is a smart contract\n\t\tif(AddressUtils.isContract(_to)) {\n\t\t\t// check it supports ERC721 interface - execute onERC721Received()\n\t\t\tbytes4 response = ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data);\n\n\t\t\t// expected response is ERC721TokenReceiver(_to).onERC721Received.selector\n\t\t\t// bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))\n\t\t\trequire(response == ERC721TokenReceiver(_to).onERC721Received.selector, \"invalid onERC721Received response\");\n\t\t}\n\t}\n\n\t/**\n\t * @inheritdoc ERC721\n\t */\n\tfunction safeTransferFrom(address _from, address _to, uint256 _tokenId) public override {\n\t\t// delegate call to overloaded `safeTransferFrom()`, set data to \"\"\n\t\tsafeTransferFrom(_from, _to, _tokenId, \"\");\n\t}\n\n\t/**\n\t * @inheritdoc ERC721\n\t */\n\tfunction transferFrom(address _from, address _to, uint256 _tokenId) public override {\n\t\t// if `_from` is equal to sender, require transfers feature to be enabled\n\t\t// otherwise require transfers on behalf feature to be enabled\n\t\trequire(_from == msg.sender && isFeatureEnabled(FEATURE_TRANSFERS)\n\t\t     || _from != msg.sender && isFeatureEnabled(FEATURE_TRANSFERS_ON_BEHALF),\n\t\t        _from == msg.sender? \"transfers are disabled\": \"transfers on behalf are disabled\");\n\n\t\t// validate destination address is set\n\t\trequire(_to != address(0), \"zero address\");\n\n\t\t// validate token ownership, which also\n\t\t// validates token existence under the hood\n\t\trequire(_from == ownerOf(_tokenId), \"access denied\");\n\n\t\t// verify operator (transaction sender) is either token owner,\n\t\t// or is approved by the token owner to transfer this particular token,\n\t\t// or is approved by the token owner to transfer any of his tokens\n\t\trequire(_from == msg.sender || msg.sender == getApproved(_tokenId) || isApprovedForAll(_from, msg.sender), \"access denied\");\n\n\t\t// transfer is not allowed for a locked token\n\t\trequire(isTransferable(_tokenId), \"locked token\");\n\n\t\t// if required, move token ownership,\n\t\t// update old and new owner's token collections accordingly:\n\t\tif(_from != _to) {\n\t\t\t// remove token from old owner's collection (also clears approval)\n\t\t\t__removeLocal(_tokenId);\n\t\t\t// add token to the new owner's collection\n\t\t\t__addLocal(_tokenId, _to);\n\t\t}\n\t\t// even if no real changes are required, approval needs to be erased\n\t\telse {\n\t\t\t// clear token approval (also emits an Approval event)\n\t\t\t__clearApproval(_from, _tokenId);\n\t\t}\n\n\t\t// fire ERC721 transfer event\n\t\temit Transfer(_from, _to, _tokenId);\n\t}\n\n\t/**\n\t * @inheritdoc ERC721\n\t */\n\tfunction approve(address _approved, uint256 _tokenId) public override {\n\t\t// make an internal approve - delegate to `__approve`\n\t\t__approve(msg.sender, _approved, _tokenId);\n\t}\n\n\t/**\n\t * @dev Powers the meta transaction for `approve` - EIP-712 signed `permit`\n\t *\n\t * @dev Approves address called `_operator` to transfer token `_tokenId`\n\t *      on behalf of the `_owner`\n\t *\n\t * @dev Zero `_operator` address indicates there is no approved address,\n\t *      and effectively removes an approval for the token specified\n\t *\n\t * @dev `_owner` must own token `_tokenId` to grant the permission\n\t * @dev Throws if `_operator` is a self address (`_owner`),\n\t *      or if `_tokenId` doesn't exist\n\t *\n\t * @param _owner owner of the token `_tokenId` to set approval on behalf of\n\t * @param _operator an address approved by the token owner\n\t *      to spend token `_tokenId` on its behalf\n\t * @param _tokenId token ID operator `_approved` is allowed to\n\t *      transfer on behalf of the token owner\n\t */\n\tfunction __approve(address _owner, address _operator, uint256 _tokenId) private {\n\t\t// get token owner address\n\t\taddress owner = ownerOf(_tokenId);\n\n\t\t// approving owner address itself doesn't make sense and is not allowed\n\t\trequire(_operator != owner, \"self approval\");\n\n\t\t// only token owner or/and approved operator can set the approval\n\t\trequire(_owner == owner || isApprovedForAll(owner, _owner), \"access denied\");\n\n\t\t// update the approval\n\t\tapprovals[_tokenId] = _operator;\n\n\t\t// emit an event\n\t\temit Approval(owner, _operator, _tokenId);\n\t}\n\n\t/**\n\t * @inheritdoc ERC721\n\t */\n\tfunction setApprovalForAll(address _operator, bool _approved) public override {\n\t\t// make an internal approve - delegate to `__approveForAll`\n\t\t__approveForAll(msg.sender, _operator, _approved);\n\t}\n\n\t/**\n\t * @dev Powers the meta transaction for `setApprovalForAll` - EIP-712 signed `permitForAll`\n\t *\n\t * @dev Approves address called `_operator` to transfer any tokens\n\t *      on behalf of the `_owner`\n\t *\n\t * @dev `_owner` must not necessarily own any tokens to grant the permission\n\t * @dev Throws if `_operator` is a self address (`_owner`)\n\t *\n\t * @param _owner owner of the tokens to set approval on behalf of\n\t * @param _operator an address to add to the set of authorized operators, i.e.\n\t *      an address approved by the token owner to spend tokens on its behalf\n\t * @param _approved true if the operator is approved, false to revoke approval\n\t */\n\tfunction __approveForAll(address _owner, address _operator, bool _approved) private {\n\t\t// approving tx sender address itself doesn't make sense and is not allowed\n\t\trequire(_operator != _owner, \"self approval\");\n\n\t\t// update the approval\n\t\tapprovedOperators[_owner][_operator] = _approved;\n\n\t\t// emit an event\n\t\temit ApprovalForAll(_owner, _operator, _approved);\n\t}\n\n\t/**\n\t * @dev Clears approval for a given token owned by a given owner,\n\t *      emits an Approval event\n\t *\n\t * @dev Unsafe: doesn't check the validity of inputs (must be kept private),\n\t *      assuming the check is done by the caller\n\t *      - token existence\n\t *      - token ownership\n\t *\n\t * @param _owner token owner to be logged into Approved event as is\n\t * @param _tokenId token ID to erase approval for and to log into Approved event as is\n\t */\n\tfunction __clearApproval(address _owner, uint256 _tokenId) internal {\n\t\t// clear token approval\n\t\tdelete approvals[_tokenId];\n\t\t// emit an ERC721 Approval event:\n\t\t// \"When a Transfer event emits, this also indicates that the approved\n\t\t// address for that NFT (if any) is reset to none.\"\n\t\temit Approval(_owner, address(0), _tokenId);\n\t}\n\n\t// ===== End: ERC721 mutative functions (transfers, approvals) =====\n\n\t// ===== Start: Meta-transactions Support =====\n\n\t/**\n\t * @notice Change or reaffirm the approved address for an NFT on behalf\n\t *\n\t * @dev Executes approve(_operator, _tokenId) on behalf of the token owner\n\t *      who EIP-712 signed the transaction, i.e. as if transaction sender is the EIP712 signer\n\t *\n\t * @dev Sets the `_tokenId` as the allowance of `_operator` over `_owner` token,\n\t *      given `_owner` EIP-712 signed approval\n\t *\n\t * @dev Emits `Approval` event in the same way as `approve` does\n\t *\n\t * @dev Requires:\n\t *     - `_operator` to be non-zero address\n\t *     - `_exp` to be a timestamp in the future\n\t *     - `v`, `r` and `s` to be a valid `secp256k1` signature from `_owner`\n\t *        over the EIP712-formatted function arguments.\n\t *     - the signature to use `_owner` current nonce (see `permitNonces`).\n\t *\n\t * @dev For more information on the signature format, see the\n\t *      https://eips.ethereum.org/EIPS/eip-2612#specification\n\t *\n\t * @param _owner owner of the token to set approval on behalf of,\n\t *      an address which signed the EIP-712 message\n\t * @param _operator new approved NFT controller\n\t * @param _tokenId token ID to approve\n\t * @param _exp signature expiration time (unix timestamp)\n\t * @param v the recovery byte of the signature\n\t * @param r half of the ECDSA signature pair\n\t * @param s half of the ECDSA signature pair\n\t */\n\tfunction permit(address _owner, address _operator, uint256 _tokenId, uint256 _exp, uint8 v, bytes32 r, bytes32 s) public {\n\t\t// verify permits are enabled\n\t\trequire(isFeatureEnabled(FEATURE_PERMITS), \"permits are disabled\");\n\n\t\t// derive signer of the EIP712 Permit message, and\n\t\t// update the nonce for that particular signer to avoid replay attack!!! ----------->>> ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓\n\t\taddress signer = __deriveSigner(abi.encode(PERMIT_TYPEHASH, _owner, _operator, _tokenId, permitNonces[_owner]++, _exp), v, r, s);\n\n\t\t// perform message integrity and security validations\n\t\trequire(signer == _owner, \"invalid signature\");\n\t\trequire(block.timestamp < _exp, \"signature expired\");\n\n\t\t// delegate call to `__approve` - execute the logic required\n\t\t__approve(_owner, _operator, _tokenId);\n\t}\n\n\t/**\n\t * @notice Enable or disable approval for a third party (\"operator\") to manage\n\t *      all of owner's assets - on behalf\n\t *\n\t * @dev Executes setApprovalForAll(_operator, _approved) on behalf of the owner\n\t *      who EIP-712 signed the transaction, i.e. as if transaction sender is the EIP712 signer\n\t *\n\t * @dev Sets the `_operator` as the token operator for `_owner` tokens,\n\t *      given `_owner` EIP-712 signed approval\n\t *\n\t * @dev Emits `ApprovalForAll` event in the same way as `setApprovalForAll` does\n\t *\n\t * @dev Requires:\n\t *     - `_operator` to be non-zero address\n\t *     - `_exp` to be a timestamp in the future\n\t *     - `v`, `r` and `s` to be a valid `secp256k1` signature from `_owner`\n\t *        over the EIP712-formatted function arguments.\n\t *     - the signature to use `_owner` current nonce (see `permitNonces`).\n\t *\n\t * @dev For more information on the signature format, see the\n\t *      https://eips.ethereum.org/EIPS/eip-2612#specification\n\t *\n\t * @param _owner owner of the tokens to set approval on behalf of,\n\t *      an address which signed the EIP-712 message\n\t * @param _operator an address to add to the set of authorized operators, i.e.\n\t *      an address approved by the token owner to spend tokens on its behalf\n\t * @param _approved true if the operator is approved, false to revoke approval\n\t * @param _exp signature expiration time (unix timestamp)\n\t * @param v the recovery byte of the signature\n\t * @param r half of the ECDSA signature pair\n\t * @param s half of the ECDSA signature pair\n\t */\n\tfunction permitForAll(address _owner, address _operator, bool _approved, uint256 _exp, uint8 v, bytes32 r, bytes32 s) public {\n\t\t// verify permits are enabled\n\t\trequire(isFeatureEnabled(FEATURE_OPERATOR_PERMITS), \"operator permits are disabled\");\n\n\t\t// derive signer of the EIP712 PermitForAll message, and\n\t\t// update the nonce for that particular signer to avoid replay attack!!! --------------------->>> ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓\n\t\taddress signer = __deriveSigner(abi.encode(PERMIT_FOR_ALL_TYPEHASH, _owner, _operator, _approved, permitNonces[_owner]++, _exp), v, r, s);\n\n\t\t// perform message integrity and security validations\n\t\trequire(signer == _owner, \"invalid signature\");\n\t\trequire(block.timestamp < _exp, \"signature expired\");\n\n\t\t// delegate call to `__approve` - execute the logic required\n\t\t__approveForAll(_owner, _operator, _approved);\n\t}\n\n\t/**\n\t * @dev Auxiliary function to verify structured EIP712 message signature and derive its signer\n\t *\n\t * @param abiEncodedTypehash abi.encode of the message typehash together with all its parameters\n\t * @param v the recovery byte of the signature\n\t * @param r half of the ECDSA signature pair\n\t * @param s half of the ECDSA signature pair\n\t */\n\tfunction __deriveSigner(bytes memory abiEncodedTypehash, uint8 v, bytes32 r, bytes32 s) private view returns(address) {\n\t\t// build the EIP-712 hashStruct of the message\n\t\tbytes32 hashStruct = keccak256(abiEncodedTypehash);\n\n\t\t// calculate the EIP-712 digest \"\\x19\\x01\" ‖ domainSeparator ‖ hashStruct(message)\n\t\tbytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR, hashStruct));\n\n\t\t// recover the address which signed the message with v, r, s\n\t\taddress signer = ECDSA.recover(digest, v, r, s);\n\n\t\t// return the signer address derived from the signature\n\t\treturn signer;\n\t}\n\n\t// ===== End: Meta-transactions Support =====\n\n\t// ===== Start: mint/burn support =====\n\n\t/**\n\t * @dev Creates new token with token ID specified\n\t *      and assigns an ownership `_to` for this token\n\t *\n\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\n\t *      `onERC721Received` on `_to` and throws if the return value is not\n\t *      `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n\t *\n\t * @dev Requires executor to have `ROLE_TOKEN_CREATOR` permission\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId ID of the token to mint\n\t * @param _data additional data with no specified format, sent in call to `_to`\n\t */\n\tfunction safeMint(address _to, uint256 _tokenId, bytes memory _data) public override {\n\t\t// delegate to unsafe mint\n\t\tmint(_to, _tokenId);\n\n\t\t// make it safe: execute `onERC721Received`\n\n\t\t// if receiver `_to` is a smart contract\n\t\tif(AddressUtils.isContract(_to)) {\n\t\t\t// check it supports ERC721 interface - execute onERC721Received()\n\t\t\tbytes4 response = ERC721TokenReceiver(_to).onERC721Received(msg.sender, address(0), _tokenId, _data);\n\n\t\t\t// expected response is ERC721TokenReceiver(_to).onERC721Received.selector\n\t\t\t// bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))\n\t\t\trequire(response == ERC721TokenReceiver(_to).onERC721Received.selector, \"invalid onERC721Received response\");\n\t\t}\n\t}\n\n\t/**\n\t * @dev Creates new token with token ID specified\n\t *      and assigns an ownership `_to` for this token\n\t *\n\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\n\t *      `onERC721Received` on `_to` and throws if the return value is not\n\t *      `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n\t *\n\t * @dev Requires executor to have `ROLE_TOKEN_CREATOR` permission\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId ID of the token to mint\n\t */\n\tfunction safeMint(address _to, uint256 _tokenId) public override {\n\t\t// delegate to `safeMint` with empty data\n\t\tsafeMint(_to, _tokenId, \"\");\n\t}\n\n\t/**\n\t * @dev Creates new tokens starting with token ID specified\n\t *      and assigns an ownership `_to` for these tokens\n\t *\n\t * @dev Token IDs to be minted: [_tokenId, _tokenId + n)\n\t *\n\t * @dev n must be greater or equal 2: `n > 1`\n\t *\n\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\n\t *      `onERC721Received` on `_to` and throws if the return value is not\n\t *      `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n\t *\n\t * @dev Requires executor to have `ROLE_TOKEN_CREATOR` permission\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId ID of the token to mint\n\t * @param n how many tokens to mint, sequentially increasing the _tokenId\n\t * @param _data additional data with no specified format, sent in call to `_to`\n\t */\n\tfunction safeMintBatch(address _to, uint256 _tokenId, uint256 n, bytes memory _data) public override {\n\t\t// delegate to unsafe mint\n\t\tmintBatch(_to, _tokenId, n);\n\n\t\t// make it safe: execute `onERC721Received`\n\n\t\t// if receiver `_to` is a smart contract\n\t\tif(AddressUtils.isContract(_to)) {\n\t\t\t// onERC721Received: for each token minted\n\t\t\tfor(uint256 i = 0; i < n; i++) {\n\t\t\t\t// check it supports ERC721 interface - execute onERC721Received()\n\t\t\t\tbytes4 response = ERC721TokenReceiver(_to).onERC721Received(msg.sender, address(0), _tokenId + i, _data);\n\n\t\t\t\t// expected response is ERC721TokenReceiver(_to).onERC721Received.selector\n\t\t\t\t// bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))\n\t\t\t\trequire(response == ERC721TokenReceiver(_to).onERC721Received.selector, \"invalid onERC721Received response\");\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @dev Creates new tokens starting with token ID specified\n\t *      and assigns an ownership `_to` for these tokens\n\t *\n\t * @dev Token IDs to be minted: [_tokenId, _tokenId + n)\n\t *\n\t * @dev n must be greater or equal 2: `n > 1`\n\t *\n\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\n\t *      `onERC721Received` on `_to` and throws if the return value is not\n\t *      `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n\t *\n\t * @dev Requires executor to have `ROLE_TOKEN_CREATOR` permission\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId ID of the token to mint\n\t * @param n how many tokens to mint, sequentially increasing the _tokenId\n\t */\n\tfunction safeMintBatch(address _to, uint256 _tokenId, uint256 n) public override {\n\t\t// delegate to `safeMint` with empty data\n\t\tsafeMintBatch(_to, _tokenId, n, \"\");\n\t}\n\n\t/**\n\t * @dev Creates new token with token ID specified\n\t *      and assigns an ownership `_to` for this token\n\t *\n\t * @dev Unsafe: doesn't execute `onERC721Received` on the receiver.\n\t *      Prefer the use of `saveMint` instead of `mint`.\n\t *\n\t * @dev Requires executor to have `ROLE_TOKEN_CREATOR` permission\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId ID of the token to mint\n\t */\n\tfunction mint(address _to, uint256 _tokenId) public override {\n\t\t// check if caller has sufficient permissions to mint tokens\n\t\trequire(isSenderInRole(ROLE_TOKEN_CREATOR), \"access denied\");\n\n\t\t// verify the inputs\n\n\t\t// verify destination address is set\n\t\trequire(_to != address(0), \"zero address\");\n\t\t// verify the token ID is \"tiny\" (32 bits long at most)\n\t\trequire(uint32(_tokenId) == _tokenId, \"token ID overflow\");\n\n\t\t// verify token doesn't yet exist\n\t\trequire(!exists(_tokenId), \"already minted\");\n\n\t\t// create token ownership record,\n\t\t// add token to `allTokens` and new owner's collections\n\t\t// add token to both local and global collections (enumerations)\n\t\t__addToken(_tokenId, _to);\n\n\t\t// fire ERC721 transfer event\n\t\temit Transfer(address(0), _to, _tokenId);\n\t}\n\n\t/**\n\t * @dev Creates new tokens starting with token ID specified\n\t *      and assigns an ownership `_to` for these tokens\n\t *\n\t * @dev Token IDs to be minted: [_tokenId, _tokenId + n)\n\t *\n\t * @dev n must be greater or equal 2: `n > 1`\n\t *\n\t * @dev Unsafe: doesn't execute `onERC721Received` on the receiver.\n\t *      Prefer the use of `saveMintBatch` instead of `mintBatch`.\n\t *\n\t * @dev Requires executor to have `ROLE_TOKEN_CREATOR` permission\n\t *\n\t * @param _to an address to mint tokens to\n\t * @param _tokenId ID of the first token to mint\n\t * @param n how many tokens to mint, sequentially increasing the _tokenId\n\t */\n\tfunction mintBatch(address _to, uint256 _tokenId, uint256 n) public override {\n\t\t// check if caller has sufficient permissions to mint tokens\n\t\trequire(isSenderInRole(ROLE_TOKEN_CREATOR), \"access denied\");\n\n\t\t// verify the inputs\n\n\t\t// verify destination address is set\n\t\trequire(_to != address(0), \"zero address\");\n\t\t// verify n is set properly\n\t\trequire(n > 1, \"n is too small\");\n\t\t// verify the token ID is \"tiny\" (32 bits long at most)\n\t\trequire(uint32(_tokenId) == _tokenId, \"token ID overflow\");\n\t\trequire(uint32(_tokenId + n - 1) == _tokenId + n - 1, \"n-th token ID overflow\");\n\n\t\t// verification: for each token to be minted\n\t\tfor(uint256 i = 0; i < n; i++) {\n\t\t\t// verify token doesn't yet exist\n\t\t\trequire(!exists(_tokenId + i), \"already minted\");\n\t\t}\n\n\t\t// create token ownership records,\n\t\t// add tokens to `allTokens` and new owner's collections\n\t\t// add tokens to both local and global collections (enumerations)\n\t\t__addTokens(_to, _tokenId, n);\n\n\t\t// events: for each token minted\n\t\tfor(uint256 i = 0; i < n; i++) {\n\t\t\t// fire ERC721 transfer event\n\t\t\temit Transfer(address(0), _to, _tokenId + i);\n\t\t}\n\t}\n\n\t/**\n\t * @dev Destroys the token with token ID specified\n\t *\n\t * @dev Requires executor to have `ROLE_TOKEN_DESTROYER` permission\n\t *      or FEATURE_OWN_BURNS/FEATURE_BURNS_ON_BEHALF features to be enabled\n\t *\n\t * @dev Can be disabled by the contract creator forever by disabling\n\t *      FEATURE_OWN_BURNS/FEATURE_BURNS_ON_BEHALF features and then revoking\n\t *      its own roles to burn tokens and to enable burning features\n\t *\n\t * @param _tokenId ID of the token to burn\n\t */\n\tfunction burn(uint256 _tokenId) public override {\n\t\t// read token owner data\n\t\t// verifies token exists under the hood\n\t\taddress _from = ownerOf(_tokenId);\n\n\t\t// check if caller has sufficient permissions to burn tokens\n\t\t// and if not - check for possibility to burn own tokens or to burn on behalf\n\t\tif(!isSenderInRole(ROLE_TOKEN_DESTROYER)) {\n\t\t\t// if `_from` is equal to sender, require own burns feature to be enabled\n\t\t\t// otherwise require burns on behalf feature to be enabled\n\t\t\trequire(_from == msg.sender && isFeatureEnabled(FEATURE_OWN_BURNS)\n\t\t\t     || _from != msg.sender && isFeatureEnabled(FEATURE_BURNS_ON_BEHALF),\n\t\t\t        _from == msg.sender? \"burns are disabled\": \"burns on behalf are disabled\");\n\n\t\t\t// verify sender is either token owner, or approved by the token owner to burn tokens\n\t\t\trequire(_from == msg.sender || msg.sender == getApproved(_tokenId) || isApprovedForAll(_from, msg.sender), \"access denied\");\n\t\t}\n\n\t\t// remove token ownership record (also clears approval),\n\t\t// remove token from both local and global collections\n\t\t__removeToken(_tokenId);\n\n\t\t// delete token URI mapping\n\t\tdelete _tokenURIs[_tokenId];\n\n\t\t// fire ERC721 transfer event\n\t\temit Transfer(_from, address(0), _tokenId);\n\t}\n\n\t// ===== End: mint/burn support =====\n\n\t// ----- Start: auxiliary internal/private functions -----\n\n\t/**\n\t * @dev Adds token to the new owner's collection (local),\n\t *      used internally to transfer existing tokens, to mint new\n\t *\n\t * @dev Unsafe: doesn't check for data structures consistency\n\t *      (token existence, token ownership, etc.)\n\t *\n\t * @dev Must be kept private at all times. Inheriting smart contracts\n\t *      may be interested in overriding this function.\n\t *\n\t * @param _tokenId token ID to add\n\t * @param _to new owner address to add token to\n\t */\n\tfunction __addLocal(uint256 _tokenId, address _to) internal virtual {\n\t\t// get a reference to the collection where token goes to\n\t\tuint32[] storage destination = collections[_to];\n\n\t\t// update local index and ownership, do not change global index\n\t\ttokens[_tokenId] = tokens[_tokenId]\n\t\t\t//  |unused |global | local | ownership information (address)      |\n\t\t\t& 0x00000000FFFFFFFF000000000000000000000000000000000000000000000000\n\t\t\t| uint192(destination.length) << 160 | uint160(_to);\n\n\t\t// push token into the local collection\n\t\tdestination.push(uint32(_tokenId));\n\t}\n\n\t/**\n\t * @dev Add token to both local and global collections (enumerations),\n\t *      used internally to mint new tokens\n\t *\n\t * @dev Unsafe: doesn't check for data structures consistency\n\t *      (token existence, token ownership, etc.)\n\t *\n\t * @dev Must be kept private at all times. Inheriting smart contracts\n\t *      may be interested in overriding this function.\n\t *\n\t * @param _tokenId token ID to add\n\t * @param _to new owner address to add token to\n\t */\n\tfunction __addToken(uint256 _tokenId, address _to) internal virtual {\n\t\t// get a reference to the collection where token goes to\n\t\tuint32[] storage destination = collections[_to];\n\n\t\t// update token global and local indexes, ownership\n\t\ttokens[_tokenId] = uint224(allTokens.length) << 192 | uint192(destination.length) << 160 | uint160(_to);\n\n\t\t// push token into the collection\n\t\tdestination.push(uint32(_tokenId));\n\n\t\t// push it into the global `allTokens` collection (enumeration)\n\t\tallTokens.push(uint32(_tokenId));\n\t}\n\n\t/**\n\t * @dev Add tokens to both local and global collections (enumerations),\n\t *      used internally to mint new tokens in batches\n\t *\n\t * @dev Token IDs to be added: [_tokenId, _tokenId + n)\n\t *      n is expected to be greater or equal 2, but this is not checked\n\t *\n\t * @dev Unsafe: doesn't check for data structures consistency\n\t *      (token existence, token ownership, etc.)\n\t *\n\t * @dev Must be kept private at all times. Inheriting smart contracts\n\t *      may be interested in overriding this function.\n\t *\n\t * @param _to new owner address to add token to\n\t * @param _tokenId first token ID to add\n\t * @param n how many tokens to add, sequentially increasing the _tokenId\n\t */\n\tfunction __addTokens(address _to, uint256 _tokenId, uint256 n) internal virtual {\n\t\t// get a reference to the collection where tokens go to\n\t\tuint32[] storage destination = collections[_to];\n\n\t\t// for each token to be added\n\t\tfor(uint256 i = 0; i < n; i++) {\n\t\t\t// update token global and local indexes, ownership\n\t\t\ttokens[_tokenId + i] = uint224(allTokens.length + i) << 192 | uint192(destination.length + i) << 160 | uint160(_to);\n\t\t}\n\n\t\t// push tokens into the local collection\n\t\tdestination.push32(uint32(_tokenId), uint32(n));\n\t\t// push tokens into the global `allTokens` collection (enumeration)\n\t\tallTokens.push32(uint32(_tokenId), uint32(n));\n\t}\n\n\t/**\n\t * @dev Removes token from owner's local collection,\n\t *      used internally to transfer or burn existing tokens\n\t *\n\t * @dev Unsafe: doesn't check for data structures consistency\n\t *      (token existence, token ownership, etc.)\n\t *\n\t * @dev Must be kept private at all times. Inheriting smart contracts\n\t *      may be interested in overriding this function.\n\t *\n\t * @param _tokenId token ID to remove\n\t */\n\tfunction __removeLocal(uint256 _tokenId) internal virtual {\n\t\t// read token data, containing global and local indexes, owner address\n\t\tuint256 token = tokens[_tokenId];\n\n\t\t// get a reference to the token's owner collection (local)\n\t\tuint32[] storage source = collections[address(uint160(token))];\n\n\t\t// token index within the collection\n\t\tuint32 i = uint32(token >> 160);\n\n\t\t// get an ID of the last token in the collection\n\t\tuint32 sourceId = source[source.length - 1];\n\n\t\t// if the token we're to remove from the collection is not the last one,\n\t\t// we need to move last token in the collection into index `i`\n\t\tif(i != source.length - 1) {\n\t\t\t// we put the last token in the collection to the position released\n\n\t\t\t// update last token local index to point to proper place in the collection\n\t\t\t// preserve global index and ownership info\n\t\t\ttokens[sourceId] = tokens[sourceId]\n\t\t\t\t//  |unused |global | local | ownership information (address)      |\n\t\t\t\t& 0x00000000FFFFFFFF00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n\t\t\t\t| uint192(i) << 160;\n\n\t\t\t// put it into the position `i` within the collection\n\t\t\tsource[i] = sourceId;\n\t\t}\n\n\t\t// trim the collection by removing last element\n\t\tsource.pop();\n\n\t\t// clear token approval (also emits an Approval event)\n\t\t__clearApproval(address(uint160(token)), _tokenId);\n\t}\n\n\t/**\n\t * @dev Removes token from both local and global collections (enumerations),\n\t *      used internally to burn existing tokens\n\t *\n\t * @dev Unsafe: doesn't check for data structures consistency\n\t *      (token existence, token ownership, etc.)\n\t *\n\t * @dev Must be kept private at all times. Inheriting smart contracts\n\t *      may be interested in overriding this function.\n\t *\n\t * @param _tokenId token ID to remove\n\t */\n\tfunction __removeToken(uint256 _tokenId) internal virtual {\n\t\t// remove token from owner's (local) collection first\n\t\t__removeLocal(_tokenId);\n\n\t\t// token index within the global collection\n\t\tuint32 i = uint32(tokens[_tokenId] >> 192);\n\n\t\t// delete the token\n\t\tdelete tokens[_tokenId];\n\n\t\t// get an ID of the last token in the collection\n\t\tuint32 lastId = allTokens[allTokens.length - 1];\n\n\t\t// if the token we're to remove from the collection is not the last one,\n\t\t// we need to move last token in the collection into index `i`\n\t\tif(i != allTokens.length - 1) {\n\t\t\t// we put the last token in the collection to the position released\n\n\t\t\t// update last token global index to point to proper place in the collection\n\t\t\t// preserve local index and ownership info\n\t\t\ttokens[lastId] = tokens[lastId]\n\t\t\t\t//  |unused |global | local | ownership information (address)      |\n\t\t\t\t& 0x0000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n\t\t\t\t| uint224(i) << 192;\n\n\t\t\t// put it into the position `i` within the collection\n\t\t\tallTokens[i] = lastId;\n\t\t}\n\n\t\t// trim the collection by removing last element\n\t\tallTokens.pop();\n\t}\n\n\t// ----- End: auxiliary internal/private functions -----\n}\n"
    },
    "contracts/interfaces/ERC721Spec.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./ERC165Spec.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard\n *\n * @notice See https://eips.ethereum.org/EIPS/eip-721\n *\n * @dev Solidity issue #3412: The ERC721 interfaces include explicit mutability guarantees for each function.\n *      Mutability guarantees are, in order weak to strong: payable, implicit nonpayable, view, and pure.\n *      Implementation MUST meet the mutability guarantee in this interface and MAY meet a stronger guarantee.\n *      For example, a payable function in this interface may be implemented as nonpayable\n *      (no state mutability specified) in implementing contract.\n *      It is expected a later Solidity release will allow stricter contract to inherit from this interface,\n *      but current workaround is that we edit this interface to add stricter mutability before inheriting:\n *      we have removed all \"payable\" modifiers.\n *\n * @dev The ERC-165 identifier for this interface is 0x80ac58cd.\n *\n * @author William Entriken, Dieter Shirley, Jacob Evans, Nastassia Sachs\n */\ninterface ERC721 is ERC165 {\n\t/// @dev This emits when ownership of any NFT changes by any mechanism.\n\t///  This event emits when NFTs are created (`from` == 0) and destroyed\n\t///  (`to` == 0). Exception: during contract creation, any number of NFTs\n\t///  may be created and assigned without emitting Transfer. At the time of\n\t///  any transfer, the approved address for that NFT (if any) is reset to none.\n\tevent Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\n\n\t/// @dev This emits when the approved address for an NFT is changed or\n\t///  reaffirmed. The zero address indicates there is no approved address.\n\t///  When a Transfer event emits, this also indicates that the approved\n\t///  address for that NFT (if any) is reset to none.\n\tevent Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\n\n\t/// @dev This emits when an operator is enabled or disabled for an owner.\n\t///  The operator can manage all NFTs of the owner.\n\tevent ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n\n\t/// @notice Count all NFTs assigned to an owner\n\t/// @dev NFTs assigned to the zero address are considered invalid, and this\n\t///  function throws for queries about the zero address.\n\t/// @param _owner An address for whom to query the balance\n\t/// @return The number of NFTs owned by `_owner`, possibly zero\n\tfunction balanceOf(address _owner) external view returns (uint256);\n\n\t/// @notice Find the owner of an NFT\n\t/// @dev NFTs assigned to zero address are considered invalid, and queries\n\t///  about them do throw.\n\t/// @param _tokenId The identifier for an NFT\n\t/// @return The address of the owner of the NFT\n\tfunction ownerOf(uint256 _tokenId) external view returns (address);\n\n\t/// @notice Transfers the ownership of an NFT from one address to another address\n\t/// @dev Throws unless `msg.sender` is the current owner, an authorized\n\t///  operator, or the approved address for this NFT. Throws if `_from` is\n\t///  not the current owner. Throws if `_to` is the zero address. Throws if\n\t///  `_tokenId` is not a valid NFT. When transfer is complete, this function\n\t///  checks if `_to` is a smart contract (code size > 0). If so, it calls\n\t///  `onERC721Received` on `_to` and throws if the return value is not\n\t///  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n\t/// @param _from The current owner of the NFT\n\t/// @param _to The new owner\n\t/// @param _tokenId The NFT to transfer\n\t/// @param _data Additional data with no specified format, sent in call to `_to`\n\tfunction safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external /*payable*/;\n\n\t/// @notice Transfers the ownership of an NFT from one address to another address\n\t/// @dev This works identically to the other function with an extra data parameter,\n\t///  except this function just sets data to \"\".\n\t/// @param _from The current owner of the NFT\n\t/// @param _to The new owner\n\t/// @param _tokenId The NFT to transfer\n\tfunction safeTransferFrom(address _from, address _to, uint256 _tokenId) external /*payable*/;\n\n\t/// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\n\t///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\n\t///  THEY MAY BE PERMANENTLY LOST\n\t/// @dev Throws unless `msg.sender` is the current owner, an authorized\n\t///  operator, or the approved address for this NFT. Throws if `_from` is\n\t///  not the current owner. Throws if `_to` is the zero address. Throws if\n\t///  `_tokenId` is not a valid NFT.\n\t/// @param _from The current owner of the NFT\n\t/// @param _to The new owner\n\t/// @param _tokenId The NFT to transfer\n\tfunction transferFrom(address _from, address _to, uint256 _tokenId) external /*payable*/;\n\n\t/// @notice Change or reaffirm the approved address for an NFT\n\t/// @dev The zero address indicates there is no approved address.\n\t///  Throws unless `msg.sender` is the current NFT owner, or an authorized\n\t///  operator of the current owner.\n\t/// @param _approved The new approved NFT controller\n\t/// @param _tokenId The NFT to approve\n\tfunction approve(address _approved, uint256 _tokenId) external /*payable*/;\n\n\t/// @notice Enable or disable approval for a third party (\"operator\") to manage\n\t///  all of `msg.sender`'s assets\n\t/// @dev Emits the ApprovalForAll event. The contract MUST allow\n\t///  multiple operators per owner.\n\t/// @param _operator Address to add to the set of authorized operators\n\t/// @param _approved True if the operator is approved, false to revoke approval\n\tfunction setApprovalForAll(address _operator, bool _approved) external;\n\n\t/// @notice Get the approved address for a single NFT\n\t/// @dev Throws if `_tokenId` is not a valid NFT.\n\t/// @param _tokenId The NFT to find the approved address for\n\t/// @return The approved address for this NFT, or the zero address if there is none\n\tfunction getApproved(uint256 _tokenId) external view returns (address);\n\n\t/// @notice Query if an address is an authorized operator for another address\n\t/// @param _owner The address that owns the NFTs\n\t/// @param _operator The address that acts on behalf of the owner\n\t/// @return True if `_operator` is an approved operator for `_owner`, false otherwise\n\tfunction isApprovedForAll(address _owner, address _operator) external view returns (bool);\n}\n\n/// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.\ninterface ERC721TokenReceiver {\n\t/// @notice Handle the receipt of an NFT\n\t/// @dev The ERC721 smart contract calls this function on the recipient\n\t///  after a `transfer`. This function MAY throw to revert and reject the\n\t///  transfer. Return of other than the magic value MUST result in the\n\t///  transaction being reverted.\n\t///  Note: the contract address is always the message sender.\n\t/// @param _operator The address which called `safeTransferFrom` function\n\t/// @param _from The address which previously owned the token\n\t/// @param _tokenId The NFT identifier which is being transferred\n\t/// @param _data Additional data with no specified format\n\t/// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n\t///  unless throwing\n\tfunction onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4);\n}\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n *\n * @notice See https://eips.ethereum.org/EIPS/eip-721\n *\n * @dev The ERC-165 identifier for this interface is 0x5b5e139f.\n *\n * @author William Entriken, Dieter Shirley, Jacob Evans, Nastassia Sachs\n */\ninterface ERC721Metadata is ERC721 {\n\t/// @notice A descriptive name for a collection of NFTs in this contract\n\tfunction name() external view returns (string memory _name);\n\n\t/// @notice An abbreviated name for NFTs in this contract\n\tfunction symbol() external view returns (string memory _symbol);\n\n\t/// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\n\t/// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\n\t///  3986. The URI may point to a JSON file that conforms to the \"ERC721\n\t///  Metadata JSON Schema\".\n\tfunction tokenURI(uint256 _tokenId) external view returns (string memory);\n}\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n *\n * @notice See https://eips.ethereum.org/EIPS/eip-721\n *\n * @dev The ERC-165 identifier for this interface is 0x780e9d63.\n *\n * @author William Entriken, Dieter Shirley, Jacob Evans, Nastassia Sachs\n */\ninterface ERC721Enumerable is ERC721 {\n\t/// @notice Count NFTs tracked by this contract\n\t/// @return A count of valid NFTs tracked by this contract, where each one of\n\t///  them has an assigned and queryable owner not equal to the zero address\n\tfunction totalSupply() external view returns (uint256);\n\n\t/// @notice Enumerate valid NFTs\n\t/// @dev Throws if `_index` >= `totalSupply()`.\n\t/// @param _index A counter less than `totalSupply()`\n\t/// @return The token identifier for the `_index`th NFT,\n\t///  (sort order not specified)\n\tfunction tokenByIndex(uint256 _index) external view returns (uint256);\n\n\t/// @notice Enumerate NFTs assigned to an owner\n\t/// @dev Throws if `_index` >= `balanceOf(_owner)` or if\n\t///  `_owner` is the zero address, representing invalid NFTs.\n\t/// @param _owner An address where we are interested in NFTs owned by them\n\t/// @param _index A counter less than `balanceOf(_owner)`\n\t/// @return The token identifier for the `_index`th NFT assigned to `_owner`,\n\t///   (sort order not specified)\n\tfunction tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\n}\n"
    },
    "contracts/lib/AddressUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title Address Utils\n *\n * @dev Utility library of inline functions on addresses\n *\n * @dev Copy of the Zeppelin's library:\n *      https://github.com/gnosis/openzeppelin-solidity/blob/master/contracts/AddressUtils.sol\n */\nlibrary AddressUtils {\n\n\t/**\n\t * @notice Checks if the target address is a contract\n\t *\n\t * @dev It is unsafe to assume that an address for which this function returns\n\t *      false is an externally-owned account (EOA) and not a contract.\n\t *\n\t * @dev Among others, `isContract` will return false for the following\n\t *      types of addresses:\n\t *        - an externally-owned account\n\t *        - a contract in construction\n\t *        - an address where a contract will be created\n\t *        - an address where a contract lived, but was destroyed\n\t *\n\t * @param addr address to check\n\t * @return whether the target address is a contract\n\t */\n\tfunction isContract(address addr) internal view returns (bool) {\n\t\t// a variable to load `extcodesize` to\n\t\tuint256 size = 0;\n\n\t\t// XXX Currently there is no better way to check if there is a contract in an address\n\t\t// than to check the size of the code at that address.\n\t\t// See https://ethereum.stackexchange.com/a/14016/36603 for more details about how this works.\n\t\t// TODO: Check this again before the Serenity release, because all addresses will be contracts.\n\t\t// solium-disable-next-line security/no-inline-assembly\n\t\tassembly {\n\t\t\t// retrieve the size of the code at address `addr`\n\t\t\tsize := extcodesize(addr)\n\t\t}\n\n\t\t// positive size indicates a smart contract address\n\t\treturn size > 0;\n\t}\n}\n"
    },
    "contracts/lib/ArrayUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title Array Utils\n *\n * @notice Solidity doesn't always work with arrays in an optimal way.\n *      This library collects functions helping to optimize gas usage\n *      when working with arrays in Solidity.\n *\n * @dev One of the most important use cases for arrays is \"tight\" arrays -\n *      arrays which store values significantly less than 256-bits numbers\n *\n * @author Basil Gorin\n */\nlibrary ArrayUtils {\n\t/**\n\t * @dev Pushes `n` 32-bits values sequentially into storage allocated array `data`\n\t *      starting from the 32-bits value `v0`\n\t *\n\t * @dev Optimizations comparing to non-assembly implementation:\n\t *      - reads+writes to array size slot only once (instead of `n` times)\n\t *      - reads from the array data slots only once (instead of `7n/8` times)\n\t *      - writes into array data slots `n/8` times (instead of `n` times)\n\t *\n\t * @dev Maximum gas saving estimate: ~3n sstore, or 15,000 * n\n\t *\n\t * @param data storage array pointer to an array of 32-bits elements\n\t * @param v0 first number to push into the array\n\t * @param n number of values to push, pushes [v0, ..., v0 + n - 1]\n\t */\n\tfunction push32(uint32[] storage data, uint32 v0, uint32 n) internal {\n\t\t// we're going to write 32-bits values into 256-bits storage slots of the array\n\t\t// each 256-slot can store up to 8 32-bits sub-blocks, it can also be partially empty\n\t\tassembly {\n\t\t\t// for dynamic arrays their slot (array.slot) contains the array length\n\t\t\t// array data is stored separately in consequent storage slots starting\n\t\t\t// from the slot with the address keccak256(array.slot)\n\n\t\t\t// read the array length into `len` and increase it by `n`\n\t\t\tlet len := sload(data.slot)\n\t\t\tsstore(data.slot, add(len, n))\n\n\t\t\t// find where to write elements and store this location into `loc`\n\t\t\t// load array storage slot number into memory onto position 0,\n\t\t\t// calculate the keccak256 of the slot number (first 32 bytes at position 0)\n\t\t\t// - this will point to the beginning of the array,\n\t\t\t// so we add array length divided by 8 to point to the last array slot\n\t\t\tmstore(0, data.slot)\n\t\t\tlet loc := add(keccak256(0, 32), div(len, 8))\n\n\t\t\t// if we start writing data into already partially occupied slot (`len % 8 != 0`)\n\t\t\t// we need to modify the contents of that slot: read it and rewrite it\n\t\t\tlet offset := mod(len, 8)\n\t\t\tif not(iszero(offset)) {\n\t\t\t\t// how many 32-bits sub-blocks left in the slot\n\t\t\t\tlet left := sub(8, offset)\n\t\t\t\t// update the `left` value not to exceed `n`\n\t\t\t\tif gt(left, n) { left := n }\n\t\t\t\t// load the contents of the first slot (partially occupied)\n\t\t\t\tlet v256 := sload(loc)\n\t\t\t\t// write the slot in 32-bits sub-blocks\n\t\t\t\tfor { let j := 0 } lt(j, left) { j := add(j, 1) } {\n\t\t\t\t\t// write sub-block `j` at offset: `(j + offset) * 32` bits, length: 32-bits\n\t\t\t\t\t// v256 |= (v0 + j) << (j + offset) * 32\n\t\t\t\t\tv256 := or(v256, shl(mul(add(j, offset), 32), add(v0, j)))\n\t\t\t\t}\n\t\t\t\t// write first slot back, it can be still partially occupied, it can also be full\n\t\t\t\tsstore(loc, v256)\n\t\t\t\t// update `loc`: move to the next slot\n\t\t\t\tloc := add(loc, 1)\n\t\t\t\t// update `v0`: increment by number of values pushed\n\t\t\t\tv0 := add(v0, left)\n\t\t\t\t// update `n`: decrement by number of values pushed\n\t\t\t\tn := sub(n, left)\n\t\t\t}\n\n\t\t\t// rest of the slots (if any) are empty and will be only written to\n\t\t\t// write the array in 256-bits (8x32) slots\n\t\t\t// `i` iterates [0, n) with the 256-bits step, which is 8 taken `n` is 32-bits long\n\t\t\tfor { let i := 0 } lt(i, n) { i := add(i, 8) } {\n\t\t\t\t// how many 32-bits sub-blocks left in the slot\n\t\t\t\tlet left := 8\n\t\t\t\t// update the `left` value not to exceed `n`\n\t\t\t\tif gt(left, n) { left := n }\n\t\t\t\t// init the 256-bits slot value\n\t\t\t\tlet v256 := 0\n\t\t\t\t// write the slot in 32-bits sub-blocks\n\t\t\t\tfor { let j := 0 } lt(j, left) { j := add(j, 1) } {\n\t\t\t\t\t// write sub-block `j` at offset: `j * 32` bits, length: 32-bits\n\t\t\t\t\t// v256 |= (v0 + i + j) << j * 32\n\t\t\t\t\tv256 := or(v256, shl(mul(j, 32), add(v0, add(i, j))))\n\t\t\t\t}\n\t\t\t\t// write slot `i / 8`\n\t\t\t\tsstore(add(loc, div(i, 8)), v256)\n\t\t\t}\n\t\t}\n\t}\n\n}\n"
    },
    "contracts/lib/StringUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title String Utils Library\n *\n * @dev Library for working with strings, primarily converting\n *      between strings and integer types\n *\n * @author Basil Gorin\n */\nlibrary StringUtils {\n\t/**\n\t * @dev Converts a string to unsigned integer using the specified `base`\n\t * @dev Throws on invalid input\n\t *      (wrong characters for a given `base`)\n\t * @dev Throws if given `base` is not supported\n\t * @param a string to convert\n\t * @param base number base, one of 2, 8, 10, 16\n\t * @return i a number representing given string\n\t */\n\tfunction atoi(string memory a, uint8 base) internal pure returns (uint256 i) {\n\t\t// check if the base is valid\n\t\trequire(base == 2 || base == 8 || base == 10 || base == 16);\n\n\t\t// convert string into bytes for convenient iteration\n\t\tbytes memory buf = bytes(a);\n\n\t\t// iterate over the string (bytes buffer)\n\t\tfor(uint256 p = 0; p < buf.length; p++) {\n\t\t\t// extract the digit\n\t\t\tuint8 digit = uint8(buf[p]) - 0x30;\n\n\t\t\t// if digit is greater then 10 - mind the gap\n\t\t\t// see `itoa` function for more details\n\t\t\tif(digit > 10) {\n\t\t\t\t// remove the gap\n\t\t\t\tdigit -= 7;\n\t\t\t}\n\n\t\t\t// check if digit meets the base\n\t\t\trequire(digit < base);\n\n\t\t\t// move to the next digit slot\n\t\t\ti *= base;\n\n\t\t\t// add digit to the result\n\t\t\ti += digit;\n\t\t}\n\n\t\t// return the result\n\t\treturn i;\n\t}\n\n\t/**\n\t * @dev Converts a integer to a string using the specified `base`\n\t * @dev Throws if given `base` is not supported\n\t * @param i integer to convert\n\t * @param base number base, one of 2, 8, 10, 16\n\t * @return a a string representing given integer\n\t */\n\tfunction itoa(uint256 i, uint8 base) internal pure returns (string memory a) {\n\t\t// check if the base is valid\n\t\trequire(base == 2 || base == 8 || base == 10 || base == 16);\n\n\t\t// for zero input the result is \"0\" string for any base\n\t\tif(i == 0) {\n\t\t\treturn \"0\";\n\t\t}\n\n\t\t// bytes buffer to put ASCII characters into\n\t\tbytes memory buf = new bytes(256);\n\n\t\t// position within a buffer to be used in cycle\n\t\tuint256 p = 0;\n\n\t\t// extract digits one by one in a cycle\n\t\twhile(i > 0) {\n\t\t\t// extract current digit\n\t\t\tuint8 digit = uint8(i % base);\n\n\t\t\t// convert it to an ASCII code\n\t\t\t// 0x20 is \" \"\n\t\t\t// 0x30-0x39 is \"0\"-\"9\"\n\t\t\t// 0x41-0x5A is \"A\"-\"Z\"\n\t\t\t// 0x61-0x7A is \"a\"-\"z\" (\"A\"-\"Z\" XOR \" \")\n\t\t\tuint8 ascii = digit + 0x30;\n\n\t\t\t// if digit is greater then 10,\n\t\t\t// fix the 0x3A-0x40 gap of punctuation marks\n\t\t\t// (7 characters in ASCII table)\n\t\t\tif(digit >= 10) {\n\t\t\t\t// jump through the gap\n\t\t\t\tascii += 7;\n\t\t\t}\n\n\t\t\t// write character into the buffer\n\t\t\tbuf[p++] = bytes1(ascii);\n\n\t\t\t// move to the next digit\n\t\t\ti /= base;\n\t\t}\n\n\t\t// `p` contains real length of the buffer now,\n\t\t// allocate the resulting buffer of that size\n\t\tbytes memory result = new bytes(p);\n\n\t\t// copy the buffer in the reversed order\n\t\tfor(p = 0; p < result.length; p++) {\n\t\t\t// copy from the beginning of the original buffer\n\t\t\t// to the end of resulting smaller buffer\n\t\t\tresult[result.length - p - 1] = buf[p];\n\t\t}\n\n\t\t// construct string and return\n\t\treturn string(result);\n\t}\n\n\t/**\n\t * @dev Concatenates two strings `s1` and `s2`, for example, if\n\t *      `s1` == `foo` and `s2` == `bar`, the result `s` == `foobar`\n\t * @param s1 first string\n\t * @param s2 second string\n\t * @return s concatenation result s1 + s2\n\t */\n\tfunction concat(string memory s1, string memory s2) internal pure returns (string memory s) {\n\t\t// an old way of string concatenation (Solidity 0.4) is commented out\n/*\n\t\t// convert s1 into buffer 1\n\t\tbytes memory buf1 = bytes(s1);\n\t\t// convert s2 into buffer 2\n\t\tbytes memory buf2 = bytes(s2);\n\t\t// create a buffer for concatenation result\n\t\tbytes memory buf = new bytes(buf1.length + buf2.length);\n\n\t\t// copy buffer 1 into buffer\n\t\tfor(uint256 i = 0; i < buf1.length; i++) {\n\t\t\tbuf[i] = buf1[i];\n\t\t}\n\n\t\t// copy buffer 2 into buffer\n\t\tfor(uint256 j = buf1.length; j < buf2.length; j++) {\n\t\t\tbuf[j] = buf2[j - buf1.length];\n\t\t}\n\n\t\t// construct string and return\n\t\treturn string(buf);\n*/\n\n\t\t// simply use built in function\n\t\treturn string(abi.encodePacked(s1, s2));\n\t}\n}\n"
    },
    "contracts/lib/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n *\n * @dev Copy of the Zeppelin's library:\n *      https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b0cf6fbb7a70f31527f36579ad644e1cf12fdf4e/contracts/utils/cryptography/ECDSA.sol\n */\nlibrary ECDSA {\n\t/**\n\t * @dev Returns the address that signed a hashed message (`hash`) with\n\t * `signature`. This address can then be used for verification purposes.\n\t *\n\t * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n\t * this function rejects them by requiring the `s` value to be in the lower\n\t * half order, and the `v` value to be either 27 or 28.\n\t *\n\t * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n\t * verification to be secure: it is possible to craft signatures that\n\t * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n\t * this is by receiving a hash of the original message (which may otherwise\n\t * be too long), and then calling {toEthSignedMessageHash} on it.\n\t *\n\t * Documentation for signature generation:\n\t * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n\t * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n\t */\n\tfunction recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n\t\t// Divide the signature in r, s and v variables\n\t\tbytes32 r;\n\t\tbytes32 s;\n\t\tuint8 v;\n\n\t\t// Check the signature length\n\t\t// - case 65: r,s,v signature (standard)\n\t\t// - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n\t\tif (signature.length == 65) {\n\t\t\t// ecrecover takes the signature parameters, and the only way to get them\n\t\t\t// currently is to use assembly.\n\t\t\tassembly {\n\t\t\t\tr := mload(add(signature, 0x20))\n\t\t\t\ts := mload(add(signature, 0x40))\n\t\t\t\tv := byte(0, mload(add(signature, 0x60)))\n\t\t\t}\n\t\t}\n\t\telse if (signature.length == 64) {\n\t\t\t// ecrecover takes the signature parameters, and the only way to get them\n\t\t\t// currently is to use assembly.\n\t\t\tassembly {\n\t\t\t\tlet vs := mload(add(signature, 0x40))\n\t\t\t\tr := mload(add(signature, 0x20))\n\t\t\t\ts := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n\t\t\t\tv := add(shr(255, vs), 27)\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\trevert(\"invalid signature length\");\n\t\t}\n\n\t\treturn recover(hash, v, r, s);\n\t}\n\n\t/**\n\t * @dev Overload of {ECDSA-recover} that receives the `v`,\n\t * `r` and `s` signature fields separately.\n\t */\n\tfunction recover(\n\t\tbytes32 hash,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) internal pure returns (address) {\n\t\t// EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n\t\t// unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n\t\t// the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\n\t\t// signatures from current libraries generate a unique signature with an s-value in the lower half order.\n\t\t//\n\t\t// If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n\t\t// with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n\t\t// vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n\t\t// these malleable signatures as well.\n\t\trequire(\n\t\t\tuint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0,\n\t\t\t\"invalid signature 's' value\"\n\t\t);\n\t\trequire(v == 27 || v == 28, \"invalid signature 'v' value\");\n\n\t\t// If the signature is valid (and not malleable), return the signer address\n\t\taddress signer = ecrecover(hash, v, r, s);\n\t\trequire(signer != address(0), \"invalid signature\");\n\n\t\treturn signer;\n\t}\n\n\t/**\n\t * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n\t * produces hash corresponding to the one signed with the\n\t * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n\t * JSON-RPC method as part of EIP-191.\n\t *\n\t * See {recover}.\n\t */\n\tfunction toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n\t\t// 32 is the length in bytes of hash,\n\t\t// enforced by the type signature above\n\t\treturn keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n\t}\n\n\t/**\n\t * @dev Returns an Ethereum Signed Typed Data, created from a\n\t * `domainSeparator` and a `structHash`. This produces hash corresponding\n\t * to the one signed with the\n\t * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n\t * JSON-RPC method as part of EIP-712.\n\t *\n\t * See {recover}.\n\t */\n\tfunction toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n\t\treturn keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n\t}\n}\n"
    },
    "contracts/utils/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title Access Control List\n *\n * @notice Access control smart contract provides an API to check\n *      if specific operation is permitted globally and/or\n *      if particular user has a permission to execute it.\n *\n * @notice It deals with two main entities: features and roles.\n *\n * @notice Features are designed to be used to enable/disable specific\n *      functions (public functions) of the smart contract for everyone.\n * @notice User roles are designed to restrict access to specific\n *      functions (restricted functions) of the smart contract to some users.\n *\n * @notice Terms \"role\", \"permissions\" and \"set of permissions\" have equal meaning\n *      in the documentation text and may be used interchangeably.\n * @notice Terms \"permission\", \"single permission\" implies only one permission bit set.\n *\n * @notice Access manager is a special role which allows to grant/revoke other roles.\n *      Access managers can only grant/revoke permissions which they have themselves.\n *      As an example, access manager with no other roles set can only grant/revoke its own\n *      access manager permission and nothing else.\n *\n * @notice Access manager permission should be treated carefully, as a super admin permission:\n *      Access manager with even no other permission can interfere with another account by\n *      granting own access manager permission to it and effectively creating more powerful\n *      permission set than its own.\n *\n * @dev Both current and OpenZeppelin AccessControl implementations feature a similar API\n *      to check/know \"who is allowed to do this thing\".\n * @dev Zeppelin implementation is more flexible:\n *      - it allows setting unlimited number of roles, while current is limited to 256 different roles\n *      - it allows setting an admin for each role, while current allows having only one global admin\n * @dev Current implementation is more lightweight:\n *      - it uses only 1 bit per role, while Zeppelin uses 256 bits\n *      - it allows setting up to 256 roles at once, in a single transaction, while Zeppelin allows\n *        setting only one role in a single transaction\n *\n * @dev This smart contract is designed to be inherited by other\n *      smart contracts which require access control management capabilities.\n *\n * @dev Access manager permission has a bit 255 set.\n *      This bit must not be used by inheriting contracts for any other permissions/features.\n *\n * @author Basil Gorin\n */\ncontract AccessControl {\n\t/**\n\t * @notice Access manager is responsible for assigning the roles to users,\n\t *      enabling/disabling global features of the smart contract\n\t * @notice Access manager can add, remove and update user roles,\n\t *      remove and update global features\n\t *\n\t * @dev Role ROLE_ACCESS_MANAGER allows modifying user roles and global features\n\t * @dev Role ROLE_ACCESS_MANAGER has single bit at position 255 enabled\n\t */\n\tuint256 public constant ROLE_ACCESS_MANAGER = 0x8000000000000000000000000000000000000000000000000000000000000000;\n\n\t/**\n\t * @dev Bitmask representing all the possible permissions (super admin role)\n\t * @dev Has all the bits are enabled (2^256 - 1 value)\n\t */\n\tuint256 private constant FULL_PRIVILEGES_MASK = type(uint256).max; // before 0.8.0: uint256(-1) overflows to 0xFFFF...\n\n\t/**\n\t * @notice Privileged addresses with defined roles/permissions\n\t * @notice In the context of ERC20/ERC721 tokens these can be permissions to\n\t *      allow minting or burning tokens, transferring on behalf and so on\n\t *\n\t * @dev Maps user address to the permissions bitmask (role), where each bit\n\t *      represents a permission\n\t * @dev Bitmask 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n\t *      represents all possible permissions\n\t * @dev 'This' address mapping represents global features of the smart contract\n\t */\n\tmapping(address => uint256) public userRoles;\n\n\t/**\n\t * @dev Fired in updateRole() and updateFeatures()\n\t *\n\t * @param _by operator which called the function\n\t * @param _to address which was granted/revoked permissions\n\t * @param _requested permissions requested\n\t * @param _actual permissions effectively set\n\t */\n\tevent RoleUpdated(address indexed _by, address indexed _to, uint256 _requested, uint256 _actual);\n\n\t/**\n\t * @notice Creates an access control instance,\n\t *      setting contract creator to have full privileges\n\t */\n\tconstructor() {\n\t\t// contract creator has full privileges\n\t\tuserRoles[msg.sender] = FULL_PRIVILEGES_MASK;\n\t}\n\n\t/**\n\t * @notice Retrieves globally set of features enabled\n\t *\n\t * @dev Effectively reads userRoles role for the contract itself\n\t *\n\t * @return 256-bit bitmask of the features enabled\n\t */\n\tfunction features() public view returns(uint256) {\n\t\t// features are stored in 'this' address  mapping of `userRoles` structure\n\t\treturn userRoles[address(this)];\n\t}\n\n\t/**\n\t * @notice Updates set of the globally enabled features (`features`),\n\t *      taking into account sender's permissions\n\t *\n\t * @dev Requires transaction sender to have `ROLE_ACCESS_MANAGER` permission\n\t * @dev Function is left for backward compatibility with older versions\n\t *\n\t * @param _mask bitmask representing a set of features to enable/disable\n\t */\n\tfunction updateFeatures(uint256 _mask) public {\n\t\t// delegate call to `updateRole`\n\t\tupdateRole(address(this), _mask);\n\t}\n\n\t/**\n\t * @notice Updates set of permissions (role) for a given user,\n\t *      taking into account sender's permissions.\n\t *\n\t * @dev Setting role to zero is equivalent to removing an all permissions\n\t * @dev Setting role to `FULL_PRIVILEGES_MASK` is equivalent to\n\t *      copying senders' permissions (role) to the user\n\t * @dev Requires transaction sender to have `ROLE_ACCESS_MANAGER` permission\n\t *\n\t * @param operator address of a user to alter permissions for or zero\n\t *      to alter global features of the smart contract\n\t * @param role bitmask representing a set of permissions to\n\t *      enable/disable for a user specified\n\t */\n\tfunction updateRole(address operator, uint256 role) public {\n\t\t// caller must have a permission to update user roles\n\t\trequire(isSenderInRole(ROLE_ACCESS_MANAGER), \"access denied\");\n\n\t\t// evaluate the role and reassign it\n\t\tuserRoles[operator] = evaluateBy(msg.sender, userRoles[operator], role);\n\n\t\t// fire an event\n\t\temit RoleUpdated(msg.sender, operator, role, userRoles[operator]);\n\t}\n\n\t/**\n\t * @notice Determines the permission bitmask an operator can set on the\n\t *      target permission set\n\t * @notice Used to calculate the permission bitmask to be set when requested\n\t *     in `updateRole` and `updateFeatures` functions\n\t *\n\t * @dev Calculated based on:\n\t *      1) operator's own permission set read from userRoles[operator]\n\t *      2) target permission set - what is already set on the target\n\t *      3) desired permission set - what do we want set target to\n\t *\n\t * @dev Corner cases:\n\t *      1) Operator is super admin and its permission set is `FULL_PRIVILEGES_MASK`:\n\t *        `desired` bitset is returned regardless of the `target` permission set value\n\t *        (what operator sets is what they get)\n\t *      2) Operator with no permissions (zero bitset):\n\t *        `target` bitset is returned regardless of the `desired` value\n\t *        (operator has no authority and cannot modify anything)\n\t *\n\t * @dev Example:\n\t *      Consider an operator with the permissions bitmask     00001111\n\t *      is about to modify the target permission set          01010101\n\t *      Operator wants to set that permission set to          00110011\n\t *      Based on their role, an operator has the permissions\n\t *      to update only lowest 4 bits on the target, meaning that\n\t *      high 4 bits of the target set in this example is left\n\t *      unchanged and low 4 bits get changed as desired:      01010011\n\t *\n\t * @param operator address of the contract operator which is about to set the permissions\n\t * @param target input set of permissions to operator is going to modify\n\t * @param desired desired set of permissions operator would like to set\n\t * @return resulting set of permissions given operator will set\n\t */\n\tfunction evaluateBy(address operator, uint256 target, uint256 desired) public view returns(uint256) {\n\t\t// read operator's permissions\n\t\tuint256 p = userRoles[operator];\n\n\t\t// taking into account operator's permissions,\n\t\t// 1) enable the permissions desired on the `target`\n\t\ttarget |= p & desired;\n\t\t// 2) disable the permissions desired on the `target`\n\t\ttarget &= FULL_PRIVILEGES_MASK ^ (p & (FULL_PRIVILEGES_MASK ^ desired));\n\n\t\t// return calculated result\n\t\treturn target;\n\t}\n\n\t/**\n\t * @notice Checks if requested set of features is enabled globally on the contract\n\t *\n\t * @param required set of features to check against\n\t * @return true if all the features requested are enabled, false otherwise\n\t */\n\tfunction isFeatureEnabled(uint256 required) public view returns(bool) {\n\t\t// delegate call to `__hasRole`, passing `features` property\n\t\treturn __hasRole(features(), required);\n\t}\n\n\t/**\n\t * @notice Checks if transaction sender `msg.sender` has all the permissions required\n\t *\n\t * @param required set of permissions (role) to check against\n\t * @return true if all the permissions requested are enabled, false otherwise\n\t */\n\tfunction isSenderInRole(uint256 required) public view returns(bool) {\n\t\t// delegate call to `isOperatorInRole`, passing transaction sender\n\t\treturn isOperatorInRole(msg.sender, required);\n\t}\n\n\t/**\n\t * @notice Checks if operator has all the permissions (role) required\n\t *\n\t * @param operator address of the user to check role for\n\t * @param required set of permissions (role) to check\n\t * @return true if all the permissions requested are enabled, false otherwise\n\t */\n\tfunction isOperatorInRole(address operator, uint256 required) public view returns(bool) {\n\t\t// delegate call to `__hasRole`, passing operator's permissions (role)\n\t\treturn __hasRole(userRoles[operator], required);\n\t}\n\n\t/**\n\t * @dev Checks if role `actual` contains all the permissions required `required`\n\t *\n\t * @param actual existent role\n\t * @param required required role\n\t * @return true if actual has required role (all permissions), false otherwise\n\t */\n\tfunction __hasRole(uint256 actual, uint256 required) internal pure returns(bool) {\n\t\t// check the bitmask for the role required and return the result\n\t\treturn actual & required == required;\n\t}\n}\n"
    },
    "contracts/interfaces/ERC165Spec.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title ERC-165 Standard Interface Detection\n *\n * @dev Interface of the ERC165 standard, as defined in the\n *       https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * @dev Implementers can declare support of contract interfaces,\n *      which can then be queried by others.\n *\n * @author Christian Reitwießner, Nick Johnson, Fabian Vogelsteller, Jordi Baylina, Konrad Feldmeier, William Entriken\n */\ninterface ERC165 {\n\t/**\n\t * @notice Query if a contract implements an interface\n\t *\n\t * @dev Interface identification is specified in ERC-165.\n\t *      This function uses less than 30,000 gas.\n\t *\n\t * @param interfaceID The interface identifier, as specified in ERC-165\n\t * @return `true` if the contract implements `interfaceID` and\n\t *      `interfaceID` is not 0xffffffff, `false` otherwise\n\t */\n\tfunction supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n"
    },
    "contracts/token/ShortERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ERC721Spec.sol\";\nimport \"../interfaces/ERC721SpecExt.sol\";\nimport \"../lib/AddressUtils.sol\";\nimport \"../lib/StringUtils.sol\";\nimport \"../lib/ECDSA.sol\";\nimport \"../utils/AccessControl.sol\";\n\n/**\n * @title Short ERC721\n *\n * @notice Short ERC721 defines an NFT with short (up to 96 bits) ID space.\n *      ERC721 enumeration support requires additional writes to the storage:\n *      - when transferring a token in order to update the NFT collections of\n *        the previous and next owners,\n *      - when minting/burning a token in order to update global NFT collection\n *\n * @notice Reducing the NFT ID space to 96 bits allows to eliminate the need to have\n *      and to write to one of the additional storage mappings\n *\n * @notice Short NFT ID (up to 96 bits) is concatenated in storage with owner address\n *      (160 bits) resulting in a whole 256 bits slot occupied, and eliminating\n *      the need to store NFT index within owner collection in a separate storage slot.\n *\n * @notice This smart contract is designed to be inherited by concrete implementations,\n *      which are expected to define token metadata, auxiliary functions to access the metadata,\n *      and explicitly define token minting interface, which should be built on top\n *      of current smart contract internal interface\n *\n * @notice Fully ERC721-compatible with all optional interfaces implemented (metadata, enumeration),\n *      see https://eips.ethereum.org/EIPS/eip-721\n *\n * @notice Note: current implementation doesn't support token burning. Burning doesn't come for free\n *      and requires additional mapping maintenance which is written to in both `mint` and `burn` functions.\n *      See {BurnableShortERC721} for burning support\n *\n * @dev Reducing the NFT ID space to 64 bits would allow to optimize batch minting by more tight\n *      packing of the arrays storing NFT IDs (`allTokens` and owners' `collections`)\n *\n * @dev Reducing the NFT ID space to 48 bits would allow to get \"free\" burn support for enumerable ERC721\n *      by eliminating the need to maintain `tokenIndexes` mapping (see {BurnableShortERC721})\n *\n * @dev ERC721: contract has passed adopted OpenZeppelin ERC721 tests\n *        https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/test/token/ERC721/ERC721.behavior.js\n *        https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/test/token/ERC721/extensions/ERC721URIStorage.test.js\n *\n * @dev A note on token URI: there are major differences on how token URI behaves comparing to Zeppelin impl:\n *      1. A token URI can be set for non-existing token for pre-allocation purposes,\n *         still the URI will be deleted once token is burnt\n *      2. If token URI is set, base URI has no affect on the token URI, the two are not concatenated,\n *         base URI is used to construct the token URI only if the latter was not explicitly set\n *\n * @dev Supports EIP-712 powered permits - permit() - approve() with signature.\n *      Supports EIP-712 powered operator permits - permitForAll() - setApprovalForAll() with signature.\n *\n * @dev EIP712 Domain:\n *      name: AliERC721v1\n *      version: not in use, omitted (name already contains version)\n *      chainId: EIP-155 chain id\n *      verifyingContract: deployed contract address\n *      salt: permitNonces[owner], where owner is an address which allows operation on their tokens\n *\n * @dev Permit type:\n *      owner: address\n *      operator: address\n *      tokenId: uint256\n *      nonce: uint256\n *      deadline: uint256\n *\n * @dev Permit typeHash:\n *        keccak256(\"Permit(address owner,address operator,uint256 tokenId,uint256 nonce,uint256 deadline)\")\n *\n * @dev PermitForAll type:\n *      owner: address\n *      operator: address\n *      approved: bool\n *      nonce: uint256\n *      deadline: uint256\n *\n * @dev PermitForAll typeHash:\n *        keccak256(\"PermitForAll(address owner,address operator,bool approved,uint256 nonce,uint256 deadline)\")\n *\n * @dev See https://eips.ethereum.org/EIPS/eip-712\n * @dev See usage examples in tests: erc721_permits.js\n *\n * @author Basil Gorin\n */\nabstract contract ShortERC721 is ERC721Enumerable, ERC721Metadata, WithBaseURI, MintableERC721, AccessControl {\n\t/**\n\t * @dev Smart contract unique identifier, a random number\n\t *\n\t * @dev Should be regenerated each time smart contact source code is changed\n\t *      and changes smart contract itself is to be redeployed\n\t *\n\t * @dev Generated using https://www.random.org/bytes/\n\t * @dev Example value: 0xdbdd2b4ff38a8516da0b8e7ae93288b5e2fed0c92fb051cee90ccf4e4ec9736e\n\t */\n\tfunction TOKEN_UID() external view virtual returns(uint256);\n\n\t/**\n\t * @notice ERC-20 compatible descriptive name for a collection of NFTs in this contract\n\t *\n\t * @inheritdoc ERC721Metadata\n\t */\n\tstring public override name;\n\n\t/**\n\t * @notice ERC-20 compatible abbreviated name for a collection of NFTs in this contract\n\t *\n\t * @inheritdoc ERC721Metadata\n\t */\n\tstring public override symbol;\n\n\t/**\n\t * @notice Current implementation includes a function `decimals` that returns uint8(0)\n\t *      to be more compatible with ERC-20\n\t *\n\t * @dev ERC20 compliant token decimals is equal to zero since ERC721 token is non-fungible\n\t *      and therefore non-divisible\n\t */\n\tuint8 public constant decimals = 0;\n\n\t/**\n\t * @notice Ownership information for all the tokens in existence\n\t *\n\t * @dev Maps `Token ID => Token ID Index | Token Owner Address`, where\n\t *      - Token ID Index denotes Token ID index in the array of all the tokens owned by the owner,\n\t *      - Token ID Index is 96 bits long and is stored in high 96 bits of the mapping value,\n\t *      - `|` denotes bitwise concatenation of the\n\t *        96 bits long Token ID Index and 160 bits long Token Owner Address\n\t * @dev Token Owner Address for a given Token ID is lower 160 bits of the mapping value\n\t */\n\tmapping(uint256 => uint256) internal tokens;\n\n\t/**\n\t * @notice Enumerated collections of the tokens owned by particular owners\n\t *\n\t * @dev We call these collections \"Local\" token collections\n\t *\n\t * @dev Maps `Token Owner Address => Owned Token IDs Array`\n\t *\n\t * @dev Token owner balance is the length of their token collection:\n\t *      `balanceOf(owner) = collections[owner].length`\n\t */\n\tmapping(address => uint96[]) internal collections;\n\n\t/**\n\t * @notice An array of all the tokens in existence\n\t *\n\t * @dev We call this collection \"Global\" token collection\n\t *\n\t * @dev Array with all Token IDs, used for enumeration\n\t *\n\t * @dev Total token supply `tokenSupply` is the length of this collection:\n\t *      `totalSupply() = allTokens.length`\n\t */\n\tuint96[] internal allTokens;\n\n\t/**\n\t * @notice Addresses approved by token owners to transfer their tokens\n\t *\n\t * @dev `Maps Token ID => Approved Address`, where\n\t *      Approved Address is an address allowed transfer ownership for the token\n\t *      defined by Token ID\n\t */\n\tmapping(uint256 => address) internal approvals;\n\n\t/**\n\t * @notice Addresses approved by token owners to transfer all their tokens\n\t *\n\t * @dev Maps `Token Owner Address => Operator Address => Approval State` - true/false (approved/not), where\n\t *      - Token Owner Address is any address which may own tokens or not,\n\t *      - Operator Address is any other address which may own tokens or not,\n\t *      - Approval State is a flag indicating if Operator Address is allowed to\n\t *        transfer tokens owned by Token Owner Address o their behalf\n\t */\n\tmapping(address => mapping(address => bool)) internal approvedOperators;\n\n\t/**\n\t * @dev A record of nonces for signing/validating signatures in EIP-712 based\n\t *      `permit` and `permitForAll` functions\n\t *\n\t * @dev Each time the nonce is used, it is increased by one, meaning reordering\n\t *      of the EIP-712 transactions is not possible\n\t *\n\t * @dev Inspired by EIP-2612 extension for ERC20 token standard\n\t *\n\t * @dev Maps token owner address => token owner nonce\n\t */\n\tmapping(address => uint256) public permitNonces;\n\n\t/**\n\t * @dev Base URI is used to construct ERC721Metadata.tokenURI as\n\t *      `base URI + token ID` if token URI is not set (not present in `_tokenURIs` mapping)\n\t *\n\t * @dev For example, if base URI is https://api.com/token/, then token #1\n\t *      will have an URI https://api.com/token/1\n\t *\n\t * @dev If token URI is set with `setTokenURI()` it will be returned as is via `tokenURI()`\n\t */\n\tstring public override baseURI = \"\";\n\n\t/**\n\t * @dev Optional mapping for token URIs to be returned as is when `tokenURI()`\n\t *      is called; if mapping doesn't exist for token, the URI is constructed\n\t *      as `base URI + token ID`, where plus (+) denotes string concatenation\n\t */\n\tmapping(uint256 => string) internal _tokenURIs;\n\n\t/**\n\t * @notice Enables ERC721 transfers of the tokens\n\t *      (transfer by the token owner himself)\n\t * @dev Feature FEATURE_TRANSFERS must be enabled in order for\n\t *      `transferFrom()` function to succeed when executed by token owner\n\t */\n\tuint32 public constant FEATURE_TRANSFERS = 0x0000_0001;\n\n\t/**\n\t * @notice Enables ERC721 transfers on behalf\n\t *      (transfer by someone else on behalf of token owner)\n\t * @dev Feature FEATURE_TRANSFERS_ON_BEHALF must be enabled in order for\n\t *      `transferFrom()` function to succeed whe executed by approved operator\n\t * @dev Token owner must call `approve()` or `setApprovalForAll()`\n\t *      first to authorize the transfer on behalf\n\t */\n\tuint32 public constant FEATURE_TRANSFERS_ON_BEHALF = 0x0000_0002;\n\n\t/**\n\t * @notice Enables token owners to burn their own tokens\n\t *\n\t * @dev Feature FEATURE_OWN_BURNS must be enabled in order for\n\t *      `burn()` function to succeed when called by token owner\n\t */\n\tuint32 public constant FEATURE_OWN_BURNS = 0x0000_0008;\n\n\t/**\n\t * @notice Enables approved operators to burn tokens on behalf of their owners\n\t *\n\t * @dev Feature FEATURE_BURNS_ON_BEHALF must be enabled in order for\n\t *      `burn()` function to succeed when called by approved operator\n\t */\n\tuint32 public constant FEATURE_BURNS_ON_BEHALF = 0x0000_0010;\n\n\t/**\n\t * @notice Enables approvals on behalf (permits via an EIP712 signature)\n\t * @dev Feature FEATURE_PERMITS must be enabled in order for\n\t *      `permit()` function to succeed\n\t */\n\tuint32 public constant FEATURE_PERMITS = 0x0000_0200;\n\n\t/**\n\t * @notice Enables operator approvals on behalf (permits for all via an EIP712 signature)\n\t * @dev Feature FEATURE_OPERATOR_PERMITS must be enabled in order for\n\t *      `permitForAll()` function to succeed\n\t */\n\tuint32 public constant FEATURE_OPERATOR_PERMITS = 0x0000_0400;\n\n\t/**\n\t * @notice Token creator is responsible for creating (minting)\n\t *      tokens to an arbitrary address\n\t * @dev Role ROLE_TOKEN_CREATOR allows minting tokens\n\t *      (calling `mint` function)\n\t */\n\tuint32 public constant ROLE_TOKEN_CREATOR = 0x0001_0000;\n\n\t/**\n\t * @notice Token destroyer is responsible for destroying (burning)\n\t *      tokens owned by an arbitrary address\n\t * @dev Role ROLE_TOKEN_DESTROYER allows burning tokens\n\t *      (calling `burn` function)\n\t */\n\tuint32 public constant ROLE_TOKEN_DESTROYER = 0x0002_0000;\n\n\t/**\n\t * @notice URI manager is responsible for managing base URI\n\t *      part of the token URI ERC721Metadata interface\n\t *\n\t * @dev Role ROLE_URI_MANAGER allows updating the base URI\n\t *      (executing `setBaseURI` function)\n\t */\n\tuint32 public constant ROLE_URI_MANAGER = 0x0010_0000;\n\n\t/**\n\t * @notice EIP-712 contract's domain typeHash,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\n\t *\n\t * @dev Note: we do not include version into the domain typehash/separator,\n\t *      it is implied version is concatenated to the name field, like \"AliERC721v1\"\n\t */\n\t// keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\")\n\tbytes32 public constant DOMAIN_TYPEHASH = 0x8cad95687ba82c2ce50e74f7b754645e5117c3a5bec8151c0726d5857980a866;\n\n\t/**\n\t * @notice EIP-712 contract's domain separator,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator\n\t */\n\tbytes32 public immutable DOMAIN_SEPARATOR;\n\n\t/**\n\t * @notice EIP-712 permit (EIP-2612) struct typeHash,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\n\t */\n\t// keccak256(\"Permit(address owner,address operator,uint256 tokenId,uint256 nonce,uint256 deadline)\")\n\tbytes32 public constant PERMIT_TYPEHASH = 0xee2282d7affd5a432b221a559e429129347b0c19a3f102179a5fb1859eef3d29;\n\n\t/**\n\t * @notice EIP-712 permitForAll (EIP-2612) struct typeHash,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\n\t */\n\t// keccak256(\"PermitForAll(address owner,address operator,bool approved,uint256 nonce,uint256 deadline)\")\n\tbytes32 public constant PERMIT_FOR_ALL_TYPEHASH = 0x47ab88482c90e4bb94b82a947ae78fa91fb25de1469ab491f4c15b9a0a2677ee;\n\n\t/**\n\t * @dev Fired in setBaseURI()\n\t *\n\t * @param _by an address which executed update\n\t * @param _oldVal old _baseURI value\n\t * @param _newVal new _baseURI value\n\t */\n\tevent BaseURIUpdated(address indexed _by, string _oldVal, string _newVal);\n\n\t/**\n\t * @dev Fired in setTokenURI()\n\t *\n\t * @param _by an address which executed update\n\t * @param _tokenId token ID which URI was updated\n\t * @param _oldVal old _baseURI value\n\t * @param _newVal new _baseURI value\n\t */\n\tevent TokenURIUpdated(address indexed _by, uint256 _tokenId, string _oldVal, string _newVal);\n\n\t/**\n\t * @dev Constructs/deploys ERC721 instance with the name and symbol specified\n\t *\n\t * @param _name name of the token to be accessible as `name()`,\n\t *      ERC-20 compatible descriptive name for a collection of NFTs in this contract\n\t * @param _symbol token symbol to be accessible as `symbol()`,\n\t *      ERC-20 compatible descriptive name for a collection of NFTs in this contract\n\t */\n\tconstructor(string memory _name, string memory _symbol) {\n\t\t// set the name\n\t\tname = _name;\n\n\t\t// set the symbol\n\t\tsymbol = _symbol;\n\n\t\t// build the EIP-712 contract domain separator, see https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator\n\t\t// note: we specify contract version in its name\n\t\tDOMAIN_SEPARATOR = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(\"AliERC721v1\")), block.chainid, address(this)));\n\t}\n\n\t/**\n\t * @dev Verifies if token is transferable (i.e. can change ownership, allowed to be transferred);\n\t *      The default behaviour is to always allow transfer if token exists\n\t *\n\t * @dev Implementations may modify the default behaviour based on token metadata\n\t *      if required\n\t *\n\t * @param _tokenId ID of the token to check if it's transferable\n\t * @return true if token is transferable, false otherwise\n\t */\n\tfunction isTransferable(uint256 _tokenId) public view virtual returns(bool) {\n\t\t// validate token existence\n\t\trequire(exists(_tokenId), \"token doesn't exist\");\n\n\t\t// generic implementation returns true if token exists\n\t\treturn true;\n\t}\n\n\t/**\n\t * @notice Checks if specified token exists\n\t *\n\t * @dev Returns whether the specified token ID has an ownership\n\t *      information associated with it\n\t *\n\t * @inheritdoc MintableERC721\n\t *\n\t * @param _tokenId ID of the token to query existence for\n\t * @return whether the token exists (true - exists, false - doesn't exist)\n\t */\n\tfunction exists(uint256 _tokenId) public override view returns(bool) {\n\t\t// read ownership information and return a check if it's not zero (set)\n\t\treturn tokens[_tokenId] != 0;\n\t}\n\n\t/**\n\t * @inheritdoc ERC165\n\t */\n\tfunction supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n\t\t// construct the interface support from required and optional ERC721 interfaces\n\t\treturn interfaceId == type(ERC165).interfaceId\n\t\t\t|| interfaceId == type(ERC721).interfaceId\n\t\t\t|| interfaceId == type(ERC721Metadata).interfaceId\n\t\t\t|| interfaceId == type(ERC721Enumerable).interfaceId\n\t\t\t|| interfaceId == type(MintableERC721).interfaceId;\n\t}\n\n\t// ===== Start: ERC721 Metadata =====\n\n\t/**\n\t * @dev Restricted access function which updates base URI used to construct\n\t *      ERC721Metadata.tokenURI\n\t *\n\t * @dev Requires executor to have ROLE_URI_MANAGER permission\n\t *\n\t * @param _baseURI new base URI to set\n\t */\n\tfunction setBaseURI(string memory _baseURI) public virtual {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_URI_MANAGER), \"access denied\");\n\n\t\t// emit an event first - to log both old and new values\n\t\temit BaseURIUpdated(msg.sender, baseURI, _baseURI);\n\n\t\t// and update base URI\n\t\tbaseURI = _baseURI;\n\t}\n\n\t/**\n\t * @dev Returns token URI if it was previously set with `setTokenURI`,\n\t *      otherwise constructs it as base URI + token ID\n\t *\n\t * @inheritdoc ERC721Metadata\n\t */\n\tfunction tokenURI(uint256 _tokenId) public view override returns (string memory) {\n\t\t// verify token exists\n\t\trequire(exists(_tokenId), \"token doesn't exist\");\n\n\t\t// read the token URI for the token specified\n\t\tstring memory _tokenURI = _tokenURIs[_tokenId];\n\n\t\t// if token URI is set\n\t\tif(bytes(_tokenURI).length > 0) {\n\t\t\t// just return it\n\t\t\treturn _tokenURI;\n\t\t}\n\n\t\t// if base URI is not set\n\t\tif(bytes(baseURI).length == 0) {\n\t\t\t// return an empty string\n\t\t\treturn \"\";\n\t\t}\n\n\t\t// otherwise concatenate base URI + token ID\n\t\treturn StringUtils.concat(baseURI, StringUtils.itoa(_tokenId, 10));\n\t}\n\n\t/**\n\t * @dev Sets the token URI for the token defined by its ID\n\t *\n\t * @param _tokenId an ID of the token to set URI for\n\t * @param _tokenURI token URI to set\n\t */\n\tfunction setTokenURI(uint256 _tokenId, string memory _tokenURI) public virtual {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_URI_MANAGER), \"access denied\");\n\n\t\t// we do not verify token existence: we want to be able to\n\t\t// preallocate token URIs before tokens are actually minted\n\n\t\t// emit an event first - to log both old and new values\n\t\temit TokenURIUpdated(msg.sender, _tokenId, _tokenURIs[_tokenId], _tokenURI);\n\n\t\t// and update token URI\n\t\t_tokenURIs[_tokenId] = _tokenURI;\n\t}\n\n\t// ===== End: ERC721 Metadata =====\n\n\t// ===== Start: ERC721, ERC721Enumerable Getters (view functions) =====\n\n\t/**\n\t * @inheritdoc ERC721\n\t */\n\tfunction balanceOf(address _owner) public view override returns (uint256) {\n\t\t// check `_owner` address is set\n\t\trequire(_owner != address(0), \"zero address\");\n\n\t\t// derive owner balance for the their owned tokens collection\n\t\t// as the length of that collection\n\t\treturn collections[_owner].length;\n\t}\n\n\t/**\n\t * @inheritdoc ERC721\n\t */\n\tfunction ownerOf(uint256 _tokenId) public view override returns (address) {\n\t\t// derive ownership information of the token from the ownership mapping\n\t\t// by extracting lower 160 bits of the mapping value as an address\n\t\taddress owner = address(uint160(tokens[_tokenId]));\n\n\t\t// verify owner/token exists\n\t\trequire(owner != address(0), \"token doesn't exist\");\n\n\t\t// return owner address\n\t\treturn owner;\n\t}\n\n\t/**\n\t * @inheritdoc ERC721Enumerable\n\t */\n\tfunction totalSupply() public view override returns (uint256) {\n\t\t// derive total supply value from the array of all existing tokens\n\t\t// as the length of this array\n\t\treturn allTokens.length;\n\t}\n\n\t/**\n\t * @inheritdoc ERC721Enumerable\n\t */\n\tfunction tokenByIndex(uint256 _index) public view override returns (uint256) {\n\t\t// index out of bounds check\n\t\trequire(_index < totalSupply(), \"index out of bounds\");\n\n\t\t// find the token ID requested and return\n\t\treturn allTokens[_index];\n\t}\n\n\t/**\n\t * @inheritdoc ERC721Enumerable\n\t */\n\tfunction tokenOfOwnerByIndex(address _owner, uint256 _index) public view override returns (uint256) {\n\t\t// index out of bounds check\n\t\trequire(_index < balanceOf(_owner), \"index out of bounds\");\n\n\t\t// find the token ID requested and return\n\t\treturn collections[_owner][_index];\n\t}\n\n\t/**\n\t * @inheritdoc ERC721\n\t */\n\tfunction getApproved(uint256 _tokenId) public view override returns (address) {\n\t\t// verify token specified exists\n\t\trequire(exists(_tokenId), \"token doesn't exist\");\n\n\t\t// read the approval value and return\n\t\treturn approvals[_tokenId];\n\t}\n\n\t/**\n\t * @inheritdoc ERC721\n\t */\n\tfunction isApprovedForAll(address _owner, address _operator) public view override returns (bool) {\n\t\t// read the approval state value and return\n\t\treturn approvedOperators[_owner][_operator];\n\t}\n\n\t// ===== End: ERC721, ERC721Enumerable Getters (view functions) =====\n\n\t// ===== Start: ERC721 mutative functions (transfers, approvals) =====\n\n\t/**\n\t * @inheritdoc ERC721\n\t */\n\tfunction safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory _data) public override {\n\t\t// delegate call to unsafe transfer on behalf `transferFrom()`\n\t\ttransferFrom(_from, _to, _tokenId);\n\n\t\t// if receiver `_to` is a smart contract\n\t\tif(AddressUtils.isContract(_to)) {\n\t\t\t// check it supports ERC721 interface - execute onERC721Received()\n\t\t\tbytes4 response = ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data);\n\n\t\t\t// expected response is ERC721TokenReceiver(_to).onERC721Received.selector\n\t\t\t// bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))\n\t\t\trequire(response == ERC721TokenReceiver(_to).onERC721Received.selector, \"invalid onERC721Received response\");\n\t\t}\n\t}\n\n\t/**\n\t * @inheritdoc ERC721\n\t */\n\tfunction safeTransferFrom(address _from, address _to, uint256 _tokenId) public override {\n\t\t// delegate call to overloaded `safeTransferFrom()`, set data to \"\"\n\t\tsafeTransferFrom(_from, _to, _tokenId, \"\");\n\t}\n\n\t/**\n\t * @inheritdoc ERC721\n\t */\n\tfunction transferFrom(address _from, address _to, uint256 _tokenId) public override {\n\t\t// if `_from` is equal to sender, require transfers feature to be enabled\n\t\t// otherwise require transfers on behalf feature to be enabled\n\t\trequire(_from == msg.sender && isFeatureEnabled(FEATURE_TRANSFERS)\n\t\t     || _from != msg.sender && isFeatureEnabled(FEATURE_TRANSFERS_ON_BEHALF),\n\t\t        _from == msg.sender? \"transfers are disabled\": \"transfers on behalf are disabled\");\n\n\t\t// validate destination address is set\n\t\trequire(_to != address(0), \"zero address\");\n\n\t\t// validate token ownership, which also\n\t\t// validates token existence under the hood\n\t\trequire(_from == ownerOf(_tokenId), \"access denied\");\n\n\t\t// verify operator (transaction sender) is either token owner,\n\t\t// or is approved by the token owner to transfer this particular token,\n\t\t// or is approved by the token owner to transfer any of his tokens\n\t\trequire(_from == msg.sender || msg.sender == getApproved(_tokenId) || isApprovedForAll(_from, msg.sender), \"access denied\");\n\n\t\t// transfer is not allowed for a locked token\n\t\trequire(isTransferable(_tokenId), \"locked token\");\n\n\t\t// if required, move token ownership,\n\t\t// update old and new owner's token collections accordingly:\n\t\tif(_from != _to) {\n\t\t\t// remove token from old owner's collection (also clears approval)\n\t\t\t__removeLocal(_tokenId);\n\t\t\t// add token to the new owner's collection\n\t\t\t__addLocal(_tokenId, _to);\n\t\t}\n\t\t// even if no real changes are required, approval needs to be erased\n\t\telse {\n\t\t\t// clear token approval (also emits an Approval event)\n\t\t\t__clearApproval(_from, _tokenId);\n\t\t}\n\n\t\t// fire ERC721 transfer event\n\t\temit Transfer(_from, _to, _tokenId);\n\t}\n\n\t/**\n\t * @inheritdoc ERC721\n\t */\n\tfunction approve(address _approved, uint256 _tokenId) public override {\n\t\t// make an internal approve - delegate to `__approve`\n\t\t__approve(msg.sender, _approved, _tokenId);\n\t}\n\n\t/**\n\t * @dev Powers the meta transaction for `approve` - EIP-712 signed `permit`\n\t *\n\t * @dev Approves address called `_operator` to transfer token `_tokenId`\n\t *      on behalf of the `_owner`\n\t *\n\t * @dev Zero `_operator` address indicates there is no approved address,\n\t *      and effectively removes an approval for the token specified\n\t *\n\t * @dev `_owner` must own token `_tokenId` to grant the permission\n\t * @dev Throws if `_operator` is a self address (`_owner`),\n\t *      or if `_tokenId` doesn't exist\n\t *\n\t * @param _owner owner of the token `_tokenId` to set approval on behalf of\n\t * @param _operator an address approved by the token owner\n\t *      to spend token `_tokenId` on its behalf\n\t * @param _tokenId token ID operator `_approved` is allowed to\n\t *      transfer on behalf of the token owner\n\t */\n\tfunction __approve(address _owner, address _operator, uint256 _tokenId) private {\n\t\t// get token owner address\n\t\taddress owner = ownerOf(_tokenId);\n\n\t\t// approving owner address itself doesn't make sense and is not allowed\n\t\trequire(_operator != owner, \"self approval\");\n\n\t\t// only token owner or/and approved operator can set the approval\n\t\trequire(_owner == owner || isApprovedForAll(owner, _owner), \"access denied\");\n\n\t\t// update the approval\n\t\tapprovals[_tokenId] = _operator;\n\n\t\t// emit an event\n\t\temit Approval(owner, _operator, _tokenId);\n\t}\n\n\t/**\n\t * @inheritdoc ERC721\n\t */\n\tfunction setApprovalForAll(address _operator, bool _approved) public override {\n\t\t// make an internal approve - delegate to `__approveForAll`\n\t\t__approveForAll(msg.sender, _operator, _approved);\n\t}\n\n\t/**\n\t * @dev Powers the meta transaction for `setApprovalForAll` - EIP-712 signed `permitForAll`\n\t *\n\t * @dev Approves address called `_operator` to transfer any tokens\n\t *      on behalf of the `_owner`\n\t *\n\t * @dev `_owner` must not necessarily own any tokens to grant the permission\n\t * @dev Throws if `_operator` is a self address (`_owner`)\n\t *\n\t * @param _owner owner of the tokens to set approval on behalf of\n\t * @param _operator an address to add to the set of authorized operators, i.e.\n\t *      an address approved by the token owner to spend tokens on its behalf\n\t * @param _approved true if the operator is approved, false to revoke approval\n\t */\n\tfunction __approveForAll(address _owner, address _operator, bool _approved) private {\n\t\t// approving tx sender address itself doesn't make sense and is not allowed\n\t\trequire(_operator != _owner, \"self approval\");\n\n\t\t// update the approval\n\t\tapprovedOperators[_owner][_operator] = _approved;\n\n\t\t// emit an event\n\t\temit ApprovalForAll(_owner, _operator, _approved);\n\t}\n\n\t/**\n\t * @dev Clears approval for a given token owned by a given owner,\n\t *      emits an Approval event\n\t *\n\t * @dev Unsafe: doesn't check the validity of inputs (must be kept private),\n\t *      assuming the check is done by the caller\n\t *      - token existence\n\t *      - token ownership\n\t *\n\t * @param _owner token owner to be logged into Approved event as is\n\t * @param _tokenId token ID to erase approval for and to log into Approved event as is\n\t */\n\tfunction __clearApproval(address _owner, uint256 _tokenId) internal {\n\t\t// clear token approval\n\t\tdelete approvals[_tokenId];\n\t\t// emit an ERC721 Approval event:\n\t\t// \"When a Transfer event emits, this also indicates that the approved\n\t\t// address for that NFT (if any) is reset to none.\"\n\t\temit Approval(_owner, address(0), _tokenId);\n\t}\n\n\t// ===== End: ERC721 mutative functions (transfers, approvals) =====\n\n\t// ===== Start: Meta-transactions Support =====\n\n\t/**\n\t * @notice Change or reaffirm the approved address for an NFT on behalf\n\t *\n\t * @dev Executes approve(_operator, _tokenId) on behalf of the token owner\n\t *      who EIP-712 signed the transaction, i.e. as if transaction sender is the EIP712 signer\n\t *\n\t * @dev Sets the `_tokenId` as the allowance of `_operator` over `_owner` token,\n\t *      given `_owner` EIP-712 signed approval\n\t *\n\t * @dev Emits `Approval` event in the same way as `approve` does\n\t *\n\t * @dev Requires:\n\t *     - `_operator` to be non-zero address\n\t *     - `_exp` to be a timestamp in the future\n\t *     - `v`, `r` and `s` to be a valid `secp256k1` signature from `_owner`\n\t *        over the EIP712-formatted function arguments.\n\t *     - the signature to use `_owner` current nonce (see `permitNonces`).\n\t *\n\t * @dev For more information on the signature format, see the\n\t *      https://eips.ethereum.org/EIPS/eip-2612#specification\n\t *\n\t * @param _owner owner of the token to set approval on behalf of,\n\t *      an address which signed the EIP-712 message\n\t * @param _operator new approved NFT controller\n\t * @param _tokenId token ID to approve\n\t * @param _exp signature expiration time (unix timestamp)\n\t * @param v the recovery byte of the signature\n\t * @param r half of the ECDSA signature pair\n\t * @param s half of the ECDSA signature pair\n\t */\n\tfunction permit(address _owner, address _operator, uint256 _tokenId, uint256 _exp, uint8 v, bytes32 r, bytes32 s) public {\n\t\t// verify permits are enabled\n\t\trequire(isFeatureEnabled(FEATURE_PERMITS), \"permits are disabled\");\n\n\t\t// derive signer of the EIP712 Permit message, and\n\t\t// update the nonce for that particular signer to avoid replay attack!!! ----------->>> ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓\n\t\taddress signer = __deriveSigner(abi.encode(PERMIT_TYPEHASH, _owner, _operator, _tokenId, permitNonces[_owner]++, _exp), v, r, s);\n\n\t\t// perform message integrity and security validations\n\t\trequire(signer == _owner, \"invalid signature\");\n\t\trequire(block.timestamp < _exp, \"signature expired\");\n\n\t\t// delegate call to `__approve` - execute the logic required\n\t\t__approve(_owner, _operator, _tokenId);\n\t}\n\n\t/**\n\t * @notice Enable or disable approval for a third party (\"operator\") to manage\n\t *      all of owner's assets - on behalf\n\t *\n\t * @dev Executes setApprovalForAll(_operator, _approved) on behalf of the owner\n\t *      who EIP-712 signed the transaction, i.e. as if transaction sender is the EIP712 signer\n\t *\n\t * @dev Sets the `_operator` as the token operator for `_owner` tokens,\n\t *      given `_owner` EIP-712 signed approval\n\t *\n\t * @dev Emits `ApprovalForAll` event in the same way as `setApprovalForAll` does\n\t *\n\t * @dev Requires:\n\t *     - `_operator` to be non-zero address\n\t *     - `_exp` to be a timestamp in the future\n\t *     - `v`, `r` and `s` to be a valid `secp256k1` signature from `_owner`\n\t *        over the EIP712-formatted function arguments.\n\t *     - the signature to use `_owner` current nonce (see `permitNonces`).\n\t *\n\t * @dev For more information on the signature format, see the\n\t *      https://eips.ethereum.org/EIPS/eip-2612#specification\n\t *\n\t * @param _owner owner of the tokens to set approval on behalf of,\n\t *      an address which signed the EIP-712 message\n\t * @param _operator an address to add to the set of authorized operators, i.e.\n\t *      an address approved by the token owner to spend tokens on its behalf\n\t * @param _approved true if the operator is approved, false to revoke approval\n\t * @param _exp signature expiration time (unix timestamp)\n\t * @param v the recovery byte of the signature\n\t * @param r half of the ECDSA signature pair\n\t * @param s half of the ECDSA signature pair\n\t */\n\tfunction permitForAll(address _owner, address _operator, bool _approved, uint256 _exp, uint8 v, bytes32 r, bytes32 s) public {\n\t\t// verify permits are enabled\n\t\trequire(isFeatureEnabled(FEATURE_OPERATOR_PERMITS), \"operator permits are disabled\");\n\n\t\t// derive signer of the EIP712 PermitForAll message, and\n\t\t// update the nonce for that particular signer to avoid replay attack!!! --------------------->>> ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓\n\t\taddress signer = __deriveSigner(abi.encode(PERMIT_FOR_ALL_TYPEHASH, _owner, _operator, _approved, permitNonces[_owner]++, _exp), v, r, s);\n\n\t\t// perform message integrity and security validations\n\t\trequire(signer == _owner, \"invalid signature\");\n\t\trequire(block.timestamp < _exp, \"signature expired\");\n\n\t\t// delegate call to `__approve` - execute the logic required\n\t\t__approveForAll(_owner, _operator, _approved);\n\t}\n\n\t/**\n\t * @dev Auxiliary function to verify structured EIP712 message signature and derive its signer\n\t *\n\t * @param abiEncodedTypehash abi.encode of the message typehash together with all its parameters\n\t * @param v the recovery byte of the signature\n\t * @param r half of the ECDSA signature pair\n\t * @param s half of the ECDSA signature pair\n\t */\n\tfunction __deriveSigner(bytes memory abiEncodedTypehash, uint8 v, bytes32 r, bytes32 s) private view returns(address) {\n\t\t// build the EIP-712 hashStruct of the message\n\t\tbytes32 hashStruct = keccak256(abiEncodedTypehash);\n\n\t\t// calculate the EIP-712 digest \"\\x19\\x01\" ‖ domainSeparator ‖ hashStruct(message)\n\t\tbytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR, hashStruct));\n\n\t\t// recover the address which signed the message with v, r, s\n\t\taddress signer = ECDSA.recover(digest, v, r, s);\n\n\t\t// return the signer address derived from the signature\n\t\treturn signer;\n\t}\n\n\t// ===== End: Meta-transactions Support =====\n\n\t// ===== Start: mint support =====\n\n\t/**\n\t * @dev Creates new token with token ID specified\n\t *      and assigns an ownership `_to` for this token\n\t *\n\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\n\t *      `onERC721Received` on `_to` and throws if the return value is not\n\t *      `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n\t *\n\t * @dev Requires executor to have `ROLE_TOKEN_CREATOR` permission\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId ID of the token to mint\n\t * @param _data additional data with no specified format, sent in call to `_to`\n\t */\n\tfunction safeMint(address _to, uint256 _tokenId, bytes memory _data) public override {\n\t\t// delegate to unsafe mint\n\t\tmint(_to, _tokenId);\n\n\t\t// make it safe: execute `onERC721Received`\n\n\t\t// if receiver `_to` is a smart contract\n\t\tif(AddressUtils.isContract(_to)) {\n\t\t\t// check it supports ERC721 interface - execute onERC721Received()\n\t\t\tbytes4 response = ERC721TokenReceiver(_to).onERC721Received(msg.sender, address(0), _tokenId, _data);\n\n\t\t\t// expected response is ERC721TokenReceiver(_to).onERC721Received.selector\n\t\t\t// bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))\n\t\t\trequire(response == ERC721TokenReceiver(_to).onERC721Received.selector, \"invalid onERC721Received response\");\n\t\t}\n\t}\n\n\t/**\n\t * @dev Creates new token with token ID specified\n\t *      and assigns an ownership `_to` for this token\n\t *\n\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\n\t *      `onERC721Received` on `_to` and throws if the return value is not\n\t *      `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n\t *\n\t * @dev Requires executor to have `ROLE_TOKEN_CREATOR` permission\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId ID of the token to mint\n\t */\n\tfunction safeMint(address _to, uint256 _tokenId) public override {\n\t\t// delegate to `safeMint` with empty data\n\t\tsafeMint(_to, _tokenId, \"\");\n\t}\n\n\t/**\n\t * @dev Creates new tokens starting with token ID specified\n\t *      and assigns an ownership `_to` for these tokens\n\t *\n\t * @dev Token IDs to be minted: [_tokenId, _tokenId + n)\n\t *\n\t * @dev n must be greater or equal 2: `n > 1`\n\t *\n\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\n\t *      `onERC721Received` on `_to` and throws if the return value is not\n\t *      `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n\t *\n\t * @dev Requires executor to have `ROLE_TOKEN_CREATOR` permission\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId ID of the token to mint\n\t * @param n how many tokens to mint, sequentially increasing the _tokenId\n\t * @param _data additional data with no specified format, sent in call to `_to`\n\t */\n\tfunction safeMintBatch(address _to, uint256 _tokenId, uint256 n, bytes memory _data) public override {\n\t\t// delegate to unsafe mint\n\t\tmintBatch(_to, _tokenId, n);\n\n\t\t// make it safe: execute `onERC721Received`\n\n\t\t// if receiver `_to` is a smart contract\n\t\tif(AddressUtils.isContract(_to)) {\n\t\t\t// onERC721Received: for each token minted\n\t\t\tfor(uint256 i = 0; i < n; i++) {\n\t\t\t\t// check it supports ERC721 interface - execute onERC721Received()\n\t\t\t\tbytes4 response = ERC721TokenReceiver(_to).onERC721Received(msg.sender, address(0), _tokenId + i, _data);\n\n\t\t\t\t// expected response is ERC721TokenReceiver(_to).onERC721Received.selector\n\t\t\t\t// bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))\n\t\t\t\trequire(response == ERC721TokenReceiver(_to).onERC721Received.selector, \"invalid onERC721Received response\");\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @dev Creates new tokens starting with token ID specified\n\t *      and assigns an ownership `_to` for these tokens\n\t *\n\t * @dev Token IDs to be minted: [_tokenId, _tokenId + n)\n\t *\n\t * @dev n must be greater or equal 2: `n > 1`\n\t *\n\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\n\t *      `onERC721Received` on `_to` and throws if the return value is not\n\t *      `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n\t *\n\t * @dev Requires executor to have `ROLE_TOKEN_CREATOR` permission\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId ID of the token to mint\n\t * @param n how many tokens to mint, sequentially increasing the _tokenId\n\t */\n\tfunction safeMintBatch(address _to, uint256 _tokenId, uint256 n) public override {\n\t\t// delegate to `safeMint` with empty data\n\t\tsafeMintBatch(_to, _tokenId, n, \"\");\n\t}\n\n\t/**\n\t * @dev Creates new token with token ID specified\n\t *      and assigns an ownership `_to` for this token\n\t *\n\t * @dev Unsafe: doesn't execute `onERC721Received` on the receiver.\n\t *      Prefer the use of `saveMint` instead of `mint`.\n\t *\n\t * @dev Requires executor to have `ROLE_TOKEN_CREATOR` permission\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId ID of the token to mint\n\t */\n\tfunction mint(address _to, uint256 _tokenId) public override {\n\t\t// check if caller has sufficient permissions to mint tokens\n\t\trequire(isSenderInRole(ROLE_TOKEN_CREATOR), \"access denied\");\n\n\t\t// verify the inputs\n\n\t\t// verify the token ID is \"short\" (96 bits long at most)\n\t\trequire(uint96(_tokenId) == _tokenId, \"token ID overflow\");\n\t\t// verify destination address is set\n\t\trequire(_to != address(0), \"zero address\");\n\n\t\t// verify token doesn't yet exist\n\t\trequire(!exists(_tokenId), \"already minted\");\n\n\t\t// create token ownership record,\n\t\t// add token to `allTokens` and new owner's collections\n\t\t// add token to both local and global collections (enumerations)\n\t\t__addToken(_tokenId, _to);\n\n\t\t// fire ERC721 transfer event\n\t\temit Transfer(address(0), _to, _tokenId);\n\t}\n\n\t/**\n\t * @dev Creates new tokens starting with token ID specified\n\t *      and assigns an ownership `_to` for these tokens\n\t *\n\t * @dev Token IDs to be minted: [_tokenId, _tokenId + n)\n\t *\n\t * @dev n must be greater or equal 2: `n > 1`\n\t *\n\t * @dev Unsafe: doesn't execute `onERC721Received` on the receiver.\n\t *      Prefer the use of `saveMintBatch` instead of `mintBatch`.\n\t *\n\t * @dev Requires executor to have `ROLE_TOKEN_CREATOR` permission\n\t *\n\t * @param _to an address to mint tokens to\n\t * @param _tokenId ID of the first token to mint\n\t * @param n how many tokens to mint, sequentially increasing the _tokenId\n\t */\n\tfunction mintBatch(address _to, uint256 _tokenId, uint256 n) public override {\n\t\t// check if caller has sufficient permissions to mint tokens\n\t\trequire(isSenderInRole(ROLE_TOKEN_CREATOR), \"access denied\");\n\n\t\t// verify the inputs\n\n\t\t// verify destination address is set\n\t\trequire(_to != address(0), \"zero address\");\n\t\t// verify n is set properly\n\t\trequire(n > 1, \"n is too small\");\n\t\t// verify the token ID is \"small\" (96 bits long at most)\n\t\trequire(uint96(_tokenId) == _tokenId, \"token ID overflow\");\n\t\trequire(uint96(_tokenId + n - 1) == _tokenId + n - 1, \"n-th token ID overflow\");\n\n\t\t// verification: for each token to be minted\n\t\tfor(uint256 i = 0; i < n; i++) {\n\t\t\t// verify token doesn't yet exist\n\t\t\trequire(!exists(_tokenId + i), \"already minted\");\n\t\t}\n\n\t\t// create token ownership records,\n\t\t// add tokens to `allTokens` and new owner's collections\n\t\t// add tokens to both local and global collections (enumerations)\n\t\t__addTokens(_to, _tokenId, n);\n\n\t\t// events: for each token minted\n\t\tfor(uint256 i = 0; i < n; i++) {\n\t\t\t// fire ERC721 transfer event\n\t\t\temit Transfer(address(0), _to, _tokenId + i);\n\t\t}\n\t}\n\n\t// ===== End: mint support =====\n\n\t// ----- Start: auxiliary internal/private functions -----\n\n\t/**\n\t * @dev Adds token to the new owner's collection (local),\n\t *      used internally to transfer existing tokens, to mint new\n\t *\n\t * @dev Unsafe: doesn't check for data structures consistency\n\t *      (token existence, token ownership, etc.)\n\t *\n\t * @dev Must be kept private at all times. Inheriting smart contracts\n\t *      may be interested in overriding this function.\n\t *\n\t * @param _tokenId token ID to add\n\t * @param _to new owner address to add token to\n\t */\n\tfunction __addLocal(uint256 _tokenId, address _to) internal virtual {\n\t\t// get a reference to the collection where token goes to\n\t\tuint96[] storage destination = collections[_to];\n\n\t\t// update local index and ownership, do not change global index\n\t\ttokens[_tokenId] = destination.length << 160 | uint160(_to);\n\n\t\t// push token into the collection\n\t\tdestination.push(uint96(_tokenId));\n\t}\n\n\t/**\n\t * @dev Add token to both local and global collections (enumerations),\n\t *      used internally to mint new tokens\n\t *\n\t * @dev Unsafe: doesn't check for data structures consistency\n\t *      (token existence, token ownership, etc.)\n\t *\n\t * @dev Must be kept private at all times. Inheriting smart contracts\n\t *      may be interested in overriding this function.\n\t *\n\t * @param _tokenId token ID to add\n\t * @param _to new owner address to add token to\n\t */\n\tfunction __addToken(uint256 _tokenId, address _to) internal virtual {\n\t\t// add token to a local collection first\n\t\t__addLocal(_tokenId, _to);\n\n\t\t// push it into the global `allTokens` collection (enumeration)\n\t\tallTokens.push(uint96(_tokenId));\n\t}\n\n\t/**\n * @dev Add tokens to both local and global collections (enumerations),\n *      used internally to mint new tokens in batches\n *\n * @dev Token IDs to be added: [_tokenId, _tokenId + n)\n *      n is expected to be greater or equal 2, but this is not checked\n *\n * @dev Unsafe: doesn't check for data structures consistency\n *      (token existence, token ownership, etc.)\n *\n * @dev Must be kept private at all times. Inheriting smart contracts\n *      may be interested in overriding this function.\n *\n * @param _to new owner address to add token to\n * @param _tokenId first token ID to add\n * @param n how many tokens to add, sequentially increasing the _tokenId\n */\n\tfunction __addTokens(address _to, uint256 _tokenId, uint256 n) internal virtual {\n\t\t// get a reference to the collection where tokens go to\n\t\tuint96[] storage destination = collections[_to];\n\n\t\t// for each token to be added\n\t\tfor(uint256 i = 0; i < n; i++) {\n\t\t\t// Note: splitting one loop with three doesn't optimize writing into array\n\t\t\t// update token global and local indexes, ownership\n\t\t\ttokens[_tokenId + i] = destination.length + i << 160 | uint160(_to);\n\t\t\t// push token into the local collection\n\t\t\tdestination.push(uint96(_tokenId + i));\n\t\t\t// push it into the global `allTokens` collection (enumeration)\n\t\t\tallTokens.push(uint96(_tokenId + i));\n\t\t}\n\t}\n\n\t/**\n\t * @dev Removes token from owner's local collection,\n\t *      used internally to transfer or burn existing tokens\n\t *\n\t * @dev Unsafe: doesn't check for data structures consistency\n\t *      (token existence, token ownership, etc.)\n\t *\n\t * @dev Must be kept private at all times. Inheriting smart contracts\n\t *      may be interested in overriding this function.\n\t *\n\t * @param _tokenId token ID to remove\n\t */\n\tfunction __removeLocal(uint256 _tokenId) internal virtual {\n\t\t// read token data, containing local index, and owner address\n\t\tuint256 token = tokens[_tokenId];\n\n\t\t// get a reference to the token's owner collection (local)\n\t\tuint96[] storage source = collections[address(uint160(token))];\n\n\t\t// token index within the collection\n\t\tuint256 i = token >> 160;\n\n\t\t// get an ID of the last token in the collection\n\t\tuint96 sourceId = source[source.length - 1];\n\n\t\t// if the token we're to remove from the collection is not the last one,\n\t\t// we need to move last token in the collection into index `i`\n\t\tif(i != source.length - 1) {\n\t\t\t// we put the last token in the collection to the position released\n\n\t\t\t// update last token index to point to proper place in the collection\n\t\t\ttokens[sourceId] = tokens[sourceId]\n\t\t\t\t// | local idx              | ownership information (address)      |\n\t\t\t\t& 0x000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n\t\t\t\t| i << 160;\n\n\t\t\t// put it into the position `i` within the collection\n\t\t\tsource[i] = sourceId;\n\t\t}\n\n\t\t// trim the collection by removing last element\n\t\tsource.pop();\n\n\t\t// clear token approval (also emits an Approval event)\n\t\t__clearApproval(address(uint160(token)), _tokenId);\n\t}\n\n\t// ----- End: auxiliary internal/private functions -----\n}\n"
    },
    "contracts/token/BinanceAliERC20v2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ERC1363Spec.sol\";\nimport \"../interfaces/EIP2612.sol\";\nimport \"../interfaces/EIP3009.sol\";\nimport \"../utils/AccessControl.sol\";\nimport \"../lib/AddressUtils.sol\";\nimport \"../lib/ECDSA.sol\";\n\n/**\n * @title Artificial Liquid Intelligence ERC20 Token (Alethea, ALI)\n *\n * @notice ALI is the native utility token of the Alethea AI Protocol.\n *      It serves as protocol currency, participates in iNFTs lifecycle,\n *      (locked when iNFT is created, released when iNFT is destroyed,\n *      consumed when iNFT is upgraded).\n *      ALI token powers up the governance protocol (Alethea DAO)\n *\n * @notice Token Summary:\n *      - Symbol: ALI\n *      - Name: Artificial Liquid Intelligence Token\n *      - Decimals: 18\n *      - Initial/maximum total supply: 10,000,000,000 ALI\n *      - Initial supply holder (initial holder) address: 0x0738F702D1a7364d356729Cb8845701885C487A1 (configurable)\n *      - Not mintable: new tokens cannot be created\n *      - Burnable: existing tokens may get destroyed, total supply may decrease\n *      - DAO Support: supports voting delegation\n *\n * @notice Features Summary:\n *      - Supports atomic allowance modification, resolves well-known ERC20 issue with approve (arXiv:1907.00903)\n *      - Voting delegation and delegation on behalf via EIP-712 (like in Compound CMP token) - gives ALI token\n *        powerful governance capabilities by allowing holders to form voting groups by electing delegates\n *      - Unlimited approval feature (like in 0x ZRX token) - saves gas for transfers on behalf\n *        by eliminating the need to update “unlimited” allowance value\n *      - ERC-1363 Payable Token - ERC721-like callback execution mechanism for transfers,\n *        transfers on behalf and approvals; allows creation of smart contracts capable of executing callbacks\n *        in response to transfer or approval in a single transaction\n *      - EIP-2612: permit - 712-signed approvals - improves user experience by allowing to use a token\n *        without having an ETH to pay gas fees\n *      - EIP-3009: Transfer With Authorization - improves user experience by allowing to use a token\n *        without having an ETH to pay gas fees\n *\n * @dev Even though smart contract has mint() function which is used to mint initial token supply,\n *      the function is disabled forever after smart contract deployment by revoking `TOKEN_CREATOR`\n *      permission from the deployer account\n *\n * @dev Token balances and total supply are effectively 192 bits long, meaning that maximum\n *      possible total supply smart contract is able to track is 2^192 (close to 10^40 tokens)\n *\n * @dev Smart contract doesn't use safe math. All arithmetic operations are overflow/underflow safe.\n *      Additionally, Solidity 0.8.7 enforces overflow/underflow safety.\n *\n * @dev Multiple Withdrawal Attack on ERC20 Tokens (arXiv:1907.00903) - resolved\n *      Related events and functions are marked with \"arXiv:1907.00903\" tag:\n *        - event Transfer(address indexed _by, address indexed _from, address indexed _to, uint256 _value)\n *        - event Approve(address indexed _owner, address indexed _spender, uint256 _oldValue, uint256 _value)\n *        - function increaseAllowance(address _spender, uint256 _value) public returns (bool)\n *        - function decreaseAllowance(address _spender, uint256 _value) public returns (bool)\n *      See: https://arxiv.org/abs/1907.00903v1\n *           https://ieeexplore.ieee.org/document/8802438\n *      See: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n *\n * @dev Reviewed\n *      ERC-20   - according to https://eips.ethereum.org/EIPS/eip-20\n *      ERC-1363 - according to https://eips.ethereum.org/EIPS/eip-1363\n *      EIP-2612 - according to https://eips.ethereum.org/EIPS/eip-2612\n *      EIP-3009 - according to https://eips.ethereum.org/EIPS/eip-3009\n *\n * @dev ERC20: contract has passed\n *      - OpenZeppelin ERC20 tests\n *        https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/test/token/ERC20/ERC20.behavior.js\n *        https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/test/token/ERC20/ERC20.test.js\n *      - Ref ERC1363 tests\n *        https://github.com/vittominacori/erc1363-payable-token/blob/master/test/token/ERC1363/ERC1363.behaviour.js\n *      - OpenZeppelin EIP2612 tests\n *        https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/test/token/ERC20/extensions/draft-ERC20Permit.test.js\n *      - Coinbase EIP3009 tests\n *        https://github.com/CoinbaseStablecoin/eip-3009/blob/master/test/EIP3009.test.ts\n *      - Compound voting delegation tests\n *        https://github.com/compound-finance/compound-protocol/blob/master/tests/Governance/CompTest.js\n *        https://github.com/compound-finance/compound-protocol/blob/master/tests/Utils/EIP712.js\n *      - OpenZeppelin voting delegation tests\n *        https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/test/token/ERC20/extensions/ERC20Votes.test.js\n *      See adopted copies of all the tests in the project test folder\n *\n * @dev Compound-like voting delegation functions', public getters', and events' names\n *      were changed for better code readability (Alethea Name <- Comp/Zeppelin name):\n *      - votingDelegates           <- delegates\n *      - votingPowerHistory        <- checkpoints\n *      - votingPowerHistoryLength  <- numCheckpoints\n *      - totalSupplyHistory        <- _totalSupplyCheckpoints (private)\n *      - usedNonces                <- nonces (note: nonces are random instead of sequential)\n *      - DelegateChanged (unchanged)\n *      - VotingPowerChanged        <- DelegateVotesChanged\n *      - votingPowerOf             <- getCurrentVotes\n *      - votingPowerAt             <- getPriorVotes\n *      - totalSupplyAt             <- getPriorTotalSupply\n *      - delegate (unchanged)\n *      - delegateWithAuthorization <- delegateBySig\n * @dev Compound-like voting delegation improved to allow the use of random nonces like in EIP-3009,\n *      instead of sequential; same `usedNonces` EIP-3009 mapping is used to track nonces\n *\n * @dev Reference implementations \"used\":\n *      - Atomic allowance:    https://github.com/OpenZeppelin/openzeppelin-contracts\n *      - Unlimited allowance: https://github.com/0xProject/protocol\n *      - Voting delegation:   https://github.com/compound-finance/compound-protocol\n *                             https://github.com/OpenZeppelin/openzeppelin-contracts\n *      - ERC-1363:            https://github.com/vittominacori/erc1363-payable-token\n *      - EIP-2612:            https://github.com/Uniswap/uniswap-v2-core\n *      - EIP-3009:            https://github.com/centrehq/centre-tokens\n *                             https://github.com/CoinbaseStablecoin/eip-3009\n *      - Meta transactions:   https://github.com/0xProject/protocol\n *\n * @dev Includes resolutions for ALI ERC20 Audit by Miguel Palhas, https://hackmd.io/@naps62/alierc20-audit\n *\n */\nabstract contract AliERC20v2Base is ERC1363, EIP2612, EIP3009, AccessControl {\n\t/**\n\t * @dev Smart contract unique identifier, a random number\n\t *\n\t * @dev Should be regenerated each time smart contact source code is changed\n\t *      and changes smart contract itself is to be redeployed\n\t *\n\t * @dev Generated using https://www.random.org/bytes/\n\t */\n\tuint256 public constant TOKEN_UID = 0x8d4fb97da97378ef7d0ad259aec651f42bd22c200159282baa58486bb390286b;\n\n\t/**\n\t * @notice Name of the token: Artificial Liquid Intelligence Token\n\t *\n\t * @notice ERC20 name of the token (long name)\n\t *\n\t * @dev ERC20 `function name() public view returns (string)`\n\t *\n\t * @dev Field is declared public: getter name() is created when compiled,\n\t *      it returns the name of the token.\n\t */\n\tstring public constant name = \"Artificial Liquid Intelligence Token\";\n\n\t/**\n\t * @notice Symbol of the token: ALI\n\t *\n\t * @notice ERC20 symbol of that token (short name)\n\t *\n\t * @dev ERC20 `function symbol() public view returns (string)`\n\t *\n\t * @dev Field is declared public: getter symbol() is created when compiled,\n\t *      it returns the symbol of the token\n\t */\n\tstring public constant symbol = \"ALI\";\n\n\t/**\n\t * @notice Decimals of the token: 18\n\t *\n\t * @dev ERC20 `function decimals() public view returns (uint8)`\n\t *\n\t * @dev Field is declared public: getter decimals() is created when compiled,\n\t *      it returns the number of decimals used to get its user representation.\n\t *      For example, if `decimals` equals `6`, a balance of `1,500,000` tokens should\n\t *      be displayed to a user as `1,5` (`1,500,000 / 10 ** 6`).\n\t *\n\t * @dev NOTE: This information is only used for _display_ purposes: it in\n\t *      no way affects any of the arithmetic of the contract, including balanceOf() and transfer().\n\t */\n\tuint8 public constant decimals = 18;\n\n\t/**\n\t * @notice Total supply of the token: initially 10,000,000,000,\n\t *      with the potential to decline over time as some tokens may get burnt but not minted\n\t *\n\t * @dev ERC20 `function totalSupply() public view returns (uint256)`\n\t *\n\t * @dev Field is declared public: getter totalSupply() is created when compiled,\n\t *      it returns the amount of tokens in existence.\n\t */\n\tuint256 public override totalSupply; // is set to 10 billion * 10^18 in the constructor\n\n\t/**\n\t * @dev A record of all the token balances\n\t * @dev This mapping keeps record of all token owners:\n\t *      owner => balance\n\t */\n\tmapping(address => uint256) private tokenBalances;\n\n\t/**\n\t * @notice A record of each account's voting delegate\n\t *\n\t * @dev Auxiliary data structure used to sum up an account's voting power\n\t *\n\t * @dev This mapping keeps record of all voting power delegations:\n\t *      voting delegator (token owner) => voting delegate\n\t */\n\tmapping(address => address) public votingDelegates;\n\n\t/**\n\t * @notice Auxiliary structure to store key-value pair, used to store:\n\t *      - voting power record (key: block.timestamp, value: voting power)\n\t *      - total supply record (key: block.timestamp, value: total supply)\n\t * @notice A voting power record binds voting power of a delegate to a particular\n\t *      block when the voting power delegation change happened\n\t *         k: block.number when delegation has changed; starting from\n\t *            that block voting power value is in effect\n\t *         v: cumulative voting power a delegate has obtained starting\n\t *            from the block stored in blockNumber\n\t * @notice Total supply record binds total token supply to a particular\n\t *      block when total supply change happened (due to mint/burn operations)\n\t */\n\tstruct KV {\n\t\t/*\n\t\t * @dev key, a block number\n\t\t */\n\t\tuint64 k;\n\n\t\t/*\n\t\t * @dev value, token balance or voting power\n\t\t */\n\t\tuint192 v;\n\t}\n\n\t/**\n\t * @notice A record of each account's voting power historical data\n\t *\n\t * @dev Primarily data structure to store voting power for each account.\n\t *      Voting power sums up from the account's token balance and delegated\n\t *      balances.\n\t *\n\t * @dev Stores current value and entire history of its changes.\n\t *      The changes are stored as an array of checkpoints (key-value pairs).\n\t *      Checkpoint is an auxiliary data structure containing voting\n\t *      power (number of votes) and block number when the checkpoint is saved\n\t *\n\t * @dev Maps voting delegate => voting power record\n\t */\n\tmapping(address => KV[]) public votingPowerHistory;\n\n\t/**\n\t * @notice A record of total token supply historical data\n\t *\n\t * @dev Primarily data structure to store total token supply.\n\t *\n\t * @dev Stores current value and entire history of its changes.\n\t *      The changes are stored as an array of checkpoints (key-value pairs).\n\t *      Checkpoint is an auxiliary data structure containing total\n\t *      token supply and block number when the checkpoint is saved\n\t */\n\tKV[] public totalSupplyHistory;\n\n\t/**\n\t * @dev A record of nonces for signing/validating signatures in EIP-2612 `permit`\n\t *\n\t * @dev Note: EIP2612 doesn't imply a possibility for nonce randomization like in EIP-3009\n\t *\n\t * @dev Maps delegate address => delegate nonce\n\t */\n\tmapping(address => uint256) public override nonces;\n\n\t/**\n\t * @dev A record of used nonces for EIP-3009 transactions\n\t *\n\t * @dev A record of used nonces for signing/validating signatures\n\t *      in `delegateWithAuthorization` for every delegate\n\t *\n\t * @dev Maps authorizer address => nonce => true/false (used unused)\n\t */\n\tmapping(address => mapping(bytes32 => bool)) private usedNonces;\n\n\t/**\n\t * @notice A record of all the allowances to spend tokens on behalf\n\t * @dev Maps token owner address to an address approved to spend\n\t *      some tokens on behalf, maps approved address to that amount\n\t * @dev owner => spender => value\n\t */\n\tmapping(address => mapping(address => uint256)) private transferAllowances;\n\n\t/**\n\t * @notice Enables ERC20 transfers of the tokens\n\t *      (transfer by the token owner himself)\n\t * @dev Feature FEATURE_TRANSFERS must be enabled in order for\n\t *      `transfer()` function to succeed\n\t */\n\tuint32 public constant FEATURE_TRANSFERS = 0x0000_0001;\n\n\t/**\n\t * @notice Enables ERC20 transfers on behalf\n\t *      (transfer by someone else on behalf of token owner)\n\t * @dev Feature FEATURE_TRANSFERS_ON_BEHALF must be enabled in order for\n\t *      `transferFrom()` function to succeed\n\t * @dev Token owner must call `approve()` first to authorize\n\t *      the transfer on behalf\n\t */\n\tuint32 public constant FEATURE_TRANSFERS_ON_BEHALF = 0x0000_0002;\n\n\t/**\n\t * @dev Defines if the default behavior of `transfer` and `transferFrom`\n\t *      checks if the receiver smart contract supports ERC20 tokens\n\t * @dev When feature FEATURE_UNSAFE_TRANSFERS is enabled the transfers do not\n\t *      check if the receiver smart contract supports ERC20 tokens,\n\t *      i.e. `transfer` and `transferFrom` behave like `unsafeTransferFrom`\n\t * @dev When feature FEATURE_UNSAFE_TRANSFERS is disabled (default) the transfers\n\t *      check if the receiver smart contract supports ERC20 tokens,\n\t *      i.e. `transfer` and `transferFrom` behave like `transferFromAndCall`\n\t */\n\tuint32 public constant FEATURE_UNSAFE_TRANSFERS = 0x0000_0004;\n\n\t/**\n\t * @notice Enables token owners to burn their own tokens\n\t *\n\t * @dev Feature FEATURE_OWN_BURNS must be enabled in order for\n\t *      `burn()` function to succeed when called by token owner\n\t */\n\tuint32 public constant FEATURE_OWN_BURNS = 0x0000_0008;\n\n\t/**\n\t * @notice Enables approved operators to burn tokens on behalf of their owners\n\t *\n\t * @dev Feature FEATURE_BURNS_ON_BEHALF must be enabled in order for\n\t *      `burn()` function to succeed when called by approved operator\n\t */\n\tuint32 public constant FEATURE_BURNS_ON_BEHALF = 0x0000_0010;\n\n\t/**\n\t * @notice Enables delegators to elect delegates\n\t * @dev Feature FEATURE_DELEGATIONS must be enabled in order for\n\t *      `delegate()` function to succeed\n\t */\n\tuint32 public constant FEATURE_DELEGATIONS = 0x0000_0020;\n\n\t/**\n\t * @notice Enables delegators to elect delegates on behalf\n\t *      (via an EIP712 signature)\n\t * @dev Feature FEATURE_DELEGATIONS_ON_BEHALF must be enabled in order for\n\t *      `delegateWithAuthorization()` function to succeed\n\t */\n\tuint32 public constant FEATURE_DELEGATIONS_ON_BEHALF = 0x0000_0040;\n\n\t/**\n\t * @notice Enables ERC-1363 transfers with callback\n\t * @dev Feature FEATURE_ERC1363_TRANSFERS must be enabled in order for\n\t *      ERC-1363 `transferFromAndCall` functions to succeed\n\t */\n\tuint32 public constant FEATURE_ERC1363_TRANSFERS = 0x0000_0080;\n\n\t/**\n\t * @notice Enables ERC-1363 approvals with callback\n\t * @dev Feature FEATURE_ERC1363_APPROVALS must be enabled in order for\n\t *      ERC-1363 `approveAndCall` functions to succeed\n\t */\n\tuint32 public constant FEATURE_ERC1363_APPROVALS = 0x0000_0100;\n\n\t/**\n\t * @notice Enables approvals on behalf (EIP2612 permits\n\t *      via an EIP712 signature)\n\t * @dev Feature FEATURE_EIP2612_PERMITS must be enabled in order for\n\t *      `permit()` function to succeed\n\t */\n\tuint32 public constant FEATURE_EIP2612_PERMITS = 0x0000_0200;\n\n\t/**\n\t * @notice Enables meta transfers on behalf (EIP3009 transfers\n\t *      via an EIP712 signature)\n\t * @dev Feature FEATURE_EIP3009_TRANSFERS must be enabled in order for\n\t *      `transferWithAuthorization()` function to succeed\n\t */\n\tuint32 public constant FEATURE_EIP3009_TRANSFERS = 0x0000_0400;\n\n\t/**\n\t * @notice Enables meta transfers on behalf (EIP3009 transfers\n\t *      via an EIP712 signature)\n\t * @dev Feature FEATURE_EIP3009_RECEPTIONS must be enabled in order for\n\t *      `receiveWithAuthorization()` function to succeed\n\t */\n\tuint32 public constant FEATURE_EIP3009_RECEPTIONS = 0x0000_0800;\n\n\t/**\n\t * @notice Token creator is responsible for creating (minting)\n\t *      tokens to an arbitrary address\n\t * @dev Role ROLE_TOKEN_CREATOR allows minting tokens\n\t *      (calling `mint` function)\n\t */\n\tuint32 public constant ROLE_TOKEN_CREATOR = 0x0001_0000;\n\n\t/**\n\t * @notice Token destroyer is responsible for destroying (burning)\n\t *      tokens owned by an arbitrary address\n\t * @dev Role ROLE_TOKEN_DESTROYER allows burning tokens\n\t *      (calling `burn` function)\n\t */\n\tuint32 public constant ROLE_TOKEN_DESTROYER = 0x0002_0000;\n\n\t/**\n\t * @notice ERC20 receivers are allowed to receive tokens without ERC20 safety checks,\n\t *      which may be useful to simplify tokens transfers into \"legacy\" smart contracts\n\t * @dev When `FEATURE_UNSAFE_TRANSFERS` is not enabled addresses having\n\t *      `ROLE_ERC20_RECEIVER` permission are allowed to receive tokens\n\t *      via `transfer` and `transferFrom` functions in the same way they\n\t *      would via `unsafeTransferFrom` function\n\t * @dev When `FEATURE_UNSAFE_TRANSFERS` is enabled `ROLE_ERC20_RECEIVER` permission\n\t *      doesn't affect the transfer behaviour since\n\t *      `transfer` and `transferFrom` behave like `unsafeTransferFrom` for any receiver\n\t * @dev ROLE_ERC20_RECEIVER is a shortening for ROLE_UNSAFE_ERC20_RECEIVER\n\t */\n\tuint32 public constant ROLE_ERC20_RECEIVER = 0x0004_0000;\n\n\t/**\n\t * @notice ERC20 senders are allowed to send tokens without ERC20 safety checks,\n\t *      which may be useful to simplify tokens transfers into \"legacy\" smart contracts\n\t * @dev When `FEATURE_UNSAFE_TRANSFERS` is not enabled senders having\n\t *      `ROLE_ERC20_SENDER` permission are allowed to send tokens\n\t *      via `transfer` and `transferFrom` functions in the same way they\n\t *      would via `unsafeTransferFrom` function\n\t * @dev When `FEATURE_UNSAFE_TRANSFERS` is enabled `ROLE_ERC20_SENDER` permission\n\t *      doesn't affect the transfer behaviour since\n\t *      `transfer` and `transferFrom` behave like `unsafeTransferFrom` for any receiver\n\t * @dev ROLE_ERC20_SENDER is a shortening for ROLE_UNSAFE_ERC20_SENDER\n\t */\n\tuint32 public constant ROLE_ERC20_SENDER = 0x0008_0000;\n\n\t/**\n\t * @notice EIP-712 contract's domain typeHash,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\n\t *\n\t * @dev Note: we do not include version into the domain typehash/separator,\n\t *      it is implied version is concatenated to the name field, like \"AliERC20v2\"\n\t */\n\t// keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\")\n\tbytes32 public constant DOMAIN_TYPEHASH = 0x8cad95687ba82c2ce50e74f7b754645e5117c3a5bec8151c0726d5857980a866;\n\n\t/**\n\t * @notice EIP-712 contract's domain separator,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator\n\t */\n\tbytes32 public immutable override DOMAIN_SEPARATOR;\n\n\t/**\n\t * @notice EIP-712 delegation struct typeHash,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\n\t */\n\t// keccak256(\"Delegation(address delegate,uint256 nonce,uint256 expiry)\")\n\tbytes32 public constant DELEGATION_TYPEHASH = 0xff41620983935eb4d4a3c7384a066ca8c1d10cef9a5eca9eb97ca735cd14a755;\n\n\t/**\n\t * @notice EIP-712 permit (EIP-2612) struct typeHash,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\n\t */\n\t// keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\")\n\tbytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n\t/**\n\t * @notice EIP-712 TransferWithAuthorization (EIP-3009) struct typeHash,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\n\t */\n\t// keccak256(\"TransferWithAuthorization(address from,address to,uint256 value,uint256 validAfter,uint256 validBefore,bytes32 nonce)\")\n\tbytes32 public constant TRANSFER_WITH_AUTHORIZATION_TYPEHASH = 0x7c7c6cdb67a18743f49ec6fa9b35f50d52ed05cbed4cc592e13b44501c1a2267;\n\n\t/**\n\t * @notice EIP-712 ReceiveWithAuthorization (EIP-3009) struct typeHash,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\n\t */\n\t// keccak256(\"ReceiveWithAuthorization(address from,address to,uint256 value,uint256 validAfter,uint256 validBefore,bytes32 nonce)\")\n\tbytes32 public constant RECEIVE_WITH_AUTHORIZATION_TYPEHASH = 0xd099cc98ef71107a616c4f0f941f04c322d8e254fe26b3c6668db87aae413de8;\n\n\t/**\n\t * @notice EIP-712 CancelAuthorization (EIP-3009) struct typeHash,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\n\t */\n\t// keccak256(\"CancelAuthorization(address authorizer,bytes32 nonce)\")\n\tbytes32 public constant CANCEL_AUTHORIZATION_TYPEHASH = 0x158b0a9edf7a828aad02f63cd515c68ef2f50ba807396f6d12842833a1597429;\n\n\t/**\n\t * @dev Fired in mint() function\n\t *\n\t * @param by an address which minted some tokens (transaction sender)\n\t * @param to an address the tokens were minted to\n\t * @param value an amount of tokens minted\n\t */\n\tevent Minted(address indexed by, address indexed to, uint256 value);\n\n\t/**\n\t * @dev Fired in burn() function\n\t *\n\t * @param by an address which burned some tokens (transaction sender)\n\t * @param from an address the tokens were burnt from\n\t * @param value an amount of tokens burnt\n\t */\n\tevent Burnt(address indexed by, address indexed from, uint256 value);\n\n\t/**\n\t * @dev Resolution for the Multiple Withdrawal Attack on ERC20 Tokens (arXiv:1907.00903)\n\t *\n\t * @dev Similar to ERC20 Transfer event, but also logs an address which executed transfer\n\t *\n\t * @dev Fired in transfer(), transferFrom() and some other (non-ERC20) functions\n\t *\n\t * @param by an address which performed the transfer\n\t * @param from an address tokens were consumed from\n\t * @param to an address tokens were sent to\n\t * @param value number of tokens transferred\n\t */\n\tevent Transfer(address indexed by, address indexed from, address indexed to, uint256 value);\n\n\t/**\n\t * @dev Resolution for the Multiple Withdrawal Attack on ERC20 Tokens (arXiv:1907.00903)\n\t *\n\t * @dev Similar to ERC20 Approve event, but also logs old approval value\n\t *\n\t * @dev Fired in approve(), increaseAllowance(), decreaseAllowance() functions,\n\t *      may get fired in transfer functions\n\t *\n\t * @param owner an address which granted a permission to transfer\n\t *      tokens on its behalf\n\t * @param spender an address which received a permission to transfer\n\t *      tokens on behalf of the owner `_owner`\n\t * @param oldValue previously granted amount of tokens to transfer on behalf\n\t * @param value new granted amount of tokens to transfer on behalf\n\t */\n\tevent Approval(address indexed owner, address indexed spender, uint256 oldValue, uint256 value);\n\n\t/**\n\t * @dev Notifies that a key-value pair in `votingDelegates` mapping has changed,\n\t *      i.e. a delegator address has changed its delegate address\n\t *\n\t * @param source delegator address, a token owner, effectively transaction sender (`by`)\n\t * @param from old delegate, an address which delegate right is revoked\n\t * @param to new delegate, an address which received the voting power\n\t */\n\tevent DelegateChanged(address indexed source, address indexed from, address indexed to);\n\n\t/**\n\t * @dev Notifies that a key-value pair in `votingPowerHistory` mapping has changed,\n\t *      i.e. a delegate's voting power has changed.\n\t *\n\t * @param by an address which executed delegate, mint, burn, or transfer operation\n\t *      which had led to delegate voting power change\n\t * @param target delegate whose voting power has changed\n\t * @param fromVal previous number of votes delegate had\n\t * @param toVal new number of votes delegate has\n\t */\n\tevent VotingPowerChanged(address indexed by, address indexed target, uint256 fromVal, uint256 toVal);\n\n\t/**\n\t * @dev Deploys the token smart contract,\n\t *      assigns initial token supply to the address specified\n\t *\n\t * @param _initialHolder owner of the initial token supply\n\t * @param _initialSupply initial token supply value\n\t */\n\tconstructor(address _initialHolder, uint256 _initialSupply) {\n\t\t// verify initial holder address non-zero (is set) if there is an initial supply to mint\n\t\trequire(_initialSupply == 0 || _initialHolder != address(0), \"_initialHolder not set (zero address)\");\n\n\t\t// build the EIP-712 contract domain separator, see https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator\n\t\t// note: we specify contract version in its name\n\t\tDOMAIN_SEPARATOR = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(\"AliERC20v2\")), block.chainid, address(this)));\n\n\t\t// if there is an initial supply to mint\n\t\tif(_initialSupply != 0) {\n\t\t\t// mint the initial supply\n\t\t\tmint(_initialHolder, _initialSupply);\n\t\t}\n\t}\n\n\t/**\n\t * @inheritdoc ERC165\n\t */\n\tfunction supportsInterface(bytes4 interfaceId) public pure override returns (bool) {\n\t\t// reconstruct from current interface(s) and super interface(s) (if any)\n\t\treturn interfaceId == type(ERC165).interfaceId\n\t\t    || interfaceId == type(ERC20).interfaceId\n\t\t    || interfaceId == type(ERC1363).interfaceId\n\t\t    || interfaceId == type(EIP2612).interfaceId\n\t\t    || interfaceId == type(EIP3009).interfaceId;\n\t}\n\n\t// ===== Start: ERC-1363 functions =====\n\n\t/**\n\t * @notice Transfers some tokens and then executes `onTransferReceived` callback on the receiver\n\t *\n\t * @inheritdoc ERC1363\n\t *\n\t * @dev Called by token owner (an address which has a\n\t *      positive token balance tracked by this smart contract)\n\t * @dev Throws on any error like\n\t *      * insufficient token balance or\n\t *      * incorrect `_to` address:\n\t *          * zero address or\n\t *          * same as `_from` address (self transfer)\n\t *          * EOA or smart contract which doesn't support ERC1363Receiver interface\n\t * @dev Returns true on success, throws otherwise\n\t *\n\t * @param _to an address to transfer tokens to,\n\t *      must be a smart contract, implementing ERC1363Receiver\n\t * @param _value amount of tokens to be transferred,, zero\n\t *      value is allowed\n\t * @return true unless throwing\n\t */\n\tfunction transferAndCall(address _to, uint256 _value) public override returns (bool) {\n\t\t// delegate to `transferFromAndCall` passing `msg.sender` as `_from`\n\t\treturn transferFromAndCall(msg.sender, _to, _value);\n\t}\n\n\t/**\n\t * @notice Transfers some tokens and then executes `onTransferReceived` callback on the receiver\n\t *\n\t * @inheritdoc ERC1363\n\t *\n\t * @dev Called by token owner (an address which has a\n\t *      positive token balance tracked by this smart contract)\n\t * @dev Throws on any error like\n\t *      * insufficient token balance or\n\t *      * incorrect `_to` address:\n\t *          * zero address or\n\t *          * same as `_from` address (self transfer)\n\t *          * EOA or smart contract which doesn't support ERC1363Receiver interface\n\t * @dev Returns true on success, throws otherwise\n\t *\n\t * @param _to an address to transfer tokens to,\n\t *      must be a smart contract, implementing ERC1363Receiver\n\t * @param _value amount of tokens to be transferred,, zero\n\t *      value is allowed\n\t * @param _data [optional] additional data with no specified format,\n\t *      sent in onTransferReceived call to `_to`\n\t * @return true unless throwing\n\t */\n\tfunction transferAndCall(address _to, uint256 _value, bytes memory _data) public override returns (bool) {\n\t\t// delegate to `transferFromAndCall` passing `msg.sender` as `_from`\n\t\treturn transferFromAndCall(msg.sender, _to, _value, _data);\n\t}\n\n\t/**\n\t * @notice Transfers some tokens on behalf of address `_from' (token owner)\n\t *      to some other address `_to` and then executes `onTransferReceived` callback on the receiver\n\t *\n\t * @inheritdoc ERC1363\n\t *\n\t * @dev Called by token owner on his own or approved address,\n\t *      an address approved earlier by token owner to\n\t *      transfer some amount of tokens on its behalf\n\t * @dev Throws on any error like\n\t *      * insufficient token balance or\n\t *      * incorrect `_to` address:\n\t *          * zero address or\n\t *          * same as `_from` address (self transfer)\n\t *          * EOA or smart contract which doesn't support ERC1363Receiver interface\n\t * @dev Returns true on success, throws otherwise\n\t *\n\t * @param _from token owner which approved caller (transaction sender)\n\t *      to transfer `_value` of tokens on its behalf\n\t * @param _to an address to transfer tokens to,\n\t *      must be a smart contract, implementing ERC1363Receiver\n\t * @param _value amount of tokens to be transferred,, zero\n\t *      value is allowed\n\t * @return true unless throwing\n\t */\n\tfunction transferFromAndCall(address _from, address _to, uint256 _value) public override returns (bool) {\n\t\t// delegate to `transferFromAndCall` passing empty data param\n\t\treturn transferFromAndCall(_from, _to, _value, \"\");\n\t}\n\n\t/**\n\t * @notice Transfers some tokens on behalf of address `_from' (token owner)\n\t *      to some other address `_to` and then executes a `onTransferReceived` callback on the receiver\n\t *\n\t * @inheritdoc ERC1363\n\t *\n\t * @dev Called by token owner on his own or approved address,\n\t *      an address approved earlier by token owner to\n\t *      transfer some amount of tokens on its behalf\n\t * @dev Throws on any error like\n\t *      * insufficient token balance or\n\t *      * incorrect `_to` address:\n\t *          * zero address or\n\t *          * same as `_from` address (self transfer)\n\t *          * EOA or smart contract which doesn't support ERC1363Receiver interface\n\t * @dev Returns true on success, throws otherwise\n\t *\n\t * @param _from token owner which approved caller (transaction sender)\n\t *      to transfer `_value` of tokens on its behalf\n\t * @param _to an address to transfer tokens to,\n\t *      must be a smart contract, implementing ERC1363Receiver\n\t * @param _value amount of tokens to be transferred,, zero\n\t *      value is allowed\n\t * @param _data [optional] additional data with no specified format,\n\t *      sent in onTransferReceived call to `_to`\n\t * @return true unless throwing\n\t */\n\tfunction transferFromAndCall(address _from, address _to, uint256 _value, bytes memory _data) public override returns (bool) {\n\t\t// ensure ERC-1363 transfers are enabled\n\t\trequire(isFeatureEnabled(FEATURE_ERC1363_TRANSFERS), \"ERC1363 transfers are disabled\");\n\n\t\t// first delegate call to `unsafeTransferFrom` to perform the unsafe token(s) transfer\n\t\tunsafeTransferFrom(_from, _to, _value);\n\n\t\t// after the successful transfer - check if receiver supports\n\t\t// ERC1363Receiver and execute a callback handler `onTransferReceived`,\n\t\t// reverting whole transaction on any error\n\t\t_notifyTransferred(_from, _to, _value, _data, false);\n\n\t\t// function throws on any error, so if we're here - it means operation successful, just return true\n\t\treturn true;\n\t}\n\n\t/**\n\t * @notice Approves address called `_spender` to transfer some amount\n\t *      of tokens on behalf of the owner, then executes a `onApprovalReceived` callback on `_spender`\n\t *\n\t * @inheritdoc ERC1363\n\t *\n\t * @dev Caller must not necessarily own any tokens to grant the permission\n\t *\n\t * @dev Throws if `_spender` is an EOA or a smart contract which doesn't support ERC1363Spender interface\n\t *\n\t * @param _spender an address approved by the caller (token owner)\n\t *      to spend some tokens on its behalf\n\t * @param _value an amount of tokens spender `_spender` is allowed to\n\t *      transfer on behalf of the token owner\n\t * @return success true on success, throws otherwise\n\t */\n\tfunction approveAndCall(address _spender, uint256 _value) public override returns (bool) {\n\t\t// delegate to `approveAndCall` passing empty data\n\t\treturn approveAndCall(_spender, _value, \"\");\n\t}\n\n\t/**\n\t * @notice Approves address called `_spender` to transfer some amount\n\t *      of tokens on behalf of the owner, then executes a callback on `_spender`\n\t *\n\t * @inheritdoc ERC1363\n\t *\n\t * @dev Caller must not necessarily own any tokens to grant the permission\n\t *\n\t * @param _spender an address approved by the caller (token owner)\n\t *      to spend some tokens on its behalf\n\t * @param _value an amount of tokens spender `_spender` is allowed to\n\t *      transfer on behalf of the token owner\n\t * @param _data [optional] additional data with no specified format,\n\t *      sent in onApprovalReceived call to `_spender`\n\t * @return success true on success, throws otherwise\n\t */\n\tfunction approveAndCall(address _spender, uint256 _value, bytes memory _data) public override returns (bool) {\n\t\t// ensure ERC-1363 approvals are enabled\n\t\trequire(isFeatureEnabled(FEATURE_ERC1363_APPROVALS), \"ERC1363 approvals are disabled\");\n\n\t\t// execute regular ERC20 approve - delegate to `approve`\n\t\tapprove(_spender, _value);\n\n\t\t// after the successful approve - check if receiver supports\n\t\t// ERC1363Spender and execute a callback handler `onApprovalReceived`,\n\t\t// reverting whole transaction on any error\n\t\t_notifyApproved(_spender, _value, _data);\n\n\t\t// function throws on any error, so if we're here - it means operation successful, just return true\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Auxiliary function to invoke `onTransferReceived` on a target address\n\t *      The call is not executed if the target address is not a contract; in such\n\t *      a case function throws if `allowEoa` is set to false, succeeds if it's true\n\t *\n\t * @dev Throws on any error; returns silently on success\n\t *\n\t * @param _from representing the previous owner of the given token value\n\t * @param _to target address that will receive the tokens\n\t * @param _value the amount mount of tokens to be transferred\n\t * @param _data [optional] data to send along with the call\n\t * @param allowEoa indicates if function should fail if `_to` is an EOA\n\t */\n\tfunction _notifyTransferred(address _from, address _to, uint256 _value, bytes memory _data, bool allowEoa) private {\n\t\t// if recipient `_to` is EOA\n\t\tif (!AddressUtils.isContract(_to)) {\n\t\t\t// ensure EOA recipient is allowed\n\t\t\trequire(allowEoa, \"EOA recipient\");\n\n\t\t\t// exit if successful\n\t\t\treturn;\n\t\t}\n\n\t\t// otherwise - if `_to` is a contract - execute onTransferReceived\n\t\tbytes4 response = ERC1363Receiver(_to).onTransferReceived(msg.sender, _from, _value, _data);\n\n\t\t// expected response is ERC1363Receiver(_to).onTransferReceived.selector\n\t\t// bytes4(keccak256(\"onTransferReceived(address,address,uint256,bytes)\"))\n\t\trequire(response == ERC1363Receiver(_to).onTransferReceived.selector, \"invalid onTransferReceived response\");\n\t}\n\n\t/**\n\t * @dev Auxiliary function to invoke `onApprovalReceived` on a target address\n\t *      The call is not executed if the target address is not a contract; in such\n\t *      a case function throws if `allowEoa` is set to false, succeeds if it's true\n\t *\n\t * @dev Throws on any error; returns silently on success\n\t *\n\t * @param _spender the address which will spend the funds\n\t * @param _value the amount of tokens to be spent\n\t * @param _data [optional] data to send along with the call\n\t */\n\tfunction _notifyApproved(address _spender, uint256 _value, bytes memory _data) private {\n\t\t// ensure recipient is not EOA\n\t\trequire(AddressUtils.isContract(_spender), \"EOA spender\");\n\n\t\t// otherwise - if `_to` is a contract - execute onApprovalReceived\n\t\tbytes4 response = ERC1363Spender(_spender).onApprovalReceived(msg.sender, _value, _data);\n\n\t\t// expected response is ERC1363Spender(_to).onApprovalReceived.selector\n\t\t// bytes4(keccak256(\"onApprovalReceived(address,uint256,bytes)\"))\n\t\trequire(response == ERC1363Spender(_spender).onApprovalReceived.selector, \"invalid onApprovalReceived response\");\n\t}\n\t// ===== End: ERC-1363 functions =====\n\n\t// ===== Start: ERC20 functions =====\n\n\t/**\n\t * @notice Gets the balance of a particular address\n\t *\n\t * @inheritdoc ERC20\n\t *\n\t * @param _owner the address to query the the balance for\n\t * @return balance an amount of tokens owned by the address specified\n\t */\n\tfunction balanceOf(address _owner) public view override returns (uint256 balance) {\n\t\t// read the balance and return\n\t\treturn tokenBalances[_owner];\n\t}\n\n\t/**\n\t * @notice Transfers some tokens to an external address or a smart contract\n\t *\n\t * @inheritdoc ERC20\n\t *\n\t * @dev Called by token owner (an address which has a\n\t *      positive token balance tracked by this smart contract)\n\t * @dev Throws on any error like\n\t *      * insufficient token balance or\n\t *      * incorrect `_to` address:\n\t *          * zero address or\n\t *          * self address or\n\t *          * smart contract which doesn't support ERC20\n\t *\n\t * @param _to an address to transfer tokens to,\n\t *      must be either an external address or a smart contract,\n\t *      compliant with the ERC20 standard\n\t * @param _value amount of tokens to be transferred,, zero\n\t *      value is allowed\n\t * @return success true on success, throws otherwise\n\t */\n\tfunction transfer(address _to, uint256 _value) public override returns (bool success) {\n\t\t// just delegate call to `transferFrom`,\n\t\t// `FEATURE_TRANSFERS` is verified inside it\n\t\treturn transferFrom(msg.sender, _to, _value);\n\t}\n\n\t/**\n\t * @notice Transfers some tokens on behalf of address `_from' (token owner)\n\t *      to some other address `_to`\n\t *\n\t * @inheritdoc ERC20\n\t *\n\t * @dev Called by token owner on his own or approved address,\n\t *      an address approved earlier by token owner to\n\t *      transfer some amount of tokens on its behalf\n\t * @dev Throws on any error like\n\t *      * insufficient token balance or\n\t *      * incorrect `_to` address:\n\t *          * zero address or\n\t *          * same as `_from` address (self transfer)\n\t *          * smart contract which doesn't support ERC20\n\t *\n\t * @param _from token owner which approved caller (transaction sender)\n\t *      to transfer `_value` of tokens on its behalf\n\t * @param _to an address to transfer tokens to,\n\t *      must be either an external address or a smart contract,\n\t *      compliant with the ERC20 standard\n\t * @param _value amount of tokens to be transferred,, zero\n\t *      value is allowed\n\t * @return success true on success, throws otherwise\n\t */\n\tfunction transferFrom(address _from, address _to, uint256 _value) public override returns (bool success) {\n\t\t// depending on `FEATURE_UNSAFE_TRANSFERS` we execute either safe (default)\n\t\t// or unsafe transfer\n\t\t// if `FEATURE_UNSAFE_TRANSFERS` is enabled\n\t\t// or receiver has `ROLE_ERC20_RECEIVER` permission\n\t\t// or sender has `ROLE_ERC20_SENDER` permission\n\t\tif(isFeatureEnabled(FEATURE_UNSAFE_TRANSFERS)\n\t\t\t|| isOperatorInRole(_to, ROLE_ERC20_RECEIVER)\n\t\t\t|| isSenderInRole(ROLE_ERC20_SENDER)) {\n\t\t\t// we execute unsafe transfer - delegate call to `unsafeTransferFrom`,\n\t\t\t// `FEATURE_TRANSFERS` is verified inside it\n\t\t\tunsafeTransferFrom(_from, _to, _value);\n\t\t}\n\t\t// otherwise - if `FEATURE_UNSAFE_TRANSFERS` is disabled\n\t\t// and receiver doesn't have `ROLE_ERC20_RECEIVER` permission\n\t\telse {\n\t\t\t// we execute safe transfer - delegate call to `safeTransferFrom`, passing empty `_data`,\n\t\t\t// `FEATURE_TRANSFERS` is verified inside it\n\t\t\tsafeTransferFrom(_from, _to, _value, \"\");\n\t\t}\n\n\t\t// both `unsafeTransferFrom` and `safeTransferFrom` throw on any error, so\n\t\t// if we're here - it means operation successful,\n\t\t// just return true\n\t\treturn true;\n\t}\n\n\t/**\n\t * @notice Transfers some tokens on behalf of address `_from' (token owner)\n\t *      to some other address `_to` and then executes `onTransferReceived` callback\n\t *      on the receiver if it is a smart contract (not an EOA)\n\t *\n\t * @dev Called by token owner on his own or approved address,\n\t *      an address approved earlier by token owner to\n\t *      transfer some amount of tokens on its behalf\n\t * @dev Throws on any error like\n\t *      * insufficient token balance or\n\t *      * incorrect `_to` address:\n\t *          * zero address or\n\t *          * same as `_from` address (self transfer)\n\t *          * smart contract which doesn't support ERC1363Receiver interface\n\t * @dev Returns true on success, throws otherwise\n\t *\n\t * @param _from token owner which approved caller (transaction sender)\n\t *      to transfer `_value` of tokens on its behalf\n\t * @param _to an address to transfer tokens to,\n\t *      must be either an external address or a smart contract,\n\t *      implementing ERC1363Receiver\n\t * @param _value amount of tokens to be transferred,, zero\n\t *      value is allowed\n\t * @param _data [optional] additional data with no specified format,\n\t *      sent in onTransferReceived call to `_to` in case if its a smart contract\n\t * @return true unless throwing\n\t */\n\tfunction safeTransferFrom(address _from, address _to, uint256 _value, bytes memory _data) public returns (bool) {\n\t\t// first delegate call to `unsafeTransferFrom` to perform the unsafe token(s) transfer\n\t\tunsafeTransferFrom(_from, _to, _value);\n\n\t\t// after the successful transfer - check if receiver supports\n\t\t// ERC1363Receiver and execute a callback handler `onTransferReceived`,\n\t\t// reverting whole transaction on any error\n\t\t_notifyTransferred(_from, _to, _value, _data, true);\n\n\t\t// function throws on any error, so if we're here - it means operation successful, just return true\n\t\treturn true;\n\t}\n\n\t/**\n\t * @notice Transfers some tokens on behalf of address `_from' (token owner)\n\t *      to some other address `_to`\n\t *\n\t * @dev In contrast to `transferFromAndCall` doesn't check recipient\n\t *      smart contract to support ERC20 tokens (ERC1363Receiver)\n\t * @dev Designed to be used by developers when the receiver is known\n\t *      to support ERC20 tokens but doesn't implement ERC1363Receiver interface\n\t * @dev Called by token owner on his own or approved address,\n\t *      an address approved earlier by token owner to\n\t *      transfer some amount of tokens on its behalf\n\t * @dev Throws on any error like\n\t *      * insufficient token balance or\n\t *      * incorrect `_to` address:\n\t *          * zero address or\n\t *          * same as `_from` address (self transfer)\n\t * @dev Returns silently on success, throws otherwise\n\t *\n\t * @param _from token sender, token owner which approved caller (transaction sender)\n\t *      to transfer `_value` of tokens on its behalf\n\t * @param _to token receiver, an address to transfer tokens to\n\t * @param _value amount of tokens to be transferred,, zero\n\t *      value is allowed\n\t */\n\tfunction unsafeTransferFrom(address _from, address _to, uint256 _value) public {\n\t\t// make an internal transferFrom - delegate to `__transferFrom`\n\t\t__transferFrom(msg.sender, _from, _to, _value);\n\t}\n\n\t/**\n\t * @dev Powers the meta transactions for `unsafeTransferFrom` - EIP-3009 `transferWithAuthorization`\n\t *      and `receiveWithAuthorization`\n\t *\n\t * @dev See `unsafeTransferFrom` and `transferFrom` soldoc for details\n\t *\n\t * @param _by an address executing the transfer, it can be token owner itself,\n\t *      or an operator previously approved with `approve()`\n\t * @param _from token sender, token owner which approved caller (transaction sender)\n\t *      to transfer `_value` of tokens on its behalf\n\t * @param _to token receiver, an address to transfer tokens to\n\t * @param _value amount of tokens to be transferred,, zero\n\t *      value is allowed\n\t */\n\tfunction __transferFrom(address _by, address _from, address _to, uint256 _value) private {\n\t\t// if `_from` is equal to sender, require transfers feature to be enabled\n\t\t// otherwise require transfers on behalf feature to be enabled\n\t\trequire(_from == _by && isFeatureEnabled(FEATURE_TRANSFERS)\n\t\t     || _from != _by && isFeatureEnabled(FEATURE_TRANSFERS_ON_BEHALF),\n\t\t        _from == _by? \"transfers are disabled\": \"transfers on behalf are disabled\");\n\n\t\t// non-zero source address check - Zeppelin\n\t\t// obviously, zero source address is a client mistake\n\t\t// it's not part of ERC20 standard but it's reasonable to fail fast\n\t\t// since for zero value transfer transaction succeeds otherwise\n\t\trequire(_from != address(0), \"transfer from the zero address\");\n\n\t\t// non-zero recipient address check\n\t\trequire(_to != address(0), \"transfer to the zero address\");\n\n\t\t// sender and recipient cannot be the same\n\t\trequire(_from != _to, \"sender and recipient are the same (_from = _to)\");\n\n\t\t// sending tokens to the token smart contract itself is a client mistake\n\t\trequire(_to != address(this), \"invalid recipient (transfer to the token smart contract itself)\");\n\n\t\t// according to ERC-20 Token Standard, https://eips.ethereum.org/EIPS/eip-20\n\t\t// \"Transfers of 0 values MUST be treated as normal transfers and fire the Transfer event.\"\n\t\tif(_value == 0) {\n\t\t\t// emit an ERC20 transfer event\n\t\t\temit Transfer(_from, _to, _value);\n\n\t\t\t// don't forget to return - we're done\n\t\t\treturn;\n\t\t}\n\n\t\t// no need to make arithmetic overflow check on the _value - by design of mint()\n\n\t\t// in case of transfer on behalf\n\t\tif(_from != _by) {\n\t\t\t// read allowance value - the amount of tokens allowed to transfer - into the stack\n\t\t\tuint256 _allowance = transferAllowances[_from][_by];\n\n\t\t\t// verify sender has an allowance to transfer amount of tokens requested\n\t\t\trequire(_allowance >= _value, \"transfer amount exceeds allowance\");\n\n\t\t\t// we treat max uint256 allowance value as an \"unlimited\" and\n\t\t\t// do not decrease allowance when it is set to \"unlimited\" value\n\t\t\tif(_allowance < type(uint256).max) {\n\t\t\t\t// update allowance value on the stack\n\t\t\t\t_allowance -= _value;\n\n\t\t\t\t// update the allowance value in storage\n\t\t\t\ttransferAllowances[_from][_by] = _allowance;\n\n\t\t\t\t// emit an improved atomic approve event\n\t\t\t\temit Approval(_from, _by, _allowance + _value, _allowance);\n\n\t\t\t\t// emit an ERC20 approval event to reflect the decrease\n\t\t\t\temit Approval(_from, _by, _allowance);\n\t\t\t}\n\t\t}\n\n\t\t// verify sender has enough tokens to transfer on behalf\n\t\trequire(tokenBalances[_from] >= _value, \"transfer amount exceeds balance\");\n\n\t\t// perform the transfer:\n\t\t// decrease token owner (sender) balance\n\t\ttokenBalances[_from] -= _value;\n\n\t\t// increase `_to` address (receiver) balance\n\t\ttokenBalances[_to] += _value;\n\n\t\t// move voting power associated with the tokens transferred\n\t\t__moveVotingPower(_by, votingDelegates[_from], votingDelegates[_to], _value);\n\n\t\t// emit an improved transfer event (arXiv:1907.00903)\n\t\temit Transfer(_by, _from, _to, _value);\n\n\t\t// emit an ERC20 transfer event\n\t\temit Transfer(_from, _to, _value);\n\t}\n\n\t/**\n\t * @notice Approves address called `_spender` to transfer some amount\n\t *      of tokens on behalf of the owner (transaction sender)\n\t *\n\t * @inheritdoc ERC20\n\t *\n\t * @dev Transaction sender must not necessarily own any tokens to grant the permission\n\t *\n\t * @param _spender an address approved by the caller (token owner)\n\t *      to spend some tokens on its behalf\n\t * @param _value an amount of tokens spender `_spender` is allowed to\n\t *      transfer on behalf of the token owner\n\t * @return success true on success, throws otherwise\n\t */\n\tfunction approve(address _spender, uint256 _value) public override returns (bool success) {\n\t\t// make an internal approve - delegate to `__approve`\n\t\t__approve(msg.sender, _spender, _value);\n\n\t\t// operation successful, return true\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Powers the meta transaction for `approve` - EIP-2612 `permit`\n\t *\n\t * @dev Approves address called `_spender` to transfer some amount\n\t *      of tokens on behalf of the `_owner`\n\t *\n\t * @dev `_owner` must not necessarily own any tokens to grant the permission\n\t * @dev Throws if `_spender` is a zero address\n\t *\n\t * @param _owner owner of the tokens to set approval on behalf of\n\t * @param _spender an address approved by the token owner\n\t *      to spend some tokens on its behalf\n\t * @param _value an amount of tokens spender `_spender` is allowed to\n\t *      transfer on behalf of the token owner\n\t */\n\tfunction __approve(address _owner, address _spender, uint256 _value) private {\n\t\t// non-zero spender address check - Zeppelin\n\t\t// obviously, zero spender address is a client mistake\n\t\t// it's not part of ERC20 standard but it's reasonable to fail fast\n\t\trequire(_spender != address(0), \"approve to the zero address\");\n\n\t\t// read old approval value to emmit an improved event (arXiv:1907.00903)\n\t\tuint256 _oldValue = transferAllowances[_owner][_spender];\n\n\t\t// perform an operation: write value requested into the storage\n\t\ttransferAllowances[_owner][_spender] = _value;\n\n\t\t// emit an improved atomic approve event (arXiv:1907.00903)\n\t\temit Approval(_owner, _spender, _oldValue, _value);\n\n\t\t// emit an ERC20 approval event\n\t\temit Approval(_owner, _spender, _value);\n\t}\n\n\t/**\n\t * @notice Returns the amount which _spender is still allowed to withdraw from _owner.\n\t *\n\t * @inheritdoc ERC20\n\t *\n\t * @dev A function to check an amount of tokens owner approved\n\t *      to transfer on its behalf by some other address called \"spender\"\n\t *\n\t * @param _owner an address which approves transferring some tokens on its behalf\n\t * @param _spender an address approved to transfer some tokens on behalf\n\t * @return remaining an amount of tokens approved address `_spender` can transfer on behalf\n\t *      of token owner `_owner`\n\t */\n\tfunction allowance(address _owner, address _spender) public view override returns (uint256 remaining) {\n\t\t// read the value from storage and return\n\t\treturn transferAllowances[_owner][_spender];\n\t}\n\n\t// ===== End: ERC20 functions =====\n\n\t// ===== Start: Resolution for the Multiple Withdrawal Attack on ERC20 Tokens (arXiv:1907.00903) =====\n\n\t/**\n\t * @notice Increases the allowance granted to `spender` by the transaction sender\n\t *\n\t * @dev Resolution for the Multiple Withdrawal Attack on ERC20 Tokens (arXiv:1907.00903)\n\t *\n\t * @dev Throws if value to increase by is zero or too big and causes arithmetic overflow\n\t *\n\t * @param _spender an address approved by the caller (token owner)\n\t *      to spend some tokens on its behalf\n\t * @param _value an amount of tokens to increase by\n\t * @return success true on success, throws otherwise\n\t */\n\tfunction increaseAllowance(address _spender, uint256 _value) public returns (bool) {\n\t\t// read current allowance value\n\t\tuint256 currentVal = transferAllowances[msg.sender][_spender];\n\n\t\t// non-zero _value and arithmetic overflow check on the allowance\n\t\tunchecked {\n\t\t\t// put operation into unchecked block to display user-friendly overflow error message for Solidity 0.8+\n\t\t\trequire(currentVal + _value > currentVal, \"zero value approval increase or arithmetic overflow\");\n\t\t}\n\n\t\t// delegate call to `approve` with the new value\n\t\treturn approve(_spender, currentVal + _value);\n\t}\n\n\t/**\n\t * @notice Decreases the allowance granted to `spender` by the caller.\n\t *\n\t * @dev Resolution for the Multiple Withdrawal Attack on ERC20 Tokens (arXiv:1907.00903)\n\t *\n\t * @dev Throws if value to decrease by is zero or is greater than currently allowed value\n\t *\n\t * @param _spender an address approved by the caller (token owner)\n\t *      to spend some tokens on its behalf\n\t * @param _value an amount of tokens to decrease by\n\t * @return success true on success, throws otherwise\n\t */\n\tfunction decreaseAllowance(address _spender, uint256 _value) public returns (bool) {\n\t\t// read current allowance value\n\t\tuint256 currentVal = transferAllowances[msg.sender][_spender];\n\n\t\t// non-zero _value check on the allowance\n\t\trequire(_value > 0, \"zero value approval decrease\");\n\n\t\t// verify allowance decrease doesn't underflow\n\t\trequire(currentVal >= _value, \"ERC20: decreased allowance below zero\");\n\n\t\t// delegate call to `approve` with the new value\n\t\treturn approve(_spender, currentVal - _value);\n\t}\n\n\t// ===== End: Resolution for the Multiple Withdrawal Attack on ERC20 Tokens (arXiv:1907.00903) =====\n\n\t// ===== Start: Minting/burning extension =====\n\n\t/**\n\t * @dev Mints (creates) some tokens to address specified\n\t * @dev The value specified is treated as is without taking\n\t *      into account what `decimals` value is\n\t *\n\t * @dev Requires executor to have `ROLE_TOKEN_CREATOR` permission\n\t *\n\t * @dev Throws on overflow, if totalSupply + _value doesn't fit into uint256\n\t *\n\t * @param _to an address to mint tokens to\n\t * @param _value an amount of tokens to mint (create)\n\t * @return true function always returns true as it's prerequisite of multichain-bridge.\n\t */\n\tfunction mint(address _to, uint256 _value) public returns(bool) {\n\t\t// check if caller has sufficient permissions to mint tokens\n\t\trequire(isSenderInRole(ROLE_TOKEN_CREATOR), \"access denied\");\n\n\t\t// non-zero recipient address check\n\t\trequire(_to != address(0), \"zero address\");\n\n\t\t// non-zero _value and arithmetic overflow check on the total supply\n\t\t// this check automatically secures arithmetic overflow on the individual balance\n\t\tunchecked {\n\t\t\t// put operation into unchecked block to display user-friendly overflow error message for Solidity 0.8+\n\t\t\trequire(totalSupply + _value > totalSupply, \"zero value or arithmetic overflow\");\n\t\t}\n\n\t\t// uint192 overflow check (required by voting delegation)\n\t\trequire(totalSupply + _value <= type(uint192).max, \"total supply overflow (uint192)\");\n\n\t\t// perform mint:\n\t\t// increase total amount of tokens value\n\t\ttotalSupply += _value;\n\n\t\t// increase `_to` address balance\n\t\ttokenBalances[_to] += _value;\n\n\t\t// update total token supply history\n\t\t__updateHistory(totalSupplyHistory, add, _value);\n\n\t\t// create voting power associated with the tokens minted\n\t\t__moveVotingPower(msg.sender, address(0), votingDelegates[_to], _value);\n\n\t\t// fire a minted event\n\t\temit Minted(msg.sender, _to, _value);\n\n\t\t// emit an improved transfer event (arXiv:1907.00903)\n\t\temit Transfer(msg.sender, address(0), _to, _value);\n\n\t\t// fire ERC20 compliant transfer event\n\t\temit Transfer(address(0), _to, _value);\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Burns (destroys) some tokens from the address specified\n\t *\n\t * @dev The value specified is treated as is without taking\n\t *      into account what `decimals` value is\n\t *\n\t * @dev Requires executor to have `ROLE_TOKEN_DESTROYER` permission\n\t *      or FEATURE_OWN_BURNS/FEATURE_BURNS_ON_BEHALF features to be enabled\n\t *\n\t * @dev Can be disabled by the contract creator forever by disabling\n\t *      FEATURE_OWN_BURNS/FEATURE_BURNS_ON_BEHALF features and then revoking\n\t *      its own roles to burn tokens and to enable burning features\n\t *\n\t * @param _from an address to burn some tokens from\n\t * @param _value an amount of tokens to burn (destroy)\n\t * @return true function always returns true as it's prerequisite of multichain-bridge.\n\t */\n\tfunction burn(address _from, uint256 _value) public returns(bool) {\n\t\t// check if caller has sufficient permissions to burn tokens\n\t\t// and if not - check for possibility to burn own tokens or to burn on behalf\n\t\tif(!isSenderInRole(ROLE_TOKEN_DESTROYER)) {\n\t\t\t// if `_from` is equal to sender, require own burns feature to be enabled\n\t\t\t// otherwise require burns on behalf feature to be enabled\n\t\t\trequire(_from == msg.sender && isFeatureEnabled(FEATURE_OWN_BURNS)\n\t\t\t     || _from != msg.sender && isFeatureEnabled(FEATURE_BURNS_ON_BEHALF),\n\t\t\t        _from == msg.sender? \"burns are disabled\": \"burns on behalf are disabled\");\n\n\t\t\t// in case of burn on behalf\n\t\t\tif(_from != msg.sender) {\n\t\t\t\t// read allowance value - the amount of tokens allowed to be burnt - into the stack\n\t\t\t\tuint256 _allowance = transferAllowances[_from][msg.sender];\n\n\t\t\t\t// verify sender has an allowance to burn amount of tokens requested\n\t\t\t\trequire(_allowance >= _value, \"burn amount exceeds allowance\");\n\n\t\t\t\t// we treat max uint256 allowance value as an \"unlimited\" and\n\t\t\t\t// do not decrease allowance when it is set to \"unlimited\" value\n\t\t\t\tif(_allowance < type(uint256).max) {\n\t\t\t\t\t// update allowance value on the stack\n\t\t\t\t\t_allowance -= _value;\n\n\t\t\t\t\t// update the allowance value in storage\n\t\t\t\t\ttransferAllowances[_from][msg.sender] = _allowance;\n\n\t\t\t\t\t// emit an improved atomic approve event (arXiv:1907.00903)\n\t\t\t\t\temit Approval(msg.sender, _from, _allowance + _value, _allowance);\n\n\t\t\t\t\t// emit an ERC20 approval event to reflect the decrease\n\t\t\t\t\temit Approval(_from, msg.sender, _allowance);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// at this point we know that either sender is ROLE_TOKEN_DESTROYER or\n\t\t// we burn own tokens or on behalf (in latest case we already checked and updated allowances)\n\t\t// we have left to execute balance checks and burning logic itself\n\n\t\t// non-zero burn value check\n\t\trequire(_value != 0, \"zero value burn\");\n\n\t\t// non-zero source address check - Zeppelin\n\t\trequire(_from != address(0), \"burn from the zero address\");\n\n\t\t// verify `_from` address has enough tokens to destroy\n\t\t// (basically this is a arithmetic overflow check)\n\t\trequire(tokenBalances[_from] >= _value, \"burn amount exceeds balance\");\n\n\t\t// perform burn:\n\t\t// decrease `_from` address balance\n\t\ttokenBalances[_from] -= _value;\n\n\t\t// decrease total amount of tokens value\n\t\ttotalSupply -= _value;\n\n\t\t// update total token supply history\n\t\t__updateHistory(totalSupplyHistory, sub, _value);\n\n\t\t// destroy voting power associated with the tokens burnt\n\t\t__moveVotingPower(msg.sender, votingDelegates[_from], address(0), _value);\n\n\t\t// fire a burnt event\n\t\temit Burnt(msg.sender, _from, _value);\n\n\t\t// emit an improved transfer event (arXiv:1907.00903)\n\t\temit Transfer(msg.sender, _from, address(0), _value);\n\n\t\t// fire ERC20 compliant transfer event\n\t\temit Transfer(_from, address(0), _value);\n\n\t\treturn true;\n\t}\n\n\t// ===== End: Minting/burning extension =====\n\n\t// ===== Start: EIP-2612 functions =====\n\n\t/**\n\t * @inheritdoc EIP2612\n\t *\n\t * @dev Executes approve(_spender, _value) on behalf of the owner who EIP-712\n\t *      signed the transaction, i.e. as if transaction sender is the EIP712 signer\n\t *\n\t * @dev Sets the `_value` as the allowance of `_spender` over `_owner` tokens,\n\t *      given `_owner` EIP-712 signed approval\n\t *\n\t * @dev Inherits the Multiple Withdrawal Attack on ERC20 Tokens (arXiv:1907.00903)\n\t *      vulnerability in the same way as ERC20 `approve`, use standard ERC20 workaround\n\t *      if this might become an issue:\n\t *      https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit\n\t *\n\t * @dev Emits `Approval` event(s) in the same way as `approve` does\n\t *\n\t * @dev Requires:\n\t *     - `_spender` to be non-zero address\n\t *     - `_exp` to be a timestamp in the future\n\t *     - `v`, `r` and `s` to be a valid `secp256k1` signature from `_owner`\n\t *        over the EIP712-formatted function arguments.\n\t *     - the signature to use `_owner` current nonce (see `nonces`).\n\t *\n\t * @dev For more information on the signature format, see the\n\t *      https://eips.ethereum.org/EIPS/eip-2612#specification\n\t *\n\t * @param _owner owner of the tokens to set approval on behalf of,\n\t *      an address which signed the EIP-712 message\n\t * @param _spender an address approved by the token owner\n\t *      to spend some tokens on its behalf\n\t * @param _value an amount of tokens spender `_spender` is allowed to\n\t *      transfer on behalf of the token owner\n\t * @param _exp signature expiration time (unix timestamp)\n\t * @param v the recovery byte of the signature\n\t * @param r half of the ECDSA signature pair\n\t * @param s half of the ECDSA signature pair\n\t */\n\tfunction permit(address _owner, address _spender, uint256 _value, uint256 _exp, uint8 v, bytes32 r, bytes32 s) public override {\n\t\t// verify permits are enabled\n\t\trequire(isFeatureEnabled(FEATURE_EIP2612_PERMITS), \"EIP2612 permits are disabled\");\n\n\t\t// derive signer of the EIP712 Permit message, and\n\t\t// update the nonce for that particular signer to avoid replay attack!!! --------->>> ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓\n\t\taddress signer = __deriveSigner(abi.encode(PERMIT_TYPEHASH, _owner, _spender, _value, nonces[_owner]++, _exp), v, r, s);\n\n\t\t// perform message integrity and security validations\n\t\trequire(signer == _owner, \"invalid signature\");\n\t\trequire(block.timestamp < _exp, \"signature expired\");\n\n\t\t// delegate call to `__approve` - execute the logic required\n\t\t__approve(_owner, _spender, _value);\n\t}\n\n\t// ===== End: EIP-2612 functions =====\n\n\t// ===== Start: EIP-3009 functions =====\n\n\t/**\n\t * @inheritdoc EIP3009\n\t *\n\t * @notice Checks if specified nonce was already used\n\t *\n\t * @dev Nonces are expected to be client-side randomly generated 32-byte values\n\t *      unique to the authorizer's address\n\t *\n\t * @dev Alias for usedNonces(authorizer, nonce)\n\t *\n\t * @param _authorizer an address to check nonce for\n\t * @param _nonce a nonce to check\n\t * @return true if the nonce was used, false otherwise\n\t */\n\tfunction authorizationState(address _authorizer, bytes32 _nonce) public override view returns (bool) {\n\t\t// simply return the value from the mapping\n\t\treturn usedNonces[_authorizer][_nonce];\n\t}\n\n\t/**\n\t * @inheritdoc EIP3009\n\t *\n\t * @notice Execute a transfer with a signed authorization\n\t *\n\t * @param _from token sender and transaction authorizer\n\t * @param _to token receiver\n\t * @param _value amount to be transferred\n\t * @param _validAfter signature valid after time (unix timestamp)\n\t * @param _validBefore signature valid before time (unix timestamp)\n\t * @param _nonce unique random nonce\n\t * @param v the recovery byte of the signature\n\t * @param r half of the ECDSA signature pair\n\t * @param s half of the ECDSA signature pair\n\t */\n\tfunction transferWithAuthorization(\n\t\taddress _from,\n\t\taddress _to,\n\t\tuint256 _value,\n\t\tuint256 _validAfter,\n\t\tuint256 _validBefore,\n\t\tbytes32 _nonce,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) public override {\n\t\t// ensure EIP-3009 transfers are enabled\n\t\trequire(isFeatureEnabled(FEATURE_EIP3009_TRANSFERS), \"EIP3009 transfers are disabled\");\n\n\t\t// derive signer of the EIP712 TransferWithAuthorization message\n\t\taddress signer = __deriveSigner(abi.encode(TRANSFER_WITH_AUTHORIZATION_TYPEHASH, _from, _to, _value, _validAfter, _validBefore, _nonce), v, r, s);\n\n\t\t// perform message integrity and security validations\n\t\trequire(signer == _from, \"invalid signature\");\n\t\trequire(block.timestamp > _validAfter, \"signature not yet valid\");\n\t\trequire(block.timestamp < _validBefore, \"signature expired\");\n\n\t\t// use the nonce supplied (verify, mark as used, emit event)\n\t\t__useNonce(_from, _nonce, false);\n\n\t\t// delegate call to `__transferFrom` - execute the logic required\n\t\t__transferFrom(signer, _from, _to, _value);\n\t}\n\n\t/**\n\t * @inheritdoc EIP3009\n\t *\n\t * @notice Receive a transfer with a signed authorization from the payer\n\t *\n\t * @dev This has an additional check to ensure that the payee's address\n\t *      matches the caller of this function to prevent front-running attacks.\n\t *\n\t * @param _from token sender and transaction authorizer\n\t * @param _to token receiver\n\t * @param _value amount to be transferred\n\t * @param _validAfter signature valid after time (unix timestamp)\n\t * @param _validBefore signature valid before time (unix timestamp)\n\t * @param _nonce unique random nonce\n\t * @param v the recovery byte of the signature\n\t * @param r half of the ECDSA signature pair\n\t * @param s half of the ECDSA signature pair\n\t */\n\tfunction receiveWithAuthorization(\n\t\taddress _from,\n\t\taddress _to,\n\t\tuint256 _value,\n\t\tuint256 _validAfter,\n\t\tuint256 _validBefore,\n\t\tbytes32 _nonce,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) public override {\n\t\t// verify EIP3009 receptions are enabled\n\t\trequire(isFeatureEnabled(FEATURE_EIP3009_RECEPTIONS), \"EIP3009 receptions are disabled\");\n\n\t\t// derive signer of the EIP712 ReceiveWithAuthorization message\n\t\taddress signer = __deriveSigner(abi.encode(RECEIVE_WITH_AUTHORIZATION_TYPEHASH, _from, _to, _value, _validAfter, _validBefore, _nonce), v, r, s);\n\n\t\t// perform message integrity and security validations\n\t\trequire(signer == _from, \"invalid signature\");\n\t\trequire(block.timestamp > _validAfter, \"signature not yet valid\");\n\t\trequire(block.timestamp < _validBefore, \"signature expired\");\n\t\trequire(_to == msg.sender, \"access denied\");\n\n\t\t// use the nonce supplied (verify, mark as used, emit event)\n\t\t__useNonce(_from, _nonce, false);\n\n\t\t// delegate call to `__transferFrom` - execute the logic required\n\t\t__transferFrom(signer, _from, _to, _value);\n\t}\n\n\t/**\n\t * @inheritdoc EIP3009\n\t *\n\t * @notice Attempt to cancel an authorization\n\t *\n\t * @param _authorizer transaction authorizer\n\t * @param _nonce unique random nonce to cancel (mark as used)\n\t * @param v the recovery byte of the signature\n\t * @param r half of the ECDSA signature pair\n\t * @param s half of the ECDSA signature pair\n\t */\n\tfunction cancelAuthorization(\n\t\taddress _authorizer,\n\t\tbytes32 _nonce,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) public override {\n\t\t// derive signer of the EIP712 ReceiveWithAuthorization message\n\t\taddress signer = __deriveSigner(abi.encode(CANCEL_AUTHORIZATION_TYPEHASH, _authorizer, _nonce), v, r, s);\n\n\t\t// perform message integrity and security validations\n\t\trequire(signer == _authorizer, \"invalid signature\");\n\n\t\t// cancel the nonce supplied (verify, mark as used, emit event)\n\t\t__useNonce(_authorizer, _nonce, true);\n\t}\n\n\t/**\n\t * @dev Auxiliary function to verify structured EIP712 message signature and derive its signer\n\t *\n\t * @param abiEncodedTypehash abi.encode of the message typehash together with all its parameters\n\t * @param v the recovery byte of the signature\n\t * @param r half of the ECDSA signature pair\n\t * @param s half of the ECDSA signature pair\n\t */\n\tfunction __deriveSigner(bytes memory abiEncodedTypehash, uint8 v, bytes32 r, bytes32 s) private view returns(address) {\n\t\t// build the EIP-712 hashStruct of the message\n\t\tbytes32 hashStruct = keccak256(abiEncodedTypehash);\n\n\t\t// calculate the EIP-712 digest \"\\x19\\x01\" ‖ domainSeparator ‖ hashStruct(message)\n\t\tbytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR, hashStruct));\n\n\t\t// recover the address which signed the message with v, r, s\n\t\taddress signer = ECDSA.recover(digest, v, r, s);\n\n\t\t// return the signer address derived from the signature\n\t\treturn signer;\n\t}\n\n\t/**\n\t * @dev Auxiliary function to use/cancel the nonce supplied for a given authorizer:\n\t *      1. Verifies the nonce was not used before\n\t *      2. Marks the nonce as used\n\t *      3. Emits an event that the nonce was used/cancelled\n\t *\n\t * @dev Set `_cancellation` to false (default) to use nonce,\n\t *      set `_cancellation` to true to cancel nonce\n\t *\n\t * @dev It is expected that the nonce supplied is a randomly\n\t *      generated uint256 generated by the client\n\t *\n\t * @param _authorizer an address to use/cancel nonce for\n\t * @param _nonce random nonce to use\n\t * @param _cancellation true to emit `AuthorizationCancelled`, false to emit `AuthorizationUsed` event\n\t */\n\tfunction __useNonce(address _authorizer, bytes32 _nonce, bool _cancellation) private {\n\t\t// verify nonce was not used before\n\t\trequire(!usedNonces[_authorizer][_nonce], \"invalid nonce\");\n\n\t\t// update the nonce state to \"used\" for that particular signer to avoid replay attack\n\t\tusedNonces[_authorizer][_nonce] = true;\n\n\t\t// depending on the usage type (use/cancel)\n\t\tif(_cancellation) {\n\t\t\t// emit an event regarding the nonce cancelled\n\t\t\temit AuthorizationCanceled(_authorizer, _nonce);\n\t\t}\n\t\telse {\n\t\t\t// emit an event regarding the nonce used\n\t\t\temit AuthorizationUsed(_authorizer, _nonce);\n\t\t}\n\t}\n\n\t// ===== End: EIP-3009 functions =====\n\n\t// ===== Start: DAO Support (Compound-like voting delegation) =====\n\n\t/**\n\t * @notice Gets current voting power of the account `_of`\n\t *\n\t * @param _of the address of account to get voting power of\n\t * @return current cumulative voting power of the account,\n\t *      sum of token balances of all its voting delegators\n\t */\n\tfunction votingPowerOf(address _of) public view returns (uint256) {\n\t\t// get a link to an array of voting power history records for an address specified\n\t\tKV[] storage history = votingPowerHistory[_of];\n\n\t\t// lookup the history and return latest element\n\t\treturn history.length == 0? 0: history[history.length - 1].v;\n\t}\n\n\t/**\n\t * @notice Gets past voting power of the account `_of` at some block `_blockNum`\n\t *\n\t * @dev Throws if `_blockNum` is not in the past (not the finalized block)\n\t *\n\t * @param _of the address of account to get voting power of\n\t * @param _blockNum block number to get the voting power at\n\t * @return past cumulative voting power of the account,\n\t *      sum of token balances of all its voting delegators at block number `_blockNum`\n\t */\n\tfunction votingPowerAt(address _of, uint256 _blockNum) public view returns (uint256) {\n\t\t// make sure block number is not in the past (not the finalized block)\n\t\trequire(_blockNum < block.number, \"block not yet mined\"); // Compound msg not yet determined\n\n\t\t// `votingPowerHistory[_of]` is an array ordered by `blockNumber`, ascending;\n\t\t// apply binary search on `votingPowerHistory[_of]` to find such an entry number `i`, that\n\t\t// `votingPowerHistory[_of][i].k <= _blockNum`, but in the same time\n\t\t// `votingPowerHistory[_of][i + 1].k > _blockNum`\n\t\t// return the result - voting power found at index `i`\n\t\treturn __binaryLookup(votingPowerHistory[_of], _blockNum);\n\t}\n\n\t/**\n\t * @dev Reads an entire voting power history array for the delegate specified\n\t *\n\t * @param _of delegate to query voting power history for\n\t * @return voting power history array for the delegate of interest\n\t */\n\tfunction votingPowerHistoryOf(address _of) public view returns(KV[] memory) {\n\t\t// return an entire array as memory\n\t\treturn votingPowerHistory[_of];\n\t}\n\n\t/**\n\t * @dev Returns length of the voting power history array for the delegate specified;\n\t *      useful since reading an entire array just to get its length is expensive (gas cost)\n\t *\n\t * @param _of delegate to query voting power history length for\n\t * @return voting power history array length for the delegate of interest\n\t */\n\tfunction votingPowerHistoryLength(address _of) public view returns(uint256) {\n\t\t// read array length and return\n\t\treturn votingPowerHistory[_of].length;\n\t}\n\n\t/**\n\t * @notice Gets past total token supply value at some block `_blockNum`\n\t *\n\t * @dev Throws if `_blockNum` is not in the past (not the finalized block)\n\t *\n\t * @param _blockNum block number to get the total token supply at\n\t * @return past total token supply at block number `_blockNum`\n\t */\n\tfunction totalSupplyAt(uint256 _blockNum) public view returns(uint256) {\n\t\t// make sure block number is not in the past (not the finalized block)\n\t\trequire(_blockNum < block.number, \"block not yet mined\");\n\n\t\t// `totalSupplyHistory` is an array ordered by `k`, ascending;\n\t\t// apply binary search on `totalSupplyHistory` to find such an entry number `i`, that\n\t\t// `totalSupplyHistory[i].k <= _blockNum`, but in the same time\n\t\t// `totalSupplyHistory[i + 1].k > _blockNum`\n\t\t// return the result - value `totalSupplyHistory[i].v` found at index `i`\n\t\treturn __binaryLookup(totalSupplyHistory, _blockNum);\n\t}\n\n\t/**\n\t * @dev Reads an entire total token supply history array\n\t *\n\t * @return total token supply history array, a key-value pair array,\n\t *      where key is a block number and value is total token supply at that block\n\t */\n\tfunction entireSupplyHistory() public view returns(KV[] memory) {\n\t\t// return an entire array as memory\n\t\treturn totalSupplyHistory;\n\t}\n\n\t/**\n\t * @dev Returns length of the total token supply history array;\n\t *      useful since reading an entire array just to get its length is expensive (gas cost)\n\t *\n\t * @return total token supply history array\n\t */\n\tfunction totalSupplyHistoryLength() public view returns(uint256) {\n\t\t// read array length and return\n\t\treturn totalSupplyHistory.length;\n\t}\n\n\t/**\n\t * @notice Delegates voting power of the delegator `msg.sender` to the delegate `_to`\n\t *\n\t * @dev Accepts zero value address to delegate voting power to, effectively\n\t *      removing the delegate in that case\n\t *\n\t * @param _to address to delegate voting power to\n\t */\n\tfunction delegate(address _to) public {\n\t\t// verify delegations are enabled\n\t\trequire(isFeatureEnabled(FEATURE_DELEGATIONS), \"delegations are disabled\");\n\t\t// delegate call to `__delegate`\n\t\t__delegate(msg.sender, _to);\n\t}\n\n\t/**\n\t * @dev Powers the meta transaction for `delegate` - `delegateWithAuthorization`\n\t *\n\t * @dev Auxiliary function to delegate delegator's `_from` voting power to the delegate `_to`\n\t * @dev Writes to `votingDelegates` and `votingPowerHistory` mappings\n\t *\n\t * @param _from delegator who delegates his voting power\n\t * @param _to delegate who receives the voting power\n\t */\n\tfunction __delegate(address _from, address _to) private {\n\t\t// read current delegate to be replaced by a new one\n\t\taddress _fromDelegate = votingDelegates[_from];\n\n\t\t// read current voting power (it is equal to token balance)\n\t\tuint256 _value = tokenBalances[_from];\n\n\t\t// reassign voting delegate to `_to`\n\t\tvotingDelegates[_from] = _to;\n\n\t\t// update voting power for `_fromDelegate` and `_to`\n\t\t__moveVotingPower(_from, _fromDelegate, _to, _value);\n\n\t\t// emit an event\n\t\temit DelegateChanged(_from, _fromDelegate, _to);\n\t}\n\n\t/**\n\t * @notice Delegates voting power of the delegator (represented by its signature) to the delegate `_to`\n\t *\n\t * @dev Accepts zero value address to delegate voting power to, effectively\n\t *      removing the delegate in that case\n\t *\n\t * @dev Compliant with EIP-712: Ethereum typed structured data hashing and signing,\n\t *      see https://eips.ethereum.org/EIPS/eip-712\n\t *\n\t * @param _to address to delegate voting power to\n\t * @param _nonce nonce used to construct the signature, and used to validate it;\n\t *      nonce is increased by one after successful signature validation and vote delegation\n\t * @param _exp signature expiration time\n\t * @param v the recovery byte of the signature\n\t * @param r half of the ECDSA signature pair\n\t * @param s half of the ECDSA signature pair\n\t */\n\tfunction delegateWithAuthorization(address _to, bytes32 _nonce, uint256 _exp, uint8 v, bytes32 r, bytes32 s) public {\n\t\t// verify delegations on behalf are enabled\n\t\trequire(isFeatureEnabled(FEATURE_DELEGATIONS_ON_BEHALF), \"delegations on behalf are disabled\");\n\n\t\t// derive signer of the EIP712 Delegation message\n\t\taddress signer = __deriveSigner(abi.encode(DELEGATION_TYPEHASH, _to, _nonce, _exp), v, r, s);\n\n\t\t// perform message integrity and security validations\n\t\trequire(block.timestamp < _exp, \"signature expired\"); // Compound msg\n\n\t\t// use the nonce supplied (verify, mark as used, emit event)\n\t\t__useNonce(signer, _nonce, false);\n\n\t\t// delegate call to `__delegate` - execute the logic required\n\t\t__delegate(signer, _to);\n\t}\n\n\t/**\n\t * @dev Auxiliary function to move voting power `_value`\n\t *      from delegate `_from` to the delegate `_to`\n\t *\n\t * @dev Doesn't have any effect if `_from == _to`, or if `_value == 0`\n\t *\n\t * @param _by an address which executed delegate, mint, burn, or transfer operation\n\t *      which had led to delegate voting power change\n\t * @param _from delegate to move voting power from\n\t * @param _to delegate to move voting power to\n\t * @param _value voting power to move from `_from` to `_to`\n\t */\n\tfunction __moveVotingPower(address _by, address _from, address _to, uint256 _value) private {\n\t\t// if there is no move (`_from == _to`) or there is nothing to move (`_value == 0`)\n\t\tif(_from == _to || _value == 0) {\n\t\t\t// return silently with no action\n\t\t\treturn;\n\t\t}\n\n\t\t// if source address is not zero - decrease its voting power\n\t\tif(_from != address(0)) {\n\t\t\t// get a link to an array of voting power history records for an address specified\n\t\t\tKV[] storage _h = votingPowerHistory[_from];\n\n\t\t\t// update source voting power: decrease by `_value`\n\t\t\t(uint256 _fromVal, uint256 _toVal) = __updateHistory(_h, sub, _value);\n\n\t\t\t// emit an event\n\t\t\temit VotingPowerChanged(_by, _from, _fromVal, _toVal);\n\t\t}\n\n\t\t// if destination address is not zero - increase its voting power\n\t\tif(_to != address(0)) {\n\t\t\t// get a link to an array of voting power history records for an address specified\n\t\t\tKV[] storage _h = votingPowerHistory[_to];\n\n\t\t\t// update destination voting power: increase by `_value`\n\t\t\t(uint256 _fromVal, uint256 _toVal) = __updateHistory(_h, add, _value);\n\n\t\t\t// emit an event\n\t\t\temit VotingPowerChanged(_by, _to, _fromVal, _toVal);\n\t\t}\n\t}\n\n\t/**\n\t * @dev Auxiliary function to append key-value pair to an array,\n\t *      sets the key to the current block number and\n\t *      value as derived\n\t *\n\t * @param _h array of key-value pairs to append to\n\t * @param op a function (add/subtract) to apply\n\t * @param _delta the value for a key-value pair to add/subtract\n\t */\n\tfunction __updateHistory(\n\t\tKV[] storage _h,\n\t\tfunction(uint256,uint256) pure returns(uint256) op,\n\t\tuint256 _delta\n\t) private returns(uint256 _fromVal, uint256 _toVal) {\n\t\t// init the old value - value of the last pair of the array\n\t\t_fromVal = _h.length == 0? 0: _h[_h.length - 1].v;\n\t\t// init the new value - result of the operation on the old value\n\t\t_toVal = op(_fromVal, _delta);\n\n\t\t// if there is an existing voting power value stored for current block\n\t\tif(_h.length != 0 && _h[_h.length - 1].k == block.number) {\n\t\t\t// update voting power which is already stored in the current block\n\t\t\t_h[_h.length - 1].v = uint192(_toVal);\n\t\t}\n\t\t// otherwise - if there is no value stored for current block\n\t\telse {\n\t\t\t// add new element into array representing the value for current block\n\t\t\t_h.push(KV(uint64(block.number), uint192(_toVal)));\n\t\t}\n\t}\n\n\t/**\n\t * @dev Auxiliary function to lookup for a value in a sorted by key (ascending)\n\t *      array of key-value pairs\n\t *\n\t * @dev This function finds a key-value pair element in an array with the closest key\n\t *      to the key of interest (not exceeding that key) and returns the value\n\t *      of the key-value pair element found\n\t *\n\t * @dev An array to search in is a KV[] key-value pair array ordered by key `k`,\n\t *      it is sorted in ascending order (`k` increases as array index increases)\n\t *\n\t * @dev Returns zero for an empty array input regardless of the key input\n\t *\n\t * @param _h an array of key-value pair elements to search in\n\t * @param _k key of interest to look the value for\n\t * @return the value of the key-value pair of the key-value pair element with the closest\n\t *      key to the key of interest (not exceeding that key)\n\t */\n\tfunction __binaryLookup(KV[] storage _h, uint256 _k) private view returns(uint256) {\n\t\t// if an array is empty, there is nothing to lookup in\n\t\tif(_h.length == 0) {\n\t\t\t// by documented agreement, fall back to a zero result\n\t\t\treturn 0;\n\t\t}\n\n\t\t// check last key-value pair key:\n\t\t// if the key is smaller than the key of interest\n\t\tif(_h[_h.length - 1].k <= _k) {\n\t\t\t// we're done - return the value from the last element\n\t\t\treturn _h[_h.length - 1].v;\n\t\t}\n\n\t\t// check first voting power history record block number:\n\t\t// if history was never updated before the block of interest\n\t\tif(_h[0].k > _k) {\n\t\t\t// we're done - voting power at the block num of interest was zero\n\t\t\treturn 0;\n\t\t}\n\n\t\t// left bound of the search interval, originally start of the array\n\t\tuint256 i = 0;\n\n\t\t// right bound of the search interval, originally end of the array\n\t\tuint256 j = _h.length - 1;\n\n\t\t// the iteration process narrows down the bounds by\n\t\t// splitting the interval in a half oce per each iteration\n\t\twhile(j > i) {\n\t\t\t// get an index in the middle of the interval [i, j]\n\t\t\tuint256 k = j - (j - i) / 2;\n\n\t\t\t// read an element to compare it with the value of interest\n\t\t\tKV memory kv = _h[k];\n\n\t\t\t// if we've got a strict equal - we're lucky and done\n\t\t\tif(kv.k == _k) {\n\t\t\t\t// just return the result - pair value at index `k`\n\t\t\t\treturn kv.v;\n\t\t\t}\n\t\t\t// if the value of interest is larger - move left bound to the middle\n\t\t\telse if (kv.k < _k) {\n\t\t\t\t// move left bound `i` to the middle position `k`\n\t\t\t\ti = k;\n\t\t\t}\n\t\t\t// otherwise, when the value of interest is smaller - move right bound to the middle\n\t\t\telse {\n\t\t\t\t// move right bound `j` to the middle position `k - 1`:\n\t\t\t\t// element at position `k` is greater and cannot be the result\n\t\t\t\tj = k - 1;\n\t\t\t}\n\t\t}\n\n\t\t// reaching that point means no exact match found\n\t\t// since we're interested in the element which is not larger than the\n\t\t// element of interest, we return the lower bound `i`\n\t\treturn _h[i].v;\n\t}\n\n\t/**\n\t * @dev Adds a + b\n\t *      Function is used as a parameter for other functions\n\t *\n\t * @param a addition term 1\n\t * @param b addition term 2\n\t * @return a + b\n\t */\n\tfunction add(uint256 a, uint256 b) private pure returns(uint256) {\n\t\t// add `a` to `b` and return\n\t\treturn a + b;\n\t}\n\n\t/**\n\t * @dev Subtracts a - b\n\t *      Function is used as a parameter for other functions\n\t *\n\t * @dev Requires a ≥ b\n\t *\n\t * @param a subtraction term 1\n\t * @param b subtraction term 2, b ≤ a\n\t * @return a - b\n\t */\n\tfunction sub(uint256 a, uint256 b) private pure returns(uint256) {\n\t\t// subtract `b` from `a` and return\n\t\treturn a - b;\n\t}\n\n\t// ===== End: DAO Support (Compound-like voting delegation) =====\n}\n\n/**\n * @title Artificial Liquid Intelligence ERC20 Token (With BSC Bridging Support)\n *\n * @notice Binance Smart Chain (BSC) extension contract ads the functions required to bridge original\n *      ALI token on Ethereum L1; these are mint and burn functions executed\n *      when the tokens are deposited from from Ethereum L1 into BSC L2 (mint),\n *      and when the tokens are withdrawn back from BSC L2 into Ethereum L1 (burn).\n *\n * @notice Read more:\n *      https://docs.polygon.technology/docs/develop/ethereum-polygon/mintable-assets\n */\ncontract BinanceAliERC20v2 is AliERC20v2Base {\n\n\t/**\n\t * @dev \"underlying\" is a dummy variable. Multichain frontend\n\t *      recognizes our token via \"underlying\"\n\t */\n\taddress public immutable underlying;\n\n\t/**\n\t * @dev Constructs/deploys Polygon ALI instance,\n\t *      assigns initial token supply to the address specified\n\t */\n\tconstructor() AliERC20v2Base(address(0), 0) {\n\t\t// explicitly set \"underlying\" to zero\n\t\tunderlying = address(0);\n\t}\n}\n"
    },
    "contracts/interfaces/ERC1363Spec.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./ERC20Spec.sol\";\nimport \"./ERC165Spec.sol\";\n\n/**\n * @title ERC1363 Interface\n *\n * @dev Interface defining a ERC1363 Payable Token contract.\n *      Implementing contracts MUST implement the ERC1363 interface as well as the ERC20 and ERC165 interfaces.\n */\ninterface ERC1363 is ERC20, ERC165  {\n\t/*\n\t * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n\t * 0xb0202a11 ===\n\t *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n\t *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n\t *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n\t *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n\t *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n\t *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n\t */\n\n\t/**\n\t * @notice Transfer tokens from `msg.sender` to another address and then call `onTransferReceived` on receiver\n\t * @param to address The address which you want to transfer to\n\t * @param value uint256 The amount of tokens to be transferred\n\t * @return true unless throwing\n\t */\n\tfunction transferAndCall(address to, uint256 value) external returns (bool);\n\n\t/**\n\t * @notice Transfer tokens from `msg.sender` to another address and then call `onTransferReceived` on receiver\n\t * @param to address The address which you want to transfer to\n\t * @param value uint256 The amount of tokens to be transferred\n\t * @param data bytes Additional data with no specified format, sent in call to `to`\n\t * @return true unless throwing\n\t */\n\tfunction transferAndCall(address to, uint256 value, bytes memory data) external returns (bool);\n\n\t/**\n\t * @notice Transfer tokens from one address to another and then call `onTransferReceived` on receiver\n\t * @param from address The address which you want to send tokens from\n\t * @param to address The address which you want to transfer to\n\t * @param value uint256 The amount of tokens to be transferred\n\t * @return true unless throwing\n\t */\n\tfunction transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n\n\t/**\n\t * @notice Transfer tokens from one address to another and then call `onTransferReceived` on receiver\n\t * @param from address The address which you want to send tokens from\n\t * @param to address The address which you want to transfer to\n\t * @param value uint256 The amount of tokens to be transferred\n\t * @param data bytes Additional data with no specified format, sent in call to `to`\n\t * @return true unless throwing\n\t */\n\tfunction transferFromAndCall(address from, address to, uint256 value, bytes memory data) external returns (bool);\n\n\t/**\n\t * @notice Approve the passed address to spend the specified amount of tokens on behalf of msg.sender\n\t * and then call `onApprovalReceived` on spender.\n\t * @param spender address The address which will spend the funds\n\t * @param value uint256 The amount of tokens to be spent\n\t */\n\tfunction approveAndCall(address spender, uint256 value) external returns (bool);\n\n\t/**\n\t * @notice Approve the passed address to spend the specified amount of tokens on behalf of msg.sender\n\t * and then call `onApprovalReceived` on spender.\n\t * @param spender address The address which will spend the funds\n\t * @param value uint256 The amount of tokens to be spent\n\t * @param data bytes Additional data with no specified format, sent in call to `spender`\n\t */\n\tfunction approveAndCall(address spender, uint256 value, bytes memory data) external returns (bool);\n}\n\n/**\n * @title ERC1363Receiver Interface\n *\n * @dev Interface for any contract that wants to support `transferAndCall` or `transferFromAndCall`\n *      from ERC1363 token contracts.\n */\ninterface ERC1363Receiver {\n\t/*\n\t * Note: the ERC-165 identifier for this interface is 0x88a7ca5c.\n\t * 0x88a7ca5c === bytes4(keccak256(\"onTransferReceived(address,address,uint256,bytes)\"))\n\t */\n\n\t/**\n\t * @notice Handle the receipt of ERC1363 tokens\n\t *\n\t * @dev Any ERC1363 smart contract calls this function on the recipient\n\t *      after a `transfer` or a `transferFrom`. This function MAY throw to revert and reject the\n\t *      transfer. Return of other than the magic value MUST result in the\n\t *      transaction being reverted.\n\t *      Note: the token contract address is always the message sender.\n\t *\n\t * @param operator address The address which called `transferAndCall` or `transferFromAndCall` function\n\t * @param from address The address which are token transferred from\n\t * @param value uint256 The amount of tokens transferred\n\t * @param data bytes Additional data with no specified format\n\t * @return `bytes4(keccak256(\"onTransferReceived(address,address,uint256,bytes)\"))`\n\t *      unless throwing\n\t */\n\tfunction onTransferReceived(address operator, address from, uint256 value, bytes memory data) external returns (bytes4);\n}\n\n/**\n * @title ERC1363Spender Interface\n *\n * @dev Interface for any contract that wants to support `approveAndCall`\n *      from ERC1363 token contracts.\n */\ninterface ERC1363Spender {\n\t/*\n\t * Note: the ERC-165 identifier for this interface is 0x7b04a2d0.\n\t * 0x7b04a2d0 === bytes4(keccak256(\"onApprovalReceived(address,uint256,bytes)\"))\n\t */\n\n\t/**\n\t * @notice Handle the approval of ERC1363 tokens\n\t *\n\t * @dev Any ERC1363 smart contract calls this function on the recipient\n\t *      after an `approve`. This function MAY throw to revert and reject the\n\t *      approval. Return of other than the magic value MUST result in the\n\t *      transaction being reverted.\n\t *      Note: the token contract address is always the message sender.\n\t *\n\t * @param owner address The address which called `approveAndCall` function\n\t * @param value uint256 The amount of tokens to be spent\n\t * @param data bytes Additional data with no specified format\n\t * @return `bytes4(keccak256(\"onApprovalReceived(address,uint256,bytes)\"))`\n\t *      unless throwing\n\t */\n\tfunction onApprovalReceived(address owner, uint256 value, bytes memory data) external returns (bytes4);\n}\n"
    },
    "contracts/interfaces/EIP2612.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title EIP-2612: permit - 712-signed approvals\n *\n * @notice A function permit extending ERC-20 which allows for approvals to be made via secp256k1 signatures.\n *      This kind of “account abstraction for ERC-20” brings about two main benefits:\n *        - transactions involving ERC-20 operations can be paid using the token itself rather than ETH,\n *        - approve and pull operations can happen in a single transaction instead of two consecutive transactions,\n *        - while adding as little as possible over the existing ERC-20 standard.\n *\n * @notice See https://eips.ethereum.org/EIPS/eip-2612#specification\n */\ninterface EIP2612 {\n\t/**\n\t * @notice EIP712 domain separator of the smart contract. It should be unique to the contract\n\t *      and chain to prevent replay attacks from other domains, and satisfy the requirements of EIP-712,\n\t *      but is otherwise unconstrained.\n\t */\n\tfunction DOMAIN_SEPARATOR() external view returns (bytes32);\n\n\t/**\n\t * @notice Counter of the nonces used for the given address; nonce are used sequentially\n\t *\n\t * @dev To prevent from replay attacks nonce is incremented for each address after a successful `permit` execution\n\t *\n\t * @param owner an address to query number of used nonces for\n\t * @return number of used nonce, nonce number to be used next\n\t */\n\tfunction nonces(address owner) external view returns (uint);\n\n\t/**\n\t * @notice For all addresses owner, spender, uint256s value, deadline and nonce, uint8 v, bytes32 r and s,\n\t *      a call to permit(owner, spender, value, deadline, v, r, s) will set approval[owner][spender] to value,\n\t *      increment nonces[owner] by 1, and emit a corresponding Approval event,\n\t *      if and only if the following conditions are met:\n\t *        - The current blocktime is less than or equal to deadline.\n\t *        - owner is not the zero address.\n\t *        - nonces[owner] (before the state update) is equal to nonce.\n\t *        - r, s and v is a valid secp256k1 signature from owner of the message:\n\t *\n\t * @param owner token owner address, granting an approval to spend its tokens\n\t * @param spender an address approved by the owner (token owner)\n\t *      to spend some tokens on its behalf\n\t * @param value an amount of tokens spender `spender` is allowed to\n\t *      transfer on behalf of the token owner\n\t * @param v the recovery byte of the signature\n\t * @param r half of the ECDSA signature pair\n\t * @param s half of the ECDSA signature pair\n\t */\n\tfunction permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n}\n"
    },
    "contracts/interfaces/EIP3009.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title EIP-3009: Transfer With Authorization\n *\n * @notice A contract interface that enables transferring of fungible assets via a signed authorization.\n *      See https://eips.ethereum.org/EIPS/eip-3009\n *      See https://eips.ethereum.org/EIPS/eip-3009#specification\n */\ninterface EIP3009 {\n\t/**\n\t * @dev Fired whenever the nonce gets used (ex.: `transferWithAuthorization`, `receiveWithAuthorization`)\n\t *\n\t * @param authorizer an address which has used the nonce\n\t * @param nonce the nonce used\n\t */\n\tevent AuthorizationUsed(address indexed authorizer, bytes32 indexed nonce);\n\n\t/**\n\t * @dev Fired whenever the nonce gets cancelled (ex.: `cancelAuthorization`)\n\t *\n\t * @dev Both `AuthorizationUsed` and `AuthorizationCanceled` imply the nonce\n\t *      cannot be longer used, the only difference is that `AuthorizationCanceled`\n\t *      implies no smart contract state change made (except the nonce marked as cancelled)\n\t *\n\t * @param authorizer an address which has cancelled the nonce\n\t * @param nonce the nonce cancelled\n\t */\n\tevent AuthorizationCanceled(address indexed authorizer, bytes32 indexed nonce);\n\n\t/**\n\t * @notice Returns the state of an authorization, more specifically\n\t *      if the specified nonce was already used by the address specified\n\t *\n\t * @dev Nonces are expected to be client-side randomly generated 32-byte data\n\t *      unique to the authorizer's address\n\t *\n\t * @param authorizer    Authorizer's address\n\t * @param nonce         Nonce of the authorization\n\t * @return true if the nonce is used\n\t */\n\tfunction authorizationState(\n\t\taddress authorizer,\n\t\tbytes32 nonce\n\t) external view returns (bool);\n\n\t/**\n\t * @notice Execute a transfer with a signed authorization\n\t *\n\t * @param from          Payer's address (Authorizer)\n\t * @param to            Payee's address\n\t * @param value         Amount to be transferred\n\t * @param validAfter    The time after which this is valid (unix time)\n\t * @param validBefore   The time before which this is valid (unix time)\n\t * @param nonce         Unique nonce\n\t * @param v             v of the signature\n\t * @param r             r of the signature\n\t * @param s             s of the signature\n\t */\n\tfunction transferWithAuthorization(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 value,\n\t\tuint256 validAfter,\n\t\tuint256 validBefore,\n\t\tbytes32 nonce,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) external;\n\n\t/**\n\t * @notice Receive a transfer with a signed authorization from the payer\n\t *\n\t * @dev This has an additional check to ensure that the payee's address matches\n\t *      the caller of this function to prevent front-running attacks.\n\t * @dev See https://eips.ethereum.org/EIPS/eip-3009#security-considerations\n\t *\n\t * @param from          Payer's address (Authorizer)\n\t * @param to            Payee's address\n\t * @param value         Amount to be transferred\n\t * @param validAfter    The time after which this is valid (unix time)\n\t * @param validBefore   The time before which this is valid (unix time)\n\t * @param nonce         Unique nonce\n\t * @param v             v of the signature\n\t * @param r             r of the signature\n\t * @param s             s of the signature\n\t */\n\tfunction receiveWithAuthorization(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 value,\n\t\tuint256 validAfter,\n\t\tuint256 validBefore,\n\t\tbytes32 nonce,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) external;\n\n\t/**\n\t * @notice Attempt to cancel an authorization\n\t *\n\t * @param authorizer    Authorizer's address\n\t * @param nonce         Nonce of the authorization\n\t * @param v             v of the signature\n\t * @param r             r of the signature\n\t * @param s             s of the signature\n\t */\n\tfunction cancelAuthorization(\n\t\taddress authorizer,\n\t\tbytes32 nonce,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) external;\n}\n"
    },
    "contracts/interfaces/ERC20Spec.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title EIP-20: ERC-20 Token Standard\n *\n * @notice The ERC-20 (Ethereum Request for Comments 20), proposed by Fabian Vogelsteller in November 2015,\n *      is a Token Standard that implements an API for tokens within Smart Contracts.\n *\n * @notice It provides functionalities like to transfer tokens from one account to another,\n *      to get the current token balance of an account and also the total supply of the token available on the network.\n *      Besides these it also has some other functionalities like to approve that an amount of\n *      token from an account can be spent by a third party account.\n *\n * @notice If a Smart Contract implements the following methods and events it can be called an ERC-20 Token\n *      Contract and, once deployed, it will be responsible to keep track of the created tokens on Ethereum.\n *\n * @notice See https://ethereum.org/en/developers/docs/standards/tokens/erc-20/\n * @notice See https://eips.ethereum.org/EIPS/eip-20\n */\ninterface ERC20 {\n\t/**\n\t * @dev Fired in transfer(), transferFrom() to indicate that token transfer happened\n\t *\n\t * @param from an address tokens were consumed from\n\t * @param to an address tokens were sent to\n\t * @param value number of tokens transferred\n\t */\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n\n\t/**\n\t * @dev Fired in approve() to indicate an approval event happened\n\t *\n\t * @param owner an address which granted a permission to transfer\n\t *      tokens on its behalf\n\t * @param spender an address which received a permission to transfer\n\t *      tokens on behalf of the owner `_owner`\n\t * @param value amount of tokens granted to transfer on behalf\n\t */\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\n\n\t/**\n\t * @return name of the token (ex.: USD Coin)\n\t */\n\t// OPTIONAL - This method can be used to improve usability,\n\t// but interfaces and other contracts MUST NOT expect these values to be present.\n\t// function name() external view returns (string memory);\n\n\t/**\n\t * @return symbol of the token (ex.: USDC)\n\t */\n\t// OPTIONAL - This method can be used to improve usability,\n\t// but interfaces and other contracts MUST NOT expect these values to be present.\n\t// function symbol() external view returns (string memory);\n\n\t/**\n\t * @dev Returns the number of decimals used to get its user representation.\n\t *      For example, if `decimals` equals `2`, a balance of `505` tokens should\n\t *      be displayed to a user as `5,05` (`505 / 10 ** 2`).\n\t *\n\t * @dev Tokens usually opt for a value of 18, imitating the relationship between\n\t *      Ether and Wei. This is the value {ERC20} uses, unless this function is\n\t *      overridden;\n\t *\n\t * @dev NOTE: This information is only used for _display_ purposes: it in\n\t *      no way affects any of the arithmetic of the contract, including\n\t *      {IERC20-balanceOf} and {IERC20-transfer}.\n\t *\n\t * @return token decimals\n\t */\n\t// OPTIONAL - This method can be used to improve usability,\n\t// but interfaces and other contracts MUST NOT expect these values to be present.\n\t// function decimals() external view returns (uint8);\n\n\t/**\n\t * @return the amount of tokens in existence\n\t */\n\tfunction totalSupply() external view returns (uint256);\n\n\t/**\n\t * @notice Gets the balance of a particular address\n\t *\n\t * @param _owner the address to query the the balance for\n\t * @return balance an amount of tokens owned by the address specified\n\t */\n\tfunction balanceOf(address _owner) external view returns (uint256 balance);\n\n\t/**\n\t * @notice Transfers some tokens to an external address or a smart contract\n\t *\n\t * @dev Called by token owner (an address which has a\n\t *      positive token balance tracked by this smart contract)\n\t * @dev Throws on any error like\n\t *      * insufficient token balance or\n\t *      * incorrect `_to` address:\n\t *          * zero address or\n\t *          * self address or\n\t *          * smart contract which doesn't support ERC20\n\t *\n\t * @param _to an address to transfer tokens to,\n\t *      must be either an external address or a smart contract,\n\t *      compliant with the ERC20 standard\n\t * @param _value amount of tokens to be transferred,, zero\n\t *      value is allowed\n\t * @return success true on success, throws otherwise\n\t */\n\tfunction transfer(address _to, uint256 _value) external returns (bool success);\n\n\t/**\n\t * @notice Transfers some tokens on behalf of address `_from' (token owner)\n\t *      to some other address `_to`\n\t *\n\t * @dev Called by token owner on his own or approved address,\n\t *      an address approved earlier by token owner to\n\t *      transfer some amount of tokens on its behalf\n\t * @dev Throws on any error like\n\t *      * insufficient token balance or\n\t *      * incorrect `_to` address:\n\t *          * zero address or\n\t *          * same as `_from` address (self transfer)\n\t *          * smart contract which doesn't support ERC20\n\t *\n\t * @param _from token owner which approved caller (transaction sender)\n\t *      to transfer `_value` of tokens on its behalf\n\t * @param _to an address to transfer tokens to,\n\t *      must be either an external address or a smart contract,\n\t *      compliant with the ERC20 standard\n\t * @param _value amount of tokens to be transferred,, zero\n\t *      value is allowed\n\t * @return success true on success, throws otherwise\n\t */\n\tfunction transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n\n\t/**\n\t * @notice Approves address called `_spender` to transfer some amount\n\t *      of tokens on behalf of the owner (transaction sender)\n\t *\n\t * @dev Transaction sender must not necessarily own any tokens to grant the permission\n\t *\n\t * @param _spender an address approved by the caller (token owner)\n\t *      to spend some tokens on its behalf\n\t * @param _value an amount of tokens spender `_spender` is allowed to\n\t *      transfer on behalf of the token owner\n\t * @return success true on success, throws otherwise\n\t */\n\tfunction approve(address _spender, uint256 _value) external returns (bool success);\n\n\t/**\n\t * @notice Returns the amount which _spender is still allowed to withdraw from _owner.\n\t *\n\t * @dev A function to check an amount of tokens owner approved\n\t *      to transfer on its behalf by some other address called \"spender\"\n\t *\n\t * @param _owner an address which approves transferring some tokens on its behalf\n\t * @param _spender an address approved to transfer some tokens on behalf\n\t * @return remaining an amount of tokens approved address `_spender` can transfer on behalf\n\t *      of token owner `_owner`\n\t */\n\tfunction allowance(address _owner, address _spender) external view returns (uint256 remaining);\n}\n"
    },
    "contracts/token/AliERC20v2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ERC1363Spec.sol\";\nimport \"../interfaces/EIP2612.sol\";\nimport \"../interfaces/EIP3009.sol\";\nimport \"../utils/AccessControl.sol\";\nimport \"../lib/AddressUtils.sol\";\nimport \"../lib/ECDSA.sol\";\n\n/**\n * @title Artificial Liquid Intelligence ERC20 Token (Alethea, ALI)\n *\n * @notice ALI is the native utility token of the Alethea AI Protocol.\n *      It serves as protocol currency, participates in iNFTs lifecycle,\n *      (locked when iNFT is created, released when iNFT is destroyed,\n *      consumed when iNFT is upgraded).\n *      ALI token powers up the governance protocol (Alethea DAO)\n *\n * @notice Token Summary:\n *      - Symbol: ALI\n *      - Name: Artificial Liquid Intelligence Token\n *      - Decimals: 18\n *      - Initial/maximum total supply: 10,000,000,000 ALI\n *      - Initial supply holder (initial holder) address: 0x0738F702D1a7364d356729Cb8845701885C487A1 (configurable)\n *      - Not mintable: new tokens cannot be created\n *      - Burnable: existing tokens may get destroyed, total supply may decrease\n *      - DAO Support: supports voting delegation\n *\n * @notice Features Summary:\n *      - Supports atomic allowance modification, resolves well-known ERC20 issue with approve (arXiv:1907.00903)\n *      - Voting delegation and delegation on behalf via EIP-712 (like in Compound CMP token) - gives ALI token\n *        powerful governance capabilities by allowing holders to form voting groups by electing delegates\n *      - Unlimited approval feature (like in 0x ZRX token) - saves gas for transfers on behalf\n *        by eliminating the need to update “unlimited” allowance value\n *      - ERC-1363 Payable Token - ERC721-like callback execution mechanism for transfers,\n *        transfers on behalf and approvals; allows creation of smart contracts capable of executing callbacks\n *        in response to transfer or approval in a single transaction\n *      - EIP-2612: permit - 712-signed approvals - improves user experience by allowing to use a token\n *        without having an ETH to pay gas fees\n *      - EIP-3009: Transfer With Authorization - improves user experience by allowing to use a token\n *        without having an ETH to pay gas fees\n *\n * @dev Even though smart contract has mint() function which is used to mint initial token supply,\n *      the function is disabled forever after smart contract deployment by revoking `TOKEN_CREATOR`\n *      permission from the deployer account\n *\n * @dev Token balances and total supply are effectively 192 bits long, meaning that maximum\n *      possible total supply smart contract is able to track is 2^192 (close to 10^40 tokens)\n *\n * @dev Smart contract doesn't use safe math. All arithmetic operations are overflow/underflow safe.\n *      Additionally, Solidity 0.8.7 enforces overflow/underflow safety.\n *\n * @dev Multiple Withdrawal Attack on ERC20 Tokens (arXiv:1907.00903) - resolved\n *      Related events and functions are marked with \"arXiv:1907.00903\" tag:\n *        - event Transfer(address indexed _by, address indexed _from, address indexed _to, uint256 _value)\n *        - event Approve(address indexed _owner, address indexed _spender, uint256 _oldValue, uint256 _value)\n *        - function increaseAllowance(address _spender, uint256 _value) public returns (bool)\n *        - function decreaseAllowance(address _spender, uint256 _value) public returns (bool)\n *      See: https://arxiv.org/abs/1907.00903v1\n *           https://ieeexplore.ieee.org/document/8802438\n *      See: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n *\n * @dev Reviewed\n *      ERC-20   - according to https://eips.ethereum.org/EIPS/eip-20\n *      ERC-1363 - according to https://eips.ethereum.org/EIPS/eip-1363\n *      EIP-2612 - according to https://eips.ethereum.org/EIPS/eip-2612\n *      EIP-3009 - according to https://eips.ethereum.org/EIPS/eip-3009\n *\n * @dev ERC20: contract has passed\n *      - OpenZeppelin ERC20 tests\n *        https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/test/token/ERC20/ERC20.behavior.js\n *        https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/test/token/ERC20/ERC20.test.js\n *      - Ref ERC1363 tests\n *        https://github.com/vittominacori/erc1363-payable-token/blob/master/test/token/ERC1363/ERC1363.behaviour.js\n *      - OpenZeppelin EIP2612 tests\n *        https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/test/token/ERC20/extensions/draft-ERC20Permit.test.js\n *      - Coinbase EIP3009 tests\n *        https://github.com/CoinbaseStablecoin/eip-3009/blob/master/test/EIP3009.test.ts\n *      - Compound voting delegation tests\n *        https://github.com/compound-finance/compound-protocol/blob/master/tests/Governance/CompTest.js\n *        https://github.com/compound-finance/compound-protocol/blob/master/tests/Utils/EIP712.js\n *      - OpenZeppelin voting delegation tests\n *        https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/test/token/ERC20/extensions/ERC20Votes.test.js\n *      See adopted copies of all the tests in the project test folder\n *\n * @dev Compound-like voting delegation functions', public getters', and events' names\n *      were changed for better code readability (Alethea Name <- Comp/Zeppelin name):\n *      - votingDelegates           <- delegates\n *      - votingPowerHistory        <- checkpoints\n *      - votingPowerHistoryLength  <- numCheckpoints\n *      - totalSupplyHistory        <- _totalSupplyCheckpoints (private)\n *      - usedNonces                <- nonces (note: nonces are random instead of sequential)\n *      - DelegateChanged (unchanged)\n *      - VotingPowerChanged        <- DelegateVotesChanged\n *      - votingPowerOf             <- getCurrentVotes\n *      - votingPowerAt             <- getPriorVotes\n *      - totalSupplyAt             <- getPriorTotalSupply\n *      - delegate (unchanged)\n *      - delegateWithAuthorization <- delegateBySig\n * @dev Compound-like voting delegation improved to allow the use of random nonces like in EIP-3009,\n *      instead of sequential; same `usedNonces` EIP-3009 mapping is used to track nonces\n *\n * @dev Reference implementations \"used\":\n *      - Atomic allowance:    https://github.com/OpenZeppelin/openzeppelin-contracts\n *      - Unlimited allowance: https://github.com/0xProject/protocol\n *      - Voting delegation:   https://github.com/compound-finance/compound-protocol\n *                             https://github.com/OpenZeppelin/openzeppelin-contracts\n *      - ERC-1363:            https://github.com/vittominacori/erc1363-payable-token\n *      - EIP-2612:            https://github.com/Uniswap/uniswap-v2-core\n *      - EIP-3009:            https://github.com/centrehq/centre-tokens\n *                             https://github.com/CoinbaseStablecoin/eip-3009\n *      - Meta transactions:   https://github.com/0xProject/protocol\n *\n * @dev Includes resolutions for ALI ERC20 Audit by Miguel Palhas, https://hackmd.io/@naps62/alierc20-audit\n *\n * @author Basil Gorin\n */\nabstract contract AliERC20v2Base is ERC1363, EIP2612, EIP3009, AccessControl {\n\t/**\n\t * @dev Smart contract unique identifier, a random number\n\t *\n\t * @dev Should be regenerated each time smart contact source code is changed\n\t *      and changes smart contract itself is to be redeployed\n\t *\n\t * @dev Generated using https://www.random.org/bytes/\n\t */\n\tuint256 public constant TOKEN_UID = 0x8d4fb97da97378ef7d0ad259aec651f42bd22c200159282baa58486bb390286b;\n\n\t/**\n\t * @notice Name of the token: Artificial Liquid Intelligence Token\n\t *\n\t * @notice ERC20 name of the token (long name)\n\t *\n\t * @dev ERC20 `function name() public view returns (string)`\n\t *\n\t * @dev Field is declared public: getter name() is created when compiled,\n\t *      it returns the name of the token.\n\t */\n\tstring public constant name = \"Artificial Liquid Intelligence Token\";\n\n\t/**\n\t * @notice Symbol of the token: ALI\n\t *\n\t * @notice ERC20 symbol of that token (short name)\n\t *\n\t * @dev ERC20 `function symbol() public view returns (string)`\n\t *\n\t * @dev Field is declared public: getter symbol() is created when compiled,\n\t *      it returns the symbol of the token\n\t */\n\tstring public constant symbol = \"ALI\";\n\n\t/**\n\t * @notice Decimals of the token: 18\n\t *\n\t * @dev ERC20 `function decimals() public view returns (uint8)`\n\t *\n\t * @dev Field is declared public: getter decimals() is created when compiled,\n\t *      it returns the number of decimals used to get its user representation.\n\t *      For example, if `decimals` equals `6`, a balance of `1,500,000` tokens should\n\t *      be displayed to a user as `1,5` (`1,500,000 / 10 ** 6`).\n\t *\n\t * @dev NOTE: This information is only used for _display_ purposes: it in\n\t *      no way affects any of the arithmetic of the contract, including balanceOf() and transfer().\n\t */\n\tuint8 public constant decimals = 18;\n\n\t/**\n\t * @notice Total supply of the token: initially 10,000,000,000,\n\t *      with the potential to decline over time as some tokens may get burnt but not minted\n\t *\n\t * @dev ERC20 `function totalSupply() public view returns (uint256)`\n\t *\n\t * @dev Field is declared public: getter totalSupply() is created when compiled,\n\t *      it returns the amount of tokens in existence.\n\t */\n\tuint256 public override totalSupply; // is set to 10 billion * 10^18 in the constructor\n\n\t/**\n\t * @dev A record of all the token balances\n\t * @dev This mapping keeps record of all token owners:\n\t *      owner => balance\n\t */\n\tmapping(address => uint256) private tokenBalances;\n\n\t/**\n\t * @notice A record of each account's voting delegate\n\t *\n\t * @dev Auxiliary data structure used to sum up an account's voting power\n\t *\n\t * @dev This mapping keeps record of all voting power delegations:\n\t *      voting delegator (token owner) => voting delegate\n\t */\n\tmapping(address => address) public votingDelegates;\n\n\t/**\n\t * @notice Auxiliary structure to store key-value pair, used to store:\n\t *      - voting power record (key: block.timestamp, value: voting power)\n\t *      - total supply record (key: block.timestamp, value: total supply)\n\t * @notice A voting power record binds voting power of a delegate to a particular\n\t *      block when the voting power delegation change happened\n\t *         k: block.number when delegation has changed; starting from\n\t *            that block voting power value is in effect\n\t *         v: cumulative voting power a delegate has obtained starting\n\t *            from the block stored in blockNumber\n\t * @notice Total supply record binds total token supply to a particular\n\t *      block when total supply change happened (due to mint/burn operations)\n\t */\n\tstruct KV {\n\t\t/*\n\t\t * @dev key, a block number\n\t\t */\n\t\tuint64 k;\n\n\t\t/*\n\t\t * @dev value, token balance or voting power\n\t\t */\n\t\tuint192 v;\n\t}\n\n\t/**\n\t * @notice A record of each account's voting power historical data\n\t *\n\t * @dev Primarily data structure to store voting power for each account.\n\t *      Voting power sums up from the account's token balance and delegated\n\t *      balances.\n\t *\n\t * @dev Stores current value and entire history of its changes.\n\t *      The changes are stored as an array of checkpoints (key-value pairs).\n\t *      Checkpoint is an auxiliary data structure containing voting\n\t *      power (number of votes) and block number when the checkpoint is saved\n\t *\n\t * @dev Maps voting delegate => voting power record\n\t */\n\tmapping(address => KV[]) public votingPowerHistory;\n\n\t/**\n\t * @notice A record of total token supply historical data\n\t *\n\t * @dev Primarily data structure to store total token supply.\n\t *\n\t * @dev Stores current value and entire history of its changes.\n\t *      The changes are stored as an array of checkpoints (key-value pairs).\n\t *      Checkpoint is an auxiliary data structure containing total\n\t *      token supply and block number when the checkpoint is saved\n\t */\n\tKV[] public totalSupplyHistory;\n\n\t/**\n\t * @dev A record of nonces for signing/validating signatures in EIP-2612 `permit`\n\t *\n\t * @dev Note: EIP2612 doesn't imply a possibility for nonce randomization like in EIP-3009\n\t *\n\t * @dev Maps delegate address => delegate nonce\n\t */\n\tmapping(address => uint256) public override nonces;\n\n\t/**\n\t * @dev A record of used nonces for EIP-3009 transactions\n\t *\n\t * @dev A record of used nonces for signing/validating signatures\n\t *      in `delegateWithAuthorization` for every delegate\n\t *\n\t * @dev Maps authorizer address => nonce => true/false (used unused)\n\t */\n\tmapping(address => mapping(bytes32 => bool)) private usedNonces;\n\n\t/**\n\t * @notice A record of all the allowances to spend tokens on behalf\n\t * @dev Maps token owner address to an address approved to spend\n\t *      some tokens on behalf, maps approved address to that amount\n\t * @dev owner => spender => value\n\t */\n\tmapping(address => mapping(address => uint256)) private transferAllowances;\n\n\t/**\n\t * @notice Enables ERC20 transfers of the tokens\n\t *      (transfer by the token owner himself)\n\t * @dev Feature FEATURE_TRANSFERS must be enabled in order for\n\t *      `transfer()` function to succeed\n\t */\n\tuint32 public constant FEATURE_TRANSFERS = 0x0000_0001;\n\n\t/**\n\t * @notice Enables ERC20 transfers on behalf\n\t *      (transfer by someone else on behalf of token owner)\n\t * @dev Feature FEATURE_TRANSFERS_ON_BEHALF must be enabled in order for\n\t *      `transferFrom()` function to succeed\n\t * @dev Token owner must call `approve()` first to authorize\n\t *      the transfer on behalf\n\t */\n\tuint32 public constant FEATURE_TRANSFERS_ON_BEHALF = 0x0000_0002;\n\n\t/**\n\t * @dev Defines if the default behavior of `transfer` and `transferFrom`\n\t *      checks if the receiver smart contract supports ERC20 tokens\n\t * @dev When feature FEATURE_UNSAFE_TRANSFERS is enabled the transfers do not\n\t *      check if the receiver smart contract supports ERC20 tokens,\n\t *      i.e. `transfer` and `transferFrom` behave like `unsafeTransferFrom`\n\t * @dev When feature FEATURE_UNSAFE_TRANSFERS is disabled (default) the transfers\n\t *      check if the receiver smart contract supports ERC20 tokens,\n\t *      i.e. `transfer` and `transferFrom` behave like `transferFromAndCall`\n\t */\n\tuint32 public constant FEATURE_UNSAFE_TRANSFERS = 0x0000_0004;\n\n\t/**\n\t * @notice Enables token owners to burn their own tokens\n\t *\n\t * @dev Feature FEATURE_OWN_BURNS must be enabled in order for\n\t *      `burn()` function to succeed when called by token owner\n\t */\n\tuint32 public constant FEATURE_OWN_BURNS = 0x0000_0008;\n\n\t/**\n\t * @notice Enables approved operators to burn tokens on behalf of their owners\n\t *\n\t * @dev Feature FEATURE_BURNS_ON_BEHALF must be enabled in order for\n\t *      `burn()` function to succeed when called by approved operator\n\t */\n\tuint32 public constant FEATURE_BURNS_ON_BEHALF = 0x0000_0010;\n\n\t/**\n\t * @notice Enables delegators to elect delegates\n\t * @dev Feature FEATURE_DELEGATIONS must be enabled in order for\n\t *      `delegate()` function to succeed\n\t */\n\tuint32 public constant FEATURE_DELEGATIONS = 0x0000_0020;\n\n\t/**\n\t * @notice Enables delegators to elect delegates on behalf\n\t *      (via an EIP712 signature)\n\t * @dev Feature FEATURE_DELEGATIONS_ON_BEHALF must be enabled in order for\n\t *      `delegateWithAuthorization()` function to succeed\n\t */\n\tuint32 public constant FEATURE_DELEGATIONS_ON_BEHALF = 0x0000_0040;\n\n\t/**\n\t * @notice Enables ERC-1363 transfers with callback\n\t * @dev Feature FEATURE_ERC1363_TRANSFERS must be enabled in order for\n\t *      ERC-1363 `transferFromAndCall` functions to succeed\n\t */\n\tuint32 public constant FEATURE_ERC1363_TRANSFERS = 0x0000_0080;\n\n\t/**\n\t * @notice Enables ERC-1363 approvals with callback\n\t * @dev Feature FEATURE_ERC1363_APPROVALS must be enabled in order for\n\t *      ERC-1363 `approveAndCall` functions to succeed\n\t */\n\tuint32 public constant FEATURE_ERC1363_APPROVALS = 0x0000_0100;\n\n\t/**\n\t * @notice Enables approvals on behalf (EIP2612 permits\n\t *      via an EIP712 signature)\n\t * @dev Feature FEATURE_EIP2612_PERMITS must be enabled in order for\n\t *      `permit()` function to succeed\n\t */\n\tuint32 public constant FEATURE_EIP2612_PERMITS = 0x0000_0200;\n\n\t/**\n\t * @notice Enables meta transfers on behalf (EIP3009 transfers\n\t *      via an EIP712 signature)\n\t * @dev Feature FEATURE_EIP3009_TRANSFERS must be enabled in order for\n\t *      `transferWithAuthorization()` function to succeed\n\t */\n\tuint32 public constant FEATURE_EIP3009_TRANSFERS = 0x0000_0400;\n\n\t/**\n\t * @notice Enables meta transfers on behalf (EIP3009 transfers\n\t *      via an EIP712 signature)\n\t * @dev Feature FEATURE_EIP3009_RECEPTIONS must be enabled in order for\n\t *      `receiveWithAuthorization()` function to succeed\n\t */\n\tuint32 public constant FEATURE_EIP3009_RECEPTIONS = 0x0000_0800;\n\n\t/**\n\t * @notice Token creator is responsible for creating (minting)\n\t *      tokens to an arbitrary address\n\t * @dev Role ROLE_TOKEN_CREATOR allows minting tokens\n\t *      (calling `mint` function)\n\t */\n\tuint32 public constant ROLE_TOKEN_CREATOR = 0x0001_0000;\n\n\t/**\n\t * @notice Token destroyer is responsible for destroying (burning)\n\t *      tokens owned by an arbitrary address\n\t * @dev Role ROLE_TOKEN_DESTROYER allows burning tokens\n\t *      (calling `burn` function)\n\t */\n\tuint32 public constant ROLE_TOKEN_DESTROYER = 0x0002_0000;\n\n\t/**\n\t * @notice ERC20 receivers are allowed to receive tokens without ERC20 safety checks,\n\t *      which may be useful to simplify tokens transfers into \"legacy\" smart contracts\n\t * @dev When `FEATURE_UNSAFE_TRANSFERS` is not enabled addresses having\n\t *      `ROLE_ERC20_RECEIVER` permission are allowed to receive tokens\n\t *      via `transfer` and `transferFrom` functions in the same way they\n\t *      would via `unsafeTransferFrom` function\n\t * @dev When `FEATURE_UNSAFE_TRANSFERS` is enabled `ROLE_ERC20_RECEIVER` permission\n\t *      doesn't affect the transfer behaviour since\n\t *      `transfer` and `transferFrom` behave like `unsafeTransferFrom` for any receiver\n\t * @dev ROLE_ERC20_RECEIVER is a shortening for ROLE_UNSAFE_ERC20_RECEIVER\n\t */\n\tuint32 public constant ROLE_ERC20_RECEIVER = 0x0004_0000;\n\n\t/**\n\t * @notice ERC20 senders are allowed to send tokens without ERC20 safety checks,\n\t *      which may be useful to simplify tokens transfers into \"legacy\" smart contracts\n\t * @dev When `FEATURE_UNSAFE_TRANSFERS` is not enabled senders having\n\t *      `ROLE_ERC20_SENDER` permission are allowed to send tokens\n\t *      via `transfer` and `transferFrom` functions in the same way they\n\t *      would via `unsafeTransferFrom` function\n\t * @dev When `FEATURE_UNSAFE_TRANSFERS` is enabled `ROLE_ERC20_SENDER` permission\n\t *      doesn't affect the transfer behaviour since\n\t *      `transfer` and `transferFrom` behave like `unsafeTransferFrom` for any receiver\n\t * @dev ROLE_ERC20_SENDER is a shortening for ROLE_UNSAFE_ERC20_SENDER\n\t */\n\tuint32 public constant ROLE_ERC20_SENDER = 0x0008_0000;\n\n\t/**\n\t * @notice EIP-712 contract's domain typeHash,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\n\t *\n\t * @dev Note: we do not include version into the domain typehash/separator,\n\t *      it is implied version is concatenated to the name field, like \"AliERC20v2\"\n\t */\n\t// keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\")\n\tbytes32 public constant DOMAIN_TYPEHASH = 0x8cad95687ba82c2ce50e74f7b754645e5117c3a5bec8151c0726d5857980a866;\n\n\t/**\n\t * @notice EIP-712 contract's domain separator,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator\n\t */\n\tbytes32 public immutable override DOMAIN_SEPARATOR;\n\n\t/**\n\t * @notice EIP-712 delegation struct typeHash,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\n\t */\n\t// keccak256(\"Delegation(address delegate,uint256 nonce,uint256 expiry)\")\n\tbytes32 public constant DELEGATION_TYPEHASH = 0xff41620983935eb4d4a3c7384a066ca8c1d10cef9a5eca9eb97ca735cd14a755;\n\n\t/**\n\t * @notice EIP-712 permit (EIP-2612) struct typeHash,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\n\t */\n\t// keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\")\n\tbytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n\t/**\n\t * @notice EIP-712 TransferWithAuthorization (EIP-3009) struct typeHash,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\n\t */\n\t// keccak256(\"TransferWithAuthorization(address from,address to,uint256 value,uint256 validAfter,uint256 validBefore,bytes32 nonce)\")\n\tbytes32 public constant TRANSFER_WITH_AUTHORIZATION_TYPEHASH = 0x7c7c6cdb67a18743f49ec6fa9b35f50d52ed05cbed4cc592e13b44501c1a2267;\n\n\t/**\n\t * @notice EIP-712 ReceiveWithAuthorization (EIP-3009) struct typeHash,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\n\t */\n\t// keccak256(\"ReceiveWithAuthorization(address from,address to,uint256 value,uint256 validAfter,uint256 validBefore,bytes32 nonce)\")\n\tbytes32 public constant RECEIVE_WITH_AUTHORIZATION_TYPEHASH = 0xd099cc98ef71107a616c4f0f941f04c322d8e254fe26b3c6668db87aae413de8;\n\n\t/**\n\t * @notice EIP-712 CancelAuthorization (EIP-3009) struct typeHash,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\n\t */\n\t// keccak256(\"CancelAuthorization(address authorizer,bytes32 nonce)\")\n\tbytes32 public constant CANCEL_AUTHORIZATION_TYPEHASH = 0x158b0a9edf7a828aad02f63cd515c68ef2f50ba807396f6d12842833a1597429;\n\n\t/**\n\t * @dev Fired in mint() function\n\t *\n\t * @param by an address which minted some tokens (transaction sender)\n\t * @param to an address the tokens were minted to\n\t * @param value an amount of tokens minted\n\t */\n\tevent Minted(address indexed by, address indexed to, uint256 value);\n\n\t/**\n\t * @dev Fired in burn() function\n\t *\n\t * @param by an address which burned some tokens (transaction sender)\n\t * @param from an address the tokens were burnt from\n\t * @param value an amount of tokens burnt\n\t */\n\tevent Burnt(address indexed by, address indexed from, uint256 value);\n\n\t/**\n\t * @dev Resolution for the Multiple Withdrawal Attack on ERC20 Tokens (arXiv:1907.00903)\n\t *\n\t * @dev Similar to ERC20 Transfer event, but also logs an address which executed transfer\n\t *\n\t * @dev Fired in transfer(), transferFrom() and some other (non-ERC20) functions\n\t *\n\t * @param by an address which performed the transfer\n\t * @param from an address tokens were consumed from\n\t * @param to an address tokens were sent to\n\t * @param value number of tokens transferred\n\t */\n\tevent Transfer(address indexed by, address indexed from, address indexed to, uint256 value);\n\n\t/**\n\t * @dev Resolution for the Multiple Withdrawal Attack on ERC20 Tokens (arXiv:1907.00903)\n\t *\n\t * @dev Similar to ERC20 Approve event, but also logs old approval value\n\t *\n\t * @dev Fired in approve(), increaseAllowance(), decreaseAllowance() functions,\n\t *      may get fired in transfer functions\n\t *\n\t * @param owner an address which granted a permission to transfer\n\t *      tokens on its behalf\n\t * @param spender an address which received a permission to transfer\n\t *      tokens on behalf of the owner `_owner`\n\t * @param oldValue previously granted amount of tokens to transfer on behalf\n\t * @param value new granted amount of tokens to transfer on behalf\n\t */\n\tevent Approval(address indexed owner, address indexed spender, uint256 oldValue, uint256 value);\n\n\t/**\n\t * @dev Notifies that a key-value pair in `votingDelegates` mapping has changed,\n\t *      i.e. a delegator address has changed its delegate address\n\t *\n\t * @param source delegator address, a token owner, effectively transaction sender (`by`)\n\t * @param from old delegate, an address which delegate right is revoked\n\t * @param to new delegate, an address which received the voting power\n\t */\n\tevent DelegateChanged(address indexed source, address indexed from, address indexed to);\n\n\t/**\n\t * @dev Notifies that a key-value pair in `votingPowerHistory` mapping has changed,\n\t *      i.e. a delegate's voting power has changed.\n\t *\n\t * @param by an address which executed delegate, mint, burn, or transfer operation\n\t *      which had led to delegate voting power change\n\t * @param target delegate whose voting power has changed\n\t * @param fromVal previous number of votes delegate had\n\t * @param toVal new number of votes delegate has\n\t */\n\tevent VotingPowerChanged(address indexed by, address indexed target, uint256 fromVal, uint256 toVal);\n\n\t/**\n\t * @dev Deploys the token smart contract,\n\t *      assigns initial token supply to the address specified\n\t *\n\t * @param _initialHolder owner of the initial token supply\n\t * @param _initialSupply initial token supply value\n\t */\n\tconstructor(address _initialHolder, uint256 _initialSupply) {\n\t\t// verify initial holder address non-zero (is set) if there is an initial supply to mint\n\t\trequire(_initialSupply == 0 || _initialHolder != address(0), \"_initialHolder not set (zero address)\");\n\n\t\t// build the EIP-712 contract domain separator, see https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator\n\t\t// note: we specify contract version in its name\n\t\tDOMAIN_SEPARATOR = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(\"AliERC20v2\")), block.chainid, address(this)));\n\n\t\t// if there is an initial supply to mint\n\t\tif(_initialSupply != 0) {\n\t\t\t// mint the initial supply\n\t\t\tmint(_initialHolder, _initialSupply);\n\t\t}\n\t}\n\n\t/**\n\t * @inheritdoc ERC165\n\t */\n\tfunction supportsInterface(bytes4 interfaceId) public pure override returns (bool) {\n\t\t// reconstruct from current interface(s) and super interface(s) (if any)\n\t\treturn interfaceId == type(ERC165).interfaceId\n\t\t    || interfaceId == type(ERC20).interfaceId\n\t\t    || interfaceId == type(ERC1363).interfaceId\n\t\t    || interfaceId == type(EIP2612).interfaceId\n\t\t    || interfaceId == type(EIP3009).interfaceId;\n\t}\n\n\t// ===== Start: ERC-1363 functions =====\n\n\t/**\n\t * @notice Transfers some tokens and then executes `onTransferReceived` callback on the receiver\n\t *\n\t * @inheritdoc ERC1363\n\t *\n\t * @dev Called by token owner (an address which has a\n\t *      positive token balance tracked by this smart contract)\n\t * @dev Throws on any error like\n\t *      * insufficient token balance or\n\t *      * incorrect `_to` address:\n\t *          * zero address or\n\t *          * same as `_from` address (self transfer)\n\t *          * EOA or smart contract which doesn't support ERC1363Receiver interface\n\t * @dev Returns true on success, throws otherwise\n\t *\n\t * @param _to an address to transfer tokens to,\n\t *      must be a smart contract, implementing ERC1363Receiver\n\t * @param _value amount of tokens to be transferred,, zero\n\t *      value is allowed\n\t * @return true unless throwing\n\t */\n\tfunction transferAndCall(address _to, uint256 _value) public override returns (bool) {\n\t\t// delegate to `transferFromAndCall` passing `msg.sender` as `_from`\n\t\treturn transferFromAndCall(msg.sender, _to, _value);\n\t}\n\n\t/**\n\t * @notice Transfers some tokens and then executes `onTransferReceived` callback on the receiver\n\t *\n\t * @inheritdoc ERC1363\n\t *\n\t * @dev Called by token owner (an address which has a\n\t *      positive token balance tracked by this smart contract)\n\t * @dev Throws on any error like\n\t *      * insufficient token balance or\n\t *      * incorrect `_to` address:\n\t *          * zero address or\n\t *          * same as `_from` address (self transfer)\n\t *          * EOA or smart contract which doesn't support ERC1363Receiver interface\n\t * @dev Returns true on success, throws otherwise\n\t *\n\t * @param _to an address to transfer tokens to,\n\t *      must be a smart contract, implementing ERC1363Receiver\n\t * @param _value amount of tokens to be transferred,, zero\n\t *      value is allowed\n\t * @param _data [optional] additional data with no specified format,\n\t *      sent in onTransferReceived call to `_to`\n\t * @return true unless throwing\n\t */\n\tfunction transferAndCall(address _to, uint256 _value, bytes memory _data) public override returns (bool) {\n\t\t// delegate to `transferFromAndCall` passing `msg.sender` as `_from`\n\t\treturn transferFromAndCall(msg.sender, _to, _value, _data);\n\t}\n\n\t/**\n\t * @notice Transfers some tokens on behalf of address `_from' (token owner)\n\t *      to some other address `_to` and then executes `onTransferReceived` callback on the receiver\n\t *\n\t * @inheritdoc ERC1363\n\t *\n\t * @dev Called by token owner on his own or approved address,\n\t *      an address approved earlier by token owner to\n\t *      transfer some amount of tokens on its behalf\n\t * @dev Throws on any error like\n\t *      * insufficient token balance or\n\t *      * incorrect `_to` address:\n\t *          * zero address or\n\t *          * same as `_from` address (self transfer)\n\t *          * EOA or smart contract which doesn't support ERC1363Receiver interface\n\t * @dev Returns true on success, throws otherwise\n\t *\n\t * @param _from token owner which approved caller (transaction sender)\n\t *      to transfer `_value` of tokens on its behalf\n\t * @param _to an address to transfer tokens to,\n\t *      must be a smart contract, implementing ERC1363Receiver\n\t * @param _value amount of tokens to be transferred,, zero\n\t *      value is allowed\n\t * @return true unless throwing\n\t */\n\tfunction transferFromAndCall(address _from, address _to, uint256 _value) public override returns (bool) {\n\t\t// delegate to `transferFromAndCall` passing empty data param\n\t\treturn transferFromAndCall(_from, _to, _value, \"\");\n\t}\n\n\t/**\n\t * @notice Transfers some tokens on behalf of address `_from' (token owner)\n\t *      to some other address `_to` and then executes a `onTransferReceived` callback on the receiver\n\t *\n\t * @inheritdoc ERC1363\n\t *\n\t * @dev Called by token owner on his own or approved address,\n\t *      an address approved earlier by token owner to\n\t *      transfer some amount of tokens on its behalf\n\t * @dev Throws on any error like\n\t *      * insufficient token balance or\n\t *      * incorrect `_to` address:\n\t *          * zero address or\n\t *          * same as `_from` address (self transfer)\n\t *          * EOA or smart contract which doesn't support ERC1363Receiver interface\n\t * @dev Returns true on success, throws otherwise\n\t *\n\t * @param _from token owner which approved caller (transaction sender)\n\t *      to transfer `_value` of tokens on its behalf\n\t * @param _to an address to transfer tokens to,\n\t *      must be a smart contract, implementing ERC1363Receiver\n\t * @param _value amount of tokens to be transferred,, zero\n\t *      value is allowed\n\t * @param _data [optional] additional data with no specified format,\n\t *      sent in onTransferReceived call to `_to`\n\t * @return true unless throwing\n\t */\n\tfunction transferFromAndCall(address _from, address _to, uint256 _value, bytes memory _data) public override returns (bool) {\n\t\t// ensure ERC-1363 transfers are enabled\n\t\trequire(isFeatureEnabled(FEATURE_ERC1363_TRANSFERS), \"ERC1363 transfers are disabled\");\n\n\t\t// first delegate call to `unsafeTransferFrom` to perform the unsafe token(s) transfer\n\t\tunsafeTransferFrom(_from, _to, _value);\n\n\t\t// after the successful transfer - check if receiver supports\n\t\t// ERC1363Receiver and execute a callback handler `onTransferReceived`,\n\t\t// reverting whole transaction on any error\n\t\t_notifyTransferred(_from, _to, _value, _data, false);\n\n\t\t// function throws on any error, so if we're here - it means operation successful, just return true\n\t\treturn true;\n\t}\n\n\t/**\n\t * @notice Approves address called `_spender` to transfer some amount\n\t *      of tokens on behalf of the owner, then executes a `onApprovalReceived` callback on `_spender`\n\t *\n\t * @inheritdoc ERC1363\n\t *\n\t * @dev Caller must not necessarily own any tokens to grant the permission\n\t *\n\t * @dev Throws if `_spender` is an EOA or a smart contract which doesn't support ERC1363Spender interface\n\t *\n\t * @param _spender an address approved by the caller (token owner)\n\t *      to spend some tokens on its behalf\n\t * @param _value an amount of tokens spender `_spender` is allowed to\n\t *      transfer on behalf of the token owner\n\t * @return success true on success, throws otherwise\n\t */\n\tfunction approveAndCall(address _spender, uint256 _value) public override returns (bool) {\n\t\t// delegate to `approveAndCall` passing empty data\n\t\treturn approveAndCall(_spender, _value, \"\");\n\t}\n\n\t/**\n\t * @notice Approves address called `_spender` to transfer some amount\n\t *      of tokens on behalf of the owner, then executes a callback on `_spender`\n\t *\n\t * @inheritdoc ERC1363\n\t *\n\t * @dev Caller must not necessarily own any tokens to grant the permission\n\t *\n\t * @param _spender an address approved by the caller (token owner)\n\t *      to spend some tokens on its behalf\n\t * @param _value an amount of tokens spender `_spender` is allowed to\n\t *      transfer on behalf of the token owner\n\t * @param _data [optional] additional data with no specified format,\n\t *      sent in onApprovalReceived call to `_spender`\n\t * @return success true on success, throws otherwise\n\t */\n\tfunction approveAndCall(address _spender, uint256 _value, bytes memory _data) public override returns (bool) {\n\t\t// ensure ERC-1363 approvals are enabled\n\t\trequire(isFeatureEnabled(FEATURE_ERC1363_APPROVALS), \"ERC1363 approvals are disabled\");\n\n\t\t// execute regular ERC20 approve - delegate to `approve`\n\t\tapprove(_spender, _value);\n\n\t\t// after the successful approve - check if receiver supports\n\t\t// ERC1363Spender and execute a callback handler `onApprovalReceived`,\n\t\t// reverting whole transaction on any error\n\t\t_notifyApproved(_spender, _value, _data);\n\n\t\t// function throws on any error, so if we're here - it means operation successful, just return true\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Auxiliary function to invoke `onTransferReceived` on a target address\n\t *      The call is not executed if the target address is not a contract; in such\n\t *      a case function throws if `allowEoa` is set to false, succeeds if it's true\n\t *\n\t * @dev Throws on any error; returns silently on success\n\t *\n\t * @param _from representing the previous owner of the given token value\n\t * @param _to target address that will receive the tokens\n\t * @param _value the amount mount of tokens to be transferred\n\t * @param _data [optional] data to send along with the call\n\t * @param allowEoa indicates if function should fail if `_to` is an EOA\n\t */\n\tfunction _notifyTransferred(address _from, address _to, uint256 _value, bytes memory _data, bool allowEoa) private {\n\t\t// if recipient `_to` is EOA\n\t\tif (!AddressUtils.isContract(_to)) {\n\t\t\t// ensure EOA recipient is allowed\n\t\t\trequire(allowEoa, \"EOA recipient\");\n\n\t\t\t// exit if successful\n\t\t\treturn;\n\t\t}\n\n\t\t// otherwise - if `_to` is a contract - execute onTransferReceived\n\t\tbytes4 response = ERC1363Receiver(_to).onTransferReceived(msg.sender, _from, _value, _data);\n\n\t\t// expected response is ERC1363Receiver(_to).onTransferReceived.selector\n\t\t// bytes4(keccak256(\"onTransferReceived(address,address,uint256,bytes)\"))\n\t\trequire(response == ERC1363Receiver(_to).onTransferReceived.selector, \"invalid onTransferReceived response\");\n\t}\n\n\t/**\n\t * @dev Auxiliary function to invoke `onApprovalReceived` on a target address\n\t *      The call is not executed if the target address is not a contract; in such\n\t *      a case function throws if `allowEoa` is set to false, succeeds if it's true\n\t *\n\t * @dev Throws on any error; returns silently on success\n\t *\n\t * @param _spender the address which will spend the funds\n\t * @param _value the amount of tokens to be spent\n\t * @param _data [optional] data to send along with the call\n\t */\n\tfunction _notifyApproved(address _spender, uint256 _value, bytes memory _data) private {\n\t\t// ensure recipient is not EOA\n\t\trequire(AddressUtils.isContract(_spender), \"EOA spender\");\n\n\t\t// otherwise - if `_to` is a contract - execute onApprovalReceived\n\t\tbytes4 response = ERC1363Spender(_spender).onApprovalReceived(msg.sender, _value, _data);\n\n\t\t// expected response is ERC1363Spender(_to).onApprovalReceived.selector\n\t\t// bytes4(keccak256(\"onApprovalReceived(address,uint256,bytes)\"))\n\t\trequire(response == ERC1363Spender(_spender).onApprovalReceived.selector, \"invalid onApprovalReceived response\");\n\t}\n\t// ===== End: ERC-1363 functions =====\n\n\t// ===== Start: ERC20 functions =====\n\n\t/**\n\t * @notice Gets the balance of a particular address\n\t *\n\t * @inheritdoc ERC20\n\t *\n\t * @param _owner the address to query the the balance for\n\t * @return balance an amount of tokens owned by the address specified\n\t */\n\tfunction balanceOf(address _owner) public view override returns (uint256 balance) {\n\t\t// read the balance and return\n\t\treturn tokenBalances[_owner];\n\t}\n\n\t/**\n\t * @notice Transfers some tokens to an external address or a smart contract\n\t *\n\t * @inheritdoc ERC20\n\t *\n\t * @dev Called by token owner (an address which has a\n\t *      positive token balance tracked by this smart contract)\n\t * @dev Throws on any error like\n\t *      * insufficient token balance or\n\t *      * incorrect `_to` address:\n\t *          * zero address or\n\t *          * self address or\n\t *          * smart contract which doesn't support ERC20\n\t *\n\t * @param _to an address to transfer tokens to,\n\t *      must be either an external address or a smart contract,\n\t *      compliant with the ERC20 standard\n\t * @param _value amount of tokens to be transferred,, zero\n\t *      value is allowed\n\t * @return success true on success, throws otherwise\n\t */\n\tfunction transfer(address _to, uint256 _value) public override returns (bool success) {\n\t\t// just delegate call to `transferFrom`,\n\t\t// `FEATURE_TRANSFERS` is verified inside it\n\t\treturn transferFrom(msg.sender, _to, _value);\n\t}\n\n\t/**\n\t * @notice Transfers some tokens on behalf of address `_from' (token owner)\n\t *      to some other address `_to`\n\t *\n\t * @inheritdoc ERC20\n\t *\n\t * @dev Called by token owner on his own or approved address,\n\t *      an address approved earlier by token owner to\n\t *      transfer some amount of tokens on its behalf\n\t * @dev Throws on any error like\n\t *      * insufficient token balance or\n\t *      * incorrect `_to` address:\n\t *          * zero address or\n\t *          * same as `_from` address (self transfer)\n\t *          * smart contract which doesn't support ERC20\n\t *\n\t * @param _from token owner which approved caller (transaction sender)\n\t *      to transfer `_value` of tokens on its behalf\n\t * @param _to an address to transfer tokens to,\n\t *      must be either an external address or a smart contract,\n\t *      compliant with the ERC20 standard\n\t * @param _value amount of tokens to be transferred,, zero\n\t *      value is allowed\n\t * @return success true on success, throws otherwise\n\t */\n\tfunction transferFrom(address _from, address _to, uint256 _value) public override returns (bool success) {\n\t\t// depending on `FEATURE_UNSAFE_TRANSFERS` we execute either safe (default)\n\t\t// or unsafe transfer\n\t\t// if `FEATURE_UNSAFE_TRANSFERS` is enabled\n\t\t// or receiver has `ROLE_ERC20_RECEIVER` permission\n\t\t// or sender has `ROLE_ERC20_SENDER` permission\n\t\tif(isFeatureEnabled(FEATURE_UNSAFE_TRANSFERS)\n\t\t\t|| isOperatorInRole(_to, ROLE_ERC20_RECEIVER)\n\t\t\t|| isSenderInRole(ROLE_ERC20_SENDER)) {\n\t\t\t// we execute unsafe transfer - delegate call to `unsafeTransferFrom`,\n\t\t\t// `FEATURE_TRANSFERS` is verified inside it\n\t\t\tunsafeTransferFrom(_from, _to, _value);\n\t\t}\n\t\t// otherwise - if `FEATURE_UNSAFE_TRANSFERS` is disabled\n\t\t// and receiver doesn't have `ROLE_ERC20_RECEIVER` permission\n\t\telse {\n\t\t\t// we execute safe transfer - delegate call to `safeTransferFrom`, passing empty `_data`,\n\t\t\t// `FEATURE_TRANSFERS` is verified inside it\n\t\t\tsafeTransferFrom(_from, _to, _value, \"\");\n\t\t}\n\n\t\t// both `unsafeTransferFrom` and `safeTransferFrom` throw on any error, so\n\t\t// if we're here - it means operation successful,\n\t\t// just return true\n\t\treturn true;\n\t}\n\n\t/**\n\t * @notice Transfers some tokens on behalf of address `_from' (token owner)\n\t *      to some other address `_to` and then executes `onTransferReceived` callback\n\t *      on the receiver if it is a smart contract (not an EOA)\n\t *\n\t * @dev Called by token owner on his own or approved address,\n\t *      an address approved earlier by token owner to\n\t *      transfer some amount of tokens on its behalf\n\t * @dev Throws on any error like\n\t *      * insufficient token balance or\n\t *      * incorrect `_to` address:\n\t *          * zero address or\n\t *          * same as `_from` address (self transfer)\n\t *          * smart contract which doesn't support ERC1363Receiver interface\n\t * @dev Returns true on success, throws otherwise\n\t *\n\t * @param _from token owner which approved caller (transaction sender)\n\t *      to transfer `_value` of tokens on its behalf\n\t * @param _to an address to transfer tokens to,\n\t *      must be either an external address or a smart contract,\n\t *      implementing ERC1363Receiver\n\t * @param _value amount of tokens to be transferred,, zero\n\t *      value is allowed\n\t * @param _data [optional] additional data with no specified format,\n\t *      sent in onTransferReceived call to `_to` in case if its a smart contract\n\t * @return true unless throwing\n\t */\n\tfunction safeTransferFrom(address _from, address _to, uint256 _value, bytes memory _data) public returns (bool) {\n\t\t// first delegate call to `unsafeTransferFrom` to perform the unsafe token(s) transfer\n\t\tunsafeTransferFrom(_from, _to, _value);\n\n\t\t// after the successful transfer - check if receiver supports\n\t\t// ERC1363Receiver and execute a callback handler `onTransferReceived`,\n\t\t// reverting whole transaction on any error\n\t\t_notifyTransferred(_from, _to, _value, _data, true);\n\n\t\t// function throws on any error, so if we're here - it means operation successful, just return true\n\t\treturn true;\n\t}\n\n\t/**\n\t * @notice Transfers some tokens on behalf of address `_from' (token owner)\n\t *      to some other address `_to`\n\t *\n\t * @dev In contrast to `transferFromAndCall` doesn't check recipient\n\t *      smart contract to support ERC20 tokens (ERC1363Receiver)\n\t * @dev Designed to be used by developers when the receiver is known\n\t *      to support ERC20 tokens but doesn't implement ERC1363Receiver interface\n\t * @dev Called by token owner on his own or approved address,\n\t *      an address approved earlier by token owner to\n\t *      transfer some amount of tokens on its behalf\n\t * @dev Throws on any error like\n\t *      * insufficient token balance or\n\t *      * incorrect `_to` address:\n\t *          * zero address or\n\t *          * same as `_from` address (self transfer)\n\t * @dev Returns silently on success, throws otherwise\n\t *\n\t * @param _from token sender, token owner which approved caller (transaction sender)\n\t *      to transfer `_value` of tokens on its behalf\n\t * @param _to token receiver, an address to transfer tokens to\n\t * @param _value amount of tokens to be transferred,, zero\n\t *      value is allowed\n\t */\n\tfunction unsafeTransferFrom(address _from, address _to, uint256 _value) public {\n\t\t// make an internal transferFrom - delegate to `__transferFrom`\n\t\t__transferFrom(msg.sender, _from, _to, _value);\n\t}\n\n\t/**\n\t * @dev Powers the meta transactions for `unsafeTransferFrom` - EIP-3009 `transferWithAuthorization`\n\t *      and `receiveWithAuthorization`\n\t *\n\t * @dev See `unsafeTransferFrom` and `transferFrom` soldoc for details\n\t *\n\t * @param _by an address executing the transfer, it can be token owner itself,\n\t *      or an operator previously approved with `approve()`\n\t * @param _from token sender, token owner which approved caller (transaction sender)\n\t *      to transfer `_value` of tokens on its behalf\n\t * @param _to token receiver, an address to transfer tokens to\n\t * @param _value amount of tokens to be transferred,, zero\n\t *      value is allowed\n\t */\n\tfunction __transferFrom(address _by, address _from, address _to, uint256 _value) private {\n\t\t// if `_from` is equal to sender, require transfers feature to be enabled\n\t\t// otherwise require transfers on behalf feature to be enabled\n\t\trequire(_from == _by && isFeatureEnabled(FEATURE_TRANSFERS)\n\t\t     || _from != _by && isFeatureEnabled(FEATURE_TRANSFERS_ON_BEHALF),\n\t\t        _from == _by? \"transfers are disabled\": \"transfers on behalf are disabled\");\n\n\t\t// non-zero source address check - Zeppelin\n\t\t// obviously, zero source address is a client mistake\n\t\t// it's not part of ERC20 standard but it's reasonable to fail fast\n\t\t// since for zero value transfer transaction succeeds otherwise\n\t\trequire(_from != address(0), \"transfer from the zero address\");\n\n\t\t// non-zero recipient address check\n\t\trequire(_to != address(0), \"transfer to the zero address\");\n\n\t\t// sender and recipient cannot be the same\n\t\trequire(_from != _to, \"sender and recipient are the same (_from = _to)\");\n\n\t\t// sending tokens to the token smart contract itself is a client mistake\n\t\trequire(_to != address(this), \"invalid recipient (transfer to the token smart contract itself)\");\n\n\t\t// according to ERC-20 Token Standard, https://eips.ethereum.org/EIPS/eip-20\n\t\t// \"Transfers of 0 values MUST be treated as normal transfers and fire the Transfer event.\"\n\t\tif(_value == 0) {\n\t\t\t// emit an ERC20 transfer event\n\t\t\temit Transfer(_from, _to, _value);\n\n\t\t\t// don't forget to return - we're done\n\t\t\treturn;\n\t\t}\n\n\t\t// no need to make arithmetic overflow check on the _value - by design of mint()\n\n\t\t// in case of transfer on behalf\n\t\tif(_from != _by) {\n\t\t\t// read allowance value - the amount of tokens allowed to transfer - into the stack\n\t\t\tuint256 _allowance = transferAllowances[_from][_by];\n\n\t\t\t// verify sender has an allowance to transfer amount of tokens requested\n\t\t\trequire(_allowance >= _value, \"transfer amount exceeds allowance\");\n\n\t\t\t// we treat max uint256 allowance value as an \"unlimited\" and\n\t\t\t// do not decrease allowance when it is set to \"unlimited\" value\n\t\t\tif(_allowance < type(uint256).max) {\n\t\t\t\t// update allowance value on the stack\n\t\t\t\t_allowance -= _value;\n\n\t\t\t\t// update the allowance value in storage\n\t\t\t\ttransferAllowances[_from][_by] = _allowance;\n\n\t\t\t\t// emit an improved atomic approve event\n\t\t\t\temit Approval(_from, _by, _allowance + _value, _allowance);\n\n\t\t\t\t// emit an ERC20 approval event to reflect the decrease\n\t\t\t\temit Approval(_from, _by, _allowance);\n\t\t\t}\n\t\t}\n\n\t\t// verify sender has enough tokens to transfer on behalf\n\t\trequire(tokenBalances[_from] >= _value, \"transfer amount exceeds balance\");\n\n\t\t// perform the transfer:\n\t\t// decrease token owner (sender) balance\n\t\ttokenBalances[_from] -= _value;\n\n\t\t// increase `_to` address (receiver) balance\n\t\ttokenBalances[_to] += _value;\n\n\t\t// move voting power associated with the tokens transferred\n\t\t__moveVotingPower(_by, votingDelegates[_from], votingDelegates[_to], _value);\n\n\t\t// emit an improved transfer event (arXiv:1907.00903)\n\t\temit Transfer(_by, _from, _to, _value);\n\n\t\t// emit an ERC20 transfer event\n\t\temit Transfer(_from, _to, _value);\n\t}\n\n\t/**\n\t * @notice Approves address called `_spender` to transfer some amount\n\t *      of tokens on behalf of the owner (transaction sender)\n\t *\n\t * @inheritdoc ERC20\n\t *\n\t * @dev Transaction sender must not necessarily own any tokens to grant the permission\n\t *\n\t * @param _spender an address approved by the caller (token owner)\n\t *      to spend some tokens on its behalf\n\t * @param _value an amount of tokens spender `_spender` is allowed to\n\t *      transfer on behalf of the token owner\n\t * @return success true on success, throws otherwise\n\t */\n\tfunction approve(address _spender, uint256 _value) public override returns (bool success) {\n\t\t// make an internal approve - delegate to `__approve`\n\t\t__approve(msg.sender, _spender, _value);\n\n\t\t// operation successful, return true\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Powers the meta transaction for `approve` - EIP-2612 `permit`\n\t *\n\t * @dev Approves address called `_spender` to transfer some amount\n\t *      of tokens on behalf of the `_owner`\n\t *\n\t * @dev `_owner` must not necessarily own any tokens to grant the permission\n\t * @dev Throws if `_spender` is a zero address\n\t *\n\t * @param _owner owner of the tokens to set approval on behalf of\n\t * @param _spender an address approved by the token owner\n\t *      to spend some tokens on its behalf\n\t * @param _value an amount of tokens spender `_spender` is allowed to\n\t *      transfer on behalf of the token owner\n\t */\n\tfunction __approve(address _owner, address _spender, uint256 _value) private {\n\t\t// non-zero spender address check - Zeppelin\n\t\t// obviously, zero spender address is a client mistake\n\t\t// it's not part of ERC20 standard but it's reasonable to fail fast\n\t\trequire(_spender != address(0), \"approve to the zero address\");\n\n\t\t// read old approval value to emmit an improved event (arXiv:1907.00903)\n\t\tuint256 _oldValue = transferAllowances[_owner][_spender];\n\n\t\t// perform an operation: write value requested into the storage\n\t\ttransferAllowances[_owner][_spender] = _value;\n\n\t\t// emit an improved atomic approve event (arXiv:1907.00903)\n\t\temit Approval(_owner, _spender, _oldValue, _value);\n\n\t\t// emit an ERC20 approval event\n\t\temit Approval(_owner, _spender, _value);\n\t}\n\n\t/**\n\t * @notice Returns the amount which _spender is still allowed to withdraw from _owner.\n\t *\n\t * @inheritdoc ERC20\n\t *\n\t * @dev A function to check an amount of tokens owner approved\n\t *      to transfer on its behalf by some other address called \"spender\"\n\t *\n\t * @param _owner an address which approves transferring some tokens on its behalf\n\t * @param _spender an address approved to transfer some tokens on behalf\n\t * @return remaining an amount of tokens approved address `_spender` can transfer on behalf\n\t *      of token owner `_owner`\n\t */\n\tfunction allowance(address _owner, address _spender) public view override returns (uint256 remaining) {\n\t\t// read the value from storage and return\n\t\treturn transferAllowances[_owner][_spender];\n\t}\n\n\t// ===== End: ERC20 functions =====\n\n\t// ===== Start: Resolution for the Multiple Withdrawal Attack on ERC20 Tokens (arXiv:1907.00903) =====\n\n\t/**\n\t * @notice Increases the allowance granted to `spender` by the transaction sender\n\t *\n\t * @dev Resolution for the Multiple Withdrawal Attack on ERC20 Tokens (arXiv:1907.00903)\n\t *\n\t * @dev Throws if value to increase by is zero or too big and causes arithmetic overflow\n\t *\n\t * @param _spender an address approved by the caller (token owner)\n\t *      to spend some tokens on its behalf\n\t * @param _value an amount of tokens to increase by\n\t * @return success true on success, throws otherwise\n\t */\n\tfunction increaseAllowance(address _spender, uint256 _value) public returns (bool) {\n\t\t// read current allowance value\n\t\tuint256 currentVal = transferAllowances[msg.sender][_spender];\n\n\t\t// non-zero _value and arithmetic overflow check on the allowance\n\t\tunchecked {\n\t\t\t// put operation into unchecked block to display user-friendly overflow error message for Solidity 0.8+\n\t\t\trequire(currentVal + _value > currentVal, \"zero value approval increase or arithmetic overflow\");\n\t\t}\n\n\t\t// delegate call to `approve` with the new value\n\t\treturn approve(_spender, currentVal + _value);\n\t}\n\n\t/**\n\t * @notice Decreases the allowance granted to `spender` by the caller.\n\t *\n\t * @dev Resolution for the Multiple Withdrawal Attack on ERC20 Tokens (arXiv:1907.00903)\n\t *\n\t * @dev Throws if value to decrease by is zero or is greater than currently allowed value\n\t *\n\t * @param _spender an address approved by the caller (token owner)\n\t *      to spend some tokens on its behalf\n\t * @param _value an amount of tokens to decrease by\n\t * @return success true on success, throws otherwise\n\t */\n\tfunction decreaseAllowance(address _spender, uint256 _value) public returns (bool) {\n\t\t// read current allowance value\n\t\tuint256 currentVal = transferAllowances[msg.sender][_spender];\n\n\t\t// non-zero _value check on the allowance\n\t\trequire(_value > 0, \"zero value approval decrease\");\n\n\t\t// verify allowance decrease doesn't underflow\n\t\trequire(currentVal >= _value, \"ERC20: decreased allowance below zero\");\n\n\t\t// delegate call to `approve` with the new value\n\t\treturn approve(_spender, currentVal - _value);\n\t}\n\n\t// ===== End: Resolution for the Multiple Withdrawal Attack on ERC20 Tokens (arXiv:1907.00903) =====\n\n\t// ===== Start: Minting/burning extension =====\n\n\t/**\n\t * @dev Mints (creates) some tokens to address specified\n\t * @dev The value specified is treated as is without taking\n\t *      into account what `decimals` value is\n\t *\n\t * @dev Requires executor to have `ROLE_TOKEN_CREATOR` permission\n\t *\n\t * @dev Throws on overflow, if totalSupply + _value doesn't fit into uint256\n\t *\n\t * @param _to an address to mint tokens to\n\t * @param _value an amount of tokens to mint (create)\n\t */\n\tfunction mint(address _to, uint256 _value) public {\n\t\t// check if caller has sufficient permissions to mint tokens\n\t\trequire(isSenderInRole(ROLE_TOKEN_CREATOR), \"access denied\");\n\n\t\t// non-zero recipient address check\n\t\trequire(_to != address(0), \"zero address\");\n\n\t\t// non-zero _value and arithmetic overflow check on the total supply\n\t\t// this check automatically secures arithmetic overflow on the individual balance\n\t\tunchecked {\n\t\t\t// put operation into unchecked block to display user-friendly overflow error message for Solidity 0.8+\n\t\t\trequire(totalSupply + _value > totalSupply, \"zero value or arithmetic overflow\");\n\t\t}\n\n\t\t// uint192 overflow check (required by voting delegation)\n\t\trequire(totalSupply + _value <= type(uint192).max, \"total supply overflow (uint192)\");\n\n\t\t// perform mint:\n\t\t// increase total amount of tokens value\n\t\ttotalSupply += _value;\n\n\t\t// increase `_to` address balance\n\t\ttokenBalances[_to] += _value;\n\n\t\t// update total token supply history\n\t\t__updateHistory(totalSupplyHistory, add, _value);\n\n\t\t// create voting power associated with the tokens minted\n\t\t__moveVotingPower(msg.sender, address(0), votingDelegates[_to], _value);\n\n\t\t// fire a minted event\n\t\temit Minted(msg.sender, _to, _value);\n\n\t\t// emit an improved transfer event (arXiv:1907.00903)\n\t\temit Transfer(msg.sender, address(0), _to, _value);\n\n\t\t// fire ERC20 compliant transfer event\n\t\temit Transfer(address(0), _to, _value);\n\t}\n\n\t/**\n\t * @dev Burns (destroys) some tokens from the address specified\n\t *\n\t * @dev The value specified is treated as is without taking\n\t *      into account what `decimals` value is\n\t *\n\t * @dev Requires executor to have `ROLE_TOKEN_DESTROYER` permission\n\t *      or FEATURE_OWN_BURNS/FEATURE_BURNS_ON_BEHALF features to be enabled\n\t *\n\t * @dev Can be disabled by the contract creator forever by disabling\n\t *      FEATURE_OWN_BURNS/FEATURE_BURNS_ON_BEHALF features and then revoking\n\t *      its own roles to burn tokens and to enable burning features\n\t *\n\t * @param _from an address to burn some tokens from\n\t * @param _value an amount of tokens to burn (destroy)\n\t */\n\tfunction burn(address _from, uint256 _value) public {\n\t\t// check if caller has sufficient permissions to burn tokens\n\t\t// and if not - check for possibility to burn own tokens or to burn on behalf\n\t\tif(!isSenderInRole(ROLE_TOKEN_DESTROYER)) {\n\t\t\t// if `_from` is equal to sender, require own burns feature to be enabled\n\t\t\t// otherwise require burns on behalf feature to be enabled\n\t\t\trequire(_from == msg.sender && isFeatureEnabled(FEATURE_OWN_BURNS)\n\t\t\t     || _from != msg.sender && isFeatureEnabled(FEATURE_BURNS_ON_BEHALF),\n\t\t\t        _from == msg.sender? \"burns are disabled\": \"burns on behalf are disabled\");\n\n\t\t\t// in case of burn on behalf\n\t\t\tif(_from != msg.sender) {\n\t\t\t\t// read allowance value - the amount of tokens allowed to be burnt - into the stack\n\t\t\t\tuint256 _allowance = transferAllowances[_from][msg.sender];\n\n\t\t\t\t// verify sender has an allowance to burn amount of tokens requested\n\t\t\t\trequire(_allowance >= _value, \"burn amount exceeds allowance\");\n\n\t\t\t\t// we treat max uint256 allowance value as an \"unlimited\" and\n\t\t\t\t// do not decrease allowance when it is set to \"unlimited\" value\n\t\t\t\tif(_allowance < type(uint256).max) {\n\t\t\t\t\t// update allowance value on the stack\n\t\t\t\t\t_allowance -= _value;\n\n\t\t\t\t\t// update the allowance value in storage\n\t\t\t\t\ttransferAllowances[_from][msg.sender] = _allowance;\n\n\t\t\t\t\t// emit an improved atomic approve event (arXiv:1907.00903)\n\t\t\t\t\temit Approval(msg.sender, _from, _allowance + _value, _allowance);\n\n\t\t\t\t\t// emit an ERC20 approval event to reflect the decrease\n\t\t\t\t\temit Approval(_from, msg.sender, _allowance);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// at this point we know that either sender is ROLE_TOKEN_DESTROYER or\n\t\t// we burn own tokens or on behalf (in latest case we already checked and updated allowances)\n\t\t// we have left to execute balance checks and burning logic itself\n\n\t\t// non-zero burn value check\n\t\trequire(_value != 0, \"zero value burn\");\n\n\t\t// non-zero source address check - Zeppelin\n\t\trequire(_from != address(0), \"burn from the zero address\");\n\n\t\t// verify `_from` address has enough tokens to destroy\n\t\t// (basically this is a arithmetic overflow check)\n\t\trequire(tokenBalances[_from] >= _value, \"burn amount exceeds balance\");\n\n\t\t// perform burn:\n\t\t// decrease `_from` address balance\n\t\ttokenBalances[_from] -= _value;\n\n\t\t// decrease total amount of tokens value\n\t\ttotalSupply -= _value;\n\n\t\t// update total token supply history\n\t\t__updateHistory(totalSupplyHistory, sub, _value);\n\n\t\t// destroy voting power associated with the tokens burnt\n\t\t__moveVotingPower(msg.sender, votingDelegates[_from], address(0), _value);\n\n\t\t// fire a burnt event\n\t\temit Burnt(msg.sender, _from, _value);\n\n\t\t// emit an improved transfer event (arXiv:1907.00903)\n\t\temit Transfer(msg.sender, _from, address(0), _value);\n\n\t\t// fire ERC20 compliant transfer event\n\t\temit Transfer(_from, address(0), _value);\n\t}\n\n\t// ===== End: Minting/burning extension =====\n\n\t// ===== Start: EIP-2612 functions =====\n\n\t/**\n\t * @inheritdoc EIP2612\n\t *\n\t * @dev Executes approve(_spender, _value) on behalf of the owner who EIP-712\n\t *      signed the transaction, i.e. as if transaction sender is the EIP712 signer\n\t *\n\t * @dev Sets the `_value` as the allowance of `_spender` over `_owner` tokens,\n\t *      given `_owner` EIP-712 signed approval\n\t *\n\t * @dev Inherits the Multiple Withdrawal Attack on ERC20 Tokens (arXiv:1907.00903)\n\t *      vulnerability in the same way as ERC20 `approve`, use standard ERC20 workaround\n\t *      if this might become an issue:\n\t *      https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit\n\t *\n\t * @dev Emits `Approval` event(s) in the same way as `approve` does\n\t *\n\t * @dev Requires:\n\t *     - `_spender` to be non-zero address\n\t *     - `_exp` to be a timestamp in the future\n\t *     - `v`, `r` and `s` to be a valid `secp256k1` signature from `_owner`\n\t *        over the EIP712-formatted function arguments.\n\t *     - the signature to use `_owner` current nonce (see `nonces`).\n\t *\n\t * @dev For more information on the signature format, see the\n\t *      https://eips.ethereum.org/EIPS/eip-2612#specification\n\t *\n\t * @param _owner owner of the tokens to set approval on behalf of,\n\t *      an address which signed the EIP-712 message\n\t * @param _spender an address approved by the token owner\n\t *      to spend some tokens on its behalf\n\t * @param _value an amount of tokens spender `_spender` is allowed to\n\t *      transfer on behalf of the token owner\n\t * @param _exp signature expiration time (unix timestamp)\n\t * @param v the recovery byte of the signature\n\t * @param r half of the ECDSA signature pair\n\t * @param s half of the ECDSA signature pair\n\t */\n\tfunction permit(address _owner, address _spender, uint256 _value, uint256 _exp, uint8 v, bytes32 r, bytes32 s) public override {\n\t\t// verify permits are enabled\n\t\trequire(isFeatureEnabled(FEATURE_EIP2612_PERMITS), \"EIP2612 permits are disabled\");\n\n\t\t// derive signer of the EIP712 Permit message, and\n\t\t// update the nonce for that particular signer to avoid replay attack!!! --------->>> ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓\n\t\taddress signer = __deriveSigner(abi.encode(PERMIT_TYPEHASH, _owner, _spender, _value, nonces[_owner]++, _exp), v, r, s);\n\n\t\t// perform message integrity and security validations\n\t\trequire(signer == _owner, \"invalid signature\");\n\t\trequire(block.timestamp < _exp, \"signature expired\");\n\n\t\t// delegate call to `__approve` - execute the logic required\n\t\t__approve(_owner, _spender, _value);\n\t}\n\n\t// ===== End: EIP-2612 functions =====\n\n\t// ===== Start: EIP-3009 functions =====\n\n\t/**\n\t * @inheritdoc EIP3009\n\t *\n\t * @notice Checks if specified nonce was already used\n\t *\n\t * @dev Nonces are expected to be client-side randomly generated 32-byte values\n\t *      unique to the authorizer's address\n\t *\n\t * @dev Alias for usedNonces(authorizer, nonce)\n\t *\n\t * @param _authorizer an address to check nonce for\n\t * @param _nonce a nonce to check\n\t * @return true if the nonce was used, false otherwise\n\t */\n\tfunction authorizationState(address _authorizer, bytes32 _nonce) public override view returns (bool) {\n\t\t// simply return the value from the mapping\n\t\treturn usedNonces[_authorizer][_nonce];\n\t}\n\n\t/**\n\t * @inheritdoc EIP3009\n\t *\n\t * @notice Execute a transfer with a signed authorization\n\t *\n\t * @param _from token sender and transaction authorizer\n\t * @param _to token receiver\n\t * @param _value amount to be transferred\n\t * @param _validAfter signature valid after time (unix timestamp)\n\t * @param _validBefore signature valid before time (unix timestamp)\n\t * @param _nonce unique random nonce\n\t * @param v the recovery byte of the signature\n\t * @param r half of the ECDSA signature pair\n\t * @param s half of the ECDSA signature pair\n\t */\n\tfunction transferWithAuthorization(\n\t\taddress _from,\n\t\taddress _to,\n\t\tuint256 _value,\n\t\tuint256 _validAfter,\n\t\tuint256 _validBefore,\n\t\tbytes32 _nonce,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) public override {\n\t\t// ensure EIP-3009 transfers are enabled\n\t\trequire(isFeatureEnabled(FEATURE_EIP3009_TRANSFERS), \"EIP3009 transfers are disabled\");\n\n\t\t// derive signer of the EIP712 TransferWithAuthorization message\n\t\taddress signer = __deriveSigner(abi.encode(TRANSFER_WITH_AUTHORIZATION_TYPEHASH, _from, _to, _value, _validAfter, _validBefore, _nonce), v, r, s);\n\n\t\t// perform message integrity and security validations\n\t\trequire(signer == _from, \"invalid signature\");\n\t\trequire(block.timestamp > _validAfter, \"signature not yet valid\");\n\t\trequire(block.timestamp < _validBefore, \"signature expired\");\n\n\t\t// use the nonce supplied (verify, mark as used, emit event)\n\t\t__useNonce(_from, _nonce, false);\n\n\t\t// delegate call to `__transferFrom` - execute the logic required\n\t\t__transferFrom(signer, _from, _to, _value);\n\t}\n\n\t/**\n\t * @inheritdoc EIP3009\n\t *\n\t * @notice Receive a transfer with a signed authorization from the payer\n\t *\n\t * @dev This has an additional check to ensure that the payee's address\n\t *      matches the caller of this function to prevent front-running attacks.\n\t *\n\t * @param _from token sender and transaction authorizer\n\t * @param _to token receiver\n\t * @param _value amount to be transferred\n\t * @param _validAfter signature valid after time (unix timestamp)\n\t * @param _validBefore signature valid before time (unix timestamp)\n\t * @param _nonce unique random nonce\n\t * @param v the recovery byte of the signature\n\t * @param r half of the ECDSA signature pair\n\t * @param s half of the ECDSA signature pair\n\t */\n\tfunction receiveWithAuthorization(\n\t\taddress _from,\n\t\taddress _to,\n\t\tuint256 _value,\n\t\tuint256 _validAfter,\n\t\tuint256 _validBefore,\n\t\tbytes32 _nonce,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) public override {\n\t\t// verify EIP3009 receptions are enabled\n\t\trequire(isFeatureEnabled(FEATURE_EIP3009_RECEPTIONS), \"EIP3009 receptions are disabled\");\n\n\t\t// derive signer of the EIP712 ReceiveWithAuthorization message\n\t\taddress signer = __deriveSigner(abi.encode(RECEIVE_WITH_AUTHORIZATION_TYPEHASH, _from, _to, _value, _validAfter, _validBefore, _nonce), v, r, s);\n\n\t\t// perform message integrity and security validations\n\t\trequire(signer == _from, \"invalid signature\");\n\t\trequire(block.timestamp > _validAfter, \"signature not yet valid\");\n\t\trequire(block.timestamp < _validBefore, \"signature expired\");\n\t\trequire(_to == msg.sender, \"access denied\");\n\n\t\t// use the nonce supplied (verify, mark as used, emit event)\n\t\t__useNonce(_from, _nonce, false);\n\n\t\t// delegate call to `__transferFrom` - execute the logic required\n\t\t__transferFrom(signer, _from, _to, _value);\n\t}\n\n\t/**\n\t * @inheritdoc EIP3009\n\t *\n\t * @notice Attempt to cancel an authorization\n\t *\n\t * @param _authorizer transaction authorizer\n\t * @param _nonce unique random nonce to cancel (mark as used)\n\t * @param v the recovery byte of the signature\n\t * @param r half of the ECDSA signature pair\n\t * @param s half of the ECDSA signature pair\n\t */\n\tfunction cancelAuthorization(\n\t\taddress _authorizer,\n\t\tbytes32 _nonce,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) public override {\n\t\t// derive signer of the EIP712 ReceiveWithAuthorization message\n\t\taddress signer = __deriveSigner(abi.encode(CANCEL_AUTHORIZATION_TYPEHASH, _authorizer, _nonce), v, r, s);\n\n\t\t// perform message integrity and security validations\n\t\trequire(signer == _authorizer, \"invalid signature\");\n\n\t\t// cancel the nonce supplied (verify, mark as used, emit event)\n\t\t__useNonce(_authorizer, _nonce, true);\n\t}\n\n\t/**\n\t * @dev Auxiliary function to verify structured EIP712 message signature and derive its signer\n\t *\n\t * @param abiEncodedTypehash abi.encode of the message typehash together with all its parameters\n\t * @param v the recovery byte of the signature\n\t * @param r half of the ECDSA signature pair\n\t * @param s half of the ECDSA signature pair\n\t */\n\tfunction __deriveSigner(bytes memory abiEncodedTypehash, uint8 v, bytes32 r, bytes32 s) private view returns(address) {\n\t\t// build the EIP-712 hashStruct of the message\n\t\tbytes32 hashStruct = keccak256(abiEncodedTypehash);\n\n\t\t// calculate the EIP-712 digest \"\\x19\\x01\" ‖ domainSeparator ‖ hashStruct(message)\n\t\tbytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR, hashStruct));\n\n\t\t// recover the address which signed the message with v, r, s\n\t\taddress signer = ECDSA.recover(digest, v, r, s);\n\n\t\t// return the signer address derived from the signature\n\t\treturn signer;\n\t}\n\n\t/**\n\t * @dev Auxiliary function to use/cancel the nonce supplied for a given authorizer:\n\t *      1. Verifies the nonce was not used before\n\t *      2. Marks the nonce as used\n\t *      3. Emits an event that the nonce was used/cancelled\n\t *\n\t * @dev Set `_cancellation` to false (default) to use nonce,\n\t *      set `_cancellation` to true to cancel nonce\n\t *\n\t * @dev It is expected that the nonce supplied is a randomly\n\t *      generated uint256 generated by the client\n\t *\n\t * @param _authorizer an address to use/cancel nonce for\n\t * @param _nonce random nonce to use\n\t * @param _cancellation true to emit `AuthorizationCancelled`, false to emit `AuthorizationUsed` event\n\t */\n\tfunction __useNonce(address _authorizer, bytes32 _nonce, bool _cancellation) private {\n\t\t// verify nonce was not used before\n\t\trequire(!usedNonces[_authorizer][_nonce], \"invalid nonce\");\n\n\t\t// update the nonce state to \"used\" for that particular signer to avoid replay attack\n\t\tusedNonces[_authorizer][_nonce] = true;\n\n\t\t// depending on the usage type (use/cancel)\n\t\tif(_cancellation) {\n\t\t\t// emit an event regarding the nonce cancelled\n\t\t\temit AuthorizationCanceled(_authorizer, _nonce);\n\t\t}\n\t\telse {\n\t\t\t// emit an event regarding the nonce used\n\t\t\temit AuthorizationUsed(_authorizer, _nonce);\n\t\t}\n\t}\n\n\t// ===== End: EIP-3009 functions =====\n\n\t// ===== Start: DAO Support (Compound-like voting delegation) =====\n\n\t/**\n\t * @notice Gets current voting power of the account `_of`\n\t *\n\t * @param _of the address of account to get voting power of\n\t * @return current cumulative voting power of the account,\n\t *      sum of token balances of all its voting delegators\n\t */\n\tfunction votingPowerOf(address _of) public view returns (uint256) {\n\t\t// get a link to an array of voting power history records for an address specified\n\t\tKV[] storage history = votingPowerHistory[_of];\n\n\t\t// lookup the history and return latest element\n\t\treturn history.length == 0? 0: history[history.length - 1].v;\n\t}\n\n\t/**\n\t * @notice Gets past voting power of the account `_of` at some block `_blockNum`\n\t *\n\t * @dev Throws if `_blockNum` is not in the past (not the finalized block)\n\t *\n\t * @param _of the address of account to get voting power of\n\t * @param _blockNum block number to get the voting power at\n\t * @return past cumulative voting power of the account,\n\t *      sum of token balances of all its voting delegators at block number `_blockNum`\n\t */\n\tfunction votingPowerAt(address _of, uint256 _blockNum) public view returns (uint256) {\n\t\t// make sure block number is not in the past (not the finalized block)\n\t\trequire(_blockNum < block.number, \"block not yet mined\"); // Compound msg not yet determined\n\n\t\t// `votingPowerHistory[_of]` is an array ordered by `blockNumber`, ascending;\n\t\t// apply binary search on `votingPowerHistory[_of]` to find such an entry number `i`, that\n\t\t// `votingPowerHistory[_of][i].k <= _blockNum`, but in the same time\n\t\t// `votingPowerHistory[_of][i + 1].k > _blockNum`\n\t\t// return the result - voting power found at index `i`\n\t\treturn __binaryLookup(votingPowerHistory[_of], _blockNum);\n\t}\n\n\t/**\n\t * @dev Reads an entire voting power history array for the delegate specified\n\t *\n\t * @param _of delegate to query voting power history for\n\t * @return voting power history array for the delegate of interest\n\t */\n\tfunction votingPowerHistoryOf(address _of) public view returns(KV[] memory) {\n\t\t// return an entire array as memory\n\t\treturn votingPowerHistory[_of];\n\t}\n\n\t/**\n\t * @dev Returns length of the voting power history array for the delegate specified;\n\t *      useful since reading an entire array just to get its length is expensive (gas cost)\n\t *\n\t * @param _of delegate to query voting power history length for\n\t * @return voting power history array length for the delegate of interest\n\t */\n\tfunction votingPowerHistoryLength(address _of) public view returns(uint256) {\n\t\t// read array length and return\n\t\treturn votingPowerHistory[_of].length;\n\t}\n\n\t/**\n\t * @notice Gets past total token supply value at some block `_blockNum`\n\t *\n\t * @dev Throws if `_blockNum` is not in the past (not the finalized block)\n\t *\n\t * @param _blockNum block number to get the total token supply at\n\t * @return past total token supply at block number `_blockNum`\n\t */\n\tfunction totalSupplyAt(uint256 _blockNum) public view returns(uint256) {\n\t\t// make sure block number is not in the past (not the finalized block)\n\t\trequire(_blockNum < block.number, \"block not yet mined\");\n\n\t\t// `totalSupplyHistory` is an array ordered by `k`, ascending;\n\t\t// apply binary search on `totalSupplyHistory` to find such an entry number `i`, that\n\t\t// `totalSupplyHistory[i].k <= _blockNum`, but in the same time\n\t\t// `totalSupplyHistory[i + 1].k > _blockNum`\n\t\t// return the result - value `totalSupplyHistory[i].v` found at index `i`\n\t\treturn __binaryLookup(totalSupplyHistory, _blockNum);\n\t}\n\n\t/**\n\t * @dev Reads an entire total token supply history array\n\t *\n\t * @return total token supply history array, a key-value pair array,\n\t *      where key is a block number and value is total token supply at that block\n\t */\n\tfunction entireSupplyHistory() public view returns(KV[] memory) {\n\t\t// return an entire array as memory\n\t\treturn totalSupplyHistory;\n\t}\n\n\t/**\n\t * @dev Returns length of the total token supply history array;\n\t *      useful since reading an entire array just to get its length is expensive (gas cost)\n\t *\n\t * @return total token supply history array\n\t */\n\tfunction totalSupplyHistoryLength() public view returns(uint256) {\n\t\t// read array length and return\n\t\treturn totalSupplyHistory.length;\n\t}\n\n\t/**\n\t * @notice Delegates voting power of the delegator `msg.sender` to the delegate `_to`\n\t *\n\t * @dev Accepts zero value address to delegate voting power to, effectively\n\t *      removing the delegate in that case\n\t *\n\t * @param _to address to delegate voting power to\n\t */\n\tfunction delegate(address _to) public {\n\t\t// verify delegations are enabled\n\t\trequire(isFeatureEnabled(FEATURE_DELEGATIONS), \"delegations are disabled\");\n\t\t// delegate call to `__delegate`\n\t\t__delegate(msg.sender, _to);\n\t}\n\n\t/**\n\t * @dev Powers the meta transaction for `delegate` - `delegateWithAuthorization`\n\t *\n\t * @dev Auxiliary function to delegate delegator's `_from` voting power to the delegate `_to`\n\t * @dev Writes to `votingDelegates` and `votingPowerHistory` mappings\n\t *\n\t * @param _from delegator who delegates his voting power\n\t * @param _to delegate who receives the voting power\n\t */\n\tfunction __delegate(address _from, address _to) private {\n\t\t// read current delegate to be replaced by a new one\n\t\taddress _fromDelegate = votingDelegates[_from];\n\n\t\t// read current voting power (it is equal to token balance)\n\t\tuint256 _value = tokenBalances[_from];\n\n\t\t// reassign voting delegate to `_to`\n\t\tvotingDelegates[_from] = _to;\n\n\t\t// update voting power for `_fromDelegate` and `_to`\n\t\t__moveVotingPower(_from, _fromDelegate, _to, _value);\n\n\t\t// emit an event\n\t\temit DelegateChanged(_from, _fromDelegate, _to);\n\t}\n\n\t/**\n\t * @notice Delegates voting power of the delegator (represented by its signature) to the delegate `_to`\n\t *\n\t * @dev Accepts zero value address to delegate voting power to, effectively\n\t *      removing the delegate in that case\n\t *\n\t * @dev Compliant with EIP-712: Ethereum typed structured data hashing and signing,\n\t *      see https://eips.ethereum.org/EIPS/eip-712\n\t *\n\t * @param _to address to delegate voting power to\n\t * @param _nonce nonce used to construct the signature, and used to validate it;\n\t *      nonce is increased by one after successful signature validation and vote delegation\n\t * @param _exp signature expiration time\n\t * @param v the recovery byte of the signature\n\t * @param r half of the ECDSA signature pair\n\t * @param s half of the ECDSA signature pair\n\t */\n\tfunction delegateWithAuthorization(address _to, bytes32 _nonce, uint256 _exp, uint8 v, bytes32 r, bytes32 s) public {\n\t\t// verify delegations on behalf are enabled\n\t\trequire(isFeatureEnabled(FEATURE_DELEGATIONS_ON_BEHALF), \"delegations on behalf are disabled\");\n\n\t\t// derive signer of the EIP712 Delegation message\n\t\taddress signer = __deriveSigner(abi.encode(DELEGATION_TYPEHASH, _to, _nonce, _exp), v, r, s);\n\n\t\t// perform message integrity and security validations\n\t\trequire(block.timestamp < _exp, \"signature expired\"); // Compound msg\n\n\t\t// use the nonce supplied (verify, mark as used, emit event)\n\t\t__useNonce(signer, _nonce, false);\n\n\t\t// delegate call to `__delegate` - execute the logic required\n\t\t__delegate(signer, _to);\n\t}\n\n\t/**\n\t * @dev Auxiliary function to move voting power `_value`\n\t *      from delegate `_from` to the delegate `_to`\n\t *\n\t * @dev Doesn't have any effect if `_from == _to`, or if `_value == 0`\n\t *\n\t * @param _by an address which executed delegate, mint, burn, or transfer operation\n\t *      which had led to delegate voting power change\n\t * @param _from delegate to move voting power from\n\t * @param _to delegate to move voting power to\n\t * @param _value voting power to move from `_from` to `_to`\n\t */\n\tfunction __moveVotingPower(address _by, address _from, address _to, uint256 _value) private {\n\t\t// if there is no move (`_from == _to`) or there is nothing to move (`_value == 0`)\n\t\tif(_from == _to || _value == 0) {\n\t\t\t// return silently with no action\n\t\t\treturn;\n\t\t}\n\n\t\t// if source address is not zero - decrease its voting power\n\t\tif(_from != address(0)) {\n\t\t\t// get a link to an array of voting power history records for an address specified\n\t\t\tKV[] storage _h = votingPowerHistory[_from];\n\n\t\t\t// update source voting power: decrease by `_value`\n\t\t\t(uint256 _fromVal, uint256 _toVal) = __updateHistory(_h, sub, _value);\n\n\t\t\t// emit an event\n\t\t\temit VotingPowerChanged(_by, _from, _fromVal, _toVal);\n\t\t}\n\n\t\t// if destination address is not zero - increase its voting power\n\t\tif(_to != address(0)) {\n\t\t\t// get a link to an array of voting power history records for an address specified\n\t\t\tKV[] storage _h = votingPowerHistory[_to];\n\n\t\t\t// update destination voting power: increase by `_value`\n\t\t\t(uint256 _fromVal, uint256 _toVal) = __updateHistory(_h, add, _value);\n\n\t\t\t// emit an event\n\t\t\temit VotingPowerChanged(_by, _to, _fromVal, _toVal);\n\t\t}\n\t}\n\n\t/**\n\t * @dev Auxiliary function to append key-value pair to an array,\n\t *      sets the key to the current block number and\n\t *      value as derived\n\t *\n\t * @param _h array of key-value pairs to append to\n\t * @param op a function (add/subtract) to apply\n\t * @param _delta the value for a key-value pair to add/subtract\n\t */\n\tfunction __updateHistory(\n\t\tKV[] storage _h,\n\t\tfunction(uint256,uint256) pure returns(uint256) op,\n\t\tuint256 _delta\n\t) private returns(uint256 _fromVal, uint256 _toVal) {\n\t\t// init the old value - value of the last pair of the array\n\t\t_fromVal = _h.length == 0? 0: _h[_h.length - 1].v;\n\t\t// init the new value - result of the operation on the old value\n\t\t_toVal = op(_fromVal, _delta);\n\n\t\t// if there is an existing voting power value stored for current block\n\t\tif(_h.length != 0 && _h[_h.length - 1].k == block.number) {\n\t\t\t// update voting power which is already stored in the current block\n\t\t\t_h[_h.length - 1].v = uint192(_toVal);\n\t\t}\n\t\t// otherwise - if there is no value stored for current block\n\t\telse {\n\t\t\t// add new element into array representing the value for current block\n\t\t\t_h.push(KV(uint64(block.number), uint192(_toVal)));\n\t\t}\n\t}\n\n\t/**\n\t * @dev Auxiliary function to lookup for a value in a sorted by key (ascending)\n\t *      array of key-value pairs\n\t *\n\t * @dev This function finds a key-value pair element in an array with the closest key\n\t *      to the key of interest (not exceeding that key) and returns the value\n\t *      of the key-value pair element found\n\t *\n\t * @dev An array to search in is a KV[] key-value pair array ordered by key `k`,\n\t *      it is sorted in ascending order (`k` increases as array index increases)\n\t *\n\t * @dev Returns zero for an empty array input regardless of the key input\n\t *\n\t * @param _h an array of key-value pair elements to search in\n\t * @param _k key of interest to look the value for\n\t * @return the value of the key-value pair of the key-value pair element with the closest\n\t *      key to the key of interest (not exceeding that key)\n\t */\n\tfunction __binaryLookup(KV[] storage _h, uint256 _k) private view returns(uint256) {\n\t\t// if an array is empty, there is nothing to lookup in\n\t\tif(_h.length == 0) {\n\t\t\t// by documented agreement, fall back to a zero result\n\t\t\treturn 0;\n\t\t}\n\n\t\t// check last key-value pair key:\n\t\t// if the key is smaller than the key of interest\n\t\tif(_h[_h.length - 1].k <= _k) {\n\t\t\t// we're done - return the value from the last element\n\t\t\treturn _h[_h.length - 1].v;\n\t\t}\n\n\t\t// check first voting power history record block number:\n\t\t// if history was never updated before the block of interest\n\t\tif(_h[0].k > _k) {\n\t\t\t// we're done - voting power at the block num of interest was zero\n\t\t\treturn 0;\n\t\t}\n\n\t\t// left bound of the search interval, originally start of the array\n\t\tuint256 i = 0;\n\n\t\t// right bound of the search interval, originally end of the array\n\t\tuint256 j = _h.length - 1;\n\n\t\t// the iteration process narrows down the bounds by\n\t\t// splitting the interval in a half oce per each iteration\n\t\twhile(j > i) {\n\t\t\t// get an index in the middle of the interval [i, j]\n\t\t\tuint256 k = j - (j - i) / 2;\n\n\t\t\t// read an element to compare it with the value of interest\n\t\t\tKV memory kv = _h[k];\n\n\t\t\t// if we've got a strict equal - we're lucky and done\n\t\t\tif(kv.k == _k) {\n\t\t\t\t// just return the result - pair value at index `k`\n\t\t\t\treturn kv.v;\n\t\t\t}\n\t\t\t// if the value of interest is larger - move left bound to the middle\n\t\t\telse if (kv.k < _k) {\n\t\t\t\t// move left bound `i` to the middle position `k`\n\t\t\t\ti = k;\n\t\t\t}\n\t\t\t// otherwise, when the value of interest is smaller - move right bound to the middle\n\t\t\telse {\n\t\t\t\t// move right bound `j` to the middle position `k - 1`:\n\t\t\t\t// element at position `k` is greater and cannot be the result\n\t\t\t\tj = k - 1;\n\t\t\t}\n\t\t}\n\n\t\t// reaching that point means no exact match found\n\t\t// since we're interested in the element which is not larger than the\n\t\t// element of interest, we return the lower bound `i`\n\t\treturn _h[i].v;\n\t}\n\n\t/**\n\t * @dev Adds a + b\n\t *      Function is used as a parameter for other functions\n\t *\n\t * @param a addition term 1\n\t * @param b addition term 2\n\t * @return a + b\n\t */\n\tfunction add(uint256 a, uint256 b) private pure returns(uint256) {\n\t\t// add `a` to `b` and return\n\t\treturn a + b;\n\t}\n\n\t/**\n\t * @dev Subtracts a - b\n\t *      Function is used as a parameter for other functions\n\t *\n\t * @dev Requires a ≥ b\n\t *\n\t * @param a subtraction term 1\n\t * @param b subtraction term 2, b ≤ a\n\t * @return a - b\n\t */\n\tfunction sub(uint256 a, uint256 b) private pure returns(uint256) {\n\t\t// subtract `b` from `a` and return\n\t\treturn a - b;\n\t}\n\n\t// ===== End: DAO Support (Compound-like voting delegation) =====\n}\n\n/**\n * @title Artificial Liquid Intelligence ERC20 Token (Alethea, ALI)\n *\n * @notice Ethereum mainnet implementation with the fixed supply 10,000,000,000 ALI (non-configurable)\n *\n * @author Basil Gorin\n */\ncontract AliERC20v2 is AliERC20v2Base {\n\t/**\n\t * @dev Deploys the token smart contract,\n\t *      assigns initial token supply to the address specified\n\t *\n\t * @param _initialHolder owner of the initial token supply\n\t */\n\tconstructor(address _initialHolder) AliERC20v2Base(_initialHolder, 10_000_000_000e18) {}\n}\n\n"
    },
    "contracts/token/PolygonAliERC20v2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./AliERC20v2.sol\";\n\n/**\n * @title Artificial Liquid Intelligence ERC20 Token (With Polygon Support)\n *\n * @notice Polygon extension contract ads the functions required to bridge original\n *      ALI token on Ethereum L1; these are mint and burn functions executed\n *      when the tokens are deposited from from Ethereum L1 into Polygon L2 (mint),\n *      and when the tokens are withdrawn back from Polygon L2 into Ethereum L1 (burn).\n *\n * @notice Read more:\n *      https://docs.polygon.technology/docs/develop/ethereum-polygon/mintable-assets\n */\ncontract PolygonAliERC20v2 is AliERC20v2Base {\n\n\t/**\n\t * @dev Constructs/deploys Polygon ALI instance,\n\t *      assigns initial token supply to the address specified\n\t */\n\tconstructor() AliERC20v2Base(address(0), 0) {}\n\n\t/**\n\t * @notice Executed by ChildChainManager when token is deposited on the root chain\n\t *\n\t * @dev Executable only by ChildChainManager which should be given the minting\n\t *      permission as part of the smart contract deployment process;\n\t *      handles the deposit by minting the required amount for user\n\t *\n\t * @param user user address for whom deposit is being done\n\t * @param depositData abi encoded amount\n\t */\n\tfunction deposit(address user, bytes calldata depositData) external {\n\t\t// extract the amount value to mint from the calldata\n\t\tuint256 amount = abi.decode(depositData, (uint256));\n\n\t\t// delegate to `mint`\n\t\tmint(user, amount);\n\t}\n\n\t/**\n\t * @notice Executed by the tokens owner when they want to withdraw tokens back to the root chain\n\t *\n\t * @dev Burns user's tokens;\n\t *      this transaction will be verified when exiting on the root chain\n\t *\n\t * @param amount amount of tokens to withdraw\n\t */\n\tfunction withdraw(uint256 amount) external {\n\t\t// delegate to the `burn` function\n\t\tburn(msg.sender, amount);\n\t}\n}\n"
    },
    "contracts/mocks/ERC1363Mock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ERC1363Spec.sol\";\n\n/// @dev Mock for ERC1363Receiver/ERC1363Spender interfaces\ncontract ERC1363Mock is ERC1363Receiver, ERC1363Spender {\n\t// an event to be fired in `onTransferReceived`\n\tevent OnTransferReceived(address indexed operator, address indexed from, uint256 value, bytes data);\n\t// an event to be fired in `onApprovalReceived`\n\tevent OnApprovalReceived(address indexed owner, uint256 value, bytes data);\n\n\t/// @inheritdoc ERC1363Receiver\n\tfunction onTransferReceived(address operator, address from, uint256 value, bytes memory data) public override returns (bytes4) {\n\t\t// emit an event\n\t\temit OnTransferReceived(operator, from, value, data);\n\n\t\t// always return \"success\"\n\t\treturn ERC1363Receiver(this).onTransferReceived.selector;\n\t}\n\n\t/// @inheritdoc ERC1363Spender\n\tfunction onApprovalReceived(address owner, uint256 value, bytes memory data) external override returns (bytes4) {\n\t\t// emit an event\n\t\temit OnApprovalReceived(owner, value, data);\n\n\t\t// always return \"success\"\n\t\treturn ERC1363Spender(this).onApprovalReceived.selector;\n\t}\n}\n\n// mock class using IERC1363Receiver\ncontract ERC1363ReceiverMock is ERC1363Receiver {\n\tbytes4 private _retval;\n\tbool private _reverts;\n\n\tevent Received(\n\t\taddress operator,\n\t\taddress sender,\n\t\tuint256 amount,\n\t\tbytes data,\n\t\tuint256 gas\n\t);\n\n\tconstructor(bytes4 retval, bool reverts) {\n\t\t_retval = retval;\n\t\t_reverts = reverts;\n\t}\n\n\tfunction onTransferReceived(address operator, address sender, uint256 amount, bytes memory data) public override returns (bytes4) {\n\t\trequire(!_reverts, \"ERC1363ReceiverMock: throwing\");\n\t\temit Received(operator, sender, amount, data, gasleft());\n\t\treturn _retval;\n\t}\n}\n\n// mock class using IERC1363Spender\ncontract ERC1363SpenderMock is ERC1363Spender {\n\tbytes4 private _retval;\n\tbool private _reverts;\n\n\tevent Approved(\n\t\taddress sender,\n\t\tuint256 amount,\n\t\tbytes data,\n\t\tuint256 gas\n\t);\n\n\tconstructor(bytes4 retval, bool reverts) {\n\t\t_retval = retval;\n\t\t_reverts = reverts;\n\t}\n\n\tfunction onApprovalReceived(address sender, uint256 amount, bytes memory data) public override returns (bytes4) {\n\t\trequire(!_reverts, \"ERC1363SpenderMock: throwing\");\n\t\temit Approved(sender, amount, data, gasleft());\n\t\treturn _retval;\n\t}\n}\n"
    },
    "contracts/protocol/OpenSeaFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ERC165Spec.sol\";\nimport \"../interfaces/ERC721Spec.sol\";\nimport \"../interfaces/ERC721SpecExt.sol\";\nimport \"../lib/StringUtils.sol\";\nimport \"../utils/AccessControl.sol\";\n\n/**\n * @title OpenSea ERC721 Factory interface\n *\n * @notice In order to mint items only when they're purchased, OpenSea provides a Factory interface\n *      that is used to define how the items will be minted.\n *      See https://docs.opensea.io/docs/2-custom-item-sale-contract\n *\n * @notice This is a generic factory contract that can be used to mint tokens. The configuration\n *      for minting is specified by an _optionId, which can be used to delineate various\n *      ways of minting.\n *\n * @dev Copy of the OpenSea interface:\n *      https://github.com/ProjectOpenSea/opensea-creatures/blob/master/contracts/IFactoryERC721.sol\n */\ninterface OpenSeaFactoryERC721 is ERC165 {\n\t/**\n\t * @dev Returns the name of this factory.\n\t */\n\tfunction name() external view returns (string memory);\n\n\t/**\n\t * @dev Returns the symbol for this factory.\n\t */\n\tfunction symbol() external view returns (string memory);\n\n\t/**\n\t * @dev Number of options the factory supports.\n\t */\n\tfunction numOptions() external view returns (uint256);\n\n\t/**\n\t * @dev Returns whether the option ID can be minted. Can return false if the developer wishes to\n\t *      restrict a total supply per option ID (or overall).\n\t */\n\tfunction canMint(uint256 _optionId) external view returns (bool);\n\n\t/**\n\t * @dev Returns a URL specifying some metadata about the option. This metadata can be of the\n\t *      same structure as the ERC721 metadata.\n\t */\n\tfunction tokenURI(uint256 _optionId) external view returns (string memory);\n\n\t/**\n\t * @dev Indicates that this is a factory contract. Ideally would use EIP 165 supportsInterface()\n\t */\n\tfunction supportsFactoryInterface() external view returns (bool);\n\n\t/**\n\t * @dev Mints asset(s) in accordance to a specific address with a particular \"option\". This should be\n\t *      callable only by the contract owner or the owner's Wyvern Proxy (later universal login will solve this).\n\t *      Options should also be delineated 0 - (numOptions() - 1) for convenient indexing.\n\t * @param _optionId the option id\n\t * @param _toAddress address of the future owner of the asset(s)\n\t */\n\tfunction mint(uint256 _optionId, address _toAddress) external;\n}\n\n/**\n * @dev An OpenSea delegate proxy interface which we use in ProxyRegistry.\n *      We use it to give compiler a hint that ProxyRegistry.proxies() needs to be\n *      converted to the address type explicitly\n */\ninterface OwnableDelegateProxy {}\n\n/**\n * @dev OpenSea Proxy Registry determines which address (wrapped as OwnableDelegateProxy)\n *      is allowed to mint an option at any given time\n * @dev OpenSea takes care to set it properly when an option is being bought\n */\ninterface ProxyRegistry {\n\t/**\n\t * @dev Maps owner address => eligible option minter address wrapped as OwnableDelegateProxy\n\t */\n\tfunction proxies(address) external view returns(OwnableDelegateProxy);\n}\n\n/**\n * @title OpenSea ERC721 Factory implementation\n *\n * @notice OpenSea Factory interface implementation, NFT minter contract,\n *      powers the OpenSea sale of the 9,900 personalities of the 10k sale campaign\n *\n * @dev Links to PersonalityPodERC721 smart contract on deployment, allows OpenSea to mint\n *      PersonalityPodERC721 from 101 to 10,000 (both bounds inclusive)\n *\n * @dev Each OpenSea Factory option ID is used to signify the minting of one random type of\n *      Personality Pod\n *\n * @author Basil Gorin\n */\ncontract OpenSeaFactoryImpl is OpenSeaFactoryERC721, AccessControl {\n\t/**\n\t * @dev OpenSea expects Factory to be \"Ownable\", that is having an \"owner\",\n\t *      we introduce a fake \"owner\" here with no authority\n\t */\n\taddress public owner;\n\n\t/**\n\t * @dev NFT ERC721 contract address to mint NFTs from and bind to iNFTs created\n\t */\n\taddress public immutable nftContract;\n\n\t/**\n\t * @dev OpenSea Proxy Registry determines which address is allowed to mint\n\t *      an option at any given time\n\t * @dev OpenSea takes care to set it to the NFT buyer address when they buy an option\n\t */\n\taddress public immutable proxyRegistry;\n\n\t/**\n\t * @dev Number of options the factory supports,\n\t *      options start from zero and end at `options` (exclusive)\n\t */\n\tuint32 private options;\n\n\t/**\n\t * @dev Base URI is used to construct option URI as\n\t *      `base URI + option ID`\n\t *\n\t * @dev For example, if base URI is https://api.com/option/, then option #1\n\t *      will have an URI https://api.com/option/1\n\t */\n\tstring public baseURI = \"\";\n\n\t/**\n\t * @dev Initialized with the tokenId each optionId should start minting from,\n\t *      incremented each time the option is minted\n\t *\n\t * @dev For each option, [currentTokenId[optionId], tokenIdUpperBound[optionId])\n\t *      is the range of token IDs left to be minted\n\t *\n\t * @dev Maps optionId => next available (current) token ID for an option\n\t */\n\tmapping(uint256 => uint256) public currentTokenId;\n\n\t/**\n\t * @dev At what tokenId each optionId should end minting at (exclusive)\n\t *\n\t * @dev For each option, [currentTokenId[optionId], tokenIdUpperBound[optionId])\n\t *      is the range of token IDs left to be minted\n\t *\n\t * @dev Maps optionId => final token ID (exclusive) for an option\n\t */\n\tmapping(uint256 => uint256) public tokenIdUpperBound;\n\n\t/**\n\t * @notice Minter is responsible for creating (minting) iNFTs\n\t *\n\t * @dev Role ROLE_MINTER allows minting iNFTs (calling `mint` function)\n\t */\n\tuint32 public constant ROLE_MINTER = 0x0001_0000;\n\n\t/**\n\t * @notice URI manager is responsible for managing base URI\n\t *      which is used to construct URIs for each option\n\t *\n\t * @dev Role ROLE_URI_MANAGER allows updating the base URI\n\t *      (executing `setBaseURI` function)\n\t */\n\tuint32 public constant ROLE_URI_MANAGER = 0x0010_0000;\n\n\t/**\n\t * @notice OpenSea manager is responsible for registering the factory\n\t *      in OpenSea via \"Transfer\" event mechanism\n\t *\n\t * @dev Role ROLE_OS_MANAGER allows notifying OpenSea about the contract\n\t *      \"owner\" change via emitting \"Transfer\" events read by the OpenSea\n\t *      (executing `fireTransferEvents` function)\n\t */\n\tuint32 public constant ROLE_OS_MANAGER = 0x0040_0000;\n\n\t/**\n\t * @dev Fired in mint() when Alethea NFT is created\n\t *\n\t * @param _by an address which executed the mint function\n\t * @param _optionId OpenSea option ID\n\t * @param _to an address NFT was minted to\n\t */\n\tevent Minted(address indexed _by, uint256 _optionId, address indexed _to);\n\n\t/**\n\t * @dev Fired in setBaseURI()\n\t *\n\t * @param _by an address which executed update\n\t * @param _oldVal old _baseURI value\n\t * @param _newVal new _baseURI value\n\t */\n\tevent BaseURIUpdated(address indexed _by, string _oldVal, string _newVal);\n\n\t/**\n\t * @dev An event caught by the OpenSea for automatic factory registration\n\t *      and assigning option \"owner\" to `to` address defined in the event\n\t * @dev See: OpenSea docs and source code examples,\n\t *      https://docs.opensea.io/docs/2-custom-sale-contract-viewing-your-sale-assets-on-opensea\n\t */\n\tevent Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n\t/**\n\t * @dev Creates/deploys the factory and binds it to NFT smart contract on construction\n\t *\n\t * @param _nft deployed NFT smart contract address; factory will mint NFTs of that type\n\t * @param _proxyRegistry OpenSea proxy registry address\n\t * @param _rangeBounds token ID ranges foreach option - the initial `currentTokenId` and `tokenIdUpperBound`\n\t */\n\tconstructor(address _nft, address _proxyRegistry, uint32[] memory _rangeBounds) {\n\t\t// verify the inputs are set\n\t\trequire(_nft != address(0), \"NFT contract is not set\");\n\t\trequire(_proxyRegistry != address(0), \"OpenSea proxy registry is not set\");\n\n\t\t// ensure there is at least one option (2 numbers for 1 range)\n\t\trequire(_rangeBounds.length > 1, \"invalid number of options\");\n\n\t\t// verify range bound initial element is greater than 100\n\t\trequire(_rangeBounds[0] > 100, \"invalid range bound initial element\");\n\n\t\t// verify inputs are valid smart contracts of the expected interfaces\n\t\trequire(ERC165(_nft).supportsInterface(type(ERC721).interfaceId), \"unexpected NFT type\");\n\t\trequire(ERC165(_nft).supportsInterface(type(ERC721Metadata).interfaceId), \"unexpected NFT type\");\n\t\trequire(ERC165(_nft).supportsInterface(type(MintableERC721).interfaceId), \"unexpected NFT type\");\n\n\t\t// verify that range bounds elements increase (monotonically increasing)\n\t\tfor(uint256 i = 0; i < _rangeBounds.length - 1; i++) {\n\t\t\t// compare current element and next element\n\t\t\trequire(_rangeBounds[i] < _rangeBounds[i + 1], \"invalid range bounds\");\n\t\t}\n\n\t\t// assign the NFT address\n\t\tnftContract = _nft;\n\t\t// assign owner\n\t\towner = msg.sender;\n\t\t// assign OpenSea Proxy Registry address\n\t\tproxyRegistry = _proxyRegistry;\n\t\t// number of options is derived from the range bounds array\n\t\toptions = uint32(_rangeBounds.length - 1);\n\n\t\t// assign the appropriate start and upper bound for each optionId\n\t\tfor(uint256 i = 0; i < _rangeBounds.length - 1; i++) {\n\t\t\tcurrentTokenId[i] = _rangeBounds[i];\n\t\t\ttokenIdUpperBound[i] = _rangeBounds[i + 1];\n\t\t}\n\n\t\t// fire events for each option\n\t\tfireTransferEvents(address(0), msg.sender);\n\t}\n\n\t/**\n\t * @dev Restricted access function which updates base URI for optionIds\n\t *\n\t * @param _baseURI new base URI to set\n\t */\n\tfunction setBaseURI(string memory _baseURI) public virtual {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_URI_MANAGER), \"access denied\");\n\n\t\t// emit an event first - to log both old and new values\n\t\temit BaseURIUpdated(msg.sender, baseURI, _baseURI);\n\n\t\t// and update base URI\n\t\tbaseURI = _baseURI;\n\t}\n\n\t/**\n\t * @inheritdoc ERC165\n\t */\n\tfunction supportsInterface(bytes4 interfaceId) public pure override returns (bool) {\n\t\t// reconstruct from current interface and super interface\n\t\treturn interfaceId == type(OpenSeaFactoryERC721).interfaceId;\n\t}\n\n\t/**\n\t * @inheritdoc OpenSeaFactoryERC721\n\t */\n\tfunction name() public override view returns (string memory) {\n\t\t// delegate to super implementation\n\t\treturn ERC721Metadata(nftContract).name();\n\t}\n\n\t/**\n\t * @inheritdoc OpenSeaFactoryERC721\n\t */\n\tfunction symbol() public override view returns (string memory) {\n\t\t// delegate to super implementation\n\t\treturn ERC721Metadata(nftContract).symbol();\n\t}\n\n\t/**\n\t * @inheritdoc OpenSeaFactoryERC721\n\t */\n\tfunction numOptions() public override view returns (uint256) {\n\t\t// calculate based on 0-indexed options\n\t\treturn options;\n\t}\n\n\t/**\n\t * @inheritdoc OpenSeaFactoryERC721\n\t */\n\tfunction canMint(uint256 _optionId) public override view returns (bool) {\n\t\t// check valid optionId, bounds\n\t\treturn _optionId < options && currentTokenId[_optionId] < tokenIdUpperBound[_optionId];\n\t}\n\n\t/**\n\t * @inheritdoc OpenSeaFactoryERC721\n\t */\n\tfunction tokenURI(uint256 _optionId) public override view returns (string memory) {\n\t\t// concatenate base URI + token ID\n\t\treturn StringUtils.concat(baseURI, StringUtils.itoa(_optionId, 10));\n\t}\n\n\t/**\n\t * @inheritdoc OpenSeaFactoryERC721\n\t */\n\tfunction supportsFactoryInterface() public override pure returns (bool) {\n\t\t// use ERC165 supportsInterface to return `true`\n\t\treturn supportsInterface(type(OpenSeaFactoryERC721).interfaceId);\n\t}\n\n\t/**\n\t * @inheritdoc OpenSeaFactoryERC721\n\t */\n\tfunction mint(uint256 _optionId, address _toAddress) public override {\n\t\t// verify the access permission\n\t\trequire(address(ProxyRegistry(proxyRegistry).proxies(owner)) == msg.sender, \"access denied\");\n\n\t\t// verify option ID can be minted\n\t\trequire(canMint(_optionId), \"cannot mint\");\n\n\t\t// do the mint\n\t\tMintableERC721(nftContract).mint(_toAddress, currentTokenId[_optionId]);\n\n\t\t// emit an event before increasing\n\t\temit Minted(msg.sender, currentTokenId[_optionId], _toAddress);\n\n\t\t// increment next tokenId\n\t\tcurrentTokenId[_optionId]++;\n\t}\n\n\t/**\n\t * @dev Fires transfer events for each option. Used to change contract \"owner\"\n\t *      See: OpenSea docs and source code examples,\n\t *      https://docs.opensea.io/docs/2-custom-sale-contract-viewing-your-sale-assets-on-opensea\n\t *\n\t * @param _from transfer optionIds from\n\t * @param _to transfer optionIds to\n\t */\n\tfunction fireTransferEvents(address _from, address _to) public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_OS_MANAGER), \"access denied\");\n\n\t\t// fire events for each option\n\t\tfor (uint256 i = 0; i < options; i++) {\n\t\t\temit Transfer(_from, _to, i);\n\t\t}\n\t}\n\n\t/**\n\t * Hack to get things to work automatically on OpenSea.\n\t * Use transferFrom so the frontend doesn't have to worry about different method names.\n\t */\n\tfunction transferFrom(address, address _to, uint256 _tokenId) public {\n\t\t// simply delegate to `mint`\n\t\tmint(_tokenId, _to);\n\t}\n\n\t/**\n\t * Hack to get things to work automatically on OpenSea.\n\t * Use isApprovedForAll so the frontend doesn't have to worry about different method names.\n\t */\n\tfunction isApprovedForAll(address _owner, address _operator) public view returns (bool) {\n\t\t// true if called by contract \"owner\" which is the token owner itself\n\t\tif(owner == _owner && _owner == _operator) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// lookup the registry\n\t\treturn owner == _owner && address(ProxyRegistry(proxyRegistry).proxies(_owner)) == _operator;\n\t}\n\n\t/**\n\t * Hack to get things to work automatically on OpenSea.\n\t * Use isApprovedForAll so the frontend doesn't have to worry about different method names.\n\t */\n\tfunction ownerOf(uint256) public view returns (address _owner) {\n\t\t// return smart contract \"owner\"\n\t\treturn owner;\n\t}\n}\n"
    },
    "contracts/protocol/IntelligentNFTv2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ERC20Spec.sol\";\nimport \"../interfaces/ERC721Spec.sol\";\nimport \"../lib/StringUtils.sol\";\nimport \"../utils/AccessControl.sol\";\n\n/**\n * @title Intelligent NFT Interface\n *        Version 2\n *\n * @notice External interface of IntelligentNFTv2 declared to support ERC165 detection.\n *      Despite some similarity with ERC721 interfaces, iNFT is not ERC721, any similarity\n *      should be treated as coincidental. Client applications may benefit from this similarity\n *      to reuse some of the ERC721 client code for display/reading.\n *\n * @dev See Intelligent NFT documentation below.\n *\n * @author Basil Gorin\n */\ninterface IntelligentNFTv2Spec {\n\t/**\n\t * @dev ERC20/ERC721 like name - Intelligent NFT\n\t *\n\t * @return \"Intelligent NFT\"\n\t */\n\tfunction name() external view returns (string memory);\n\n\t/**\n\t * @dev ERC20/ERC721 like symbol - iNFT\n\t *\n\t * @return \"iNFT\"\n\t */\n\tfunction symbol() external view returns (string memory);\n\n\t/**\n\t * @dev ERC721 like link to the iNFT metadata\n\t *\n\t * @param recordId iNFT ID to get metadata URI for\n\t */\n\tfunction tokenURI(uint256 recordId) external view returns (string memory);\n\n\t/**\n\t * @dev ERC20/ERC721 like counter of the iNFTs in existence (upper bound),\n\t *      some (or all) of which may not exist due to target NFT destruction\n\t *\n\t * @return amount of iNFT tracked by this smart contract\n\t */\n\tfunction totalSupply() external view returns (uint256);\n\n\t/**\n\t * @dev Check if iNFT binding with the given ID exists\n\t *\n\t * @return true if iNFT binding exist, false otherwise\n\t */\n\tfunction exists(uint256 recordId) external view returns (bool);\n\n\t/**\n\t * @dev ERC721 like function to get owner of the iNFT, which is by definition\n\t *      an owner of the underlying NFT\n\t */\n\tfunction ownerOf(uint256 recordId) external view returns (address);\n}\n\n/**\n * @title Intelligent NFT (iNFT)\n *        Version 2\n *\n * @notice Intelligent NFT (iNFT) represents an enhancement to an existing NFT\n *      (we call it a \"target\" or \"target NFT\"), it binds a GPT-3 prompt (a \"personality prompt\",\n *      delivered as a Personality Pod ERC721 token bound to iNFT)\n *      to the target to embed intelligence, is controlled and belongs to the owner of the target.\n *\n * @notice iNFT stores AI Personality and some amount of ALI tokens locked, available for\n *      unlocking when iNFT is destroyed\n *\n * @notice iNFT is not an ERC721 token, but it has some very limited similarity to an ERC721:\n *      every record is identified by ID and this ID has an owner, which is effectively the target NFT owner;\n *      still, it doesn't store ownership information itself and fully relies on the target ownership instead\n *\n * @dev Internally iNFTs consist of:\n *      - target NFT - smart contract address and ID of the NFT the iNFT is bound to\n *      - AI Personality - smart contract address and ID of the AI Personality used to produce given iNFT,\n *        representing a \"personality prompt\", and locked within an iNFT\n *      - ALI tokens amount - amount of the ALI tokens used to produce given iNFT, also locked\n *\n * @dev iNFTs can be\n *      - created, this process requires an AI Personality and ALI tokens to be locked\n *      - destroyed, this process releases an AI Personality and ALI tokens previously locked\n *\n * @author Basil Gorin\n */\ncontract IntelligentNFTv2 is IntelligentNFTv2Spec, AccessControl, ERC165 {\n\t/**\n\t * @inheritdoc IntelligentNFTv2Spec\n\t */\n\tstring public override name = \"Intelligent NFT\";\n\n\t/**\n\t * @inheritdoc IntelligentNFTv2Spec\n\t */\n\tstring public override symbol = \"iNFT\";\n\n\t/**\n\t * @dev Each intelligent token, represented by its unique ID, is bound to the target NFT,\n\t *      defined by the pair of the target NFT smart contract address and unique token ID\n\t *      within the target NFT smart contract\n\t *\n\t * @dev Effectively iNFT is owned by the target NFT owner\n\t *\n\t * @dev Additionally, each token holds an AI Personality and some amount of ALI tokens bound to it\n\t *\n\t * @dev `IntelliBinding` keeps all the binding information, including target NFT coordinates,\n\t *      bound AI Personality ID, and amount of ALI ERC20 tokens bound to the iNFT\n\t */\n\tstruct IntelliBinding {\n\t\t// Note: structure members are reordered to fit into less memory slots, see EVM memory layout\n\t\t// ----- SLOT.1 (256/256)\n\t\t/**\n\t\t * @dev Specific AI Personality is defined by the pair of AI Personality smart contract address\n\t\t *       and AI Personality ID\n\t\t *\n\t\t * @dev Address of the AI Personality smart contract\n\t\t */\n\t\taddress personalityContract;\n\n\t\t/**\n\t\t * @dev AI Personality ID within the AI Personality smart contract\n\t\t */\n\t\tuint96 personalityId;\n\n\t\t// ----- SLOT.2 (256/256)\n\t\t/**\n\t\t * @dev Amount of an ALI ERC20 tokens bound to (owned by) the iNFTs\n\t\t *\n\t\t * @dev ALI ERC20 smart contract address is defined globally as `aliContract` constant\n\t\t */\n\t\tuint96 aliValue;\n\n\t\t/**\n\t\t * @dev Address of the target NFT deployed smart contract,\n\t\t *      this is a contract a particular iNFT is bound to\n\t\t */\n\t\taddress targetContract;\n\n\t\t// ----- SLOT.3 (256/256)\n\t\t/**\n\t\t * @dev Target NFT ID within the target NFT smart contract,\n\t\t *      effectively target NFT ID and contract address define the owner of an iNFT\n\t\t */\n\t\tuint256 targetId;\n\t}\n\n\t/**\n\t * @notice iNFT binding storage, stores binding information for each existing iNFT\n\t * @dev Maps iNFT ID to its binding data, which includes underlying NFT data\n\t */\n\tmapping(uint256 => IntelliBinding) public bindings;\n\n\t/**\n\t * @notice Reverse iNFT binding allows to find iNFT bound to a particular NFT\n\t * @dev Maps target NFT (smart contract address and unique token ID) to the iNFT ID:\n\t *      NFT Contract => NFT ID => iNFT ID\n\t */\n\tmapping(address => mapping(uint256 => uint256)) public reverseBindings;\n\n\t/**\n\t * @notice Ai Personality to iNFT binding allows to find iNFT bound to a particular Ai Personality\n\t * @dev Maps Ai Personality NFT (unique token ID) to the linked iNFT:\n\t *      AI Personality Contract => AI Personality ID => iNFT ID\n\t */\n\tmapping(address => mapping(uint256 => uint256)) public personalityBindings;\n\n\t/**\n\t * @notice Total amount (maximum value estimate) of iNFT in existence.\n\t *       This value can be higher than number of effectively accessible iNFTs\n\t *       since when underlying NFT gets burned this value doesn't get updated.\n\t */\n\tuint256 public override totalSupply;\n\n\t/**\n\t * @notice Each iNFT holds some ALI tokens, which are tracked by the ALI token ERC20 smart contract defined here\n\t */\n\taddress public immutable aliContract;\n\n\t/**\n\t * @notice ALI token balance the contract is aware of, cumulative ALI obligation,\n\t *      i.e. sum of all iNFT locked ALI balances\n\t *\n\t * @dev Sum of all `IntelliBinding.aliValue` for each iNFT in existence\n\t */\n\tuint256 public aliBalance;\n\n\t/**\n\t * @dev Base URI is used to construct ERC721Metadata.tokenURI as\n\t *      `base URI + token ID` if token URI is not set (not present in `_tokenURIs` mapping)\n\t *\n\t * @dev For example, if base URI is https://api.com/token/, then token #1\n\t *      will have an URI https://api.com/token/1\n\t *\n\t * @dev If token URI is set with `setTokenURI()` it will be returned as is via `tokenURI()`\n\t */\n\tstring public baseURI = \"\";\n\n\t/**\n\t * @dev Optional mapping for token URIs to be returned as is when `tokenURI()`\n\t *      is called; if mapping doesn't exist for token, the URI is constructed\n\t *      as `base URI + token ID`, where plus (+) denotes string concatenation\n\t */\n\tmapping(uint256 => string) internal _tokenURIs;\n\n\t/**\n\t * @notice Minter is responsible for creating (minting) iNFTs\n\t *\n\t * @dev Role ROLE_MINTER allows minting iNFTs (calling `mint` function)\n\t */\n\tuint32 public constant ROLE_MINTER = 0x0001_0000;\n\n\t/**\n\t * @notice Burner is responsible for destroying (burning) iNFTs\n\t *\n\t * @dev Role ROLE_BURNER allows burning iNFTs (calling `burn` function)\n\t */\n\tuint32 public constant ROLE_BURNER = 0x0002_0000;\n\n\t/**\n\t * @notice Editor is responsible for editing (updating) iNFT records in general,\n\t *      adding/removing locked ALI tokens to/from iNFT in particular\n\t *\n\t * @dev Role ROLE_EDITOR allows editing iNFTs (calling `increaseAli`, `decreaseAli` functions)\n\t */\n\tuint32 public constant ROLE_EDITOR = 0x0004_0000;\n\n\t/**\n\t * @notice URI manager is responsible for managing base URI\n\t *      part of the token URI ERC721Metadata interface\n\t *\n\t * @dev Role ROLE_URI_MANAGER allows updating the base URI\n\t *      (executing `setBaseURI` function)\n\t */\n\tuint32 public constant ROLE_URI_MANAGER = 0x0010_0000;\n\n\t/**\n\t * @dev Fired in setBaseURI()\n\t *\n\t * @param _by an address which executed update\n\t * @param _oldVal old _baseURI value\n\t * @param _newVal new _baseURI value\n\t */\n\tevent BaseURIUpdated(address indexed _by, string _oldVal, string _newVal);\n\n\t/**\n\t * @dev Fired in setTokenURI()\n\t *\n\t * @param _by an address which executed update\n\t * @param _tokenId token ID which URI was updated\n\t * @param _oldVal old _baseURI value\n\t * @param _newVal new _baseURI value\n\t */\n\tevent TokenURIUpdated(address indexed _by, uint256 indexed _tokenId, string _oldVal, string _newVal);\n\n\t/**\n\t * @dev Fired in mint() when new iNFT is created\n\t *\n\t * @param _by an address which executed the mint function\n\t * @param _owner current owner of the NFT\n\t * @param _recordId ID of the iNFT minted (created, bound)\n\t * @param _aliValue amount of ALI tokens locked within newly created iNFT\n\t * @param _personalityContract AI Personality smart contract address\n\t * @param _personalityId ID of the AI Personality locked within newly created iNFT\n\t * @param _targetContract target NFT smart contract address\n\t * @param _targetId target NFT ID (where this iNFT binds to and belongs to)\n\t */\n\tevent Minted(\n\t\taddress indexed _by,\n\t\taddress indexed _owner,\n\t\tuint256 indexed _recordId,\n\t\tuint96 _aliValue,\n\t\taddress _personalityContract,\n\t\tuint96 _personalityId,\n\t\taddress _targetContract,\n\t\tuint256 _targetId\n\t);\n\n\t/**\n\t * @dev Fired in increaseAli() and decreaseAli() when iNFT record is updated\n\t *\n\t * @param _by an address which executed the update\n\t * @param _owner iNFT (target NFT) owner\n\t * @param _recordId ID of the updated iNFT\n\t * @param _oldAliValue amount of ALI tokens locked within iNFT before update\n\t * @param _newAliValue amount of ALI tokens locked within iNFT after update\n\t */\n\tevent Updated(\n\t\taddress indexed _by,\n\t\taddress indexed _owner,\n\t\tuint256 indexed _recordId,\n\t\tuint96 _oldAliValue,\n\t\tuint96 _newAliValue\n\t);\n\n\t/**\n\t * @dev Fired in burn() when an existing iNFT gets destroyed\n\t *\n\t * @param _by an address which executed the burn function\n\t * @param _recordId ID of the iNFT burnt (destroyed, unbound)\n\t * @param _recipient and address which received unlocked AI Personality and ALI tokens\n\t * @param _aliValue amount of ALI tokens transferred from the destroyed iNFT\n\t * @param _personalityContract AI Personality smart contract address\n\t * @param _personalityId ID of the AI Personality transferred from the destroyed iNFT\n\t * @param _targetContract target NFT smart contract\n\t * @param _targetId target NFT ID (where this iNFT was bound to and belonged to)\n\t */\n\tevent Burnt(\n\t\taddress indexed _by,\n\t\tuint256 indexed _recordId,\n\t\taddress indexed _recipient,\n\t\tuint96 _aliValue,\n\t\taddress _personalityContract,\n\t\tuint96 _personalityId,\n\t\taddress _targetContract,\n\t\tuint256 _targetId\n\t);\n\n\t/**\n\t * @dev Creates/deploys an iNFT instance bound to already ALI token instance\n\t *\n\t * @param _ali address of the deployed ALI ERC20 Token instance the iNFT is bound to\n\t */\n\tconstructor(address _ali) {\n\t\t// verify the inputs are set\n\t\trequire(_ali != address(0), \"ALI Token addr is not set\");\n\n\t\t// verify _ali is a valid ERC20\n\t\trequire(ERC165(_ali).supportsInterface(type(ERC20).interfaceId), \"unexpected ALI Token type\");\n\n\t\t// setup smart contract internal state\n\t\taliContract = _ali;\n\t}\n\n\t/**\n\t * @inheritdoc ERC165\n\t */\n\tfunction supportsInterface(bytes4 interfaceId) public pure override returns (bool) {\n\t\t// reconstruct from current interface and super interface\n\t\treturn interfaceId == type(IntelligentNFTv2Spec).interfaceId;\n\t}\n\n\t/**\n\t * @dev Restricted access function which updates base URI used to construct\n\t *      ERC721Metadata.tokenURI\n\t *\n\t * @param _baseURI new base URI to set\n\t */\n\tfunction setBaseURI(string memory _baseURI) public virtual {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_URI_MANAGER), \"access denied\");\n\n\t\t// emit an event first - to log both old and new values\n\t\temit BaseURIUpdated(msg.sender, baseURI, _baseURI);\n\n\t\t// and update base URI\n\t\tbaseURI = _baseURI;\n\t}\n\n\t/**\n\t * @dev Returns token URI if it was previously set with `setTokenURI`,\n\t *      otherwise constructs it as base URI + token ID\n\t *\n\t * @param _recordId iNFT ID to query metadata link URI for\n\t * @return URI link to fetch iNFT metadata from\n\t */\n\tfunction tokenURI(uint256 _recordId) public view override returns (string memory) {\n\t\t// verify token exists\n\t\trequire(exists(_recordId), \"iNFT doesn't exist\");\n\n\t\t// read the token URI for the token specified\n\t\tstring memory _tokenURI = _tokenURIs[_recordId];\n\n\t\t// if token URI is set\n\t\tif(bytes(_tokenURI).length > 0) {\n\t\t\t// just return it\n\t\t\treturn _tokenURI;\n\t\t}\n\n\t\t// if base URI is not set\n\t\tif(bytes(baseURI).length == 0) {\n\t\t\t// return an empty string\n\t\t\treturn \"\";\n\t\t}\n\n\t\t// otherwise concatenate base URI + token ID\n\t\treturn StringUtils.concat(baseURI, StringUtils.itoa(_recordId, 10));\n\t}\n\n\t/**\n\t * @dev Sets the token URI for the token defined by its ID\n\t *\n\t * @param _tokenId an ID of the token to set URI for\n\t * @param _tokenURI token URI to set\n\t */\n\tfunction setTokenURI(uint256 _tokenId, string memory _tokenURI) public virtual {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_URI_MANAGER), \"access denied\");\n\n\t\t// we do not verify token existence: we want to be able to\n\t\t// preallocate token URIs before tokens are actually minted\n\n\t\t// emit an event first - to log both old and new values\n\t\temit TokenURIUpdated(msg.sender, _tokenId, _tokenURIs[_tokenId], _tokenURI);\n\n\t\t// and update token URI\n\t\t_tokenURIs[_tokenId] = _tokenURI;\n\t}\n\n\t/**\n\t * @notice Verifies if given iNFT exists\n\t *\n\t * @param recordId iNFT ID to verify existence of\n\t * @return true if iNFT exists, false otherwise\n\t */\n\tfunction exists(uint256 recordId) public view override returns (bool) {\n\t\t// verify if biding exists for that tokenId and return the result\n\t\treturn bindings[recordId].targetContract != address(0);\n\t}\n\n\t/**\n\t * @notice Returns an owner of the given iNFT.\n\t *      By definition iNFT owner is an owner of the target NFT\n\t *\n\t * @param recordId iNFT ID to query ownership information for\n\t * @return address of the given iNFT owner\n\t */\n\tfunction ownerOf(uint256 recordId) public view override returns (address) {\n\t\t// get the link to the token binding (we need to access only one field)\n\t\tIntelliBinding storage binding = bindings[recordId];\n\n\t\t// verify the binding exists and throw standard Zeppelin message if not\n\t\trequire(binding.targetContract != address(0), \"iNFT doesn't exist\");\n\n\t\t// delegate `ownerOf` call to the target NFT smart contract\n\t\treturn ERC721(binding.targetContract).ownerOf(binding.targetId);\n\t}\n\n\t/**\n\t * @dev Restricted access function which creates an iNFT, binding it to the specified\n\t *      NFT, locking the AI Personality specified, and funded with the amount of ALI specified\n\t *\n\t * @dev Locks AI Personality defined by its ID within iNFT smart contract;\n\t *      AI Personality must be transferred to the iNFT smart contract\n\t *      prior to calling the `mint`, but in the same transaction with `mint`\n\t *\n\t * @dev Locks specified amount of ALI token within iNFT smart contract;\n\t *      ALI token amount must be transferred to the iNFT smart contract\n\t *      prior to calling the `mint`, but in the same transaction with `mint`\n\t *\n\t * @dev To summarize, minting transaction (a transaction which executes `mint`) must\n\t *      1) transfer AI Personality\n\t *      2) transfer ALI tokens if they are to be locked\n\t *      3) mint iNFT\n\t *      NOTE: breaking the items above into multiple transactions is not acceptable!\n\t *            (results in a security risk)\n\t *\n\t * @dev The NFT to be linked to is not required to owned by the funder, but it must exist;\n\t *      throws if target NFT doesn't exist\n\t *\n\t * @dev This is a restricted function which is accessed by iNFT Linker\n\t *\n\t * @param recordId ID of the iNFT to mint (create, bind)\n\t * @param aliValue amount of ALI tokens to bind to newly created iNFT\n\t * @param personalityContract AI Personality contract address\n\t * @param personalityId ID of the AI Personality to bind to newly created iNFT\n\t * @param targetContract target NFT smart contract\n\t * @param targetId target NFT ID (where this iNFT binds to and belongs to)\n\t */\n\tfunction mint(\n\t\tuint256 recordId,\n\t\tuint96 aliValue,\n\t\taddress personalityContract,\n\t\tuint96 personalityId,\n\t\taddress targetContract,\n\t\tuint256 targetId\n\t) public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_MINTER), \"access denied\");\n\n\t\t// verify personalityContract is a valid ERC721\n\t\trequire(ERC165(personalityContract).supportsInterface(type(ERC721).interfaceId), \"personality is not ERC721\");\n\n\t\t// verify targetContract is a valid ERC721\n\t\trequire(ERC165(targetContract).supportsInterface(type(ERC721).interfaceId), \"target NFT is not ERC721\");\n\n\t\t// verify this iNFT is not yet minted\n\t\trequire(!exists(recordId), \"iNFT already exists\");\n\n\t\t// verify target NFT is not yet bound to\n\t\trequire(reverseBindings[targetContract][targetId] == 0, \"NFT is already bound\");\n\n\t\t// verify AI Personality is not yet locked\n\t\trequire(personalityBindings[personalityContract][personalityId] == 0, \"personality already linked\");\n\n\t\t// verify if AI Personality is already transferred to iNFT\n\t\trequire(ERC721(personalityContract).ownerOf(personalityId) == address(this), \"personality is not yet transferred\");\n\n\t\t// retrieve NFT owner and verify if target NFT exists\n\t\taddress owner = ERC721(targetContract).ownerOf(targetId);\n\t\t// Note: we do not require funder to be NFT owner,\n\t\t// if required this constraint should be added by the caller (iNFT Linker)\n\t\trequire(owner != address(0), \"target NFT doesn't exist\");\n\n\t\t// in case when ALI tokens are expected to be locked within iNFT\n\t\tif(aliValue > 0) {\n\t\t\t// verify ALI tokens are already transferred to iNFT\n\t\t\trequire(aliBalance + aliValue <= ERC20(aliContract).balanceOf(address(this)), \"ALI tokens not yet transferred\");\n\n\t\t\t// update ALI balance on the contract\n\t\t\taliBalance += aliValue;\n\t\t}\n\n\t\t// bind AI Personality transferred and ALI ERC20 value transferred to an NFT specified\n\t\tbindings[recordId] = IntelliBinding({\n\t\t\tpersonalityContract : personalityContract,\n\t\t\tpersonalityId : personalityId,\n\t\t\taliValue : aliValue,\n\t\t\ttargetContract : targetContract,\n\t\t\ttargetId : targetId\n\t\t});\n\n\t\t// fill in the reverse binding\n\t\treverseBindings[targetContract][targetId] = recordId;\n\n\t\t// fill in the AI Personality to iNFT binding\n\t\tpersonalityBindings[personalityContract][personalityId] = recordId;\n\n\t\t// increase total supply counter\n\t\ttotalSupply++;\n\n\t\t// emit an event\n\t\temit Minted(\n\t\t\tmsg.sender,\n\t\t\towner,\n\t\t\trecordId,\n\t\t\taliValue,\n\t\t\tpersonalityContract,\n\t\t\tpersonalityId,\n\t\t\ttargetContract,\n\t\t\ttargetId\n\t\t);\n\t}\n\n\t/**\n\t * @dev Restricted access function which creates several iNFTs, binding them to the specified\n\t *      NFTs, locking the AI Personalities specified, each funded with the amount of ALI specified\n\t *\n\t * @dev Locks AI Personalities defined by their IDs within iNFT smart contract;\n\t *      AI Personalities must be transferred to the iNFT smart contract\n\t *      prior to calling the `mintBatch`, but in the same transaction with `mintBatch`\n\t *\n\t * @dev Locks specified amount of ALI token within iNFT smart contract for each iNFT minted;\n\t *      ALI token amount must be transferred to the iNFT smart contract\n\t *      prior to calling the `mintBatch`, but in the same transaction with `mintBatch`\n\t *\n\t * @dev To summarize, minting transaction (a transaction which executes `mintBatch`) must\n\t *      1) transfer AI Personality\n\t *      2) transfer ALI tokens if they are to be locked\n\t *      3) mint iNFT\n\t *      NOTE: breaking the items above into multiple transactions is not acceptable!\n\t *            (results in a security risk)\n\t *\n\t * @dev The NFTs to be linked to are not required to owned by the funder, but they must exist;\n\t *      throws if target NFTs don't exist\n\t *\n\t * @dev iNFT IDs to be minted: [recordId, recordId + n)\n\t * @dev AI Personality IDs to be locked: [personalityId, personalityId + n)\n\t * @dev NFT IDs to be bound to: [targetId, targetId + n)\n\t *\n\t * @dev n must be greater or equal 2: `n > 1`\n\t *\n\t * @dev This is a restricted function which is accessed by iNFT Linker\n\t *\n\t * @param recordId ID of the first iNFT to mint (create, bind)\n\t * @param aliValue amount of ALI tokens to bind to each newly created iNFT\n\t * @param personalityContract AI Personality contract address\n\t * @param personalityId ID of the first AI Personality to bind to newly created iNFT\n\t * @param targetContract target NFT smart contract\n\t * @param targetId first target NFT ID (where this iNFT binds to and belongs to)\n\t * @param n how many iNFTs to mint, sequentially increasing the recordId, personalityId, and targetId\n\t */\n\tfunction mintBatch(\n\t\tuint256 recordId,\n\t\tuint96 aliValue,\n\t\taddress personalityContract,\n\t\tuint96 personalityId,\n\t\taddress targetContract,\n\t\tuint256 targetId,\n\t\tuint96 n\n\t) public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_MINTER), \"access denied\");\n\n\t\t// verify n is set properly\n\t\trequire(n > 1, \"n is too small\");\n\n\t\t// verify personalityContract is a valid ERC721\n\t\trequire(ERC165(personalityContract).supportsInterface(type(ERC721).interfaceId), \"personality is not ERC721\");\n\n\t\t// verify targetContract is a valid ERC721\n\t\trequire(ERC165(targetContract).supportsInterface(type(ERC721).interfaceId), \"target NFT is not ERC721\");\n\n\t\t// verifications: for each iNFT in a batch\n\t\tfor(uint96 i = 0; i < n; i++) {\n\t\t\t// verify this token ID is not yet bound\n\t\t\trequire(!exists(recordId + i), \"iNFT already exists\");\n\n\t\t\t// verify the AI Personality is not yet bound\n\t\t\trequire(personalityBindings[personalityContract][personalityId + i] == 0, \"personality already linked\");\n\n\t\t\t// verify if AI Personality is already transferred to iNFT\n\t\t\trequire(ERC721(personalityContract).ownerOf(personalityId + i) == address(this), \"personality is not yet transferred\");\n\n\t\t\t// retrieve NFT owner and verify if target NFT exists\n\t\t\taddress owner = ERC721(targetContract).ownerOf(targetId + i);\n\t\t\t// Note: we do not require funder to be NFT owner,\n\t\t\t// if required this constraint should be added by the caller (iNFT Linker)\n\t\t\trequire(owner != address(0), \"target NFT doesn't exist\");\n\n\t\t\t// emit an event - we log owner for each iNFT\n\t\t\t// and its convenient to do it here when we have the owner inline\n\t\t\temit Minted(\n\t\t\t\tmsg.sender,\n\t\t\t\towner,\n\t\t\t\trecordId + i,\n\t\t\t\taliValue,\n\t\t\t\tpersonalityContract,\n\t\t\t\tpersonalityId + i,\n\t\t\t\ttargetContract,\n\t\t\t\ttargetId + i\n\t\t\t);\n\t\t}\n\n\t\t// cumulative ALI value may overflow uint96, store it into uint256 on stack\n\t\tuint256 _aliValue = uint256(aliValue) * n;\n\n\t\t// in case when ALI tokens are expected to be locked within iNFT\n\t\tif(_aliValue > 0) {\n\t\t\t// verify ALI tokens are already transferred to iNFT\n\t\t\trequire(aliBalance + _aliValue <= ERC20(aliContract).balanceOf(address(this)), \"ALI tokens not yet transferred\");\n\t\t\t// update ALI balance on the contract\n\t\t\taliBalance += _aliValue;\n\t\t}\n\n\t\t// minting: for each iNFT in a batch\n\t\tfor(uint96 i = 0; i < n; i++) {\n\t\t\t// bind AI Personality transferred and ALI ERC20 value transferred to an NFT specified\n\t\t\tbindings[recordId + i] = IntelliBinding({\n\t\t\t\tpersonalityContract : personalityContract,\n\t\t\t\tpersonalityId : personalityId + i,\n\t\t\t\taliValue : aliValue,\n\t\t\t\ttargetContract : targetContract,\n\t\t\t\ttargetId : targetId + i\n\t\t\t});\n\n\t\t\t// fill in the AI Personality to iNFT binding\n\t\t\tpersonalityBindings[personalityContract][personalityId + i] = recordId + i;\n\n\t\t\t// fill in the reverse binding\n\t\t\treverseBindings[targetContract][targetId + i] = recordId + i;\n\t\t}\n\n\t\t// increase total supply counter\n\t\ttotalSupply += n;\n\t}\n\n\t/**\n\t * @dev Restricted access function which destroys an iNFT, unbinding it from the\n\t *      linked NFT, releasing an AI Personality, and ALI tokens locked in the iNFT\n\t *\n\t * @dev Transfers an AI Personality locked in iNFT to its owner via ERC721.safeTransferFrom;\n\t *      owner must be an EOA or implement ERC721Receiver.onERC721Received properly\n\t * @dev Transfers ALI tokens locked in iNFT to its owner\n\t * @dev Since iNFT owner is determined as underlying NFT owner, this underlying NFT must\n\t *      exist and its ownerOf function must not throw and must return non-zero owner address\n\t *      for the underlying NFT ID\n\t *\n\t * @dev Doesn't verify if it's safe to send ALI tokens to the NFT owner, this check\n\t *      must be handled by the transaction executor\n\t *\n\t * @dev This is a restricted function which is accessed by iNFT Linker\n\t *\n\t * @param recordId ID of the iNFT to burn (destroy, unbind)\n\t */\n\tfunction burn(uint256 recordId) public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_BURNER), \"access denied\");\n\n\t\t// decrease total supply counter\n\t\ttotalSupply--;\n\n\t\t// read the token binding (we'll need to access all the fields)\n\t\tIntelliBinding memory binding = bindings[recordId];\n\n\t\t// verify binding exists\n\t\trequire(binding.targetContract != address(0), \"not bound\");\n\n\t\t// destroy binding first to protect from any reentrancy possibility\n\t\tdelete bindings[recordId];\n\n\t\t// free the reverse binding\n\t\tdelete reverseBindings[binding.targetContract][binding.targetId];\n\n\t\t// free the AI Personality binding\n\t\tdelete personalityBindings[binding.personalityContract][binding.personalityId];\n\n\t\t// determine an owner of the underlying NFT\n\t\taddress owner = ERC721(binding.targetContract).ownerOf(binding.targetId);\n\n\t\t// verify that owner address is set (not a zero address)\n\t\trequire(owner != address(0), \"no such NFT\");\n\n\t\t// transfer the AI Personality to the NFT owner\n\t\t// using safe transfer since we don't know if owner address can accept the AI Personality right now\n\t\tERC721(binding.personalityContract).safeTransferFrom(address(this), owner, binding.personalityId);\n\n\t\t// in case when ALI tokens were locked within iNFT\n\t\tif(binding.aliValue > 0) {\n\t\t\t// update ALI balance on the contract prior to token transfer (reentrancy style)\n\t\t\taliBalance -= binding.aliValue;\n\n\t\t\t// transfer the ALI tokens to the NFT owner\n\t\t\tERC20(aliContract).transfer(owner, binding.aliValue);\n\t\t}\n\n\t\t// emit an event\n\t\temit Burnt(\n\t\t\tmsg.sender,\n\t\t\trecordId,\n\t\t\towner,\n\t\t\tbinding.aliValue,\n\t\t\tbinding.personalityContract,\n\t\t\tbinding.personalityId,\n\t\t\tbinding.targetContract,\n\t\t\tbinding.targetId\n\t\t);\n\t}\n\n\t/**\n\t * @dev Restricted access function which updates iNFT record by increasing locked ALI tokens value,\n\t *      effectively locking additional ALI tokens to the iNFT\n\t *\n\t * @dev Locks specified amount of ALI token within iNFT smart contract;\n\t *      ALI token amount must be transferred to the iNFT smart contract\n\t *      prior to calling the `increaseAli`, but in the same transaction with `increaseAli`\n\t *\n\t * @dev To summarize, update transaction (a transaction which executes `increaseAli`) must\n\t *      1) transfer ALI tokens\n\t *      2) update the iNFT\n\t *      NOTE: breaking the items above into multiple transactions is not acceptable!\n\t *            (results in a security risk)\n\t *\n\t * @dev This is a restricted function which is accessed by iNFT Linker\n\t *\n\t * @param recordId ID of the iNFT to update\n\t * @param aliDelta amount of ALI tokens to lock\n\t */\n\tfunction increaseAli(uint256 recordId, uint96 aliDelta) public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_EDITOR), \"access denied\");\n\n\t\t// verify the inputs are set\n\t\trequire(aliDelta != 0, \"zero value\");\n\n\t\t// get iNFT owner for logging (check iNFT record exists under the hood)\n\t\taddress owner = ownerOf(recordId);\n\n\t\t// cache the ALI value of the record\n\t\tuint96 aliValue = bindings[recordId].aliValue;\n\n\t\t// verify ALI tokens are already transferred to iNFT\n\t\trequire(aliBalance + aliDelta <= ERC20(aliContract).balanceOf(address(this)), \"ALI tokens not yet transferred\");\n\n\t\t// update ALI balance on the contract\n\t\taliBalance += aliDelta;\n\n\t\t// update ALI balance on the binding\n\t\tbindings[recordId].aliValue = aliValue + aliDelta;\n\n\t\t// emit an event\n\t\temit Updated(msg.sender, owner, recordId, aliValue, aliValue + aliDelta);\n\t}\n\n\t/**\n\t * @dev Restricted access function which updates iNFT record by decreasing locked ALI tokens value,\n\t *      effectively unlocking some or all ALI tokens from the iNFT\n\t *\n\t * @dev Unlocked tokens are sent to the recipient address specified\n\t *\n\t * @dev This is a restricted function which is accessed by iNFT Linker\n\t *\n\t * @param recordId ID of the iNFT to update\n\t * @param aliDelta amount of ALI tokens to unlock\n\t * @param recipient an address to send unlocked tokens to\n\t */\n\tfunction decreaseAli(uint256 recordId, uint96 aliDelta, address recipient) public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_EDITOR), \"access denied\");\n\n\t\t// verify the inputs are set\n\t\trequire(aliDelta != 0, \"zero value\");\n\t\trequire(recipient != address(0), \"zero address\");\n\n\t\t// get iNFT owner for logging (check iNFT record exists under the hood)\n\t\taddress owner = ownerOf(recordId);\n\n\t\t// cache the ALI value of the record\n\t\tuint96 aliValue = bindings[recordId].aliValue;\n\n\t\t// positive or zero resulting balance check\n\t\trequire(aliValue >= aliDelta, \"not enough ALI\");\n\n\t\t// update ALI balance on the contract\n\t\taliBalance -= aliDelta;\n\n\t\t// update ALI balance on the binding\n\t\tbindings[recordId].aliValue = aliValue - aliDelta;\n\n\t\t// transfer the ALI tokens to the recipient\n\t\tERC20(aliContract).transfer(recipient, aliDelta);\n\n\t\t// emit an event\n\t\temit Updated(msg.sender, owner, recordId, aliValue, aliValue - aliDelta);\n\t}\n\n\t/**\n\t * @notice Determines how many tokens are locked in a particular iNFT\n\t *\n\t * @dev A shortcut for bindings(recordId).aliValue\n\t * @dev Throws if iNFT specified doesn't exist\n\t *\n\t * @param recordId iNFT ID to query locked tokens balance for\n\t * @return locked tokens balance, bindings[recordId].aliValue\n\t */\n\tfunction lockedValue(uint256 recordId) public view returns(uint96) {\n\t\t// ensure iNFT exists\n\t\trequire(exists(recordId), \"iNFT doesn't exist\");\n\n\t\t// read and return ALI value locked in the binding\n\t\treturn bindings[recordId].aliValue;\n\t}\n}\n"
    },
    "contracts/protocol/NFTStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ERC20Spec.sol\";\nimport \"../interfaces/ERC721Spec.sol\";\nimport \"../utils/AccessControl.sol\";\n\n/**\n * @title NFT Staking\n *\n * @notice Enables NFT staking for a given NFT smart contract defined on deployment\n *\n * @notice Doesn't introduce any rewards, just tracks the stake/unstake dates for each\n *      token/owner, this data will be used later on to process the rewards\n */\ncontract NFTStaking is AccessControl {\n\t/**\n\t * @dev Main staking data structure keeping track of a stake,\n\t *      used in `tokenStakes` array mapping\n\t */\n\tstruct StakeData {\n\t\t/**\n\t\t * @dev Who owned and staked the token, who will be the token\n\t\t *      returned to once unstaked\n\t\t */\n\t\taddress owner;\n\n\t\t/**\n\t\t * @dev When the token was staked and transferred from the owner,\n\t\t *      unix timestamp\n\t\t */\n\t\tuint32 stakedOn;\n\n\t\t/**\n\t\t * @dev When token was unstaked and returned back to the owner,\n\t\t *      unix timestamp\n\t\t * @dev Zero value means the token is still staked\n\t\t */\n\t\tuint32 unstakedOn;\n\t}\n\n\t/**\n\t * @dev Auxiliary data structure to help iterate over NFT owner stakes,\n\t *      used in `userStakes` array mapping\n\t */\n\tstruct StakeIndex {\n\t\t/**\n\t\t * @dev Staked token ID\n\t\t */\n\t\tuint32 tokenId;\n\n\t\t/**\n\t\t * @dev Where to look for main staking data `StakeData`\n\t\t *      in `tokenStakes` array mapping\n\t\t */\n\t\tuint32 index;\n\t}\n\n\t/**\n\t * @dev NFT smart contract to stake/unstake tokens of\n\t */\n\taddress public immutable targetContract;\n\n\t/**\n\t * @notice For each token ID stores the history of its stakes,\n\t *      last element of the history may be \"open\" (unstakedOn = 0),\n\t *      meaning the token is still staked and is ot be returned to the `owner`\n\t *\n\t * @dev Maps token ID => StakeData[]\n\t */\n\tmapping(uint32 => StakeData[]) public tokenStakes;\n\n\t/**\n\t * @notice For each owner address stores the links to its stakes,\n\t *      the link is represented as StakeIndex data struct\n\t *\n\t * @dev Maps owner address => StakeIndex[]\n\t */\n\tmapping(address => StakeIndex[]) public userStakes;\n\n\t/**\n\t * @dev Enables staking, stake(), stakeBatch()\n\t */\n\tuint32 public constant FEATURE_STAKING = 0x0000_0001;\n\n\t/**\n\t * @dev Enables unstaking, unstake(), unstakeBatch()\n\t */\n\tuint32 public constant FEATURE_UNSTAKING = 0x0000_0002;\n\n\t/**\n\t * @notice People do mistake and may send tokens by mistake; since\n\t *      staking contract is not designed to accept the tokens directly,\n\t *      it allows the rescue manager to \"rescue\" such lost tokens\n\t *\n\t * @notice Rescue manager is responsible for \"rescuing\" ERC20/ERC721 tokens\n\t *      accidentally sent to the smart contract\n\t *\n\t * @dev Role ROLE_RESCUE_MANAGER allows withdrawing non-staked ERC20/ERC721\n\t *      tokens stored on the smart contract balance\n\t */\n\tuint32 public constant ROLE_RESCUE_MANAGER = 0x0001_0000;\n\n\t/**\n\t * @dev Fired in stake(), stakeBatch()\n\t *\n\t * @param _by token owner, tx executor\n\t * @param _tokenId token ID staked and transferred into the smart contract\n\t * @param _when unix timestamp of when staking happened\n\t */\n\tevent Staked(address indexed _by, uint32 indexed _tokenId, uint32 _when);\n\n\t/**\n\t * @dev Fired in unstake(), unstakeBatch()\n\t *\n\t * @param _by token owner, tx executor\n\t * @param _tokenId token ID unstaked and transferred back to owner\n\t * @param _when unix timestamp of when unstaking happened\n\t */\n\tevent Unstaked(address indexed _by, uint32 indexed _tokenId, uint32 _when);\n\n\t/**\n\t * @dev Creates/deploys NFT staking contract bound to the already deployed\n\t *      target NFT ERC721 smart contract to be staked\n\t *\n\t * @param _nft address of the deployed NFT smart contract instance\n\t */\n\tconstructor(address _nft) {\n\t\t// verify input is set\n\t\trequire(_nft != address(0), \"target contract is not set\");\n\n\t\t// verify input is valid smart contract of the expected interface\n\t\trequire(ERC165(_nft).supportsInterface(type(ERC721).interfaceId), \"unexpected target type\");\n\n\t\t// setup smart contract internal state\n\t\ttargetContract = _nft;\n\t}\n\n\t/**\n\t * @notice How many times a particular token was staked\n\t *\n\t * @dev Used to iterate `tokenStakes(tokenId, i)`, `i < numStakes(tokenId)`\n\t *\n\t * @param tokenId token ID to query number of times staked for\n\t * @return number of times token was staked\n\t */\n\tfunction numStakes(uint32 tokenId) public view returns(uint256) {\n\t\t// just read the array length and return it\n\t\treturn tokenStakes[tokenId].length;\n\t}\n\n\t/**\n\t * @notice How many stakes a particular address has done\n\t *\n\t * @dev Used to iterate `userStakes(owner, i)`, `i < numStakes(owner)`\n\t *\n\t * @param owner an address to query number of times it staked\n\t * @return number of times a particular address has staked\n\t */\n\tfunction numStakes(address owner) public view returns(uint256) {\n\t\t// just read the array length and return it\n\t\treturn userStakes[owner].length;\n\t}\n\n\t/**\n\t * @notice Determines if the token is currently staked or not\n\t *\n\t * @param tokenId token ID to check state for\n\t * @return true if token is staked, false otherwise\n\t */\n\tfunction isStaked(uint32 tokenId) public view returns(bool) {\n\t\t// get an idea of current stakes for the token\n\t\tuint256 n = tokenStakes[tokenId].length;\n\n\t\t// evaluate based on the last stake element in the array\n\t\treturn n > 0 && tokenStakes[tokenId][n - 1].unstakedOn == 0;\n\t}\n\n\t/**\n\t * @notice Stakes the NFT; the token is transferred from its owner to the staking contract;\n\t *      token must be owned by the tx executor and be transferable by staking contract\n\t *\n\t * @param tokenId token ID to stake\n\t */\n\tfunction stake(uint32 tokenId) public {\n\t\t// verify staking is enabled\n\t\trequire(isFeatureEnabled(FEATURE_STAKING), \"staking is disabled\");\n\n\t\t// get an idea of current stakes for the token\n\t\tuint256 n = tokenStakes[tokenId].length;\n\n\t\t// verify the token is not currently staked\n\t\trequire(n == 0 || tokenStakes[tokenId][n - 1].unstakedOn != 0, \"already staked\");\n\n\t\t// verify token belongs to the address which executes staking\n\t\trequire(ERC721(targetContract).ownerOf(tokenId) == msg.sender, \"access denied\");\n\n\t\t// transfer the token from owner into the staking contract\n\t\tERC721(targetContract).transferFrom(msg.sender, address(this), tokenId);\n\n\t\t// current timestamp to be set as `stakedOn`\n\t\tuint32 stakedOn = now32();\n\n\t\t// save token stake data\n\t\ttokenStakes[tokenId].push(StakeData({\n\t\t\towner: msg.sender,\n\t\t\tstakedOn: stakedOn,\n\t\t\tunstakedOn: 0\n\t\t}));\n\n\t\t// save token stake index\n\t\tuserStakes[msg.sender].push(StakeIndex({\n\t\t\ttokenId: tokenId,\n\t\t\tindex: uint32(n)\n\t\t}));\n\n\t\t// emit an event\n\t\temit Staked(msg.sender, tokenId, stakedOn);\n\t}\n\n\t/**\n\t * @notice Stakes several NFTs; tokens are transferred from their owner to the staking contract;\n\t *      tokens must be owned by the tx executor and be transferable by staking contract\n\t *\n\t * @param tokenIds token IDs to stake\n\t */\n\tfunction stakeBatch(uint32[] memory tokenIds) public {\n\t\t// iterate the collection passed\n\t\tfor(uint256 i = 0; i < tokenIds.length; i++) {\n\t\t\t// and stake each token one by one\n\t\t\tstake(tokenIds[i]);\n\t\t}\n\t}\n\n\t/**\n\t * @notice Unstakes the NFT; the token is transferred from staking contract back\n\t *      its previous owner\n\t *\n\t * @param tokenId token ID to unstake\n\t */\n\tfunction unstake(uint32 tokenId) public {\n\t\t// verify staking is enabled\n\t\trequire(isFeatureEnabled(FEATURE_UNSTAKING), \"unstaking is disabled\");\n\n\t\t// get an idea of current stakes for the token\n\t\tuint256 n = tokenStakes[tokenId].length;\n\n\t\t// verify the token is currently staked\n\t\trequire(n != 0, \"not staked\");\n\t\trequire(tokenStakes[tokenId][n - 1].unstakedOn == 0, \"already unstaked\");\n\n\t\t// verify token belongs to the address which executes unstaking\n\t\trequire(tokenStakes[tokenId][n - 1].owner == msg.sender, \"access denied\");\n\n\t\t// current timestamp to be set as `unstakedOn`\n\t\tuint32 unstakedOn = now32();\n\n\t\t// update token stake data\n\t\ttokenStakes[tokenId][n - 1].unstakedOn = unstakedOn;\n\n\t\t// transfer the token back to owner\n\t\tERC721(targetContract).transferFrom(address(this), msg.sender, tokenId);\n\n\t\t// emit an event\n\t\temit Unstaked(msg.sender, tokenId, unstakedOn);\n\t}\n\n\t/**\n\t * @notice Unstakes several NFTs; tokens are transferred from staking contract back\n\t *      their previous owner\n\t *\n\t * @param tokenIds token IDs to unstake\n\t */\n\tfunction unstakeBatch(uint32[] memory tokenIds) public {\n\t\t// iterate the collection passed\n\t\tfor(uint256 i = 0; i < tokenIds.length; i++) {\n\t\t\t// and unstake each token one by one\n\t\t\tunstake(tokenIds[i]);\n\t\t}\n\t}\n\n\t/**\n\t * @dev Restricted access function to rescue accidentally sent ERC20 tokens,\n\t *      the tokens are rescued via `transfer` function call on the\n\t *      contract address specified and with the parameters specified:\n\t *      `_contract.transfer(_to, _value)`\n\t *\n\t * @dev Requires executor to have `ROLE_RESCUE_MANAGER` permission\n\t *\n\t * @param _contract smart contract address to execute `transfer` function on\n\t * @param _to to address in `transfer(_to, _value)`\n\t * @param _value value to transfer in `transfer(_to, _value)`\n\t */\n\tfunction rescueErc20(address _contract, address _to, uint256 _value) public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_RESCUE_MANAGER), \"access denied\");\n\n\t\t// perform the transfer as requested, without any checks\n\t\tERC20(_contract).transfer(_to, _value);\n\t}\n\n\t/**\n\t * @dev Restricted access function to rescue accidentally sent ERC721 tokens,\n\t *      the tokens are rescued via `transferFrom` function call on the\n\t *      contract address specified and with the parameters specified:\n\t *      `_contract.transferFrom(this, _to, _tokenId)`\n\t *\n\t * @dev Requires executor to have `ROLE_RESCUE_MANAGER` permission\n\t *\n\t * @param _contract smart contract address to execute `transferFrom` function on\n\t * @param _to to address in `transferFrom(this, _to, _tokenId)`\n\t * @param _tokenId token ID to transfer in `transferFrom(this, _to, _tokenId)`\n\t */\n\tfunction rescueErc721(address _contract, address _to, uint256 _tokenId) public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_RESCUE_MANAGER), \"access denied\");\n\n\t\t// verify the NFT is not staked\n\t\trequire(_contract != targetContract || !isStaked(uint32(_tokenId)), \"token is staked\");\n\n\t\t// perform the transfer as requested, without any checks\n\t\tERC721(_contract).transferFrom(address(this), _to, _tokenId);\n\t}\n\n\t/**\n\t * @dev Testing time-dependent functionality may be difficult;\n\t *      we override time in the helper test smart contract (mock)\n\t *\n\t * @return `block.timestamp` in mainnet, custom values in testnets (if overridden)\n\t */\n\tfunction now32() public view virtual returns (uint32) {\n\t\t// return current block timestamp\n\t\treturn uint32(block.timestamp);\n\t}\n}\n"
    },
    "contracts/mocks/ERC20InterfaceIdMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ERC20Spec.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n// A mock to support erc20_interface_id.js checking ERC20 interfaceId correctness\ncontract ERC20InterfaceIdMock {\n\t// Alethea ERC20 interfaceId\n\tfunction aletheaId() public pure returns(bytes4) {\n\t\treturn type(ERC20).interfaceId;\n\t}\n\n\t// Zeppelin ERC20 interfaceId\n\tfunction zeppelinId() public pure returns(bytes4) {\n\t\treturn type(IERC20).interfaceId;\n\t}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "contracts/mocks/ZeppelinERC20Mock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract ZeppelinERC20Mock is ERC20 {\n  constructor() payable ERC20(\"Mock\", \"MCK\") {}\n\n  function supportsInterface(bytes4 interfaceId) public pure returns (bool) {\n  return interfaceId == type(IERC20).interfaceId;\n  }\n\n  function mint(address account, uint256 amount) public {\n    _mint(account, amount);\n  }\n\n  function burn(address account, uint256 amount) public {\n    _burn(account, amount);\n  }\n\n  function transferInternal(\n    address from,\n    address to,\n    uint256 value\n  ) public {\n    _transfer(from, to, value);\n  }\n\n  function approveInternal(\n    address owner,\n    address spender,\n    uint256 value\n  ) public {\n    _approve(owner, spender, value);\n  }\n}\n"
    },
    "contracts/interfaces/MaticSpec.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {ERC20} from \"./ERC20Spec.sol\";\nimport {ERC721} from \"./ERC721Spec.sol\";\nimport {IERC1155} from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\n\n/**\n * @title Matic Mintable Specification\n *\n * @notice Interfaces supporting Matic integration:\n *      - MaticMintableERC20: https://github.com/maticnetwork/pos-portal/blob/master/contracts/root/RootToken/IMintableERC20.sol\n *      - MaticMintableERC721: https://github.com/maticnetwork/pos-portal/blob/master/contracts/root/RootToken/IMintableERC721.sol\n *      - MaticMintableERC1155: https://github.com/maticnetwork/pos-portal/blob/master/contracts/root/RootToken/IMintableERC1155.sol\n *\n * @dev See https://docs.matic.network/docs/develop/ethereum-matic/mintable-assets\n *\n * @author Basil Gorin\n */\n\n/**\n * @dev Matic Mintable ERC20 interface, enables Layer 2 minting in Matic,\n *      see https://docs.matic.network/docs/develop/ethereum-matic/mintable-assets\n */\ninterface MaticMintableERC20 is ERC20 {\n\t/**\n\t * @notice called by predicate contract to mint tokens while withdrawing\n\t * @dev Should be callable only by MintableERC20Predicate\n\t * Make sure minting is done only by this function\n\t * @param user user address for whom token is being minted\n\t * @param amount amount of token being minted\n\t */\n\tfunction mint(address user, uint256 amount) external;\n}\n\n/**\n * @dev Matic Mintable ERC721 interface, enables Layer 2 minting in Matic,\n *      see https://docs.matic.network/docs/develop/ethereum-matic/mintable-assets\n */\ninterface MaticMintableERC721 is ERC721 {\n\t/**\n\t * @notice called by predicate contract to mint tokens while withdrawing\n\t * @dev Should be callable only by MintableERC721Predicate\n\t * Make sure minting is done only by this function\n\t * @param user user address for whom token is being minted\n\t * @param tokenId tokenId being minted\n\t */\n\tfunction mint(address user, uint256 tokenId) external;\n\n\t/**\n\t * @notice called by predicate contract to mint tokens while withdrawing with metadata from L2\n\t * @dev Should be callable only by MintableERC721Predicate\n\t * Make sure minting is only done either by this function/ 👆\n\t * @param user user address for whom token is being minted\n\t * @param tokenId tokenId being minted\n\t * @param metaData Associated token metadata, to be decoded & set using `setTokenMetadata`\n\t *\n\t * Note : If you're interested in taking token metadata from L2 to L1 during exit, you must\n\t * implement this method\n\t */\n\tfunction mint(address user, uint256 tokenId, bytes calldata metaData) external;\n\n\t/**\n\t * @notice check if token already exists, return true if it does exist\n\t * @dev this check will be used by the predicate to determine if the token needs to be minted or transfered\n\t * @param tokenId tokenId being checked\n\t */\n\tfunction exists(uint256 tokenId) external view returns (bool);\n}\n\n/**\n * @dev Matic Mintable ERC1155 interface, enables Layer 2 minting in Matic,\n *      see https://docs.matic.network/docs/develop/ethereum-matic/mintable-assets\n */\ninterface MaticMintableERC1155 is IERC1155 {\n\t/**\n\t * @notice Creates `amount` tokens of token type `id`, and assigns them to `account`.\n\t * @dev Should be callable only by MintableERC1155Predicate\n\t * Make sure minting is done only by this function\n\t * @param account user address for whom token is being minted\n\t * @param id token which is being minted\n\t * @param amount amount of token being minted\n\t * @param data extra byte data to be accompanied with minted tokens\n\t */\n\tfunction mint(address account, uint256 id, uint256 amount, bytes calldata data) external;\n\n\t/**\n\t * @notice Batched version of singular token minting, where\n\t * for each token in `ids` respective amount to be minted from `amounts`\n\t * array, for address `to`.\n\t * @dev Should be callable only by MintableERC1155Predicate\n\t * Make sure minting is done only by this function\n\t * @param to user address for whom token is being minted\n\t * @param ids tokens which are being minted\n\t * @param amounts amount of each token being minted\n\t * @param data extra byte data to be accompanied with minted tokens\n\t */\n\tfunction mintBatch(address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "contracts/mocks/NFTStakingMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../protocol/NFTStaking.sol\";\n\n/// @dev Allows to override now32() on the NFTStaking\ncontract NFTStakingMock is NFTStaking {\n\t/// @dev Overrides now32() if set (non-zero)\n\tuint32 private _now32;\n\n\t/// @dev Deploys NFTStakingMock passing all the params to NFTStaking\n\tconstructor(address _nft) NFTStaking(_nft) {}\n\n\t/// @inheritdoc NFTStaking\n\tfunction now32() public view override returns (uint32) {\n\t\t// override now32 if it is set, delegate to super otherwise\n\t\treturn _now32 > 0? _now32: super.now32();\n\t}\n\n\t/// @dev Sets/removes now32() override (set to zero to remove)\n\tfunction setNow32(uint32 _value) public {\n\t\t_now32 = _value;\n\t}\n}\n"
    },
    "contracts/protocol/NFTFactoryV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ERC721Spec.sol\";\nimport \"../interfaces/ERC721SpecExt.sol\";\nimport \"../utils/AccessControl.sol\";\nimport \"../lib/ECDSA.sol\";\n\n/**\n * @title Alethea NFT Factory\n *\n * @notice NFT Factory is a helper smart contract responsible for minting arbitrary NFTs\n *\n * @notice It supports two mechanisms:\n *      - minting delegation: authorized address executes mint function on the helper,\n *        and helper executes minting function on the target ERC721 contract as an internal transaction\n *      - meta transaction minting or minting with an authorization: authorized address signs\n *        the minting authorization message and any address executes mint function on the helper\n *\n * @notice Second mechanism allows to shift the gas costs for the transaction to any address\n *      (usually this is the NFT beneficiary - an address which receives an NFT)\n *\n * @dev The signature is constructed via EIP-712 similar to EIP-2612, or EIP-3009\n *\n * @dev Target ERC721 contract(s) must allow helper to mint the tokens, this should be configured\n *      as part of the deployment or setup processes\n *\n * @dev Version 2 (NFTFactoryV2) adds total supply limiting feature allowing to set the NFT total\n *     supply hardcap; factory stops minting when total supply of the ERC721 to mint reaches the hardcap\n *\n * @author Basil Gorin\n */\ncontract NFTFactoryV2 is AccessControl {\n\t/**\n\t * @notice Total Supply Hardcap affects factory capability to mint: once\n\t *      target ERC721 total supply reaches the hardcap, factory stops minting it\n\t *\n\t * @dev The factory `mint` and `mintWithAuthorization` function throws\n\t *      if target ERC721 `totalSupply` value is equal or bigger than `totalSupplyHardcap`\n\t */\n\tuint256 public immutable totalSupplyHardcap;\n\n\t/**\n\t * @dev A record of used nonces for EIP-712 transactions\n\t *\n\t * @dev A record of used nonces for signing/validating signatures\n\t *      in `mintWithAuthorization` for every mint\n\t *\n\t * @dev Maps authorizer address => nonce => true/false (used unused)\n\t */\n\tmapping(address => mapping(bytes32 => bool)) private usedNonces;\n\n\t/**\n\t * @notice EIP-712 contract's domain separator,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator\n\t */\n\tbytes32 public immutable DOMAIN_SEPARATOR;\n\n\t/**\n\t * @notice EIP-712 contract's domain typeHash,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\n\t *\n\t * @dev Note: we do not include version into the domain typehash/separator,\n\t *      it is implied version is concatenated to the name field, like \"NFTFactoryV2\"\n\t */\n\t// keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\")\n\tbytes32 public constant DOMAIN_TYPEHASH = 0x8cad95687ba82c2ce50e74f7b754645e5117c3a5bec8151c0726d5857980a866;\n\n\t/**\n\t * @notice EIP-712 MintWithAuthorization struct typeHash,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\n\t */\n\t// keccak256(\"MintWithAuthorization(address contract,address to,uint256 tokenId,uint256 validAfter,uint256 validBefore,bytes32 nonce)\")\n\tbytes32 public constant MINT_WITH_AUTHORIZATION_TYPEHASH = 0x495835d970a03ff092657fca9abde67d34a0bb73a0bba258a5fa90c4ce4340f6;\n\n\t/**\n\t * @notice EIP-712 CancelAuthorization struct typeHash,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\n\t */\n\t// keccak256(\"CancelAuthorization(address authorizer,bytes32 nonce)\")\n\tbytes32 public constant CANCEL_AUTHORIZATION_TYPEHASH = 0x158b0a9edf7a828aad02f63cd515c68ef2f50ba807396f6d12842833a1597429;\n\n\t/**\n\t * @notice Enables meta transaction minting (minting with an authorization\n\t *      via an EIP712 signature)\n\t * @dev Feature FEATURE_MINTING_WITH_AUTH must be enabled in order for\n\t *      `mintWithAuthorization()` function to succeed\n\t */\n\tuint32 public constant FEATURE_MINTING_WITH_AUTH = 0x0000_0001;\n\n\t/**\n\t * @notice Factory minter is responsible for creating (minting)\n\t *      tokens to an arbitrary address\n\t * @dev Role ROLE_FACTORY_MINTER allows minting tokens\n\t *      (executing `mint` function)\n\t */\n\tuint32 public constant ROLE_FACTORY_MINTER = 0x0001_0000;\n\n\t/**\n\t * @dev Fired in mint() and mintWithAuthorization() after an NFT is minted\n\t *\n\t * @param erc721Address ERC721 contract address which was minted\n\t * @param to an address NFT was minted to\n\t * @param tokenId NFT ID which was minted\n\t */\n\tevent Minted(address indexed erc721Address, address indexed to, uint256 indexed tokenId);\n\n\t/**\n\t * @dev Fired whenever the nonce gets used (ex.: `transferWithAuthorization`, `receiveWithAuthorization`)\n\t *\n\t * @param authorizer an address which has used the nonce\n\t * @param nonce the nonce used\n\t */\n\tevent AuthorizationUsed(address indexed authorizer, bytes32 indexed nonce);\n\n\t/**\n\t * @dev Fired whenever the nonce gets cancelled (ex.: `cancelAuthorization`)\n\t *\n\t * @dev Both `AuthorizationUsed` and `AuthorizationCanceled` imply the nonce\n\t *      cannot be longer used, the only difference is that `AuthorizationCanceled`\n\t *      implies no smart contract state change made (except the nonce marked as cancelled)\n\t *\n\t * @param authorizer an address which has cancelled the nonce\n\t * @param nonce the nonce cancelled\n\t */\n\tevent AuthorizationCanceled(address indexed authorizer, bytes32 indexed nonce);\n\n\t/**\n\t * Deploys the helper contract and initializes DOMAIN_SEPARATOR using the created smart contract address\n\t *\n\t * @param _totalSupplyHardcap ERC721 total supply limit, factory stops minting the ERC721\n\t *      if its total supply (ERC721.totalSupply()) reaches the total supply had cap\n\t */\n\tconstructor(uint256 _totalSupplyHardcap) {\n\t\t// build the EIP-712 contract domain separator, see https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator\n\t\t// note: we specify contract version in its name\n\t\tDOMAIN_SEPARATOR = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(\"NFTFactoryV2\")), block.chainid, address(this)));\n\n\t\t// set the total supply hardcap\n\t\ttotalSupplyHardcap = _totalSupplyHardcap;\n\t}\n\n\t/**\n\t * @notice Restricted access function to mint an NFT\n\t *\n\t * @dev Doesn't allow minting the token with ID zero\n\t * @dev Requires an executor to have ROLE_MINTER permission\n\t * @dev Requires target ERC721 contract to be mintable (`MintableERC721`)\n\t * @dev Requires target ERC721 contract instance to allow minting via helper\n\t *\n\t * @param _targetErc721 target ERC721 contract instance to mint token on,\n\t *      compatible with `MintableERC721`\n\t * @param _to an address to mint token to\n\t * @param _tokenId target ERC721 token ID to mint\n\t */\n\tfunction mint(address _targetErc721, address _to, uint256 _tokenId) public {\n\t\t// delegate to _mint()\n\t\t__mint(msg.sender, _targetErc721, _to, _tokenId);\n\t}\n\n\t/**\n\t * @dev Auxiliary internally used function to mint an NFT\n\t *\n\t * @dev Unsafe: doesn't verify real tx executor (msg.sender) permissions, but the permissions of\n\t *      the address specified as an executor, must be kept private at all times\n\t *\n\t * @dev Doesn't allow minting the token with ID zero\n\t * @dev Requires an executor to have ROLE_MINTER permission\n\t * @dev Requires target ERC721 contract to be mintable (`MintableERC721`)\n\t * @dev Requires target ERC721 contract instance to allow minting via helper\n\t *\n\t * @param _executor an address on which behalf the operation is executed,\n\t *      this is usually `msg.sender` but this can be different address for\n\t *      the EIP-712 like transactions (mint with authorization)\n\t * @param _targetErc721 target ERC721 contract instance to mint token on,\n\t *      compatible with `MintableERC721`\n\t * @param _to an address to mint token to\n\t * @param _tokenId target ERC721 token ID to mint\n\t */\n\tfunction __mint(address _executor, address _targetErc721, address _to, uint256 _tokenId) private {\n\t\t// verify the access permission\n\t\trequire(isOperatorInRole(_executor, ROLE_FACTORY_MINTER), \"access denied\");\n\n\t\t// verify the inputs\n\t\trequire(_targetErc721 != address(0), \"ERC721 instance addr is not set\");\n\t\trequire(_to != address(0), \"NFT receiver addr is not set\");\n\t\trequire(_tokenId != 0, \"token ID is not set\");\n\n\t\t// verify if total supply hardcap is reached\n\t\trequire(ERC721Enumerable(_targetErc721).totalSupply() < totalSupplyHardcap, \"hardcap reached\");\n\n\t\t// delegate to the target ERC721 contract\n\t\tMintableERC721(_targetErc721).safeMint(_to, _tokenId);\n\n\t\t// emit an event\n\t\temit Minted(_targetErc721, _to, _tokenId);\n\t}\n\n\t/**\n\t * @notice Executes a mint function with a signed authorization\n\t *\n\t * @param _targetErc721 target ERC721 contract instance to mint token on,\n\t *      compatible with `MintableERC721`\n\t * @param _to an address to mint token to\n\t * @param _tokenId target ERC721 token ID to mint\n\t * @param _validAfter signature valid after time (unix timestamp)\n\t * @param _validBefore signature valid before time (unix timestamp)\n\t * @param _nonce unique random nonce\n\t * @param v the recovery byte of the signature\n\t * @param r half of the ECDSA signature pair\n\t * @param s half of the ECDSA signature pair\n\t */\n\tfunction mintWithAuthorization(\n\t\taddress _targetErc721,\n\t\taddress _to,\n\t\tuint256 _tokenId,\n\t\tuint256 _validAfter,\n\t\tuint256 _validBefore,\n\t\tbytes32 _nonce,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) public {\n\t\t// ensure EIP-712 minting with authorization is enabled\n\t\trequire(isFeatureEnabled(FEATURE_MINTING_WITH_AUTH), \"minting with auth is disabled\");\n\n\t\t// derive signer of the EIP712 MintWithAuthorization message\n\t\taddress signer = __deriveSigner(\n\t\t\tabi.encode(MINT_WITH_AUTHORIZATION_TYPEHASH, _targetErc721, _to, _tokenId, _validAfter, _validBefore, _nonce),\n\t\t\tv,\n\t\t\tr,\n\t\t\ts\n\t\t);\n\n\t\t// perform message integrity and security validations\n\t\trequire(block.timestamp > _validAfter, \"signature not yet valid\");\n\t\trequire(block.timestamp < _validBefore, \"signature expired\");\n\n\t\t// use the nonce supplied (verify, mark as used, emit event)\n\t\t__useNonce(signer, _nonce, false);\n\n\t\t// delegate call to `_mint` - execute the logic required\n\t\t__mint(signer, _targetErc721, _to, _tokenId);\n\t}\n\n\t/**\n\t * @notice Returns the state of an authorization, more specifically\n\t *      if the specified nonce was already used by the address specified\n\t *\n\t * @dev Nonces are expected to be client-side randomly generated 32-byte data\n\t *      unique to the authorizer's address\n\t *\n\t * @param _authorizer Authorizer's address\n\t * @param _nonce Nonce of the authorization\n\t * @return true if the nonce is used\n\t */\n\tfunction authorizationState(\n\t\taddress _authorizer,\n\t\tbytes32 _nonce\n\t) external view returns (bool) {\n\t\t// simply return the value from the mapping\n\t\treturn usedNonces[_authorizer][_nonce];\n\t}\n\n\t/**\n\t * @notice Cancels the authorization (using EIP-712 signature)\n\t *\n\t * @param _authorizer transaction authorizer\n\t * @param _nonce unique random nonce to cancel (mark as used)\n\t * @param v the recovery byte of the signature\n\t * @param r half of the ECDSA signature pair\n\t * @param s half of the ECDSA signature pair\n\t */\n\tfunction cancelAuthorization(\n\t\taddress _authorizer,\n\t\tbytes32 _nonce,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) public {\n\t\t// derive signer of the EIP712 ReceiveWithAuthorization message\n\t\taddress signer = __deriveSigner(abi.encode(CANCEL_AUTHORIZATION_TYPEHASH, _authorizer, _nonce), v, r, s);\n\n\t\t// perform message integrity and security validations\n\t\trequire(signer == _authorizer, \"invalid signature\");\n\n\t\t// cancel the nonce supplied (verify, mark as used, emit event)\n\t\t__useNonce(_authorizer, _nonce, true);\n\t}\n\n\t/**\n\t * @notice Cancels the authorization\n\t *\n\t * @param _nonce unique random nonce to cancel (mark as used)\n\t */\n\tfunction cancelAuthorization(bytes32 _nonce) public {\n\t\t// cancel the nonce supplied (verify, mark as used, emit event)\n\t\t__useNonce(msg.sender, _nonce, true);\n\t}\n\n\t/**\n\t * @dev Auxiliary function to verify structured EIP712 message signature and derive its signer\n\t *\n\t * @param abiEncodedTypehash abi.encode of the message typehash together with all its parameters\n\t * @param v the recovery byte of the signature\n\t * @param r half of the ECDSA signature pair\n\t * @param s half of the ECDSA signature pair\n\t */\n\tfunction __deriveSigner(bytes memory abiEncodedTypehash, uint8 v, bytes32 r, bytes32 s) private view returns(address) {\n\t\t// build the EIP-712 hashStruct of the message\n\t\tbytes32 hashStruct = keccak256(abiEncodedTypehash);\n\n\t\t// calculate the EIP-712 digest \"\\x19\\x01\" ‖ domainSeparator ‖ hashStruct(message)\n\t\tbytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR, hashStruct));\n\n\t\t// recover the address which signed the message with v, r, s\n\t\taddress signer = ECDSA.recover(digest, v, r, s);\n\n\t\t// return the signer address derived from the signature\n\t\treturn signer;\n\t}\n\n\t/**\n\t * @dev Auxiliary function to use/cancel the nonce supplied for a given authorizer:\n\t *      1. Verifies the nonce was not used before\n\t *      2. Marks the nonce as used\n\t *      3. Emits an event that the nonce was used/cancelled\n\t *\n\t * @dev Set `_cancellation` to false (default) to use nonce,\n\t *      set `_cancellation` to true to cancel nonce\n\t *\n\t * @dev It is expected that the nonce supplied is a randomly\n\t *      generated uint256 generated by the client\n\t *\n\t * @param _authorizer an address to use/cancel nonce for\n\t * @param _nonce random nonce to use\n\t * @param _cancellation true to emit `AuthorizationCancelled`, false to emit `AuthorizationUsed` event\n\t */\n\tfunction __useNonce(address _authorizer, bytes32 _nonce, bool _cancellation) private {\n\t\t// verify nonce was not used before\n\t\trequire(!usedNonces[_authorizer][_nonce], \"invalid nonce\");\n\n\t\t// update the nonce state to \"used\" for that particular signer to avoid replay attack\n\t\tusedNonces[_authorizer][_nonce] = true;\n\n\t\t// depending on the usage type (use/cancel)\n\t\tif(_cancellation) {\n\t\t\t// emit an event regarding the nonce cancelled\n\t\t\temit AuthorizationCanceled(_authorizer, _nonce);\n\t\t}\n\t\telse {\n\t\t\t// emit an event regarding the nonce used\n\t\t\temit AuthorizationUsed(_authorizer, _nonce);\n\t\t}\n\t}\n}\n"
    },
    "contracts/protocol/MintableSale.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ERC721SpecExt.sol\";\nimport \"../interfaces/ERC721Spec.sol\";\nimport \"../utils/AccessControl.sol\";\n\n/**\n * @title Mintable Sale\n *\n * @notice Mintable Sale sales fixed amount of NFTs (tokens) for a fixed price in a fixed period of time;\n *      it is used in 10k sale campaign to sell AI Personalities, but smart contract is generic and\n *      can sell any type of mintable NFT (see MintableERC721 interface)\n *\n * @dev Technically, all the \"fixed\" parameters can be changed on the go after smart contract is deployed\n *      and operational, but this ability is reserved for quick fix-like adjustments, and to provide\n *      an ability to restart and run a similar sale after the previous one ends\n *\n * @dev When buying a token from this smart contract, next token is minted to the recipient\n *\n * @dev Deployment and setup:\n *      1. Deploy smart contract, specify smart contract address during the deployment:\n *         - Mintable ER721 deployed instance address\n *      2. Execute `initialize` function and set up the sale parameters;\n *         sale is not active until it's initialized\n *\n * @author Basil Gorin\n */\ncontract MintableSale is AccessControl {\n\t// ----- SLOT.1 (256/256)\n\t/**\n\t * @notice Price of a single item (token) minted\n\t *      When buying several tokens at once the price accumulates accordingly, with no discount\n\t *\n\t * @dev Maximum item price is ~18.44 ETH\n\t */\n\tuint64 public itemPrice;\n\n\t/**\n\t * @dev Next token ID to mint;\n\t *      initially this is the first \"free\" ID which can be minted;\n\t *      at any point in time this should point to a free, mintable ID\n\t *      for the token\n\t *\n\t * @dev `nextId` cannot be zero, we do not ever mint NFTs with zero IDs\n\t */\n\tuint32 public nextId = 1;\n\n\t/**\n\t * @dev Last token ID to mint;\n\t *      once `nextId` exceeds `finalId` the sale pauses\n\t */\n\tuint32 public finalId;\n\n\t/**\n\t * @notice Sale start unix timestamp; the sale is active after the start (inclusive)\n\t */\n\tuint32 public saleStart;\n\n\t/**\n\t * @notice Sale end unix timestamp; the sale is active before the end (exclusive)\n\t */\n\tuint32 public saleEnd;\n\n\t/**\n\t * @notice Once set, limits the amount of tokens one can buy in a single transaction;\n\t *       When unset (zero) the amount of tokens is limited only by block size and\n\t *       amount of tokens left for sale\n\t */\n\tuint32 public batchLimit;\n\n\t/**\n\t * @notice Counter of the tokens sold (minted) by this sale smart contract\n\t */\n\tuint32 public soldCounter;\n\n\t// ----- NON-SLOTTED\n\t/**\n\t * @dev Mintable ERC721 contract address to mint\n\t */\n\taddress public immutable tokenContract;\n\n\t/**\n\t * @notice Sale manager is responsible for managing properties of the sale,\n\t *      such as sale price, amount, start/end dates, etc.\n\t *\n\t * @dev Role ROLE_SALE_MANAGER allows updating sale properties via initialize() function\n\t */\n\tuint32 public constant ROLE_SALE_MANAGER = 0x0001_0000;\n\n\t/**\n\t * @notice Withdrawal manager is responsible for withdrawing ETH obtained in sale\n\t *      from the sale smart contract\n\t *\n\t * @dev Role ROLE_WITHDRAWAL_MANAGER allows ETH withdrawals:\n\t *      - withdraw()\n\t *      - withdrawTo()\n\t */\n\tuint32 public constant ROLE_WITHDRAWAL_MANAGER = 0x0002_0000;\n\n\t/**\n\t * @dev Fired in initialize()\n\t *\n\t * @param _by an address which executed the initialization\n\t * @param _itemPrice price of one token created\n\t * @param _nextId next ID of the token to mint\n\t * @param _finalId final ID of the token to mint\n\t * @param _saleStart start of the sale, unix timestamp\n\t * @param _saleEnd end of the sale, unix timestamp\n\t * @param _batchLimit how many tokens is allowed to buy in a single transaction\n\t */\n\tevent Initialized(\n\t\taddress indexed _by,\n\t\tuint64 _itemPrice,\n\t\tuint32 _nextId,\n\t\tuint32 _finalId,\n\t\tuint32 _saleStart,\n\t\tuint32 _saleEnd,\n\t\tuint32 _batchLimit\n\t);\n\n\t/**\n\t * @dev Fired in buy(), buyTo(), buySingle(), and buySingleTo()\n\t *\n\t * @param _by an address which executed and payed the transaction, probably a buyer\n\t * @param _to an address which received token(s) minted\n\t * @param _amount number of tokens minted\n\t * @param _value ETH amount charged\n\t */\n\tevent Bought(address indexed _by, address indexed _to, uint256 _amount, uint256 _value);\n\n\t/**\n\t * @dev Fired in withdraw() and withdrawTo()\n\t *\n\t * @param _by an address which executed the withdrawal\n\t * @param _to an address which received the ETH withdrawn\n\t * @param _value ETH amount withdrawn\n\t */\n\tevent Withdrawn(address indexed _by, address indexed _to, uint256 _value);\n\n\t/**\n\t * @dev Creates/deploys MintableSale and binds it to Mintable ERC721\n\t *      smart contract on construction\n\t *\n\t * @param _tokenContract deployed Mintable ERC721 smart contract; sale will mint ERC721\n\t *      tokens of that type to the recipient\n\t */\n\tconstructor(address _tokenContract) {\n\t\t// verify the input is set\n\t\trequire(_tokenContract != address(0), \"token contract is not set\");\n\t\t\n\t\t// verify input is valid smart contract of the expected interfaces\n\t\trequire(\n\t\t\tERC165(_tokenContract).supportsInterface(type(ERC721).interfaceId)\n\t\t\t&& ERC165(_tokenContract).supportsInterface(type(MintableERC721).interfaceId),\n\t\t\t\"unexpected token contract type\"\n\t\t);\n\t\t\n\t\t// assign the addresses\n\t\ttokenContract = _tokenContract;\n\t}\n\n\t/**\n\t * @notice Number of tokens left on sale\n\t *\n\t * @dev Doesn't take into account if sale is active or not,\n\t *      if `nextId - finalId < 1` returns zero\n\t *\n\t * @return number of tokens left on sale\n\t */\n\tfunction itemsOnSale() public view returns(uint32) {\n\t\t// calculate items left on sale, taking into account that\n\t\t// finalId is on sale (inclusive bound)\n\t\treturn finalId > nextId? finalId + 1 - nextId: 0;\n\t}\n\n\t/**\n\t * @notice Number of tokens available on sale\n\t *\n\t * @dev Takes into account if sale is active or not, doesn't throw,\n\t *      returns zero if sale is inactive\n\t *\n\t * @return number of tokens available on sale\n\t */\n\tfunction itemsAvailable() public view returns(uint32) {\n\t\t// delegate to itemsOnSale() if sale is active, return zero otherwise\n\t\treturn isActive()? itemsOnSale(): 0;\n\t}\n\n\t/**\n\t * @notice Active sale is an operational sale capable of minting and selling tokens\n\t *\n\t * @dev The sale is active when all the requirements below are met:\n\t *      1. Price is set (`itemPrice` is not zero)\n\t *      2. `finalId` is not reached (`nextId <= finalId`)\n\t *      3. current timestamp is between `saleStart` (inclusive) and `saleEnd` (exclusive)\n\t *\n\t * @dev Function is marked as virtual to be overridden in the helper test smart contract (mock)\n\t *      in order to test how it affects the sale process\n\t *\n\t * @return true if sale is active (operational) and can sell tokens, false otherwise\n\t */\n\tfunction isActive() public view virtual returns(bool) {\n\t\t// evaluate sale state based on the internal state variables and return\n\t\treturn itemPrice > 0 && nextId <= finalId && saleStart <= now256() && saleEnd > now256();\n\t}\n\n\t/**\n\t * @dev Restricted access function to set up sale parameters, all at once,\n\t *      or any subset of them\n\t *\n\t * @dev To skip parameter initialization, set it to `-1`,\n\t *      that is a maximum value for unsigned integer of the corresponding type;\n\t *      `_aliSource` and `_aliValue` must both be either set or skipped\n\t *\n\t * @dev Example: following initialization will update only _itemPrice and _batchLimit,\n\t *      leaving the rest of the fields unchanged\n\t *      initialize(\n\t *          100000000000000000,\n\t *          0xFFFFFFFF,\n\t *          0xFFFFFFFF,\n\t *          0xFFFFFFFF,\n\t *          0xFFFFFFFF,\n\t *          10\n\t *      )\n\t *\n\t * @dev Requires next ID to be greater than zero (strict): `_nextId > 0`\n\t *\n\t * @dev Requires transaction sender to have `ROLE_SALE_MANAGER` role\n\t *\n\t * @param _itemPrice price of one token created;\n\t *      setting the price to zero deactivates the sale\n\t * @param _nextId next ID of the token to mint, will be increased\n\t *      in smart contract storage after every successful buy\n\t * @param _finalId final ID of the token to mint; sale is capable of producing\n\t *      `_finalId - _nextId + 1` tokens\n\t * @param _saleStart start of the sale, unix timestamp\n\t * @param _saleEnd end of the sale, unix timestamp; sale is active only\n\t *      when current time is within _saleStart (inclusive) and _saleEnd (exclusive)\n\t * @param _batchLimit how many tokens is allowed to buy in a single transaction,\n\t *      set to zero to disable the limit\n\t */\n\tfunction initialize(\n\t\tuint64 _itemPrice,\t// <<<--- keep type in sync with the body type(uint64).max !!!\n\t\tuint32 _nextId,\t// <<<--- keep type in sync with the body type(uint32).max !!!\n\t\tuint32 _finalId,\t// <<<--- keep type in sync with the body type(uint32).max !!!\n\t\tuint32 _saleStart,\t// <<<--- keep type in sync with the body type(uint32).max !!!\n\t\tuint32 _saleEnd,\t// <<<--- keep type in sync with the body type(uint32).max !!!\n\t\tuint32 _batchLimit\t// <<<--- keep type in sync with the body type(uint32).max !!!\n\t) public {\n\t\t// check the access permission\n\t\trequire(isSenderInRole(ROLE_SALE_MANAGER), \"access denied\");\n\n\t\t// verify the inputs\n\t\trequire(_nextId > 0, \"zero nextId\");\n\t\t\n\t\t// no need to verify extra parameters - \"incorrect\" values will deactivate the sale\n\n\t\t// initialize contract state based on the values supplied\n\t\t// take into account our convention that value `-1` means \"do not set\"\n\t\t// 0xFFFFFFFFFFFFFFFF, 64 bits\n\t\tif(_itemPrice != type(uint64).max) {\n\t\t\titemPrice = _itemPrice;\n\t\t}\n\t\t// 0xFFFFFFFF, 32 bits\n\t\tif(_nextId != type(uint32).max) {\n\t\t\tnextId = _nextId;\n\t\t}\n\t\t// 0xFFFFFFFF, 32 bits\n\t\tif(_finalId != type(uint32).max) {\n\t\t\tfinalId = _finalId;\n\t\t}\n\t\t// 0xFFFFFFFF, 32 bits\n\t\tif(_saleStart != type(uint32).max) {\n\t\t\tsaleStart = _saleStart;\n\t\t}\n\t\t// 0xFFFFFFFF, 32 bits\n\t\tif(_saleEnd != type(uint32).max) {\n\t\t\tsaleEnd = _saleEnd;\n\t\t}\n\t\t// 0xFFFFFFFF, 32 bits\n\t\tif(_batchLimit != type(uint32).max) {\n\t\t\tbatchLimit = _batchLimit;\n\t\t}\n\n\t\t// emit an event - read values from the storage since not all of them might be set\n\t\temit Initialized(\n\t\t\tmsg.sender,\n\t\t\titemPrice,\n\t\t\tnextId,\n\t\t\tfinalId,\n\t\t\tsaleStart,\n\t\t\tsaleEnd,\n\t\t\tbatchLimit\n\t\t);\n\t}\n\n\t/**\n\t * @notice Buys several (at least two) tokens in a batch.\n\t *      Accepts ETH as payment and mints a token\n\t *\n\t * @param _amount amount of tokens to create, two or more\n\t */\n\tfunction buy(uint32 _amount) public payable {\n\t\t// delegate to `buyTo` with the transaction sender set to be a recipient\n\t\tbuyTo(msg.sender, _amount);\n\t}\n\n\t/**\n\t * @notice Buys several (at least two) tokens in a batch to an address specified.\n\t *      Accepts ETH as payment and mints tokens\n\t *\n\t * @param _to address to mint tokens to\n\t * @param _amount amount of tokens to create, two or more\n\t */\n\tfunction buyTo(address _to, uint32 _amount) public payable {\n\t\t// verify the inputs\n\t\trequire(_to != address(0), \"recipient not set\");\n\t\trequire(_amount > 1 && (batchLimit == 0 || _amount <= batchLimit), \"incorrect amount\");\n\n\t\t// verify there is enough items available to buy the amount\n\t\t// verifies sale is in active state under the hood\n\t\trequire(itemsAvailable() >= _amount, \"inactive sale or not enough items available\");\n\n\t\t// calculate the total price required and validate the transaction value\n\t\tuint256 totalPrice = uint256(itemPrice) * _amount;\n\t\trequire(msg.value >= totalPrice, \"not enough funds\");\n\n\t\t// mint token to to the recipient\n\t\tMintableERC721(tokenContract).mintBatch(_to, nextId, _amount);\n\n\t\t// increment `nextId`\n\t\tnextId += _amount;\n\t\t// increment `soldCounter`\n\t\tsoldCounter += _amount;\n\n\t\t// if ETH amount supplied exceeds the price\n\t\tif(msg.value > totalPrice) {\n\t\t\t// send excess amount back to sender\n\t\t\tpayable(msg.sender).transfer(msg.value - totalPrice);\n\t\t}\n\n\t\t// emit en event\n\t\temit Bought(msg.sender, _to, _amount, totalPrice);\n\t}\n\n\t/**\n\t * @notice Buys single token.\n\t *      Accepts ETH as payment and mints a token\n\t */\n\tfunction buySingle() public payable {\n\t\t// delegate to `buySingleTo` with the transaction sender set to be a recipient\n\t\tbuySingleTo(msg.sender);\n\t}\n\n\t/**\n\t * @notice Buys single token to an address specified.\n\t *      Accepts ETH as payment and mints a token\n\t *\n\t * @param _to address to mint token to\n\t */\n\tfunction buySingleTo(address _to) public payable {\n\t\t// verify the inputs and transaction value\n\t\trequire(_to != address(0), \"recipient not set\");\n\t\trequire(msg.value >= itemPrice, \"not enough funds\");\n\n\t\t// verify sale is in active state\n\t\trequire(isActive(), \"inactive sale\");\n\n\t\t// mint token to the recipient\n\t\tMintableERC721(tokenContract).mint(_to, nextId);\n\t\t\n\t\t// increment `nextId`\n\t\tnextId++;\n\t\t// increment `soldCounter`\n\t\tsoldCounter++;\n\n\t\t// if ETH amount supplied exceeds the price\n\t\tif(msg.value > itemPrice) {\n\t\t\t// send excess amount back to sender\n\t\t\tpayable(msg.sender).transfer(msg.value - itemPrice);\n\t\t}\n\n\t\t// emit en event\n\t\temit Bought(msg.sender, _to, 1, itemPrice);\n\t}\n\n\t/**\n\t * @dev Restricted access function to withdraw ETH on the contract balance,\n\t *      sends ETH back to transaction sender\n\t */\n\tfunction withdraw() public {\n\t\t// delegate to `withdrawTo`\n\t\twithdrawTo(msg.sender);\n\t}\n\n\t/**\n\t * @dev Restricted access function to withdraw ETH on the contract balance,\n\t *      sends ETH to the address specified\n\t *\n\t * @param _to an address to send ETH to\n\t */\n\tfunction withdrawTo(address _to) public {\n\t\t// check the access permission\n\t\trequire(isSenderInRole(ROLE_WITHDRAWAL_MANAGER), \"access denied\");\n\n\t\t// verify withdrawal address is set\n\t\trequire(_to != address(0), \"address not set\");\n\n\t\t// ETH value to send\n\t\tuint256 _value = address(this).balance;\n\n\t\t// verify sale balance is positive (non-zero)\n\t\trequire(_value > 0, \"zero balance\");\n\n\t\t// send the entire balance to the transaction sender\n\t\tpayable(_to).transfer(_value);\n\n\t\t// emit en event\n\t\temit Withdrawn(msg.sender, _to, _value);\n\t}\n\n\t/**\n\t * @dev Testing time-dependent functionality may be difficult;\n\t *      we override time in the helper test smart contract (mock)\n\t *\n\t * @return `block.timestamp` in mainnet, custom values in testnets (if overridden)\n\t */\n\tfunction now256() public view virtual returns (uint256) {\n\t\t// return current block timestamp\n\t\treturn block.timestamp;\n\t}\n}\n"
    },
    "contracts/mocks/MintableSaleMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../protocol/MintableSale.sol\";\n\n/// @dev Allows to override isActive() and now256() on the MintableSale\ncontract MintableSaleMock is MintableSale {\n\t/// @dev Defines if isActive() should be overridden\n\tbool private _activeStateOverride;\n\n\t/// @dev Overrides isActive() if `_activeStateOverride` is true\n\tbool private _activeStateValue;\n\n\t/// @dev Overrides now256() if set (non-zero)\n\tuint256 private _now256;\n\n\t/// @dev Deploys MintableSaleMock passing all the params to MintableSale\n\tconstructor(address _tokenContract) MintableSale(_tokenContract) {}\n\n\t/// @inheritdoc MintableSale\n\tfunction isActive() public view override returns(bool) {\n\t\t// override state if required, delegate to super otherwise\n\t\treturn _activeStateOverride ? _activeStateValue : super.isActive();\n\t}\n\n\t/// @inheritdoc MintableSale\n\tfunction now256() public view override returns (uint256) {\n\t\t// override now256 if it is set, delegate to super otherwise\n\t\treturn _now256 > 0? _now256: super.now256();\n\t}\n\n\t/// @dev Sets isActive() override\n\tfunction setStateOverride(bool _value) public {\n\t\t_activeStateOverride = true;\n\t\t_activeStateValue = _value;\n\t}\n\n\t/// @dev Removes isActive() override\n\tfunction removeStateOverride() public {\n\t\t_activeStateOverride = false;\n\t}\n\n\t/// @dev Sets/removes now256() override (set to zero to remove)\n\tfunction setNow256(uint256 _value) public {\n\t\t_now256 = _value;\n\t}\n\n}\n"
    },
    "contracts/protocol/IntelliLinkerV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ERC721Spec.sol\";\nimport \"./IntelligentNFTv2.sol\";\nimport \"../utils/UpgradeableAccessControl.sol\";\n\n/**\n * @title Intelligent Token Linker (iNFT Linker)\n *\n * @notice iNFT Linker is a helper smart contract responsible for managing iNFTs.\n *      It creates and destroys iNFTs, determines iNFT creation price and destruction fee.\n *\n * @dev Known limitations (to be resolved in the future releases):\n *      - doesn't check AI Personality / target NFT compatibility: any personality\n *        can be linked to any NFT (NFT contract must be whitelisted)\n *      - doesn't support unlinking + linking in a single transaction\n *      - doesn't support AI Personality smart contract upgrades: in case when new\n *        AI Personality contract is deployed, new iNFT Linker should also be deployed\n *\n * @dev V2 modification\n *      - supports two separate whitelists for linking and unlinking\n *      - is upgradeable\n *\n * @author Basil Gorin\n */\ncontract IntelliLinkerV2 is UpgradeableAccessControl {\n\t/**\n\t * @dev iNFT Linker locks/unlocks ALI tokens defined by `aliContract` to mint/burn iNFT\n\t */\n\taddress public aliContract;\n\n\t/**\n\t * @dev iNFT Linker locks/unlocks AI Personality defined by `personalityContract` to mint/burn iNFT\n\t */\n\taddress public personalityContract;\n\n\t/**\n\t * @dev iNFT Linker mints/burns iNFTs defined by `iNftContract`\n\t */\n\taddress public iNftContract;\n\n\t/**\n\t * @dev iNFTs may get created with the ALI tokens bound to them,\n\t *      linking fee may get charged when creating an iNFT\n\t *\n\t * @dev Linking price, how much ALI tokens is charged upon iNFT creation;\n\t *      `linkPrice - linkFee` is locked within the iNFT created\n\t */\n\tuint96 public linkPrice;\n\n\t/**\n\t * @dev iNFTs may get created with the ALI tokens bound to them,\n\t *      linking fee may get charged when creating an iNFT\n\t *\n\t * @dev Linking fee, how much ALI tokens is sent into treasury `feeDestination`\n\t *      upon iNFT creation\n\t *\n\t * @dev Both `linkFee` and `feeDestination` must be set for the fee to be charged;\n\t *      both `linkFee` and `feeDestination` can be either set or unset\n\t */\n\tuint96 public linkFee;\n\n\t/**\n\t * @dev iNFTs may get created with the ALI tokens bound to them,\n\t *      linking fee may get charged when creating an iNFT\n\t *\n\t * @dev Treasury `feeDestination` is an address to send linking fee to upon iNFT creation\n\t *\n\t * @dev Both `linkFee` and `feeDestination` must be set for the fee to be charged;\n\t *      both `linkFee` and `feeDestination` can be either set or unset\n\t */\n\taddress public feeDestination;\n\n\t/**\n\t/**\n\t * @dev Next iNFT ID to mint; initially this is the first \"free\" ID which can be minted;\n\t *      at any point in time this should point to a free, mintable ID for iNFT\n\t *\n\t * @dev iNFT ID space up to 0xFFFF_FFFF (uint32 max) is reserved for the sales\n\t */\n\tuint256 public nextId;\n\n\t/**\n\t * @dev Target NFT Contracts allowed iNFT to be linked to;\n\t *      is not taken into account if FEATURE_ALLOW_ANY_NFT_CONTRACT is enabled\n\t * @dev Lowest bit (zero) defines if contract is allowed to be linked to;\n\t *      Next bit (one) defines if contract is allowed to be unlinked from\n\t */\n\tmapping(address => uint8) public whitelistedTargetContracts;\n\n\t/**\n\t * @notice Enables iNFT linking (creation)\n\t *\n\t * @dev Feature FEATURE_LINKING must be enabled\n\t *      as a prerequisite for `link()` function to succeed\n\t */\n\tuint32 public constant FEATURE_LINKING = 0x0000_0001;\n\n\t/**\n\t * @notice Enables iNFT unlinking (destruction)\n\t *\n\t * @dev Feature FEATURE_UNLINKING must be enabled\n\t *      for the `unlink()` and `unlinkNFT()` functions to succeed\n\t */\n\tuint32 public constant FEATURE_UNLINKING = 0x0000_0002;\n\n\t/**\n\t * @notice Allows linker to link (mint) iNFT bound to any target NFT contract,\n\t *      independently whether it was previously whitelisted or not\n\t * @dev Feature FEATURE_ALLOW_ANY_NFT_CONTRACT allows linking (minting) iNFTs\n\t *      bound to any target NFT contract, without a check if it's whitelisted in\n\t *      `whitelistedTargetContracts` or not\n\t */\n\tuint32 public constant FEATURE_ALLOW_ANY_NFT_CONTRACT = 0x0000_0004;\n\n\t/**\n\t * @notice Enables depositing more ALI to already existing iNFTs\n\t *\n\t * @dev Feature FEATURE_DEPOSITS must be enabled\n\t *      for the `deposit()` function to succeed\n\t */\n\tuint32 public constant FEATURE_DEPOSITS = 0x0000_0008;\n\n\t/**\n\t * @notice Enables ALI withdrawals from the iNFT (without destroying them)\n\t *\n\t * @dev Feature FEATURE_WITHDRAWALS must be enabled\n\t *      for the `withdraw()` function to succeed\n\t */\n\tuint32 public constant FEATURE_WITHDRAWALS = 0x0000_0010;\n\n\t/**\n\t * @notice Link price manager is responsible for updating linking price\n\t *\n\t * @dev Role ROLE_LINK_PRICE_MANAGER allows `updateLinkPrice` execution,\n\t *      and `linkPrice` modification\n\t */\n\tuint32 public constant ROLE_LINK_PRICE_MANAGER = 0x0001_0000;\n\n\t/**\n\t * @notice Next ID manager is responsible for updating `nextId` variable,\n\t *      pointing to the next iNFT ID free slot\n\t *\n\t * @dev Role ROLE_NEXT_ID_MANAGER allows `updateNextId` execution,\n\t *     and `nextId` modification\n\t */\n\tuint32 public constant ROLE_NEXT_ID_MANAGER = 0x0002_0000;\n\n\t/**\n\t * @notice Whitelist manager is responsible for managing the target NFT contracts\n\t *     whitelist, which are the contracts iNFT is allowed to be bound to\n\t *\n\t * @dev Role ROLE_WHITELIST_MANAGER allows `whitelistTargetContract` execution,\n\t *     and `whitelistedTargetContracts` mapping modification\n\t */\n\tuint32 public constant ROLE_WHITELIST_MANAGER = 0x0004_0000;\n\n\t/**\n\t * @dev Fired in link() when new iNFT is created\n\t *\n\t * @param _by an address which executed (and funded) the link function\n\t * @param _iNftId ID of the iNFT minted\n\t * @param _linkPrice amount of ALI tokens locked (transferred) to newly created iNFT\n\t * @param _linkFee amount of ALI tokens charged as a fee and sent to the treasury\n\t * @param _personalityContract AI Personality contract address\n\t * @param _personalityId ID of the AI Personality locked (transferred) to newly created iNFT\n\t * @param _targetContract target NFT smart contract\n\t * @param _targetId target NFT ID (where this iNFT binds to and belongs to)\n\t */\n\tevent Linked(\n\t\taddress indexed _by,\n\t\tuint256 _iNftId,\n\t\tuint96 _linkPrice,\n\t\tuint96 _linkFee,\n\t\taddress indexed _personalityContract,\n\t\tuint96 indexed _personalityId,\n\t\taddress _targetContract,\n\t\tuint256 _targetId\n\t);\n\n\t/**\n\t * @dev Fired in unlink() when an existing iNFT gets destroyed\n\t *\n\t * @param _by an address which executed the unlink function\n\t *      (and which received unlocked AI Personality and ALI tokens)\n\t * @param _iNftId ID of the iNFT burnt\n\t */\n\tevent Unlinked(address indexed _by, uint256 indexed _iNftId);\n\n\t/**\n\t * @dev Fired in deposit(), withdraw() when an iNFT ALI balance gets changed\n\t *\n\t * @param _by an address which executed the deposit/withdraw function\n\t *      (in case of withdraw it received unlocked ALI tokens)\n\t * @param _iNftId ID of the iNFT to update\n\t * @param _aliDelta locked ALI tokens delta, positive for deposit, negative for withdraw\n\t * @param _feeValue amount of ALI tokens charged as a fee\n\t */\n\tevent LinkUpdated(address indexed _by, uint256 indexed _iNftId, int128 _aliDelta, uint96 _feeValue);\n\n\t/**\n\t * @dev Fired in updateLinkPrice()\n\t *\n\t * @param _by an address which executed the operation\n\t * @param _linkPrice new linking price set\n\t * @param _linkFee new linking fee set\n\t * @param _feeDestination new treasury address set\n\t */\n\tevent LinkPriceChanged(address indexed _by, uint96 _linkPrice, uint96 _linkFee, address indexed _feeDestination);\n\n\t/**\n\t * @dev Fired in updateNextId()\n\t *\n\t * @param _by an address which executed the operation\n\t * @param _oldVal old nextId value\n\t * @param _newVal new nextId value\n\t */\n\tevent NextIdChanged(address indexed _by, uint256 _oldVal, uint256 _newVal);\n\n\t/**\n\t * @dev Fired in whitelistTargetContract()\n\t *\n\t * @param _by an address which executed the operation\n\t * @param _targetContract target NFT contract address affected\n\t * @param _oldVal old whitelisted raw value (contains both linking/unlinking flags)\n\t * @param _newVal new whitelisted raw value (contains both linking/unlinking flags)\n\t */\n\tevent TargetContractWhitelisted(address indexed _by, address indexed _targetContract, uint8 _oldVal, uint8 _newVal);\n\n\t/**\n\t * @dev \"Constructor replacement\" for upgradeable, must be execute immediately after deployment\n\t *      see https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#initializers\n\t *\n\t * @dev Binds an iNFT Linker instance to already deployed\n\t *      iNFT, AI Personality and ALI Token instances\n\t *\n\t * @param _ali address of the deployed ALI ERC20 Token instance the iNFT Linker is bound to\n\t * @param _personality address of the deployed AI Personality instance the iNFT Linker is bound to\n\t * @param _iNft address of the deployed iNFT instance the iNFT Linker is bound to\n\t */\n\tfunction postConstruct(address _ali, address _personality, address _iNft) public virtual initializer {\n\t\t// verify inputs are set\n\t\trequire(_ali != address(0), \"ALI Token addr is not set\");\n\t\trequire(_personality != address(0), \"AI Personality addr is not set\");\n\t\trequire(_iNft != address(0), \"iNFT addr is not set\");\n\n\t\t// verify inputs are valid smart contracts of the expected interfaces\n\t\trequire(ERC165(_ali).supportsInterface(type(ERC20).interfaceId), \"unexpected ALI Token type\");\n\t\trequire(ERC165(_personality).supportsInterface(type(ERC721).interfaceId), \"unexpected AI Personality type\");\n\t\trequire(ERC165(_iNft).supportsInterface(type(IntelligentNFTv2Spec).interfaceId), \"unexpected iNFT type\");\n\n\t\t// setup smart contract internal state\n\t\taliContract = _ali;\n\t\tpersonalityContract = _personality;\n\t\tiNftContract = _iNft;\n\n\t\t// setup the defaults\n\t\t// linkPrice = 2_000 ether; // we use \"ether\" suffix instead of \"e18\"\n\t\t// iNFT ID space up to 0xFFFF_FFFF (uint32 max) is reserved for the sales\n\t\t// iNFT ID space up to 0x1_FFFF_FFFF is reserved for IntelliLinker (v1, non-upgradeable)\n\t\tnextId = 0x2_0000_0000;\n\n\t\t// execute all parent initializers in cascade\n\t\tUpgradeableAccessControl._postConstruct(msg.sender);\n\t}\n\n\t/**\n\t * @notice Links given AI Personality with the given NFT and forms an iNFT.\n\t *      AI Personality specified and `linkPrice` ALI are transferred into minted iNFT\n\t *      and are effectively locked within an iNFT until it is destructed (burnt)\n\t *\n\t * @dev AI Personality and ALI tokens are transferred from the transaction sender account\n\t *      to iNFT smart contract\n\t * @dev Sender must approve both AI Personality and ALI tokens transfers to be\n\t *      performed by the linker contract\n\t *\n\t * @param personalityId AI Personality ID to be locked into iNFT\n\t * @param targetContract NFT address iNFT to be linked to\n\t * @param targetId NFT ID iNFT to be linked to\n\t */\n\tfunction link(uint96 personalityId, address targetContract, uint256 targetId) public virtual {\n\t\t// verify linking is enabled\n\t\trequire(isFeatureEnabled(FEATURE_LINKING), \"linking is disabled\");\n\n\t\t// verify AI Personality belongs to transaction sender\n\t\trequire(ERC721(personalityContract).ownerOf(personalityId) == msg.sender, \"access denied\");\n\t\t// verify NFT contract is either whitelisted or any NFT contract is allowed globally\n\t\trequire(\n\t\t\tisAllowedForLinking(targetContract) || isFeatureEnabled(FEATURE_ALLOW_ANY_NFT_CONTRACT),\n\t\t\t\"not a whitelisted NFT contract\"\n\t\t);\n\n\t\t// if linking fee is set\n\t\tif(linkFee > 0) {\n\t\t\t// transfer ALI tokens to the treasury - `feeDestination`\n\t\t\tERC20(aliContract).transferFrom(msg.sender, feeDestination, linkFee);\n\t\t}\n\n\t\t// if linking price is set\n\t\tif(linkPrice > 0) {\n\t\t\t// transfer ALI tokens to iNFT contract to be locked\n\t\t\tERC20(aliContract).transferFrom(msg.sender, iNftContract, linkPrice - linkFee);\n\t\t}\n\n\t\t// transfer AI Personality to iNFT contract to be locked\n\t\tERC721(personalityContract).transferFrom(msg.sender, iNftContract, personalityId);\n\n\t\t// mint the next iNFT, increment next iNFT ID to be minted\n\t\tIntelligentNFTv2(iNftContract).mint(nextId++, linkPrice - linkFee, personalityContract, personalityId, targetContract, targetId);\n\n\t\t// emit an event\n\t\temit Linked(msg.sender, nextId - 1, linkPrice, linkFee, personalityContract, personalityId, targetContract, targetId);\n\t}\n\n\t/**\n\t * @notice Destroys given iNFT, unlinking it from underlying NFT and unlocking\n\t *      the AI Personality and ALI tokens locked in iNFT.\n\t *      AI Personality and ALI tokens are transferred to the underlying NFT owner\n\t *\n\t * @dev Can be executed only by iNFT owner (effectively underlying NFT owner)\n\t *\n\t * @param iNftId ID of the iNFT to unlink\n\t */\n\tfunction unlink(uint256 iNftId) public virtual {\n\t\t// verify unlinking is enabled\n\t\trequire(isFeatureEnabled(FEATURE_UNLINKING), \"unlinking is disabled\");\n\n\t\t// get a link to an iNFT contract to perform several actions with it\n\t\tIntelligentNFTv2 iNFT = IntelligentNFTv2(iNftContract);\n\n\t\t// get target NFT contract address from the iNFT binding\n\t\t(,,,address targetContract,) = iNFT.bindings(iNftId);\n\t\t// verify NFT contract is either whitelisted or any NFT contract is allowed globally\n\t\trequire(\n\t\t\tisAllowedForUnlinking(targetContract) || isFeatureEnabled(FEATURE_ALLOW_ANY_NFT_CONTRACT),\n\t\t\t\"not a whitelisted NFT contract\"\n\t\t);\n\n\t\t// verify the transaction is executed by iNFT owner (effectively by underlying NFT owner)\n\t\trequire(iNFT.ownerOf(iNftId) == msg.sender, \"not an iNFT owner\");\n\n\t\t// burn the iNFT unlocking the AI Personality and ALI tokens - delegate to `IntelligentNFTv2.burn`\n\t\tiNFT.burn(iNftId);\n\n\t\t// emit an event\n\t\temit Unlinked(msg.sender, iNftId);\n\t}\n\n\t/**\n\t * @notice Unlinks given NFT by destroying iNFTs and unlocking\n\t *      the AI Personality and ALI tokens locked in iNFTs.\n\t *      AI Personality and ALI tokens are transferred to the underlying NFT owner\n\t *\n\t * @dev Can be executed only by NFT owner (effectively underlying NFT owner)\n\t *\n\t * @param nftContract NFT address iNFTs to be unlinked to\n\t * @param nftId NFT ID iNFTs to be unlinked to\n\t */\n\tfunction unlinkNFT(address nftContract, uint256 nftId) public virtual {\n\t\t// verify unlinking is enabled\n\t\trequire(isFeatureEnabled(FEATURE_UNLINKING), \"unlinking is disabled\");\n\n\t\t// get a link to an iNFT contract to perform several actions with it\n\t\tIntelligentNFTv2 iNFT = IntelligentNFTv2(iNftContract);\n\n\t\t// verify the transaction is executed by NFT owner\n\t\trequire(ERC721(nftContract).ownerOf(nftId) == msg.sender, \"not an NFT owner\");\n\n\t\t// get iNFT ID linked with given NFT\n\t\tuint256 iNftId = iNFT.reverseBindings(nftContract, nftId);\n\n\t\t// verify NFT contract is either whitelisted or any NFT contract is allowed globally\n\t\trequire(\n\t\t\tisAllowedForUnlinking(nftContract) || isFeatureEnabled(FEATURE_ALLOW_ANY_NFT_CONTRACT),\n\t\t\t\"not a whitelisted NFT contract\"\n\t\t);\n\n\t\t// burn the iNFT unlocking the AI Personality and ALI tokens - delegate to `IntelligentNFTv2.burn`\n\t\tiNFT.burn(iNftId);\n\n\t\t// emit an event\n\t\temit Unlinked(msg.sender, iNftId);\n\t}\n\n\t/**\n\t * @notice Deposits additional ALI tokens into already existing iNFT\n\t *\n\t * @dev Can be executed only by NFT owner (effectively underlying NFT owner)\n\t *\n\t * @dev ALI tokens are transferred from the transaction sender account to iNFT smart contract\n\t *      Sender must approve ALI tokens transfers to be performed by the linker contract\n\t *\n\t * @param iNftId ID of the iNFT to transfer (and lock) tokens to\n\t * @param aliValue amount of ALI tokens to transfer (and lock)\n\t */\n\tfunction deposit(uint256 iNftId, uint96 aliValue) public virtual {\n\t\t// verify deposits are enabled\n\t\trequire(isFeatureEnabled(FEATURE_DEPOSITS), \"deposits are disabled\");\n\n\t\t// get a link to an iNFT contract to perform several actions with it\n\t\tIntelligentNFTv2 iNFT = IntelligentNFTv2(iNftContract);\n\n\t\t// verify the transaction is executed by iNFT owner (effectively by underlying NFT owner)\n\t\trequire(iNFT.ownerOf(iNftId) == msg.sender, \"not an iNFT owner\");\n\n\t\t// effective ALI value locked in iNFT may get altered according to the linking fee set\n\t\t// init effective fee as if linking fee is not set\n\t\tuint96 _linkFee = 0;\n\t\t// init effective ALI value locked as if linking fee is not set\n\t\tuint96 _aliValue = aliValue;\n\t\t// in case when link price/fee are set (effectively meaning fee percent is set)\n\t\tif(linkPrice != 0 && linkFee != 0) {\n\t\t\t// we need to make sure the fee is charged from the value supplied\n\t\t\t// proportionally to the value supplied and fee percent\n\t\t\t_linkFee = uint96(uint256(_aliValue) * linkFee / linkPrice);\n\n\t\t\t// recalculate ALI value to be locked accordingly\n\t\t\t_aliValue = aliValue - _linkFee;\n\n\t\t\t// transfer ALI tokens to the treasury - `feeDestination`\n\t\t\tERC20(aliContract).transferFrom(msg.sender, feeDestination, _linkFee);\n\t\t}\n\n\t\t// transfer ALI tokens to iNFT contract to be locked\n\t\tERC20(aliContract).transferFrom(msg.sender, iNftContract, _aliValue);\n\n\t\t// update the iNFT record\n\t\tiNFT.increaseAli(iNftId, _aliValue);\n\n\t\t// emit an event\n\t\temit LinkUpdated(msg.sender, iNftId, int128(uint128(_aliValue)), _linkFee);\n\t}\n\n\t/**\n\t * @notice Withdraws some ALI tokens from already existing iNFT without destroying it\n\t *\n\t * @dev Can be executed only by NFT owner (effectively underlying NFT owner)\n\t *\n\t * @dev ALI tokens are transferred to the iNFT owner (transaction executor)\n\t *\n\t * @param iNftId ID of the iNFT to unlock tokens from\n\t * @param aliValue amount of ALI tokens to unlock\n\t */\n\tfunction withdraw(uint256 iNftId, uint96 aliValue) public virtual {\n\t\t// verify withdrawals are enabled\n\t\trequire(isFeatureEnabled(FEATURE_WITHDRAWALS), \"withdrawals are disabled\");\n\n\t\t// get a link to an iNFT contract to perform several actions with it\n\t\tIntelligentNFTv2 iNFT = IntelligentNFTv2(iNftContract);\n\n\t\t// verify the transaction is executed by iNFT owner (effectively by underlying NFT owner)\n\t\trequire(iNFT.ownerOf(iNftId) == msg.sender, \"not an iNFT owner\");\n\n\t\t// ensure iNFT locked balance doesn't go below `linkPrice - linkFee`\n\t\trequire(iNFT.lockedValue(iNftId) >= aliValue + linkPrice, \"deposit too low\");\n\n\t\t// update the iNFT record and transfer tokens back to the iNFT owner\n\t\tiNFT.decreaseAli(iNftId, aliValue, msg.sender);\n\n\t\t// emit an event\n\t\temit LinkUpdated(msg.sender, iNftId, -int128(uint128(aliValue)), 0);\n\t}\n\n\t/**\n\t * @dev Restricted access function to modify\n\t *      - linking price `linkPrice`,\n\t *      - linking fee `linkFee`, and\n\t *      - treasury address `feeDestination`\n\t *\n\t * @dev Requires executor to have ROLE_LINK_PRICE_MANAGER permission\n\t * @dev Requires linking price to be either unset (zero), or not less than 1e12 (0.000001 ALI)\n\t * @dev Requires both linking fee and treasury address to be either set or unset (zero);\n\t *      if set, linking fee must not be less than 1e12 (0.000001 ALI);\n\t *      if set, linking fee must not exceed linking price\n\t *\n\t * @param _linkPrice new linking price to be set\n\t * @param _linkFee new linking fee to be set\n\t * @param _feeDestination treasury address\n\t */\n\tfunction updateLinkPrice(uint96 _linkPrice, uint96 _linkFee, address _feeDestination) public virtual {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_LINK_PRICE_MANAGER), \"access denied\");\n\n\t\t// verify the price is not too low if it's set\n\t\trequire(_linkPrice == 0 || _linkPrice >= 1e12, \"invalid price\");\n\n\t\t// linking fee/treasury should be either both set or both unset\n\t\t// linking fee must not be too low if set\n\t\trequire(_linkFee == 0 && _feeDestination == address(0) || _linkFee >= 1e12 && _feeDestination != address(0), \"invalid linking fee/treasury\");\n\t\t// linking fee must not exceed linking price\n\t\trequire(_linkFee <= _linkPrice, \"linking fee exceeds linking price\");\n\n\t\t// update the linking price, fee, and treasury address\n\t\tlinkPrice = _linkPrice;\n\t\tlinkFee = _linkFee;\n\t\tfeeDestination = _feeDestination;\n\n\t\t// emit an event\n\t\temit LinkPriceChanged(msg.sender, _linkPrice, _linkFee, _feeDestination);\n\t}\n\n\t/**\n\t * @dev Restricted access function to modify next iNFT ID `nextId`\n\t *\n\t * @param _nextId new next iNFT ID to be set\n\t */\n\tfunction updateNextId(uint256 _nextId) public virtual {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_NEXT_ID_MANAGER), \"access denied\");\n\n\t\t// verify nextId is in safe bounds\n\t\trequire(_nextId > 0xFFFF_FFFF, \"value too low\");\n\n\t\t// emit a event\n\t\temit NextIdChanged(msg.sender, nextId, _nextId);\n\n\t\t// update next ID\n\t\tnextId = _nextId;\n\t}\n\n\t/**\n\t * @dev Restricted access function to manage whitelisted NFT contracts mapping `whitelistedTargetContracts`\n\t *\n\t * @dev Requires executor to have ROLE_WHITELIST_MANAGER permission\n\t *\n\t * @param targetContract target NFT contract address to add/remove to/from the whitelist\n\t * @param allowedForLinking true to add, false to remove to/from whitelist (allowed for linking)\n\t * @param allowedForUnlinking true to add, false to remove to/from whitelist (allowed for unlinking)\n\t */\n\tfunction whitelistTargetContract(\n\t\taddress targetContract,\n\t\tbool allowedForLinking,\n\t\tbool allowedForUnlinking\n\t) public virtual {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_WHITELIST_MANAGER), \"access denied\");\n\n\t\t// verify the address is set\n\t\trequire(targetContract != address(0), \"zero address\");\n\n\t\t// delisting is always possible, whitelisting - only for valid ERC721\n\t\tif(allowedForLinking) {\n\t\t\t// verify targetContract is a valid ERC721\n\t\t\trequire(ERC165(targetContract).supportsInterface(type(ERC721).interfaceId), \"target NFT is not ERC721\");\n\t\t}\n\n\t\t// derive the uint8 value representing two boolean flags:\n\t\t// Lowest bit (zero) defines if contract is allowed to be linked to;\n\t\t// Next bit (one) defines if contract is allowed to be unlinked from\n\t\tuint8 newVal = (allowedForLinking? 0x1: 0x0) | (allowedForUnlinking? 0x2: 0x0);\n\n\t\t// emit an event\n\t\temit TargetContractWhitelisted(msg.sender, targetContract, whitelistedTargetContracts[targetContract], newVal);\n\n\t\t// update the contract address in the whitelist\n\t\twhitelistedTargetContracts[targetContract] = newVal;\n\t}\n\n\t/**\n\t * @notice Checks if specified target NFT contract is allowed to be linked to\n\t *\n\t * @dev Using this function can be more convenient than accessing the\n\t *      `whitelistedTargetContracts` directly since the mapping contains linking/unlinking\n\t *      flags packed into uint8\n\t *\n\t * @param targetContract target NFT contract address to query for\n\t * @return true if target NFT contract is allowed to be linked to, false otherwise\n\t */\n\tfunction isAllowedForLinking(address targetContract) public view virtual returns (bool) {\n\t\t// read the mapping and extract the lowest bit (zero) containing information required\n\t\treturn whitelistedTargetContracts[targetContract] & 0x1 == 0x1;\n\t}\n\n\t/**\n\t * @notice Checks if specified target NFT contract is allowed to be unlinked from\n\t *\n\t * @dev Using this function can be more convenient than accessing the\n\t *      `whitelistedTargetContracts` directly since the mapping contains linking/unlinking\n\t *      flags packed into uint8\n\t *\n\t * @param targetContract target NFT contract address to query for\n\t * @return true if target NFT contract is allowed to be unlinked from, false otherwise\n\t */\n\tfunction isAllowedForUnlinking(address targetContract) public view virtual returns (bool) {\n\t\t// read the mapping and extract the next bit (one) containing information required\n\t\treturn whitelistedTargetContracts[targetContract] & 0x2 == 0x2;\n\t}\n}\n"
    },
    "contracts/utils/UpgradeableAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\n/**\n * @title Upgradeable Access Control List // ERC1967Proxy\n *\n * @notice Access control smart contract provides an API to check\n *      if a specific operation is permitted globally and/or\n *      if a particular user has a permission to execute it.\n *\n * @notice It deals with two main entities: features and roles.\n *\n * @notice Features are designed to be used to enable/disable public functions\n *      of the smart contract (used by a wide audience).\n * @notice User roles are designed to control the access to restricted functions\n *      of the smart contract (used by a limited set of maintainers).\n *\n * @notice Terms \"role\", \"permissions\" and \"set of permissions\" have equal meaning\n *      in the documentation text and may be used interchangeably.\n * @notice Terms \"permission\", \"single permission\" implies only one permission bit set.\n *\n * @notice Access manager is a special role which allows to grant/revoke other roles.\n *      Access managers can only grant/revoke permissions which they have themselves.\n *      As an example, access manager with no other roles set can only grant/revoke its own\n *      access manager permission and nothing else.\n *\n * @notice Access manager permission should be treated carefully, as a super admin permission:\n *      Access manager with even no other permission can interfere with another account by\n *      granting own access manager permission to it and effectively creating more powerful\n *      permission set than its own.\n *\n * @dev Both current and OpenZeppelin AccessControl implementations feature a similar API\n *      to check/know \"who is allowed to do this thing\".\n * @dev Zeppelin implementation is more flexible:\n *      - it allows setting unlimited number of roles, while current is limited to 256 different roles\n *      - it allows setting an admin for each role, while current allows having only one global admin\n * @dev Current implementation is more lightweight:\n *      - it uses only 1 bit per role, while Zeppelin uses 256 bits\n *      - it allows setting up to 256 roles at once, in a single transaction, while Zeppelin allows\n *        setting only one role in a single transaction\n *\n * @dev This smart contract is designed to be inherited by other\n *      smart contracts which require access control management capabilities.\n *\n * @dev Access manager permission has a bit 255 set.\n *      This bit must not be used by inheriting contracts for any other permissions/features.\n *\n * @dev This is an upgradeable version of the ACL, based on Zeppelin implementation for ERC1967,\n *      see https://docs.openzeppelin.com/contracts/4.x/upgradeable\n *      see https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable\n *      see https://forum.openzeppelin.com/t/uups-proxies-tutorial-solidity-javascript/7786\n *\n * @author Basil Gorin\n */\nabstract contract UpgradeableAccessControl is UUPSUpgradeable {\n\t/**\n\t * @notice Privileged addresses with defined roles/permissions\n\t * @notice In the context of ERC20/ERC721 tokens these can be permissions to\n\t *      allow minting or burning tokens, transferring on behalf and so on\n\t *\n\t * @dev Maps user address to the permissions bitmask (role), where each bit\n\t *      represents a permission\n\t * @dev Bitmask 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n\t *      represents all possible permissions\n\t * @dev 'This' address mapping represents global features of the smart contract\n\t */\n\tmapping(address => uint256) public userRoles;\n\n\t/**\n\t * @dev Empty reserved space in storage. The size of the __gap array is calculated so that\n\t *      the amount of storage used by a contract always adds up to the 50.\n\t *      See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n\t */\n\tuint256[49] private __gap;\n\n\t/**\n\t * @notice Access manager is responsible for assigning the roles to users,\n\t *      enabling/disabling global features of the smart contract\n\t * @notice Access manager can add, remove and update user roles,\n\t *      remove and update global features\n\t *\n\t * @dev Role ROLE_ACCESS_MANAGER allows modifying user roles and global features\n\t * @dev Role ROLE_ACCESS_MANAGER has single bit at position 255 enabled\n\t */\n\tuint256 public constant ROLE_ACCESS_MANAGER = 0x8000000000000000000000000000000000000000000000000000000000000000;\n\n\t/**\n\t * @notice Upgrade manager is responsible for smart contract upgrades,\n\t *      see https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable\n\t *      see https://docs.openzeppelin.com/contracts/4.x/upgradeable\n\t *\n\t * @dev Role ROLE_UPGRADE_MANAGER allows passing the _authorizeUpgrade() check\n\t * @dev Role ROLE_UPGRADE_MANAGER has single bit at position 254 enabled\n\t */\n\tuint256 public constant ROLE_UPGRADE_MANAGER = 0x4000000000000000000000000000000000000000000000000000000000000000;\n\n\t/**\n\t * @dev Bitmask representing all the possible permissions (super admin role)\n\t * @dev Has all the bits are enabled (2^256 - 1 value)\n\t */\n\tuint256 private constant FULL_PRIVILEGES_MASK = type(uint256).max; // before 0.8.0: uint256(-1) overflows to 0xFFFF...\n\n\t/**\n\t * @dev Fired in updateRole() and updateFeatures()\n\t *\n\t * @param _by operator which called the function\n\t * @param _to address which was granted/revoked permissions\n\t * @param _requested permissions requested\n\t * @param _actual permissions effectively set\n\t */\n\tevent RoleUpdated(address indexed _by, address indexed _to, uint256 _requested, uint256 _actual);\n\n\t/**\n\t * @dev UUPS initializer, sets the contract owner to have full privileges\n\t *\n\t * @dev Can be executed only in constructor during deployment,\n\t *      reverts when executed in already deployed contract\n\t *\n\t * @dev IMPORTANT:\n\t *      this function MUST be executed during proxy deployment (in proxy constructor),\n\t *      otherwise it renders useless and cannot be executed at all,\n\t *      resulting in no admin control over the proxy and no possibility to do future upgrades\n\t *\n\t * @param _owner smart contract owner having full privileges\n\t */\n\tfunction _postConstruct(address _owner) internal virtual initializer {\n\t\t// ensure this function is execute only in constructor\n\t\trequire(!AddressUpgradeable.isContract(address(this)), \"invalid context\");\n\n\t\t// grant owner full privileges\n\t\tuserRoles[_owner] = FULL_PRIVILEGES_MASK;\n\n\t\t// fire an event\n\t\temit RoleUpdated(msg.sender, _owner, FULL_PRIVILEGES_MASK, FULL_PRIVILEGES_MASK);\n\t}\n\n\t/**\n\t * @notice Returns an address of the implementation smart contract,\n\t *      see ERC1967Upgrade._getImplementation()\n\t *\n\t * @return the current implementation address\n\t */\n\tfunction getImplementation() public view virtual returns (address) {\n\t\t// delegate to `ERC1967Upgrade._getImplementation()`\n\t\treturn _getImplementation();\n\t}\n\n\t/**\n\t * @notice Retrieves globally set of features enabled\n\t *\n\t * @dev Effectively reads userRoles role for the contract itself\n\t *\n\t * @return 256-bit bitmask of the features enabled\n\t */\n\tfunction features() public view returns (uint256) {\n\t\t// features are stored in 'this' address  mapping of `userRoles` structure\n\t\treturn userRoles[address(this)];\n\t}\n\n\t/**\n\t * @notice Updates set of the globally enabled features (`features`),\n\t *      taking into account sender's permissions\n\t *\n\t * @dev Requires transaction sender to have `ROLE_ACCESS_MANAGER` permission\n\t * @dev Function is left for backward compatibility with older versions\n\t *\n\t * @param _mask bitmask representing a set of features to enable/disable\n\t */\n\tfunction updateFeatures(uint256 _mask) public {\n\t\t// delegate call to `updateRole`\n\t\tupdateRole(address(this), _mask);\n\t}\n\n\t/**\n\t * @notice Updates set of permissions (role) for a given user,\n\t *      taking into account sender's permissions.\n\t *\n\t * @dev Setting role to zero is equivalent to removing an all permissions\n\t * @dev Setting role to `FULL_PRIVILEGES_MASK` is equivalent to\n\t *      copying senders' permissions (role) to the user\n\t * @dev Requires transaction sender to have `ROLE_ACCESS_MANAGER` permission\n\t *\n\t * @param operator address of a user to alter permissions for or zero\n\t *      to alter global features of the smart contract\n\t * @param role bitmask representing a set of permissions to\n\t *      enable/disable for a user specified\n\t */\n\tfunction updateRole(address operator, uint256 role) public {\n\t\t// caller must have a permission to update user roles\n\t\trequire(isSenderInRole(ROLE_ACCESS_MANAGER), \"access denied\");\n\n\t\t// evaluate the role and reassign it\n\t\tuserRoles[operator] = evaluateBy(msg.sender, userRoles[operator], role);\n\n\t\t// fire an event\n\t\temit RoleUpdated(msg.sender, operator, role, userRoles[operator]);\n\t}\n\n\t/**\n\t * @notice Determines the permission bitmask an operator can set on the\n\t *      target permission set\n\t * @notice Used to calculate the permission bitmask to be set when requested\n\t *     in `updateRole` and `updateFeatures` functions\n\t *\n\t * @dev Calculated based on:\n\t *      1) operator's own permission set read from userRoles[operator]\n\t *      2) target permission set - what is already set on the target\n\t *      3) desired permission set - what do we want set target to\n\t *\n\t * @dev Corner cases:\n\t *      1) Operator is super admin and its permission set is `FULL_PRIVILEGES_MASK`:\n\t *        `desired` bitset is returned regardless of the `target` permission set value\n\t *        (what operator sets is what they get)\n\t *      2) Operator with no permissions (zero bitset):\n\t *        `target` bitset is returned regardless of the `desired` value\n\t *        (operator has no authority and cannot modify anything)\n\t *\n\t * @dev Example:\n\t *      Consider an operator with the permissions bitmask     00001111\n\t *      is about to modify the target permission set          01010101\n\t *      Operator wants to set that permission set to          00110011\n\t *      Based on their role, an operator has the permissions\n\t *      to update only lowest 4 bits on the target, meaning that\n\t *      high 4 bits of the target set in this example is left\n\t *      unchanged and low 4 bits get changed as desired:      01010011\n\t *\n\t * @param operator address of the contract operator which is about to set the permissions\n\t * @param target input set of permissions to operator is going to modify\n\t * @param desired desired set of permissions operator would like to set\n\t * @return resulting set of permissions given operator will set\n\t */\n\tfunction evaluateBy(address operator, uint256 target, uint256 desired) public view returns (uint256) {\n\t\t// read operator's permissions\n\t\tuint256 p = userRoles[operator];\n\n\t\t// taking into account operator's permissions,\n\t\t// 1) enable the permissions desired on the `target`\n\t\ttarget |= p & desired;\n\t\t// 2) disable the permissions desired on the `target`\n\t\ttarget &= FULL_PRIVILEGES_MASK ^ (p & (FULL_PRIVILEGES_MASK ^ desired));\n\n\t\t// return calculated result\n\t\treturn target;\n\t}\n\n\t/**\n\t * @notice Checks if requested set of features is enabled globally on the contract\n\t *\n\t * @param required set of features to check against\n\t * @return true if all the features requested are enabled, false otherwise\n\t */\n\tfunction isFeatureEnabled(uint256 required) public view returns (bool) {\n\t\t// delegate call to `__hasRole`, passing `features` property\n\t\treturn __hasRole(features(), required);\n\t}\n\n\t/**\n\t * @notice Checks if transaction sender `msg.sender` has all the permissions required\n\t *\n\t * @param required set of permissions (role) to check against\n\t * @return true if all the permissions requested are enabled, false otherwise\n\t */\n\tfunction isSenderInRole(uint256 required) public view returns (bool) {\n\t\t// delegate call to `isOperatorInRole`, passing transaction sender\n\t\treturn isOperatorInRole(msg.sender, required);\n\t}\n\n\t/**\n\t * @notice Checks if operator has all the permissions (role) required\n\t *\n\t * @param operator address of the user to check role for\n\t * @param required set of permissions (role) to check\n\t * @return true if all the permissions requested are enabled, false otherwise\n\t */\n\tfunction isOperatorInRole(address operator, uint256 required) public view returns (bool) {\n\t\t// delegate call to `__hasRole`, passing operator's permissions (role)\n\t\treturn __hasRole(userRoles[operator], required);\n\t}\n\n\t/**\n\t * @dev Checks if role `actual` contains all the permissions required `required`\n\t *\n\t * @param actual existent role\n\t * @param required required role\n\t * @return true if actual has required role (all permissions), false otherwise\n\t */\n\tfunction __hasRole(uint256 actual, uint256 required) internal pure returns (bool) {\n\t\t// check the bitmask for the role required and return the result\n\t\treturn actual & required == required;\n\t}\n\n\t/**\n\t * @inheritdoc UUPSUpgradeable\n\t */\n\tfunction _authorizeUpgrade(address) internal virtual override {\n\t\t// caller must have a permission to upgrade the contract\n\t\trequire(isSenderInRole(ROLE_UPGRADE_MANAGER), \"access denied\");\n\t}\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/utils/UUPSUpgradeable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1967/ERC1967UpgradeUpgradeable.sol\";\nimport \"./Initializable.sol\";\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n *\n * _Available since v4.1._\n */\nabstract contract UUPSUpgradeable is Initializable, ERC1967UpgradeUpgradeable {\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n        __ERC1967Upgrade_init_unchained();\n        __UUPSUpgradeable_init_unchained();\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n    address private immutable __self = address(this);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        require(address(this) != __self, \"Function must be called through delegatecall\");\n        require(_getImplementation() == __self, \"Function must be called through active proxy\");\n        _;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeTo(address newImplementation) external virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallSecure(newImplementation, new bytes(0), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallSecure(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeTo} and {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeaconUpgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/StorageSlotUpgradeable.sol\";\nimport \"../utils/Initializable.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967UpgradeUpgradeable is Initializable {\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n        __ERC1967Upgrade_init_unchained();\n    }\n\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            _functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallSecure(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        address oldImplementation = _getImplementation();\n\n        // Initial upgrade and setup call\n        _setImplementation(newImplementation);\n        if (data.length > 0 || forceCall) {\n            _functionDelegateCall(newImplementation, data);\n        }\n\n        // Perform rollback test if not already in progress\n        StorageSlotUpgradeable.BooleanSlot storage rollbackTesting = StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT);\n        if (!rollbackTesting.value) {\n            // Trigger rollback using upgradeTo from the new implementation\n            rollbackTesting.value = true;\n            _functionDelegateCall(\n                newImplementation,\n                abi.encodeWithSignature(\"upgradeTo(address)\", oldImplementation)\n            );\n            rollbackTesting.value = false;\n            // Check rollback was effective\n            require(oldImplementation == _getImplementation(), \"ERC1967Upgrade: upgrade breaks further upgrades\");\n            // Finally reset to the new implementation and log the upgrade\n            _upgradeTo(newImplementation);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            _functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function _functionDelegateCall(address target, bytes memory data) private returns (bytes memory) {\n        require(AddressUpgradeable.isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return AddressUpgradeable.verifyCallResult(success, returndata, \"Address: low-level delegate call failed\");\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() initializer {}\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\n        // contract may have been reentered.\n        require(_initializing ? _isConstructor() : !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} modifier, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlotUpgradeable {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/beacon/IBeaconUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeaconUpgradeable {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "contracts/mocks/AccessControlMocks.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../utils/AccessControl.sol\";\nimport \"../utils/UpgradeableAccessControl.sol\";\n\n/**\n * @title Access Control Mock\n *\n * @notice Used to test the AccessControl core functionality\n *\n * @author Basil Gorin\n */\ncontract AccessControlMock is AccessControl {\n\t// set contract owner to the deployer address\n\tconstructor() AccessControl() {}\n}\n\n/**\n * @title Upgradeable Access Control Mock\n *\n * @notice Used to test the UpgradeableAccessControl core functionality\n *\n * @author Basil Gorin\n */\ncontract UpgradeableAccessControlMock is UpgradeableAccessControl {\n\t// v1 identifier\n\tstring public v1;\n\n\t/**\n\t * @dev UUPS initializer, sets the contract owner to have full privileges\n\t *\n\t * param _owner smart contract owner having full privileges\n\t */\n\tfunction postConstruct() public virtual/* initializer*/ {\n\t\t// execute parent initializer\n\t\t_postConstruct(msg.sender);\n\n\t\t// self init\n\t\tv1 = \"v1\";\n\t}\n}\n\n/**\n * @title Upgradeable Access Control Mock 2\n *\n * @notice Used to test the UpgradeableAccessControl core functionality\n *\n * @author Basil Gorin\n */\ncontract UpgradeableAccessControlMock2 is UpgradeableAccessControl {\n\t// v2 identifier\n\tstring public v2;\n\n\t/**\n\t * @dev UUPS initializer, sets the contract owner to have full privileges\n\t *\n\t * param _owner smart contract owner having full privileges\n\t */\n\tfunction postConstruct() public virtual/* initializer*/ {\n\t\t// execute parent initializer\n\t\t_postConstruct(msg.sender);\n\n\t\t// self init\n\t\tv2 = \"v2\";\n\t}\n}\n"
    },
    "contracts/protocol/IntelliLinker.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ERC721Spec.sol\";\nimport \"./IntelligentNFTv2.sol\";\n\n/**\n * @title Intelligent Token Linker (iNFT Linker)\n *\n * @notice iNFT Linker is a helper smart contract responsible for managing iNFTs.\n *      It creates and destroys iNFTs, determines iNFT creation price and destruction fee.\n *\n * @dev Known limitations (to be resolved in the future releases):\n *      - doesn't check AI Personality / target NFT compatibility: any personality\n *        can be linked to any NFT (NFT contract must be whitelisted)\n *      - doesn't support unlinking + linking in a single transaction\n *      - doesn't support AI Personality smart contract upgrades: in case when new\n *        AI Personality contract is deployed, new iNFT Linker should also be deployed\n *\n * @author Basil Gorin\n */\ncontract IntelliLinker is AccessControl {\n\t/**\n\t * @dev iNFT Linker locks/unlocks ALI tokens defined by `aliContract` to mint/burn iNFT\n\t */\n\taddress public immutable aliContract;\n\n\t/**\n\t * @dev iNFT Linker locks/unlocks AI Personality defined by `personalityContract` to mint/burn iNFT\n\t */\n\taddress public immutable personalityContract;\n\n\t/**\n\t * @dev iNFT Linker mints/burns iNFTs defined by `iNftContract`\n\t */\n\taddress public immutable iNftContract;\n\n\t/**\n\t * @dev iNFTs may get created with the ALI tokens bound to them,\n\t *      linking fee may get charged when creating an iNFT\n\t *\n\t * @dev Linking price, how much ALI tokens is charged upon iNFT creation;\n\t *      `linkPrice - linkFee` is locked within the iNFT created\n\t */\n\tuint96 public linkPrice = 2_000 ether; // we use \"ether\" suffix instead of \"e18\"\n\n\t/**\n\t * @dev iNFTs may get created with the ALI tokens bound to them,\n\t *      linking fee may get charged when creating an iNFT\n\t *\n\t * @dev Linking fee, how much ALI tokens is sent into treasury `feeDestination`\n\t *      upon iNFT creation\n\t *\n\t * @dev Both `linkFee` and `feeDestination` must be set for the fee to be charged;\n\t *      both `linkFee` and `feeDestination` can be either set or unset\n\t */\n\tuint96 public linkFee;\n\n\t/**\n\t * @dev iNFTs may get created with the ALI tokens bound to them,\n\t *      linking fee may get charged when creating an iNFT\n\t *\n\t * @dev Treasury `feeDestination` is an address to send linking fee to upon iNFT creation\n\t *\n\t * @dev Both `linkFee` and `feeDestination` must be set for the fee to be charged;\n\t *      both `linkFee` and `feeDestination` can be either set or unset\n\t */\n\taddress public feeDestination;\n\n\t/**\n\t/**\n\t * @dev Next iNFT ID to mint; initially this is the first \"free\" ID which can be minted;\n\t *      at any point in time this should point to a free, mintable ID for iNFT\n\t *\n\t * @dev iNFT ID space up to 0xFFFF_FFFF (uint32 max) is reserved for the sales\n\t */\n\tuint256 public nextId = 0x1_0000_0000;\n\n\t/**\n\t * @dev Target NFT Contracts allowed iNFT to be linked to;\n\t *      is not taken into account if FEATURE_ALLOW_ANY_NFT_CONTRACT is enabled\n\t */\n\tmapping(address => bool) public whitelistedTargetContracts;\n\n\t/**\n\t * @notice Enables iNFT linking (creation)\n\t *\n\t * @dev Feature FEATURE_LINKING must be enabled\n\t *      as a prerequisite for `link()` function to succeed\n\t */\n\tuint32 public constant FEATURE_LINKING = 0x0000_0001;\n\n\t/**\n\t * @notice Enables iNFT unlinking (destruction)\n\t *\n\t * @dev Feature FEATURE_UNLINKING must be enabled\n\t *      for the `unlink()` and `unlinkNFT()` functions to succeed\n\t */\n\tuint32 public constant FEATURE_UNLINKING = 0x0000_0002;\n\n\t/**\n\t * @notice Allows linker to link (mint) iNFT bound to any target NFT contract,\n\t *      independently whether it was previously whitelisted or not\n\t * @dev Feature FEATURE_ALLOW_ANY_NFT_CONTRACT allows linking (minting) iNFTs\n\t *      bound to any target NFT contract, without a check if it's whitelisted in\n\t *      `whitelistedTargetContracts` or not\n\t */\n\tuint32 public constant FEATURE_ALLOW_ANY_NFT_CONTRACT = 0x0000_0004;\n\n\t/**\n\t * @notice Enables depositing more ALI to already existing iNFTs\n\t *\n\t * @dev Feature FEATURE_DEPOSITS must be enabled\n\t *      for the `deposit()` function to succeed\n\t */\n\tuint32 public constant FEATURE_DEPOSITS = 0x0000_0008;\n\n\t/**\n\t * @notice Enables ALI withdrawals from the iNFT (without destroying them)\n\t *\n\t * @dev Feature FEATURE_WITHDRAWALS must be enabled\n\t *      for the `withdraw()` function to succeed\n\t */\n\tuint32 public constant FEATURE_WITHDRAWALS = 0x0000_0010;\n\n\t/**\n\t * @notice Link price manager is responsible for updating linking price\n\t *\n\t * @dev Role ROLE_LINK_PRICE_MANAGER allows `updateLinkPrice` execution,\n\t *      and `linkPrice` modification\n\t */\n\tuint32 public constant ROLE_LINK_PRICE_MANAGER = 0x0001_0000;\n\n\t/**\n\t * @notice Next ID manager is responsible for updating `nextId` variable,\n\t *      pointing to the next iNFT ID free slot\n\t *\n\t * @dev Role ROLE_NEXT_ID_MANAGER allows `updateNextId` execution,\n\t *     and `nextId` modification\n\t */\n\tuint32 public constant ROLE_NEXT_ID_MANAGER = 0x0002_0000;\n\n\t/**\n\t * @notice Whitelist manager is responsible for managing the target NFT contracts\n\t *     whitelist, which are the contracts iNFT is allowed to be bound to\n\t *\n\t * @dev Role ROLE_WHITELIST_MANAGER allows `whitelistTargetContract` execution,\n\t *     and `whitelistedTargetContracts` mapping modification\n\t */\n\tuint32 public constant ROLE_WHITELIST_MANAGER = 0x0004_0000;\n\n\t/**\n\t * @dev Fired in link() when new iNFT is created\n\t *\n\t * @param _by an address which executed (and funded) the link function\n\t * @param _iNftId ID of the iNFT minted\n\t * @param _linkPrice amount of ALI tokens locked (transferred) to newly created iNFT\n\t * @param _linkFee amount of ALI tokens charged as a fee and sent to the treasury\n\t * @param _personalityContract AI Personality contract address\n\t * @param _personalityId ID of the AI Personality locked (transferred) to newly created iNFT\n\t * @param _targetContract target NFT smart contract\n\t * @param _targetId target NFT ID (where this iNFT binds to and belongs to)\n\t */\n\tevent Linked(\n\t\taddress indexed _by,\n\t\tuint256 _iNftId,\n\t\tuint96 _linkPrice,\n\t\tuint96 _linkFee,\n\t\taddress indexed _personalityContract,\n\t\tuint96 indexed _personalityId,\n\t\taddress _targetContract,\n\t\tuint256 _targetId\n\t);\n\n\t/**\n\t * @dev Fired in unlink() when an existing iNFT gets destroyed\n\t *\n\t * @param _by an address which executed the unlink function\n\t *      (and which received unlocked AI Personality and ALI tokens)\n\t * @param _iNftId ID of the iNFT burnt\n\t */\n\tevent Unlinked(address indexed _by, uint256 indexed _iNftId);\n\n\t/**\n\t * @dev Fired in deposit(), withdraw() when an iNFT ALI balance gets changed\n\t *\n\t * @param _by an address which executed the deposit/withdraw function\n\t *      (in case of withdraw it received unlocked ALI tokens)\n\t * @param _iNftId ID of the iNFT to update\n\t * @param _aliDelta locked ALI tokens delta, positive for deposit, negative for withdraw\n\t * @param _feeValue amount of ALI tokens charged as a fee\n\t */\n\tevent LinkUpdated(address indexed _by, uint256 indexed _iNftId, int128 _aliDelta, uint96 _feeValue);\n\n\t/**\n\t * @dev Fired in updateLinkPrice()\n\t *\n\t * @param _by an address which executed the operation\n\t * @param _linkPrice new linking price set\n\t * @param _linkFee new linking fee set\n\t * @param _feeDestination new treasury address set\n\t */\n\tevent LinkPriceChanged(address indexed _by, uint96 _linkPrice, uint96 _linkFee, address indexed _feeDestination);\n\n\t/**\n\t * @dev Fired in updateNextId()\n\t *\n\t * @param _by an address which executed the operation\n\t * @param _oldVal old nextId value\n\t * @param _newVal new nextId value\n\t */\n\tevent NextIdChanged(address indexed _by, uint256 _oldVal, uint256 _newVal);\n\n\t/**\n\t * @dev Fired in whitelistTargetContract()\n\t *\n\t * @param _by an address which executed the operation\n\t * @param _targetContract target NFT contract address affected\n\t * @param _oldVal old whitelisted value\n\t * @param _newVal new whitelisted value\n\t */\n\tevent TargetContractWhitelisted(address indexed _by, address indexed _targetContract, bool _oldVal, bool _newVal);\n\n\t/**\n\t * @dev Creates/deploys an iNFT Linker instance bound to already deployed\n\t *      iNFT, AI Personality and ALI Token instances\n\t *\n\t * @param _ali address of the deployed ALI ERC20 Token instance the iNFT Linker is bound to\n\t * @param _personality address of the deployed AI Personality instance the iNFT Linker is bound to\n\t * @param _iNft address of the deployed iNFT instance the iNFT Linker is bound to\n\t */\n\tconstructor(address _ali, address _personality, address _iNft) {\n\t\t// verify inputs are set\n\t\trequire(_ali != address(0), \"ALI Token addr is not set\");\n\t\trequire(_personality != address(0), \"AI Personality addr is not set\");\n\t\trequire(_iNft != address(0), \"iNFT addr is not set\");\n\n\t\t// verify inputs are valid smart contracts of the expected interfaces\n\t\trequire(ERC165(_ali).supportsInterface(type(ERC20).interfaceId), \"unexpected ALI Token type\");\n\t\trequire(ERC165(_personality).supportsInterface(type(ERC721).interfaceId), \"unexpected AI Personality type\");\n\t\trequire(ERC165(_iNft).supportsInterface(type(IntelligentNFTv2Spec).interfaceId), \"unexpected iNFT type\");\n\n\t\t// setup smart contract internal state\n\t\taliContract = _ali;\n\t\tpersonalityContract = _personality;\n\t\tiNftContract = _iNft;\n\t}\n\n\t/**\n\t * @notice Links given AI Personality with the given NFT and forms an iNFT.\n\t *      AI Personality specified and `linkPrice` ALI are transferred into minted iNFT\n\t *      and are effectively locked within an iNFT until it is destructed (burnt)\n\t *\n\t * @dev AI Personality and ALI tokens are transferred from the transaction sender account\n\t *      to iNFT smart contract\n\t * @dev Sender must approve both AI Personality and ALI tokens transfers to be\n\t *      performed by the linker contract\n\t *\n\t * @param personalityId AI Personality ID to be locked into iNFT\n\t * @param targetContract NFT address iNFT to be linked to\n\t * @param targetId NFT ID iNFT to be linked to\n\t */\n\tfunction link(uint96 personalityId, address targetContract, uint256 targetId) public {\n\t\t// verify linking is enabled\n\t\trequire(isFeatureEnabled(FEATURE_LINKING), \"linking is disabled\");\n\n\t\t// verify AI Personality belongs to transaction sender\n\t\trequire(ERC721(personalityContract).ownerOf(personalityId) == msg.sender, \"access denied\");\n\t\t// verify NFT contract is either whitelisted or any NFT contract is allowed globally\n\t\trequire(whitelistedTargetContracts[targetContract] || isFeatureEnabled(FEATURE_ALLOW_ANY_NFT_CONTRACT), \"not a whitelisted NFT contract\");\n\n\t\t// if linking fee is set\n\t\tif(linkFee > 0) {\n\t\t\t// transfer ALI tokens to the treasury - `feeDestination`\n\t\t\tERC20(aliContract).transferFrom(msg.sender, feeDestination, linkFee);\n\t\t}\n\n\t\t// if linking price is set\n\t\tif(linkPrice > 0) {\n\t\t\t// transfer ALI tokens to iNFT contract to be locked\n\t\t\tERC20(aliContract).transferFrom(msg.sender, iNftContract, linkPrice - linkFee);\n\t\t}\n\n\t\t// transfer AI Personality to iNFT contract to be locked\n\t\tERC721(personalityContract).transferFrom(msg.sender, iNftContract, personalityId);\n\n\t\t// mint the next iNFT, increment next iNFT ID to be minted\n\t\tIntelligentNFTv2(iNftContract).mint(nextId++, linkPrice - linkFee, personalityContract, personalityId, targetContract, targetId);\n\n\t\t// emit an event\n\t\temit Linked(msg.sender, nextId - 1, linkPrice, linkFee, personalityContract, personalityId, targetContract, targetId);\n\t}\n\n\t/**\n\t * @notice Destroys given iNFT, unlinking it from underlying NFT and unlocking\n\t *      the AI Personality and ALI tokens locked in iNFT.\n\t *      AI Personality and ALI tokens are transferred to the underlying NFT owner\n\t *\n\t * @dev Can be executed only by iNFT owner (effectively underlying NFT owner)\n\t *\n\t * @param iNftId ID of the iNFT to unlink\n\t */\n\tfunction unlink(uint256 iNftId) public {\n\t\t// verify unlinking is enabled\n\t\trequire(isFeatureEnabled(FEATURE_UNLINKING), \"unlinking is disabled\");\n\n\t\t// get a link to an iNFT contract to perform several actions with it\n\t\tIntelligentNFTv2 iNFT = IntelligentNFTv2(iNftContract);\n\n\t\t// verify the transaction is executed by iNFT owner (effectively by underlying NFT owner)\n\t\trequire(iNFT.ownerOf(iNftId) == msg.sender, \"not an iNFT owner\");\n\n\t\t// burn the iNFT unlocking the AI Personality and ALI tokens - delegate to `IntelligentNFTv2.burn`\n\t\tiNFT.burn(iNftId);\n\n\t\t// emit an event\n\t\temit Unlinked(msg.sender, iNftId);\n\t}\n\n\t/**\n\t * @notice Unlinks given NFT by destroying iNFTs and unlocking\n\t *      the AI Personality and ALI tokens locked in iNFTs.\n\t *      AI Personality and ALI tokens are transferred to the underlying NFT owner\n\t *\n\t * @dev Can be executed only by NFT owner (effectively underlying NFT owner)\n\t *\n\t * @param nftContract NFT address iNFTs to be unlinked to\n\t * @param nftId NFT ID iNFTs to be unlinked to\n\t */\n\tfunction unlinkNFT(address nftContract, uint256 nftId) public {\n\t\t// verify unlinking is enabled\n\t\trequire(isFeatureEnabled(FEATURE_UNLINKING), \"unlinking is disabled\");\n\n\t\t// get a link to an iNFT contract to perform several actions with it\n\t\tIntelligentNFTv2 iNFT = IntelligentNFTv2(iNftContract);\n\n\t\t// verify the transaction is executed by NFT owner\n\t\trequire(ERC721(nftContract).ownerOf(nftId) == msg.sender, \"not an NFT owner\");\n\n\t\t// get iNFT ID linked with given NFT\n\t\tuint256 iNftId = iNFT.reverseBindings(nftContract, nftId);\n\n\t\t// burn the iNFT unlocking the AI Personality and ALI tokens - delegate to `IntelligentNFTv2.burn`\n\t\tiNFT.burn(iNftId);\n\n\t\t// emit an event\n\t\temit Unlinked(msg.sender, iNftId);\n\t}\n\n\t/**\n\t * @notice Deposits additional ALI tokens into already existing iNFT\n\t *\n\t * @dev Can be executed only by NFT owner (effectively underlying NFT owner)\n\t *\n\t * @dev ALI tokens are transferred from the transaction sender account to iNFT smart contract\n\t *      Sender must approve ALI tokens transfers to be performed by the linker contract\n\t *\n\t * @param iNftId ID of the iNFT to transfer (and lock) tokens to\n\t * @param aliValue amount of ALI tokens to transfer (and lock)\n\t */\n\tfunction deposit(uint256 iNftId, uint96 aliValue) public {\n\t\t// verify deposits are enabled\n\t\trequire(isFeatureEnabled(FEATURE_DEPOSITS), \"deposits are disabled\");\n\n\t\t// get a link to an iNFT contract to perform several actions with it\n\t\tIntelligentNFTv2 iNFT = IntelligentNFTv2(iNftContract);\n\n\t\t// verify the transaction is executed by iNFT owner (effectively by underlying NFT owner)\n\t\trequire(iNFT.ownerOf(iNftId) == msg.sender, \"not an iNFT owner\");\n\n\t\t// effective ALI value locked in iNFT may get altered according to the linking fee set\n\t\t// init effective fee as if linking fee is not set\n\t\tuint96 _linkFee = 0;\n\t\t// init effective ALI value locked as if linking fee is not set\n\t\tuint96 _aliValue = aliValue;\n\t\t// in case when link price/fee are set (effectively meaning fee percent is set)\n\t\tif(linkPrice != 0 && linkFee != 0) {\n\t\t\t// we need to make sure the fee is charged from the value supplied\n\t\t\t// proportionally to the value supplied and fee percent\n\t\t\t_linkFee = uint96(uint256(_aliValue) * linkFee / linkPrice);\n\n\t\t\t// recalculate ALI value to be locked accordingly\n\t\t\t_aliValue = aliValue - _linkFee;\n\n\t\t\t// transfer ALI tokens to the treasury - `feeDestination`\n\t\t\tERC20(aliContract).transferFrom(msg.sender, feeDestination, _linkFee);\n\t\t}\n\n\t\t// transfer ALI tokens to iNFT contract to be locked\n\t\tERC20(aliContract).transferFrom(msg.sender, iNftContract, _aliValue);\n\n\t\t// update the iNFT record\n\t\tiNFT.increaseAli(iNftId, _aliValue);\n\n\t\t// emit an event\n\t\temit LinkUpdated(msg.sender, iNftId, int128(uint128(_aliValue)), _linkFee);\n\t}\n\n\t/**\n\t * @notice Withdraws some ALI tokens from already existing iNFT without destroying it\n\t *\n\t * @dev Can be executed only by NFT owner (effectively underlying NFT owner)\n\t *\n\t * @dev ALI tokens are transferred to the iNFT owner (transaction executor)\n\t *\n\t * @param iNftId ID of the iNFT to unlock tokens from\n\t * @param aliValue amount of ALI tokens to unlock\n\t */\n\tfunction withdraw(uint256 iNftId, uint96 aliValue) public {\n\t\t// verify withdrawals are enabled\n\t\trequire(isFeatureEnabled(FEATURE_WITHDRAWALS), \"withdrawals are disabled\");\n\n\t\t// get a link to an iNFT contract to perform several actions with it\n\t\tIntelligentNFTv2 iNFT = IntelligentNFTv2(iNftContract);\n\n\t\t// verify the transaction is executed by iNFT owner (effectively by underlying NFT owner)\n\t\trequire(iNFT.ownerOf(iNftId) == msg.sender, \"not an iNFT owner\");\n\n\t\t// ensure iNFT locked balance doesn't go below `linkPrice - linkFee`\n\t\trequire(iNFT.lockedValue(iNftId) >= aliValue + linkPrice, \"deposit too low\");\n\n\t\t// update the iNFT record and transfer tokens back to the iNFT owner\n\t\tiNFT.decreaseAli(iNftId, aliValue, msg.sender);\n\n\t\t// emit an event\n\t\temit LinkUpdated(msg.sender, iNftId, -int128(uint128(aliValue)), 0);\n\t}\n\n\t/**\n\t * @dev Restricted access function to modify\n\t *      - linking price `linkPrice`,\n\t *      - linking fee `linkFee`, and\n\t *      - treasury address `feeDestination`\n\t *\n\t * @dev Requires executor to have ROLE_LINK_PRICE_MANAGER permission\n\t * @dev Requires linking price to be either unset (zero), or not less than 1e12 (0.000001 ALI)\n\t * @dev Requires both linking fee and treasury address to be either set or unset (zero);\n\t *      if set, linking fee must not be less than 1e12 (0.000001 ALI);\n\t *      if set, linking fee must not exceed linking price\n\t *\n\t * @param _linkPrice new linking price to be set\n\t * @param _linkFee new linking fee to be set\n\t * @param _feeDestination treasury address\n\t */\n\tfunction updateLinkPrice(uint96 _linkPrice, uint96 _linkFee, address _feeDestination) public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_LINK_PRICE_MANAGER), \"access denied\");\n\n\t\t// verify the price is not too low if it's set\n\t\trequire(_linkPrice == 0 || _linkPrice >= 1e12, \"invalid price\");\n\n\t\t// linking fee/treasury should be either both set or both unset\n\t\t// linking fee must not be too low if set\n\t\trequire(_linkFee == 0 && _feeDestination == address(0) || _linkFee >= 1e12 && _feeDestination != address(0), \"invalid linking fee/treasury\");\n\t\t// linking fee must not exceed linking price\n\t\trequire(_linkFee <= _linkPrice, \"linking fee exceeds linking price\");\n\n\t\t// update the linking price, fee, and treasury address\n\t\tlinkPrice = _linkPrice;\n\t\tlinkFee = _linkFee;\n\t\tfeeDestination = _feeDestination;\n\n\t\t// emit an event\n\t\temit LinkPriceChanged(msg.sender, _linkPrice, _linkFee, _feeDestination);\n\t}\n\n\t/**\n\t * @dev Restricted access function to modify next iNFT ID `nextId`\n\t *\n\t * @param _nextId new next iNFT ID to be set\n\t */\n\tfunction updateNextId(uint256 _nextId) public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_NEXT_ID_MANAGER), \"access denied\");\n\n\t\t// verify nextId is in safe bounds\n\t\trequire(_nextId > 0xFFFF_FFFF, \"value too low\");\n\n\t\t// emit a event\n\t\temit NextIdChanged(msg.sender, nextId, _nextId);\n\n\t\t// update next ID\n\t\tnextId = _nextId;\n\t}\n\n\t/**\n\t * @dev Restricted access function to manage whitelisted NFT contracts mapping `whitelistedTargetContracts`\n\t *\n\t * @dev Requires executor to have ROLE_WHITELIST_MANAGER permission\n\t *\n\t * @param targetContract target NFT contract address to add/remove to/from the whitelist\n\t * @param whitelist true to add, false to remove to/from whitelist\n\t */\n\tfunction whitelistTargetContract(address targetContract, bool whitelist) public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_WHITELIST_MANAGER), \"access denied\");\n\n\t\t// verify the address is set\n\t\trequire(targetContract != address(0), \"zero address\");\n\n\t\t// delisting is always possible, whitelisting - only for valid ERC721\n\t\tif(whitelist) {\n\t\t\t// verify targetContract is a valid ERC721\n\t\t\trequire(ERC165(targetContract).supportsInterface(type(ERC721).interfaceId), \"target NFT is not ERC721\");\n\t\t}\n\n\t\t// emit an event\n\t\temit TargetContractWhitelisted(msg.sender, targetContract, whitelistedTargetContracts[targetContract], whitelist);\n\n\t\t// add/remove the contract address to/from the whitelist\n\t\twhitelistedTargetContracts[targetContract] = whitelist;\n\t}\n}\n"
    },
    "contracts/protocol/ERC721Drop.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ERC721Spec.sol\";\nimport \"../interfaces/ERC721SpecExt.sol\";\nimport \"../utils/AccessControl.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\n\n/**\n * @title ERC721 Airdrop\n *\n * @notice During the release 2.0 distribution event of 10,000 personality pods,\n *      it became clear there is a need to distribute around 10% for free, as an Airdrop.\n *\n * @notice ERC721Drop contract introduces a scalable mechanism to mint NFTs to an arbitrary\n *      amount of addresses by leveraging the power of Merkle trees to \"compress\" minting data.\n *\n * @notice The input data is an array of (address, tokenId) pairs; Merkle tree is built out\n *      from this array, and the tree root is stored on the contract by its data manager.\n *      When minting (address, tokenId), executor specifies also the Merkle proof for an\n *      element (address, tokenId) to mint.\n *\n * @author Basil Gorin\n */\ncontract ERC721Drop is AccessControl {\n\t// Use Zeppelin MerkleProof Library to verify Merkle proofs\n\tusing MerkleProof for bytes32[];\n\n\t/**\n\t * @notice Input data root, Merkle tree root for an array of (address, tokenId) pairs,\n\t *      available for minting\n\t *\n\t * @notice Merkle root effectively \"compresses\" the (potentially) huge array of data elements\n\t *      and allows to store it in a single 256-bits storage slot on-chain\n\t */\n\tbytes32 public root;\n\n\t/**\n\t * @dev Mintable ERC721 contract address to mint tokens of\n\t */\n\taddress public immutable targetContract;\n\n\t/**\n\t * @notice Enables the airdrop, redeeming the tokens\n\t *\n\t * @dev Feature FEATURE_REDEEM_ACTIVE must be enabled in order for\n\t *      `mint()` function to succeed\n\t */\n\tuint32 public constant FEATURE_REDEEM_ACTIVE = 0x0000_0001;\n\n\t/**\n\t * @notice Data manager is responsible for supplying the valid input data array\n\t *      Merkle root which then can be used to mint tokens, meaning effectively,\n\t *      that data manager may act as a minter on the target NFT contract\n\t *\n\t * @dev Role ROLE_DATA_MANAGER allows setting the Merkle tree root via setInputDataRoot()\n\t */\n\tuint32 public constant ROLE_DATA_MANAGER = 0x0001_0000;\n\n\t/**\n\t * @dev Fired in setInputDataRoot()\n\t *\n\t * @param _by an address which executed the operation\n\t * @param _root new Merkle root value\n\t */\n\tevent RootChanged(address indexed _by, bytes32 _root);\n\n\t/**\n\t * @dev Fired in redeem()\n\t *\n\t * @param _by an address which executed the operation\n\t * @param _to an address the token was minted to\n\t * @param _tokenId token ID minted\n\t * @param _proof Merkle proof for the (_to, _tokenId) pair\n\t */\n\tevent Redeemed(address indexed _by, address indexed _to, uint256 indexed _tokenId, bytes32[] _proof);\n\n\t/**\n\t * @dev Creates/deploys ERC721Drop and binds it to ERC721 smart contract on construction\n\t *\n\t * @param _target deployed Mintable ERC721 smart contract; contract will mint NFTs of that type\n\t */\n\tconstructor(address _target) {\n\t\t// verify the input is set\n\t\trequire(_target != address(0), \"target contract is not set\");\n\n\t\t// verify the input is valid smart contract of the expected interfaces\n\t\trequire(\n\t\t\tERC165(_target).supportsInterface(type(ERC721).interfaceId)\n\t\t\t&& ERC165(_target).supportsInterface(type(MintableERC721).interfaceId),\n\t\t\t\"unexpected target type\"\n\t\t);\n\n\t\t// assign the address\n\t\ttargetContract = _target;\n\t}\n\n\t/**\n\t * @notice Restricted access function to update input data root (Merkle tree root),\n\t *       and to define, effectively, the tokens to be created by this smart contract\n\t *\n\t * @dev Requires executor to have `ROLE_DATA_MANAGER` permission\n\t *\n\t * @param _root Merkle tree root for the input data array\n\t */\n\tfunction setInputDataRoot(bytes32 _root) public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_DATA_MANAGER), \"access denied\");\n\n\t\t// update input data Merkle tree root\n\t\troot = _root;\n\n\t\t// emit an event\n\t\temit RootChanged(msg.sender, _root);\n\t}\n\n\t/**\n\t * @notice Verifies the validity of a `(_to, _tokenId)` pair supplied based on the Merkle root\n\t *      of the entire `(_to, _tokenId)` data array (pre-stored in the contract), and the Merkle\n\t *      proof `_proof` for the particular `(_to, _tokenId)` pair supplied\n\t *\n\t * @dev Merkle tree and proof can be constructed using the `web3-utils`, `merkletreejs`,\n\t *      and `keccak256` npm packages:\n\t *      1. Hash the original array data elements (_to, _tokenId) via `web3.utils.soliditySha3`,\n\t *         making sure the packing order and types are exactly as in `mint()` signature\n\t *      2. Create a sorted MerkleTree (`merkletreejs`) from the hashed array, use `keccak256`\n\t *         from the `keccak256` npm package as a hashing function, do not hash leaves\n\t *         (already hashed in step 1); Ex. MerkleTree options: {hashLeaves: false, sortPairs: true}\n\t *      3. For any given data element (_to, _tokenId) the proof is constructed by hashing it\n\t *         (as in step 1) and querying the MerkleTree for a proof, providing the hashed element\n\t *         as a leaf\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId token ID to mint\n\t * @param _proof Merkle proof for the (_to, _tokenId) pair supplied\n\t * @return true if Merkle proof is valid (data belongs to the original array), false otherwise\n\t */\n\tfunction isTokenValid(address _to, uint256 _tokenId, bytes32[] memory _proof) public view returns(bool) {\n\t\t// construct Merkle tree leaf from the inputs supplied\n\t\tbytes32 leaf = keccak256(abi.encodePacked(_to, _tokenId));\n\n\t\t// verify the proof supplied, and return the verification result\n\t\treturn _proof.verify(root, leaf);\n\t}\n\n\t/**\n\t * @notice Mints token `_tokenId` to an address `_to`, verifying the validity\n\t *      of a `(_to, _tokenId)` pair via the Merkle proof `_proof`\n\t *\n\t * @dev Merkle tree and proof can be constructed using the `web3-utils`, `merkletreejs`,\n\t *      and `keccak256` npm packages:\n\t *      1. Hash the original array data elements (_to, _tokenId) via `web3.utils.soliditySha3`,\n\t *         making sure the packing order and types are exactly as in `mint()` signature\n\t *      2. Create a sorted MerkleTree (`merkletreejs`) from the hashed array, use `keccak256`\n\t *         from the `keccak256` npm package as a hashing function, do not hash leaves\n\t *         (already hashed in step 1); Ex. MerkleTree options: {hashLeaves: false, sortPairs: true}\n\t *      3. For any given data element (_to, _tokenId) the proof is constructed by hashing it\n\t *         (as in step 1) and querying the MerkleTree for a proof, providing the hashed element\n\t *         as a leaf\n\t *\n\t * @dev Throws is the data or merkle proof supplied is not valid\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId token ID to mint\n\t * @param _proof Merkle proof for the (_to, _tokenId) pair supplied\n\t */\n\tfunction redeem(address _to, uint256 _tokenId, bytes32[] memory _proof) public {\n\t\t// verify airdrop is in active state\n\t\trequire(isFeatureEnabled(FEATURE_REDEEM_ACTIVE), \"redeems are disabled\");\n\n\t\t// verify the `(_to, _tokenId)` pair is valid\n\t\trequire(isTokenValid(_to, _tokenId, _proof), \"invalid token\");\n\n\t\t// mint the token\n\t\tMintableERC721(targetContract).safeMint(_to, _tokenId);\n\n\t\t// emit an event\n\t\temit Redeemed(msg.sender, _to, _tokenId, _proof);\n\t}\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle Trees proofs.\n *\n * The proofs can be generated using the JavaScript library\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\n *\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merklee tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     *\n     * _Available since v4.4._\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n            if (computedHash <= proofElement) {\n                // Hash(current computed hash + current element of the proof)\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\n            } else {\n                // Hash(current element of the proof + current computed hash)\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\n            }\n        }\n        return computedHash;\n    }\n}\n"
    },
    "contracts/mocks/ZeppelinERC721ReceiverMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ERC721Spec.sol\";\n\ncontract ZeppelinERC721ReceiverMock is ERC721TokenReceiver {\n\tenum Error {\n\t\tNone,\n\t\tRevertWithMessage,\n\t\tRevertWithoutMessage,\n\t\tPanic\n\t}\n\n\tbytes4 private immutable _retval;\n\tError private immutable _error;\n\n\tevent Received(address operator, address from, uint256 tokenId, bytes data, uint256 gas);\n\n\tconstructor(bytes4 retval, Error error) {\n\t\t_retval = retval;\n\t\t_error = error;\n\t}\n\n\tfunction onERC721Received(\n\t\taddress operator,\n\t\taddress from,\n\t\tuint256 tokenId,\n\t\tbytes memory data\n\t) public override returns (bytes4) {\n\t\tif (_error == Error.RevertWithMessage) {\n\t\t\trevert(\"ERC721ReceiverMock: reverting\");\n\t\t} else if (_error == Error.RevertWithoutMessage) {\n\t\t\trevert();\n\t\t} else if (_error == Error.Panic) {\n\t\t\tuint256 a = uint256(0) / uint256(0);\n\t\t\ta;\n\t\t}\n\t\temit Received(operator, from, tokenId, data, gasleft());\n\t\treturn _retval;\n\t}\n}\n"
    },
    "contracts/protocol/FixedSupplySale.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ERC721SpecExt.sol\";\nimport \"./IntelligentNFTv2.sol\";\nimport \"../utils/AccessControl.sol\";\n\n/**\n * @title Fixed Supply Sale\n *\n * @notice Fixed Supply Sale sales fixed amount of iNFTs for a fixed price in a fixed period of time;\n *      underlying NFTs and AI Personalities are being minted as well as a part of the sale process\n *\n * @notice In restricted mode (FEATURE_PUBLIC_SALE feature disabled) sells the items only to\n *      accounts having `ROLE_BUYER` permission (used to mint first hundred iNFTs in the 10k sale campaign)\n *\n * @dev Technically, all the \"fixed\" parameters can be changed on the go after smart contract is deployed\n *      and operational, but this ability is reserved for quick fix-like adjustments, and to provide\n *      an ability to restart and run a similar sale after the previous one ends\n *\n * @dev When buying an iNFT from this smart contract:\n *      1) next NFT is minted to the transaction sender address\n *      2) next AI Personality is minted directly to iNFT smart contract for further locking\n *      3) next iNFT is created, bound to an NFT minted in step (1)\n *         and locking the AI Personality minted in step (2)\n *      4) no ALI tokens are minted, no ALI tokens are locked or consumed in the process\n *\n * @dev Deployment and setup:\n *      1. Deploy smart contract, specify smart contract addresses during the deployment\n *         - iNFT deployed instance address\n *         - NFT deployed instance address\n *         - AI Personality deployed instance address\n *      2. Execute `initialize` function and set up the sale parameters;\n *         sale is not active until it's initialized\n *\n * @author Basil Gorin\n */\ncontract FixedSupplySale is AccessControl {\n\t// ----- SLOT.1 (256/256)\n\t/**\n\t * @notice Price of a single iNFT minted (with the underlying NFT and AI Personality minted)\n\t *      When buying several iNFTs at once the price accumulates accordingly, with no discount\n\t *\n\t * @dev Maximum item price is ~18.44 ETH\n\t */\n\tuint64 public itemPrice;\n\n\t/**\n\t * @dev Next iNFT / bound NFT / AI Personality ID to mint;\n\t *      initially this is the first \"free\" ID which can be minted;\n\t *      at any point in time this should point to a free, mintable ID\n\t *      for iNFT / bound NFT / AI Personality\n\t *\n\t * @dev `nextId` cannot be zero, we do not ever mint NFTs with zero IDs\n\t */\n\tuint32 public nextId = 1;\n\n\t/**\n\t * @dev Last iNFT / bound NFT / AI Personality ID to mint;\n\t *      once `nextId` exceeds `finalId` the sale pauses\n\t */\n\tuint32 public finalId;\n\n\t/**\n\t * @notice Sale start unix timestamp; the sale is active after the start (inclusive)\n\t */\n\tuint32 public saleStart;\n\n\t/**\n\t * @notice Sale end unix timestamp; the sale is active before the end (exclusive)\n\t */\n\tuint32 public saleEnd;\n\n\t/**\n\t * @notice Once set, limits the amount of iNFTs one can buy in a single transaction;\n\t *       When unset (zero) the amount of iNFTs is limited only by block size and\n\t *       amount of iNFTs left for sale\n\t */\n\tuint32 public batchLimit;\n\n\t/**\n\t * @notice Counter of the iNFTs sold (minted) by this sale smart contract\n\t */\n\tuint32 public soldCounter;\n\n\t// ----- NON-SLOTTED\n\t/**\n\t * @dev ALI ERC20 contract address to transfer tokens and bind to iNFTs created,\n\t *      should match with `iNftContract.aliContract`\n\t */\n\taddress public immutable aliContract;\n\n\t/**\n\t * @dev NFT ERC721 contract address to mint NFTs from and bind to iNFTs created\n\t */\n\taddress public immutable nftContract;\n\n\t/**\n\t * @dev Personality Pod ERC721 contract address to mint and lock into iNFTs created\n\t */\n\taddress public immutable personalityContract;\n\n\t/**\n\t * @dev iNFT contract address used to create iNFTs\n\t */\n\taddress public immutable iNftContract;\n\n\t// ----- SLOT.2\n\t/**\n\t * @dev iNFTs may get created with the ALI tokens bound to them.\n\t *      The tokens are transferred from the address specified.\n\t *      The address specified has to approve the sale to spend tokens.\n\t *\n\t * @dev Both `aliSource` and `aliValue` must be set in order to bind tokens\n\t *      to iNFTs sold\n\t *\n\t * @dev Both `aliSource` and `aliValue` can be either set or unset\n\t */\n\taddress public aliSource;\n\n\t/**\n\t * @dev iNFTs may get created with the ALI tokens bound to them.\n\t *      Specified amount of tokens is transferred from the address specified above\n\t *      for each iNFT created, and is bound within the iNFT\n\t *      The address specified above has to approve the sale to spend tokens.\n\t *\n\t * @dev Both `aliSource` and `aliValue` must be set in order to bind tokens\n\t *      to iNFTs sold\n\t *\n\t * @dev Both `aliSource` and `aliValue` can be either set or unset\n\t */\n\tuint96 public aliValue;\n\n\t/**\n\t * @notice Allows buying the items publicly, effectively ignoring the buyer permission\n\t *\n\t * @dev When `FEATURE_PUBLIC_SALE` is enabled, `ROLE_BUYER` is ignored and\n\t *      buying items via buy(), buyTo(), buySingle(), buySingleTo() becomes publicly accessible\n\t */\n\tuint32 public constant FEATURE_PUBLIC_SALE = 0x0000_0001;\n\n\t/**\n\t * @notice Sale manager is responsible for managing properties of the sale,\n\t *      such as sale price, amount, start/end dates, etc.\n\t *\n\t * @dev Role ROLE_SALE_MANAGER allows updating sale properties via initialize() function\n\t */\n\tuint32 public constant ROLE_SALE_MANAGER = 0x0001_0000;\n\n\t/**\n\t * @notice Withdrawal manager is responsible for withdrawing ETH obtained in sale\n\t *      from the sale smart contract\n\t *\n\t * @dev Role ROLE_WITHDRAWAL_MANAGER allows ETH withdrawals:\n\t *      - withdraw()\n\t *      - withdrawTo()\n\t */\n\tuint32 public constant ROLE_WITHDRAWAL_MANAGER = 0x0002_0000;\n\n\t/**\n\t * @notice Buyer can buy items via the restricted sale\n\t *\n\t * @dev Role ROLE_BUYER allows buying items via buy(), buyTo(), buySingle(), buySingleTo()\n\t */\n\tuint32 public constant ROLE_BUYER = 0x0004_0000;\n\n\t/**\n\t * @dev Fired in initialize()\n\t *\n\t * @param _by an address which executed the initialization\n\t * @param _itemPrice price of one iNFT created\n\t * @param _nextId next ID of the iNFT, NFT, and AI Pod to mint\n\t * @param _finalId final ID of the iNFT, NFT, and AI Pod to mint\n\t * @param _saleStart start of the sale, unix timestamp\n\t * @param _saleEnd end of the sale, unix timestamp\n\t * @param _batchLimit how many iNFTs is allowed to buy in a single transaction\n\t * @param _aliSource an address to transfer ALI tokens from to bind to iNFTs created\n\t * @param _aliValue an amount of ALI tokens to transfer and bind for each iNFT created\n\t */\n\tevent Initialized(\n\t\taddress indexed _by,\n\t\tuint64 _itemPrice,\n\t\tuint32 _nextId,\n\t\tuint32 _finalId,\n\t\tuint32 _saleStart,\n\t\tuint32 _saleEnd,\n\t\tuint32 _batchLimit,\n\t\taddress indexed _aliSource,\n\t\tuint96 _aliValue\n\t);\n\n\t/**\n\t * @dev Fired in buy(), buyTo(), buySingle(), and buySingleTo()\n\t *\n\t * @param _by an address which executed and payed the transaction, probably a buyer\n\t * @param _to an address which received token(s) and iNFT(s) minted\n\t * @param _amount number of tokens and iNFTs minted\n\t * @param _aliValue number of ALI tokens transferred\n\t * @param _value ETH amount charged\n\t */\n\tevent Bought(address indexed _by, address indexed _to, uint256 _amount, uint256 _aliValue, uint256 _value);\n\n\t/**\n\t * @dev Fired in withdraw() and withdrawTo()\n\t *\n\t * @param _by an address which executed the withdrawal\n\t * @param _to an address which received the ETH withdrawn\n\t * @param _value ETH amount withdrawn\n\t */\n\tevent Withdrawn(address indexed _by, address indexed _to, uint256 _value);\n\n\t/**\n\t * @dev Creates/deploys FixedSupplySale and binds it to NFT, AI Personality, and iNFT\n\t *      smart contracts on construction\n\t *\n\t * @param _ali deployed ALI ERC20 smart contract address; sale may bind tokens to iNFTs created\n\t * @param _iNft deployed iNFT smart contract address; sale will create iNFTs of that type\n\t * @param _nft deployed NFT smart contract address; sale will mint NFTs of that type\n\t *      and bind created iNFT to these NFTs\n\t * @param _personality deployed AI Personality smart contract; sale will mint AI Personality\n\t *      tokens of that type and lock them within iNFTs\n\t */\n\tconstructor(address _ali, address _nft, address _personality, address _iNft) {\n\t\t// verify the inputs are set\n\t\trequire(_ali != address(0), \"ALI Token contract is not set\");\n\t\trequire(_nft != address(0), \"NFT contract is not set\");\n\t\trequire(_personality != address(0), \"AI Personality contract is not set\");\n\t\trequire(_iNft != address(0), \"iNFT contract is not set\");\n\n\t\t// verify inputs are valid smart contracts of the expected interfaces\n\t\trequire(ERC165(_ali).supportsInterface(type(ERC20).interfaceId), \"unexpected ALI Token type\");\n\t\trequire(\n\t\t\tERC165(_nft).supportsInterface(type(ERC721).interfaceId)\n\t\t\t&& ERC165(_nft).supportsInterface(type(MintableERC721).interfaceId),\n\t\t\t\"unexpected NFT type\"\n\t\t);\n\t\trequire(\n\t\t\tERC165(_personality).supportsInterface(type(ERC721).interfaceId)\n\t\t\t&& ERC165(_personality).supportsInterface(type(MintableERC721).interfaceId),\n\t\t\t\"unexpected AI Personality type\"\n\t\t);\n\t\trequire(ERC165(_iNft).supportsInterface(type(IntelligentNFTv2Spec).interfaceId), \"unexpected iNFT type\");\n\n\t\t// assign the addresses\n\t\taliContract = _ali;\n\t\tnftContract = _nft;\n\t\tpersonalityContract = _personality;\n\t\tiNftContract = _iNft;\n\t}\n\n\t/**\n\t * @notice Number of iNFTs left on sale\n\t *\n\t * @dev Doesn't take into account if sale is active or not,\n\t *      if `nextId - finalId < 1` returns zero\n\t *\n\t * @return number of iNFTs left on sale\n\t */\n\tfunction itemsOnSale() public view returns(uint32) {\n\t\t// calculate items left on sale, taking into account that\n\t\t// finalId is on sale (inclusive bound)\n\t\treturn finalId > nextId? finalId + 1 - nextId: 0;\n\t}\n\n\t/**\n\t * @notice Number of iNFTs available on sale\n\t *\n\t * @dev Takes into account if sale is active or not, doesn't throw,\n\t *      returns zero if sale is inactive\n\t *\n\t * @return number of iNFTs available on sale\n\t */\n\tfunction itemsAvailable() public view returns(uint32) {\n\t\t// delegate to itemsOnSale() if sale is active, return zero otherwise\n\t\treturn isActive()? itemsOnSale(): 0;\n\t}\n\n\t/**\n\t * @notice Active sale is an operational sale capable of minting and selling\n\t *      iNFTs (together with minting the underlying assets - NFTs and AI Personalities)\n\t *\n\t * @dev The sale is active when all the requirements below are met:\n\t *      1. Price is set (`itemPrice` is not zero)\n\t *      2. `finalId` is not reached (`nextId <= finalId`)\n\t *      3. current timestamp is between `saleStart` (inclusive) and `saleEnd` (exclusive)\n\t *\n\t * @dev Function is marked as virtual to be overridden in the helper test smart contract (mock)\n\t *      in order to test how it affects the sale process\n\t *\n\t * @return true if sale is active (operational) and can sell iNFTs, false otherwise\n\t */\n\tfunction isActive() public view virtual returns(bool) {\n\t\t// evaluate sale state based on the internal state variables and return\n\t\treturn itemPrice > 0 && nextId <= finalId && saleStart <= now256() && saleEnd > now256();\n\t}\n\n\t/**\n\t * @dev Restricted access function to set up sale parameters, all at once,\n\t *      or any subset of them\n\t *\n\t * @dev To skip parameter initialization, set it to `-1`,\n\t *      that is a maximum value for unsigned integer of the corresponding type;\n\t *      `_aliSource` and `_aliValue` must both be either set or skipped\n\t *\n\t * @dev Example: following initialization will update only _itemPrice and _batchLimit,\n\t *      leaving the rest of the fields unchanged\n\t *      initialize(\n\t *          100000000000000000,\n\t *          0xFFFFFFFF,\n\t *          0xFFFFFFFF,\n\t *          0xFFFFFFFF,\n\t *          0xFFFFFFFF,\n\t *          10,\n\t *          0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF,\n\t *          0xFFFFFFFFFFFFFFFFFFFFFFFF\n\t *      )\n\t *\n\t * @dev Requires next ID to be greater than zero (strict): `_nextId > 0`\n\t * @dev Requires ALI source/value to be both either set or unset (zero);\n\t *      if set, ALI value must not be less than 1e12 (0.000001 ALI)\n\t *\n\t * @dev Requires transaction sender to have `ROLE_SALE_MANAGER` role\n\t *\n\t * @param _itemPrice price of one iNFT created (with NFT and AI Personality also minted);\n\t *      setting the price to zero deactivates the sale\n\t * @param _nextId next ID of the iNFT, NFT, and AI Pod to mint, will be increased\n\t *      in smart contract storage after every successful buy\n\t * @param _finalId final ID of the iNFT, NFT, and AI Pod to mint; sale is capable of producing\n\t *      `_finalId - _nextId + 1` iNFTs\n\t * @param _saleStart start of the sale, unix timestamp\n\t * @param _saleEnd end of the sale, unix timestamp; sale is active only\n\t *      when current time is within _saleStart (inclusive) and _saleEnd (exclusive)\n\t * @param _batchLimit how many iNFTs is allowed to buy in a single transaction,\n\t *      set to zero to disable the limit\n\t * @param _aliSource an address to transfer ALI tokens from to bind to iNFTs created\n\t * @param _aliValue an amount of ALI tokens to transfer and bind for each iNFT created\n\t */\n\tfunction initialize(\n\t\tuint64 _itemPrice,\t// <<<--- keep type in sync with the body type(uint64).max !!!\n\t\tuint32 _nextId,\t// <<<--- keep type in sync with the body type(uint32).max !!!\n\t\tuint32 _finalId,\t// <<<--- keep type in sync with the body type(uint32).max !!!\n\t\tuint32 _saleStart,\t// <<<--- keep type in sync with the body type(uint32).max !!!\n\t\tuint32 _saleEnd,\t// <<<--- keep type in sync with the body type(uint32).max !!!\n\t\tuint32 _batchLimit,\t// <<<--- keep type in sync with the body type(uint32).max !!!\n\t\taddress _aliSource,\t// <<<--- keep that in sync with the body type(uint160).max !!!\n\t\tuint96 _aliValue\t// <<<--- keep type in sync with the body type(uint96).max !!!\n\t) public {\n\t\t// check the access permission\n\t\trequire(isSenderInRole(ROLE_SALE_MANAGER), \"access denied\");\n\n\t\t// verify the inputs\n\t\trequire(_nextId > 0, \"zero nextId\");\n\t\t// ALI source/value should be either both set or both unset\n\t\t// ALI value must not be too low if set\n\t\trequire(_aliSource == address(0) && _aliValue == 0 || _aliSource != address(0) && _aliValue >= 1e12, \"invalid ALI source/value\");\n\n\t\t// no need to verify extra parameters - \"incorrect\" values will deactivate the sale\n\n\t\t// initialize contract state based on the values supplied\n\t\t// take into account our convention that value `-1` means \"do not set\"\n\t\t// 0xFFFFFFFFFFFFFFFF, 64 bits\n\t\tif(_itemPrice != type(uint64).max) {\n\t\t\titemPrice = _itemPrice;\n\t\t}\n\t\t// 0xFFFFFFFF, 32 bits\n\t\tif(_nextId != type(uint32).max) {\n\t\t\tnextId = _nextId;\n\t\t}\n\t\t// 0xFFFFFFFF, 32 bits\n\t\tif(_finalId != type(uint32).max) {\n\t\t\tfinalId = _finalId;\n\t\t}\n\t\t// 0xFFFFFFFF, 32 bits\n\t\tif(_saleStart != type(uint32).max) {\n\t\t\tsaleStart = _saleStart;\n\t\t}\n\t\t// 0xFFFFFFFF, 32 bits\n\t\tif(_saleEnd != type(uint32).max) {\n\t\t\tsaleEnd = _saleEnd;\n\t\t}\n\t\t// 0xFFFFFFFF, 32 bits\n\t\tif(_batchLimit != type(uint32).max) {\n\t\t\tbatchLimit = _batchLimit;\n\t\t}\n\t\t// 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF and 0xFFFFFFFFFFFFFFFFFFFFFFFF, 160 and 96 bits\n\t\tif(uint160(_aliSource) != type(uint160).max && _aliValue != type(uint96).max) {\n\t\t\taliSource = _aliSource;\n\t\t\taliValue = _aliValue;\n\t\t}\n\n\t\t// emit an event - read values from the storage since not all of them might be set\n\t\temit Initialized(\n\t\t\tmsg.sender,\n\t\t\titemPrice,\n\t\t\tnextId,\n\t\t\tfinalId,\n\t\t\tsaleStart,\n\t\t\tsaleEnd,\n\t\t\tbatchLimit,\n\t\t\taliSource,\n\t\t\taliValue\n\t\t);\n\t}\n\n\t/**\n\t * @notice Buys several (at least two) iNFTs in a batch.\n\t *      Accepts ETH as payment and creates iNFT with minted bound NFT and minted linked AI Personality\n\t *\n\t * @param _amount amount of iNFTs to create (same amount of NFTs and AI Personalities\n\t *      will be created and bound/locked to iNFT), two or more\n\t */\n\tfunction buy(uint32 _amount) public virtual payable {\n\t\t// delegate to `buyTo` with the transaction sender set to be a recipient\n\t\tbuyTo(msg.sender, _amount);\n\t}\n\n\t/**\n\t * @notice Buys several (at least two) iNFTs in a batch to an address specified.\n\t *      Accepts ETH as payment and creates iNFT with minted bound NFT and minted linked AI Personality\n\t *\n\t * @param _to address to mint tokens and iNFTs to\n\t * @param _amount amount of iNFTs to create (same amount of NFTs and AI Personalities\n\t *      will be created and bound/locked to iNFT), two or more\n\t */\n\tfunction buyTo(address _to, uint32 _amount) public virtual payable {\n\t\t// check the access permission\n\t\trequire(isFeatureEnabled(FEATURE_PUBLIC_SALE) || isSenderInRole(ROLE_BUYER), \"access denied\");\n\n\t\t// verify the inputs\n\t\trequire(_to != address(0), \"recipient not set\");\n\t\trequire(_amount > 1 && (batchLimit == 0 || _amount <= batchLimit), \"incorrect amount\");\n\n\t\t// verify there is enough items available to buy the amount\n\t\t// verifies sale is in active state under the hood\n\t\trequire(itemsAvailable() >= _amount, \"inactive sale or not enough items available\");\n\n\t\t// calculate the total price required and validate the transaction value\n\t\tuint256 totalPrice = uint256(itemPrice) * _amount;\n\t\trequire(msg.value >= totalPrice, \"not enough funds\");\n\n\t\t// based on ALI value set on the contract and amount of iNFTs to create\n\t\t// calculate the cumulative ALI value to be sent to iNFT\n\t\t// note: cumulative ALI value may overflow uint96, store it into uint256 on stack\n\t\tuint256 _aliValue = uint256(aliValue) * _amount;\n\t\t// if it's not zero (that is if ALI token binding is enabled)\n\t\tif(_aliValue != 0) {\n\t\t\t// transfer ALI amount required to iNFT smart contract\n\t\t\tERC20(aliContract).transferFrom(aliSource, iNftContract, _aliValue);\n\t\t}\n\n\t\t// mint NFTs to the recipient\n\t\tMintableERC721(nftContract).safeMintBatch(_to, nextId, _amount);\n\n\t\t// mint AI Personality directly to iNFT smart contract\n\t\tMintableERC721(personalityContract).mintBatch(iNftContract, nextId, _amount);\n\n\t\t// create iNFT bound to NFT minted and locking the AI Personality minted\n\t\tIntelligentNFTv2(iNftContract).mintBatch(\n\t\t\tnextId, // first recordId\n\t\t\taliValue, // ALI value\n\t\t\tpersonalityContract, // AI Personality contract address\n\t\t\tnextId, // first AI Personality ID\n\t\t\tnftContract, // NFT contract address\n\t\t\tnextId, // first target NFT ID\n\t\t\t_amount // amount of iNFTs to create\n\t\t);\n\n\t\t// increment `nextId`\n\t\tnextId += _amount;\n\t\t// increment `soldCounter`\n\t\tsoldCounter += _amount;\n\n\t\t// if ETH amount supplied exceeds the price\n\t\tif(msg.value > totalPrice) {\n\t\t\t// send excess amount back to sender\n\t\t\tpayable(msg.sender).transfer(msg.value - totalPrice);\n\t\t}\n\n\t\t// emit en event\n\t\temit Bought(msg.sender, _to, _amount, _aliValue, totalPrice);\n\t}\n\n\t/**\n\t * @notice Buys single iNFTs.\n\t *      Accepts ETH as payment and creates iNFT with minted bound NFT and minted linked AI Personality\n\t */\n\tfunction buySingle() public virtual payable {\n\t\t// delegate to `buySingleTo` with the transaction sender set to be a recipient\n\t\tbuySingleTo(msg.sender);\n\t}\n\n\t/**\n\t * @notice Buys single iNFTs to an address specified.\n\t *      Accepts ETH as payment and creates iNFT with minted bound NFT and minted linked AI Personality\n\t *\n\t * @param _to address to mint tokens and iNFT to\n\t */\n\tfunction buySingleTo(address _to) public virtual payable {\n\t\t// check the access permission\n\t\trequire(isFeatureEnabled(FEATURE_PUBLIC_SALE) || isSenderInRole(ROLE_BUYER), \"access denied\");\n\n\t\t// verify the inputs and transaction value\n\t\trequire(_to != address(0), \"recipient not set\");\n\t\trequire(msg.value >= itemPrice, \"not enough funds\");\n\n\t\t// verify sale is in active state\n\t\trequire(isActive(), \"inactive sale\");\n\n\t\t// if ALI token binding is enabled\n\t\tif(aliValue != 0) {\n\t\t\t// transfer ALI amount required to iNFT smart contract\n\t\t\tERC20(aliContract).transferFrom(aliSource, iNftContract, aliValue);\n\t\t}\n\t\t// mint NFT to the recipient\n\t\tMintableERC721(nftContract).safeMint(_to, nextId);\n\t\t// mint AI Personality directly to iNFT smart contract\n\t\tMintableERC721(personalityContract).mint(iNftContract, nextId);\n\t\t// create iNFT bound to NFT minted and locking the AI Personality minted\n\t\tIntelligentNFTv2(iNftContract).mint(nextId, aliValue, personalityContract, nextId, nftContract, nextId);\n\n\t\t// increment `nextId`\n\t\tnextId++;\n\t\t// increment `soldCounter`\n\t\tsoldCounter++;\n\n\t\t// if ETH amount supplied exceeds the price\n\t\tif(msg.value > itemPrice) {\n\t\t\t// send excess amount back to sender\n\t\t\tpayable(msg.sender).transfer(msg.value - itemPrice);\n\t\t}\n\n\t\t// emit en event\n\t\temit Bought(msg.sender, _to, 1, aliValue, itemPrice);\n\t}\n\n\t/**\n\t * @dev Restricted access function to withdraw ETH on the contract balance,\n\t *      sends ETH back to transaction sender\n\t */\n\tfunction withdraw() public {\n\t\t// delegate to `withdrawTo`\n\t\twithdrawTo(msg.sender);\n\t}\n\n\t/**\n\t * @dev Restricted access function to withdraw ETH on the contract balance,\n\t *      sends ETH to the address specified\n\t *\n\t * @param _to an address to send ETH to\n\t */\n\tfunction withdrawTo(address _to) public {\n\t\t// check the access permission\n\t\trequire(isSenderInRole(ROLE_WITHDRAWAL_MANAGER), \"access denied\");\n\n\t\t// verify withdrawal address is set\n\t\trequire(_to != address(0), \"address not set\");\n\n\t\t// ETH value to send\n\t\tuint256 _value = address(this).balance;\n\n\t\t// verify sale balance is positive (non-zero)\n\t\trequire(_value > 0, \"zero balance\");\n\n\t\t// send the entire balance to the transaction sender\n\t\tpayable(_to).transfer(_value);\n\n\t\t// emit en event\n\t\temit Withdrawn(msg.sender, _to, _value);\n\t}\n\n\t/**\n\t * @dev Testing time-dependent functionality may be difficult;\n\t *      we override time in the helper test smart contract (mock)\n\t *\n\t * @return `block.timestamp` in mainnet, custom values in testnets (if overridden)\n\t */\n\tfunction now256() public view virtual returns (uint256) {\n\t\t// return current block timestamp\n\t\treturn block.timestamp;\n\t}\n}\n"
    },
    "contracts/mocks/FixedSupplySaleMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../protocol/FixedSupplySale.sol\";\n\n/// @dev Allows to override isActive() and now256() on the FixedSupplySale\ncontract FixedSupplySaleMock is FixedSupplySale {\n\t/// @dev Defines if isActive() should be overridden\n\tbool private _activeStateOverride;\n\n\t/// @dev Overrides isActive() if `_activeStateOverride` is true\n\tbool private _activeStateValue;\n\n\t/// @dev Overrides now256() if set (non-zero)\n\tuint256 private _now256;\n\n\t/// @dev Deploys FixedSupplySaleMock passing all the params to FixedSupplySale\n\tconstructor(address _ali, address _nft, address _personality, address _iNft)\n\t\tFixedSupplySale(_ali, _nft, _personality, _iNft) {}\n\n\t/// @inheritdoc FixedSupplySale\n\tfunction isActive() public view override returns(bool) {\n\t\t// override state if required, delegate to super otherwise\n\t\treturn _activeStateOverride ? _activeStateValue : super.isActive();\n\t}\n\n\t/// @inheritdoc FixedSupplySale\n\tfunction now256() public view override returns (uint256) {\n\t\t// override now256 if it is set, delegate to super otherwise\n\t\treturn _now256 > 0? _now256: super.now256();\n\t}\n\n\t/// @dev Sets isActive() override\n\tfunction setStateOverride(bool _value) public {\n\t\t_activeStateOverride = true;\n\t\t_activeStateValue = _value;\n\t}\n\n\t/// @dev Removes isActive() override\n\tfunction removeStateOverride() public {\n\t\t_activeStateOverride = false;\n\t}\n\n\t/// @dev Sets/removes now256() override (set to zero to remove)\n\tfunction setNow256(uint256 _value) public {\n\t\t_now256 = _value;\n\t}\n\n}\n"
    },
    "contracts/mocks/ProxyRegistryMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../protocol/OpenSeaFactory.sol\";\n\ncontract ProxyRegistryMock is ProxyRegistry {\n\t// an address to return as proxies(address)\n\taddress private owner;\n\n\t// creates a registry returning msg.sender as proxies(address)\n\tconstructor() {\n\t\towner = msg.sender;\n\t}\n\n\t// allows to override the owner - proxies(address)\n\tfunction setOwner(address _owner) public {\n\t\towner = _owner;\n\t}\n\n\t/**\n\t * @inheritdoc ProxyRegistry\n\t */\n\tfunction proxies(address) public override view returns(OwnableDelegateProxy) {\n\t\treturn OwnableDelegateProxy(owner);\n\t}\n}\n"
    },
    "contracts/interfaces/EIP2981Spec.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./ERC165Spec.sol\";\n\n///\n/// @dev Interface for the NFT Royalty Standard\n///\ninterface EIP2981 is ERC165 {\n\t/// ERC165 bytes to add to interface array - set in parent contract\n\t/// implementing this standard\n\t///\n\t/// bytes4(keccak256(\"royaltyInfo(uint256,uint256)\")) == 0x2a55205a\n\t/// bytes4 private constant _INTERFACE_ID_ERC2981 = 0x2a55205a;\n\t/// _registerInterface(_INTERFACE_ID_ERC2981);\n\n\t/// @notice Called with the sale price to determine how much royalty\n\t//          is owed and to whom.\n\t/// @param _tokenId - the NFT asset queried for royalty information\n\t/// @param _salePrice - the sale price of the NFT asset specified by _tokenId\n\t/// @return receiver - address of who should be sent the royalty payment\n\t/// @return royaltyAmount - the royalty payment amount for _salePrice\n\tfunction royaltyInfo(\n\t\tuint256 _tokenId,\n\t\tuint256 _salePrice\n\t) external view returns (\n\t\taddress receiver,\n\t\tuint256 royaltyAmount\n\t);\n}\n"
    },
    "contracts/token/RoyalERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/EIP2981Spec.sol\";\nimport \"./TinyERC721.sol\";\n\n/**\n * @title Royal ER721\n *\n * @dev Supports EIP-2981 royalties on NFT secondary sales\n *      Supports OpenSea contract metadata royalties\n *      Introduces fake \"owner\" to support OpenSea collections\n *\n * @author Basil Gorin\n */\nabstract contract RoyalERC721 is EIP2981, TinyERC721 {\n\t/**\n\t * @dev OpenSea expects NFTs to be \"Ownable\", that is having an \"owner\",\n\t *      we introduce a fake \"owner\" here with no authority\n\t */\n\taddress public owner;\n\n\t/**\n\t * @notice Address to receive EIP-2981 royalties from secondary sales\n\t *         see https://eips.ethereum.org/EIPS/eip-2981\n\t */\n\taddress public royaltyReceiver = address(0x379e2119f6e0D6088537da82968e2a7ea178dDcF);\n\n\t/**\n\t * @notice Percentage of token sale price to be used for EIP-2981 royalties from secondary sales\n\t *         see https://eips.ethereum.org/EIPS/eip-2981\n\t *\n\t * @dev Has 2 decimal precision. E.g. a value of 500 would result in a 5% royalty fee\n\t */\n\tuint16 public royaltyPercentage = 750; // default OpenSea value\n\n\t/**\n\t * @notice Contract level metadata to define collection name, description, and royalty fees.\n\t *         see https://docs.opensea.io/docs/contract-level-metadata\n\t *\n\t * @dev Should be set by URI manager. By default only includes royalty information\n\t */\n\tstring public contractURI = \"https://gateway.pinata.cloud/ipfs/QmU92w8iKpcaabCoyHtMg7iivWGqW2gW1hgARDtqCmJUWv\";\n\n\t/**\n\t * @notice Royalty manager is responsible for managing the EIP2981 royalty info\n\t *\n\t * @dev Role ROLE_ROYALTY_MANAGER allows updating the royalty information\n\t *      (executing `setRoyaltyInfo` function)\n\t */\n\tuint32 public constant ROLE_ROYALTY_MANAGER = 0x0020_0000;\n\n\t/**\n\t * @notice Owner manager is responsible for setting/updating an \"owner\" field\n\t *\n\t * @dev Role ROLE_OWNER_MANAGER allows updating the \"owner\" field\n\t *      (executing `setOwner` function)\n\t */\n\tuint32 public constant ROLE_OWNER_MANAGER = 0x0040_0000;\n\n\t/**\n\t * @dev Fired in setContractURI()\n\t *\n\t * @param _by an address which executed update\n\t * @param _value new contractURI value\n\t */\n\tevent ContractURIUpdated(address indexed _by, string _value);\n\n\t/**\n\t * @dev Fired in setRoyaltyInfo()\n\t *\n\t * @param _by an address which executed update\n\t * @param _receiver new royaltyReceiver value\n\t * @param _percentage new royaltyPercentage value\n\t */\n\tevent RoyaltyInfoUpdated(\n\t\taddress indexed _by,\n\t\taddress indexed _receiver,\n\t\tuint16 _percentage\n\t);\n\n\t/**\n\t * @dev Fired in setOwner()\n\t *\n\t * @param _by an address which set the new \"owner\"\n\t * @param _oldVal previous \"owner\" address\n\t * @param _newVal new \"owner\" address\n\t */\n\tevent OwnerUpdated(address indexed _by, address indexed _oldVal, address indexed _newVal);\n\n\t/**\n\t * @dev Fired in setOwner() - OpenZeppelin Ownable compliant event\n\t *\n\t * @param previousOwner previous \"owner\" address\n\t * @param newOwner new \"owner\" address\n\t */\n\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\t/**\n\t * @dev Constructs/deploys ERC721 with EIP-2981 instance with the name and symbol specified\n\t *\n\t * @param _name token name (ERC721Metadata)\n\t * @param _symbol token symbol (ERC721Metadata)\n\t */\n\tconstructor(string memory _name, string memory _symbol) TinyERC721(_name, _symbol) {\n\t\t// initialize the \"owner\" as a deployer account\n\t\towner = msg.sender;\n\t}\n\n\t/**\n\t * @dev Restricted access function which updates the contract URI\n\t *\n\t * @dev Requires executor to have ROLE_URI_MANAGER permission\n\t *\n\t * @param _contractURI new contract URI to set\n\t */\n\tfunction setContractURI(string memory _contractURI) public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_URI_MANAGER), \"access denied\");\n\n\t\t// update the contract URI\n\t\tcontractURI = _contractURI;\n\n\t\t// emit an event\n\t\temit ContractURIUpdated(msg.sender, _contractURI);\n\t}\n\n\t/**\n\t * @notice EIP-2981 function to calculate royalties for sales in secondary marketplaces.\n\t *         see https://eips.ethereum.org/EIPS/eip-2981\n\t *\n\t * @inheritdoc EIP2981\n\t */\n\tfunction royaltyInfo(\n\t\tuint256,\n\t\tuint256 _salePrice\n\t) public view override returns (\n\t\taddress receiver,\n\t\tuint256 royaltyAmount\n\t) {\n\t\t// simply calculate the values and return the result\n\t\treturn (royaltyReceiver, _salePrice * royaltyPercentage / 100_00);\n\t}\n\n\t/**\n\t * @dev Restricted access function which updates the royalty info\n\t *\n\t * @dev Requires executor to have ROLE_ROYALTY_MANAGER permission\n\t *\n\t * @param _royaltyReceiver new royalty receiver to set\n\t * @param _royaltyPercentage new royalty percentage to set\n\t */\n\tfunction setRoyaltyInfo(address _royaltyReceiver, uint16 _royaltyPercentage) public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_ROYALTY_MANAGER), \"access denied\");\n\n\t\t// verify royalty percentage is zero if receiver is also zero\n\t\trequire(_royaltyReceiver != address(0) || _royaltyPercentage == 0, \"invalid receiver\");\n\t\t// verify royalty percentage doesn't exceed 100%\n\t\trequire(_royaltyPercentage <= 100_00, \"royalty percentage exceeds 100%\");\n\n\t\t// update the values\n\t\troyaltyReceiver = _royaltyReceiver;\n\t\troyaltyPercentage = _royaltyPercentage;\n\n\t\t// emit an event\n\t\temit RoyaltyInfoUpdated(msg.sender, _royaltyReceiver, _royaltyPercentage);\n\t}\n\n\t/**\n\t * @notice Checks if the address supplied is an \"owner\" of the smart contract\n\t *      Note: an \"owner\" doesn't have any authority on the smart contract and is \"nominal\"\n\t *\n\t * @return true if the caller is the current owner.\n\t */\n\tfunction isOwner(address _addr) public view returns(bool) {\n\t\t// just evaluate and return the result\n\t\treturn _addr == owner;\n\t}\n\n\t/**\n\t * @dev Restricted access function to set smart contract \"owner\"\n\t *      Note: an \"owner\" set doesn't have any authority, and cannot even update \"owner\"\n\t *\n\t * @dev Requires executor to have ROLE_OWNER_MANAGER permission\n\t *\n\t * @param _owner new \"owner\" of the smart contract\n\t */\n\tfunction transferOwnership(address _owner) public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_OWNER_MANAGER), \"access denied\");\n\n\t\t// emit an event first - to log both old and new values\n\t\temit OwnerUpdated(msg.sender, owner, _owner);\n\n\t\t// emit zeppelin ownable-compliant ownership transfer event\n\t\temit OwnershipTransferred(owner, _owner);\n\n\t\t// update \"owner\"\n\t\towner = _owner;\n\t}\n\n\t/**\n\t * @inheritdoc ERC165\n\t */\n\tfunction supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, TinyERC721) returns (bool) {\n\t\t// construct the interface support from EIP-2981 and super interfaces\n\t\treturn interfaceId == type(EIP2981).interfaceId || super.supportsInterface(interfaceId);\n\t}\n}\n"
    },
    "contracts/token/WhitelabelNFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./RoyalERC721.sol\";\n\n/**\n * @title Whitelabel NFT\n *\n * @notice Whitelabel NFT is a non-upgradeable ERC721 standard implementation\n *\n * @dev Whitelabel NFT is a Tiny ERC721, it supports minting and burning,\n *      its token ID space is limited to 32 bits\n *\n * @dev Whitelabel NFT supports EIP-2981 royalties on NFT secondary sales,\n *      and OpenSea royalties\n *\n * @author Basil Gorin\n */\ncontract WhitelabelNFT is RoyalERC721 {\n\t/**\n\t * @inheritdoc TinyERC721\n\t */\n\tuint256 public constant override TOKEN_UID = 0x50c16d79fc64e49cf554b52a1bdf271f1a30a6999329cb1b4642bb24597f282f;\n\n\t/**\n\t * @dev Constructs/deploys Whitelabel NFT instance\n\t *      with the name and symbol defined during the deployment\n\t */\n\tconstructor(string memory _name, string memory _symbol) RoyalERC721(_name, _symbol) {}\n}\n"
    },
    "contracts/token/PersonalityPodERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./RoyalERC721.sol\";\n\n/**\n * @title Personality Pod, a.k.a. AI Personality\n *\n * @notice Personality Pod replaces AI Pod in version 2 release, it doesn't\n *      store any metadata on-chain, all the token related data except URI\n *      (rarity, traits, etc.) is expected to be stored off-chain\n *\n * @notice Terms Personality Pod and AI Personality have identical meaning and\n *      used interchangeably all over the code, documentation, scripts, etc.\n *\n * @dev Personality Pod is a Tiny ERC721, it supports minting and burning,\n *      its token ID space is limited to 32 bits\n *\n * @author Basil Gorin\n */\ncontract PersonalityPodERC721 is RoyalERC721 {\n\t/**\n\t * @inheritdoc TinyERC721\n\t */\n\tuint256 public constant override TOKEN_UID = 0xd9b5d3b66c60255ffa16c57c0f1b2db387997fa02af673da5767f1acb0f345af;\n\n\t/**\n\t * @dev Constructs/deploys AI Personality instance\n\t *      with the name and symbol defined during the deployment\n\t */\n\tconstructor(string memory _name, string memory _symbol) RoyalERC721(_name, _symbol) {}\n}\n"
    },
    "contracts/token/AletheaNFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./RoyalERC721.sol\";\n\n/**\n * @title Alethea NFT\n *\n * @notice Alethea NFT is an ERC721 token used as a target NFT for iNFT protocol\n *\n * @dev Alethea NFT is a Tiny ERC721, it supports minting and burning,\n *      its token ID space is limited to 32 bits\n *\n * @author Basil Gorin\n */\ncontract AletheaNFT is RoyalERC721 {\n\t/**\n\t * @inheritdoc TinyERC721\n\t */\n\tuint256 public constant override TOKEN_UID = 0x275ee64af649fe998ccbaec4f443dc216eef3bab6f11080eeeedfbdd303c59a6;\n\n\t/**\n\t * @dev Constructs/deploys Alethea NFT instance\n\t *      with the name and symbol defined during the deployment\n\t */\n\tconstructor(string memory _name, string memory _symbol) RoyalERC721(_name, _symbol) {}\n}\n"
    },
    "contracts/mocks/RoyalERC721Mock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../token/RoyalERC721.sol\";\n\n// Zeppelin ERC721 tests support\ncontract RoyalERC721Mock is RoyalERC721 {\n\t/**\n\t * @inheritdoc TinyERC721\n\t */\n\tuint256 public constant override TOKEN_UID = 0x0250bec6b1a03636668f5072a8f5675e5fbd3e485d8a1213fc8279b78cb6f33d;\n\n\tconstructor(string memory _name, string memory _symbol) RoyalERC721(_name, _symbol) {}\n}\n"
    },
    "contracts/mocks/AliCompMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../token/AliERC20v2.sol\";\n\n// Token extension to simplify Compound-like voting delegation testing\ncontract AliCompMock is AliERC20v2 {\n\tconstructor(address _initialHolder) AliERC20v2(_initialHolder){}\n\n\t// replaces 3 transactions in CompTest to be put into single block with a single transaction\n\tfunction __delegate_transfer_transfer(address a1, address a2, uint256 val) public {\n\t\tdelegate(a1);      // transaction 1\n\t\ttransfer(a2, val); // transaction 2\n\t\ttransfer(a2, val); // transaction 3\n\t}\n\n\t// taken from CompHarness.sol, used in CompScenarioTest\n\tfunction generateCheckpoints(uint count, uint offset) external {\n\t\tfor (uint i = 1 + offset; i <= count + offset; i++) {\n\t\t\tvotingPowerHistory[msg.sender].push(KV(uint64(i), uint192(i)));\n\t\t}\n\t}\n}\n"
    },
    "contracts/protocol/NFTFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ERC721SpecExt.sol\";\nimport \"../utils/AccessControl.sol\";\nimport \"../lib/ECDSA.sol\";\n\n/**\n * @title Alethea NFT Factory\n *\n * @notice NFT Factory is a helper smart contract responsible for minting arbitrary NFTs\n *\n * @notice It supports two mechanisms:\n *      - minting delegation: authorized address executes mint function on the helper,\n *        and helper executes minting function on the target ERC721 contract as an internal transaction\n *      - meta transaction minting or minting with an authorization: authorized address signs\n *        the minting authorization message and any address executes mint function on the helper\n *\n * @notice Second mechanism allows to shift the gas costs for the transaction to any address\n *      (usually this is the NFT beneficiary - an address which receives an NFT)\n *\n * @dev The signature is constructed via EIP-712 similar to EIP-2612, or EIP-3009\n *\n * @dev Target ERC721 contract(s) must allow helper to mint the tokens, this should be configured\n *      as part of the deployment or setup processes\n *\n * @author Basil Gorin\n */\ncontract NFTFactory is AccessControl {\n\t/**\n\t * @dev A record of used nonces for EIP-712 transactions\n\t *\n\t * @dev A record of used nonces for signing/validating signatures\n\t *      in `mintWithAuthorization` for every mint\n\t *\n\t * @dev Maps authorizer address => nonce => true/false (used unused)\n\t */\n\tmapping(address => mapping(bytes32 => bool)) private usedNonces;\n\n\t/**\n\t * @notice EIP-712 contract's domain separator,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator\n\t */\n\tbytes32 public immutable DOMAIN_SEPARATOR;\n\n\t/**\n\t * @notice EIP-712 contract's domain typeHash,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\n\t *\n\t * @dev Note: we do not include version into the domain typehash/separator,\n\t *      it is implied version is concatenated to the name field, like \"NFTFactoryV2\"\n\t */\n\t// keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\")\n\tbytes32 public constant DOMAIN_TYPEHASH = 0x8cad95687ba82c2ce50e74f7b754645e5117c3a5bec8151c0726d5857980a866;\n\n\t/**\n\t * @notice EIP-712 MintWithAuthorization struct typeHash,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\n\t */\n\t// keccak256(\"MintWithAuthorization(address contract,address to,uint256 tokenId,uint256 validAfter,uint256 validBefore,bytes32 nonce)\")\n\tbytes32 public constant MINT_WITH_AUTHORIZATION_TYPEHASH = 0x495835d970a03ff092657fca9abde67d34a0bb73a0bba258a5fa90c4ce4340f6;\n\n\t/**\n\t * @notice EIP-712 CancelAuthorization struct typeHash,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\n\t */\n\t// keccak256(\"CancelAuthorization(address authorizer,bytes32 nonce)\")\n\tbytes32 public constant CANCEL_AUTHORIZATION_TYPEHASH = 0x158b0a9edf7a828aad02f63cd515c68ef2f50ba807396f6d12842833a1597429;\n\n\t/**\n\t * @notice Enables meta transaction minting (minting with an authorization\n\t *      via an EIP712 signature)\n\t * @dev Feature FEATURE_MINTING_WITH_AUTH must be enabled in order for\n\t *      `mintWithAuthorization()` function to succeed\n\t */\n\tuint32 public constant FEATURE_MINTING_WITH_AUTH = 0x0000_0001;\n\n\t/**\n\t * @notice Factory minter is responsible for creating (minting)\n\t *      tokens to an arbitrary address\n\t * @dev Role ROLE_FACTORY_MINTER allows minting tokens\n\t *      (executing `mint` function)\n\t */\n\tuint32 public constant ROLE_FACTORY_MINTER = 0x0001_0000;\n\n\t/**\n\t * @dev Fired in mint() and mintWithAuthorization() after an NFT is minted\n\t *\n\t * @param erc721Address ERC721 contract address which was minted\n\t * @param to an address NFT was minted to\n\t * @param tokenId NFT ID which was minted\n\t */\n\tevent Minted(address indexed erc721Address, address indexed to, uint256 indexed tokenId);\n\n\t/**\n\t * @dev Fired whenever the nonce gets used (ex.: `transferWithAuthorization`, `receiveWithAuthorization`)\n\t *\n\t * @param authorizer an address which has used the nonce\n\t * @param nonce the nonce used\n\t */\n\tevent AuthorizationUsed(address indexed authorizer, bytes32 indexed nonce);\n\n\t/**\n\t * @dev Fired whenever the nonce gets cancelled (ex.: `cancelAuthorization`)\n\t *\n\t * @dev Both `AuthorizationUsed` and `AuthorizationCanceled` imply the nonce\n\t *      cannot be longer used, the only difference is that `AuthorizationCanceled`\n\t *      implies no smart contract state change made (except the nonce marked as cancelled)\n\t *\n\t * @param authorizer an address which has cancelled the nonce\n\t * @param nonce the nonce cancelled\n\t */\n\tevent AuthorizationCanceled(address indexed authorizer, bytes32 indexed nonce);\n\n\t/**\n\t * Deploys the helper contract and initializes DOMAIN_SEPARATOR using the created smart contract address\n\t */\n\tconstructor() {\n\t\t// build the EIP-712 contract domain separator, see https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator\n\t\t// note: we specify contract version in its name\n\t\tDOMAIN_SEPARATOR = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(\"NFTFactoryV1\")), block.chainid, address(this)));\n\t}\n\n\t/**\n\t * @notice Restricted access function to mint an NFT\n\t *\n\t * @dev Doesn't allow minting the token with ID zero\n\t * @dev Requires an executor to have ROLE_MINTER permission\n\t * @dev Requires target ERC721 contract to be mintable (`MintableERC721`)\n\t * @dev Requires target ERC721 contract instance to allow minting via helper\n\t *\n\t * @param _mintableErc721 target ERC721 contract instance to mint token on,\n\t *      compatible with `MintableERC721`\n\t * @param _to an address to mint token to\n\t * @param _tokenId target ERC721 token ID to mint\n\t */\n\tfunction mint(address _mintableErc721, address _to, uint256 _tokenId) public {\n\t\t// delegate to _mint()\n\t\t__mint(msg.sender, _mintableErc721, _to, _tokenId);\n\t}\n\n\t/**\n\t * @dev Auxiliary internally used function to mint an NFT\n\t *\n\t * @dev Unsafe: doesn't verify real tx executor (msg.sender) permissions, but the permissions of\n\t *      the address specified as an executor, must be kept private at all times\n\t *\n\t * @dev Doesn't allow minting the token with ID zero\n\t * @dev Requires an executor to have ROLE_MINTER permission\n\t * @dev Requires target ERC721 contract to be mintable (`MintableERC721`)\n\t * @dev Requires target ERC721 contract instance to allow minting via helper\n\t *\n\t * @param _executor an address on which behalf the operation is executed,\n\t *      this is usually `msg.sender` but this can be different address for\n\t *      the EIP-712 like transactions (mint with authorization)\n\t * @param _mintableErc721 target ERC721 contract instance to mint token on,\n\t *      compatible with `MintableERC721`\n\t * @param _to an address to mint token to\n\t * @param _tokenId target ERC721 token ID to mint\n\t */\n\tfunction __mint(address _executor, address _mintableErc721, address _to, uint256 _tokenId) private {\n\t\t// verify the access permission\n\t\trequire(isOperatorInRole(_executor, ROLE_FACTORY_MINTER), \"access denied\");\n\n\t\t// verify the inputs\n\t\trequire(_mintableErc721 != address(0), \"ERC721 instance addr is not set\");\n\t\trequire(_to != address(0), \"NFT receiver addr is not set\");\n\t\trequire(_tokenId != 0, \"token ID is not set\");\n\n\t\t// delegate to the target ERC721 contract\n\t\tMintableERC721(_mintableErc721).safeMint(_to, _tokenId);\n\n\t\t// emit an event\n\t\temit Minted(_mintableErc721, _to, _tokenId);\n\t}\n\n\t/**\n\t * @notice Executes a mint function with a signed authorization\n\t *\n\t * @param _mintableErc721 target ERC721 contract instance to mint token on,\n\t *      compatible with `MintableERC721`\n\t * @param _to an address to mint token to\n\t * @param _tokenId target ERC721 token ID to mint\n\t * @param _validAfter signature valid after time (unix timestamp)\n\t * @param _validBefore signature valid before time (unix timestamp)\n\t * @param _nonce unique random nonce\n\t * @param v the recovery byte of the signature\n\t * @param r half of the ECDSA signature pair\n\t * @param s half of the ECDSA signature pair\n\t */\n\tfunction mintWithAuthorization(\n\t\taddress _mintableErc721,\n\t\taddress _to,\n\t\tuint256 _tokenId,\n\t\tuint256 _validAfter,\n\t\tuint256 _validBefore,\n\t\tbytes32 _nonce,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) public {\n\t\t// ensure EIP-712 minting with authorization is enabled\n\t\trequire(isFeatureEnabled(FEATURE_MINTING_WITH_AUTH), \"minting with auth is disabled\");\n\n\t\t// derive signer of the EIP712 MintWithAuthorization message\n\t\taddress signer = __deriveSigner(\n\t\t\tabi.encode(MINT_WITH_AUTHORIZATION_TYPEHASH, _mintableErc721, _to, _tokenId, _validAfter, _validBefore, _nonce),\n\t\t\tv,\n\t\t\tr,\n\t\t\ts\n\t\t);\n\n\t\t// perform message integrity and security validations\n\t\trequire(block.timestamp > _validAfter, \"signature not yet valid\");\n\t\trequire(block.timestamp < _validBefore, \"signature expired\");\n\n\t\t// use the nonce supplied (verify, mark as used, emit event)\n\t\t__useNonce(signer, _nonce, false);\n\n\t\t// delegate call to `_mint` - execute the logic required\n\t\t__mint(signer, _mintableErc721, _to, _tokenId);\n\t}\n\n\t/**\n\t * @notice Returns the state of an authorization, more specifically\n\t *      if the specified nonce was already used by the address specified\n\t *\n\t * @dev Nonces are expected to be client-side randomly generated 32-byte data\n\t *      unique to the authorizer's address\n\t *\n\t * @param _authorizer Authorizer's address\n\t * @param _nonce Nonce of the authorization\n\t * @return true if the nonce is used\n\t */\n\tfunction authorizationState(\n\t\taddress _authorizer,\n\t\tbytes32 _nonce\n\t) external view returns (bool) {\n\t\t// simply return the value from the mapping\n\t\treturn usedNonces[_authorizer][_nonce];\n\t}\n\n\t/**\n\t * @notice Cancels the authorization (using EIP-712 signature)\n\t *\n\t * @param _authorizer transaction authorizer\n\t * @param _nonce unique random nonce to cancel (mark as used)\n\t * @param v the recovery byte of the signature\n\t * @param r half of the ECDSA signature pair\n\t * @param s half of the ECDSA signature pair\n\t */\n\tfunction cancelAuthorization(\n\t\taddress _authorizer,\n\t\tbytes32 _nonce,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) public {\n\t\t// derive signer of the EIP712 ReceiveWithAuthorization message\n\t\taddress signer = __deriveSigner(abi.encode(CANCEL_AUTHORIZATION_TYPEHASH, _authorizer, _nonce), v, r, s);\n\n\t\t// perform message integrity and security validations\n\t\trequire(signer == _authorizer, \"invalid signature\");\n\n\t\t// cancel the nonce supplied (verify, mark as used, emit event)\n\t\t__useNonce(_authorizer, _nonce, true);\n\t}\n\n\t/**\n\t * @notice Cancels the authorization\n\t *\n\t * @param _nonce unique random nonce to cancel (mark as used)\n\t */\n\tfunction cancelAuthorization(bytes32 _nonce) public {\n\t\t// cancel the nonce supplied (verify, mark as used, emit event)\n\t\t__useNonce(msg.sender, _nonce, true);\n\t}\n\n\t/**\n\t * @dev Auxiliary function to verify structured EIP712 message signature and derive its signer\n\t *\n\t * @param abiEncodedTypehash abi.encode of the message typehash together with all its parameters\n\t * @param v the recovery byte of the signature\n\t * @param r half of the ECDSA signature pair\n\t * @param s half of the ECDSA signature pair\n\t */\n\tfunction __deriveSigner(bytes memory abiEncodedTypehash, uint8 v, bytes32 r, bytes32 s) private view returns(address) {\n\t\t// build the EIP-712 hashStruct of the message\n\t\tbytes32 hashStruct = keccak256(abiEncodedTypehash);\n\n\t\t// calculate the EIP-712 digest \"\\x19\\x01\" ‖ domainSeparator ‖ hashStruct(message)\n\t\tbytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR, hashStruct));\n\n\t\t// recover the address which signed the message with v, r, s\n\t\taddress signer = ECDSA.recover(digest, v, r, s);\n\n\t\t// return the signer address derived from the signature\n\t\treturn signer;\n\t}\n\n\t/**\n\t * @dev Auxiliary function to use/cancel the nonce supplied for a given authorizer:\n\t *      1. Verifies the nonce was not used before\n\t *      2. Marks the nonce as used\n\t *      3. Emits an event that the nonce was used/cancelled\n\t *\n\t * @dev Set `_cancellation` to false (default) to use nonce,\n\t *      set `_cancellation` to true to cancel nonce\n\t *\n\t * @dev It is expected that the nonce supplied is a randomly\n\t *      generated uint256 generated by the client\n\t *\n\t * @param _authorizer an address to use/cancel nonce for\n\t * @param _nonce random nonce to use\n\t * @param _cancellation true to emit `AuthorizationCancelled`, false to emit `AuthorizationUsed` event\n\t */\n\tfunction __useNonce(address _authorizer, bytes32 _nonce, bool _cancellation) private {\n\t\t// verify nonce was not used before\n\t\trequire(!usedNonces[_authorizer][_nonce], \"invalid nonce\");\n\n\t\t// update the nonce state to \"used\" for that particular signer to avoid replay attack\n\t\tusedNonces[_authorizer][_nonce] = true;\n\n\t\t// depending on the usage type (use/cancel)\n\t\tif(_cancellation) {\n\t\t\t// emit an event regarding the nonce cancelled\n\t\t\temit AuthorizationCanceled(_authorizer, _nonce);\n\t\t}\n\t\telse {\n\t\t\t// emit an event regarding the nonce used\n\t\t\temit AuthorizationUsed(_authorizer, _nonce);\n\t\t}\n\t}\n}\n"
    },
    "contracts/token/BurnableShortERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./ShortERC721.sol\";\n\n/**\n * @title Burnable Short ERC721\n *\n * @notice Short ERC721 extension to support token burning,\n *      See {ShortERC721}\n *\n * @author Basil Gorin\n */\nabstract contract BurnableShortERC721 is ShortERC721, BurnableERC721 {\n\t/**\n\t * @dev To support burning for enumerable ERC721 we have to be able\n\t *      to quickly remove tokens from `allTokens` array (without iterating it)\n\t *\n\t * @dev Following mapping stores token indexes within `allTokens` array\n\t *\n\t * @dev Maps `Token ID => Token ID Index`\n\t */\n\tmapping(uint256 => uint256) private tokenIndexes;\n\n\t/**\n\t * @dev Constructs/deploys burnable ERC721 instance with the name and symbol specified\n\t *\n\t * @param _name name of the token to be accessible as `name()`\n\t * @param _symbol token symbol to be accessible as `symbol()`\n\t */\n\tconstructor(string memory _name, string memory _symbol) ShortERC721(_name, _symbol) {}\n\n\t/**\n\t * @inheritdoc ERC165\n\t */\n\tfunction supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n\t\t// construct the interface from current and super implementations\n\t\treturn interfaceId == type(MintableERC721).interfaceId || super.supportsInterface(interfaceId);\n\t}\n\n\t// ===== Start: burn support =====\n\n\t/**\n\t * @dev Destroys the token with token ID specified\n\t *\n\t * @dev Requires executor to have `ROLE_TOKEN_DESTROYER` permission\n\t *      or FEATURE_OWN_BURNS/FEATURE_BURNS_ON_BEHALF features to be enabled\n\t *\n\t * @dev Can be disabled by the contract creator forever by disabling\n\t *      FEATURE_OWN_BURNS/FEATURE_BURNS_ON_BEHALF features and then revoking\n\t *      its own roles to burn tokens and to enable burning features\n\t *\n\t * @param _tokenId ID of the token to burn\n\t */\n\tfunction burn(uint256 _tokenId) public override {\n\t\t// read token owner data\n\t\t// verifies token exists under the hood\n\t\taddress _from = ownerOf(_tokenId);\n\n\t\t// check if caller has sufficient permissions to burn tokens\n\t\t// and if not - check for possibility to burn own tokens or to burn on behalf\n\t\tif(!isSenderInRole(ROLE_TOKEN_DESTROYER)) {\n\t\t\t// if `_from` is equal to sender, require own burns feature to be enabled\n\t\t\t// otherwise require burns on behalf feature to be enabled\n\t\t\trequire(_from == msg.sender && isFeatureEnabled(FEATURE_OWN_BURNS)\n\t\t\t     || _from != msg.sender && isFeatureEnabled(FEATURE_BURNS_ON_BEHALF),\n\t\t\t        _from == msg.sender? \"burns are disabled\": \"burns on behalf are disabled\");\n\n\t\t\t// verify sender is either token owner, or approved by the token owner to burn tokens\n\t\t\trequire(_from == msg.sender || msg.sender == getApproved(_tokenId) || isApprovedForAll(_from, msg.sender), \"access denied\");\n\t\t}\n\n\t\t// remove token ownership record (also clears approval),\n\t\t// remove token from both local and global collections\n\t\t__removeToken(_tokenId);\n\n\t\t// delete token URI mapping\n\t\tdelete _tokenURIs[_tokenId];\n\n\t\t// fire ERC721 transfer event\n\t\temit Transfer(_from, address(0), _tokenId);\n\t}\n\n\t// ===== End: burn support =====\n\n\t// ----- Start: auxiliary internal/private functions -----\n\n\t/**\n\t * @inheritdoc ShortERC721\n\t *\n\t * @dev Adds a code to initialize `tokenIndexes` mapping required for burn support\n\t */\n\tfunction __addToken(uint256 _tokenId, address _to) internal virtual override {\n\t\t// write global token index data\n\t\ttokenIndexes[_tokenId] = allTokens.length;\n\n\t\t// execute default parent code\n\t\tsuper.__addToken(_tokenId, _to);\n\t}\n\n\t/**\n\t * @inheritdoc ShortERC721\n\t *\n\t * @dev Adds a code to initialize `tokenIndexes` mapping required for burn support\n\t */\n\tfunction __addTokens(address _to, uint256 _tokenId, uint256 n) internal virtual override {\n\t\t// for each token to be added\n\t\tfor(uint256 i = 0; i < n; i++) {\n\t\t\t// write global token index data\n\t\t\ttokenIndexes[_tokenId + i] = allTokens.length;\n\t\t}\n\n\t\t// execute default parent code\n\t\tsuper.__addTokens(_to, _tokenId, n);\n\t}\n\n\t/**\n\t * @dev Removes token from both local and global collections (enumerations),\n\t *      used internally to burn existing tokens\n\t *\n\t * @dev Unsafe: doesn't check for data structures consistency\n\t *      (token existence, token ownership, etc.)\n\t *\n\t * @dev Must be kept private at all times. Inheriting smart contracts\n\t *      may be interested in overriding this function.\n\t *\n\t * @param _tokenId token ID to remove\n\t */\n\tfunction __removeToken(uint256 _tokenId) internal virtual {\n\t\t// remove token from owner's (local) collection first\n\t\t__removeLocal(_tokenId);\n\n\t\t// token index within the global collection\n\t\tuint256 i = tokenIndexes[_tokenId];\n\n\t\t// delete the token\n\t\tdelete tokens[_tokenId];\n\n\t\t// get an ID of the last token in the collection\n\t\tuint96 lastId = allTokens[allTokens.length - 1];\n\n\t\t// if the token we're to remove from the collection is not the last one,\n\t\t// we need to move last token in the collection into index `i`\n\t\tif(i != allTokens.length - 1) {\n\t\t\t// we put the last token in the collection to the position released\n\n\t\t\t// update last token index to point to proper place in the collection\n\t\t\ttokenIndexes[lastId] = i;\n\n\t\t\t// put it into the position `i` within the collection\n\t\t\tallTokens[i] = lastId;\n\t\t}\n\n\t\t// trim the collection by removing last element\n\t\tallTokens.pop();\n\t}\n\n\t// ----- End: auxiliary internal/private functions -----\n}\n"
    },
    "contracts/mocks/BurnableShortERC721Mock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../token/BurnableShortERC721.sol\";\n\n// Zeppelin ERC721 tests support\ncontract BurnableShortERC721Mock is BurnableShortERC721 {\n\t/**\n\t * @inheritdoc ShortERC721\n\t */\n\tuint256 public constant override TOKEN_UID = 0x8d4fb97da97378ef7d0ad259aec651f42bd22c200159282baa58486bb390286b;\n\n\tconstructor(string memory _name, string memory _symbol) BurnableShortERC721(_name, _symbol) {}\n}\n"
    },
    "contracts/mocks/ShortERC721Mock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../token/ShortERC721.sol\";\n\n// Zeppelin ERC721 tests support\ncontract ShortERC721Mock is ShortERC721 {\n\t/**\n\t * @inheritdoc ShortERC721\n\t */\n\tuint256 public constant override TOKEN_UID = 0x77a854386ba78c1ee8a3be2be18b485dd7f2f85e899d7dfe143cd3e1d5e4e877;\n\n\tconstructor(string memory _name, string memory _symbol) ShortERC721(_name, _symbol) {}\n}\n"
    },
    "contracts/mocks/LockableShortERC721Mock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../token/ShortERC721.sol\";\n\ncontract LockableShortERC721Mock is ShortERC721 {\n\t/// @dev Used to override isTransferable behaviour\n\tmapping(uint256 => bool) transferable;\n\n\t/**\n\t * @inheritdoc ShortERC721\n\t */\n\tuint256 public constant override TOKEN_UID = 0xe76696cd154d0436a87c600fb76c141850c0be74a8a5d25d60187407b7383d1f;\n\n\tconstructor(string memory _name, string memory _symbol) ShortERC721(_name, _symbol) {}\n\n\t/// @dev Used to override isTransferable behaviour\n\tfunction setTransferable(uint256 _tokenId, bool _value) public {\n\t\ttransferable[_tokenId] = _value;\n\t}\n\n\t/**\n\t * @inheritdoc ShortERC721\n\t */\n\tfunction isTransferable(uint256 _tokenId) public view override returns(bool) {\n\t\treturn transferable[_tokenId];\n\t}\n}\n"
    },
    "contracts/mocks/ArrayBlockMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../lib/ArrayUtils.sol\";\n\n/**\n * @dev Helper contract to measure sequential array writing gas savings\n * @dev Supports seq_rnd_gas.js tess and ArrayUtils library\n */\ncontract ArrayBlockMock {\n\tusing ArrayUtils for uint32[];\n\tuint32[] public array321;\n\tuint32[] public array322;\n\tuint256[] public array2561;\n\tuint256[] public array2562;\n\n\tfunction writeSequential(uint32 m, uint32 n) public {\n\t\tfor(uint32 i = 0; i < n; i++) {\n\t\t\tarray321.push(i + m);\n\t\t}\n\t\tfor(uint32 i = 0; i < n; i++) {\n\t\t\tarray322.push(i + m);\n\t\t}\n\t}\n\n\tfunction writeRandomized(uint32 m, uint32 n) public {\n\t\tfor(uint32 i = 0; i < n; i++) {\n\t\t\tarray321.push(i + m);\n\t\t\tarray322.push(i + m);\n\t\t}\n\t}\n\n\tfunction writePacked(uint32 m, uint32 n) public {\n\t\tfor(uint256 i = 0; i < n; i += 8) {\n\t\t\tuint256 e = 0;\n\t\t\tfor(uint256 j = 0; j < 8; j++) {\n\t\t\t\te |= (i + j + m) << j * 32;\n\t\t\t}\n\t\t\tarray2561.push(e);\n\t\t\tarray2562.push(e);\n\t\t}\n\t}\n\n\tfunction writeWithAssembly(uint32 m, uint32 n) public {\n\t\tarray321.push32(m, n);\n\t\tarray322.push32(m, n);\n\t}\n\n\tfunction getArray321() public view returns(uint32[] memory) {\n\t\treturn array321;\n\t}\n\n\tfunction getArray322() public view returns(uint32[] memory) {\n\t\treturn array322;\n\t}\n\n\tfunction getArray2561() public view returns(uint256[] memory) {\n\t\treturn array2561;\n\t}\n\n\tfunction getArray2562() public view returns(uint256[] memory) {\n\t\treturn array2562;\n\t}\n\n}\n"
    },
    "contracts/mocks/TinyERC721Mock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../token/TinyERC721.sol\";\n\n// Zeppelin ERC721 tests support\ncontract TinyERC721Mock is TinyERC721 {\n\t/**\n\t * @inheritdoc TinyERC721\n\t */\n\tuint256 public constant override TOKEN_UID = 0x0250bec6b1a03636668f5072a8f5675e5fbd3e485d8a1213fc8279b78cb6f33d;\n\n\tconstructor(string memory _name, string memory _symbol) TinyERC721(_name, _symbol) {}\n}\n"
    },
    "contracts/mocks/LockableTinyERC721Mock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../token/TinyERC721.sol\";\n\ncontract LockableTinyERC721Mock is TinyERC721 {\n\t/// @dev Used to override isTransferable behaviour\n\tmapping(uint256 => bool) transferable;\n\n\t/**\n\t * @inheritdoc TinyERC721\n\t */\n\tuint256 public constant override TOKEN_UID = 0x10ea00872172d27aedaa569f59f69fd6de0bf0b041cca3d8fb52105bf9366c54;\n\n\tconstructor(string memory _name, string memory _symbol) TinyERC721(_name, _symbol) {}\n\n\t/// @dev Used to override isTransferable behaviour\n\tfunction setTransferable(uint256 _tokenId, bool _value) public {\n\t\ttransferable[_tokenId] = _value;\n\t}\n\n\t/**\n\t * @inheritdoc TinyERC721\n\t */\n\tfunction isTransferable(uint256 _tokenId) public view override returns(bool) {\n\t\treturn transferable[_tokenId];\n\t}\n}\n"
    },
    "contracts/interfaces/ImmutableSpec.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title Immutable X Mintable Specification\n *\n * @notice Interfaces supporting IMX integration:\n *      - ImmutableMintableERC20: @imtbl/imx-contracts/contracts/IMintable.sol\n *      - ImmutableMintableERC721: @imtbl/imx-contracts/contracts/IMintable.sol\n *\n * @dev See https://docs.x.immutable.com/docs/minting-assets-1\n * @dev See https://docs.x.immutable.com/docs/partner-nft-minting-setup\n *\n * @author Basil Gorin\n */\n\n/**\n * @dev IMX Mintable interface, enables Layer 2 minting in IMX,\n *      see https://docs.x.immutable.com/docs/minting-assets-1\n *\n * @dev See @imtbl/imx-contracts/contracts/IMintable.sol\n */\ninterface ImmutableMintableERC20 {\n\t/**\n\t * @dev Mints ERC20 tokens\n\t *\n\t * @param to address to mint tokens to\n\t * @param amount amount of tokens to mint\n\t * @param mintingBlob [optional] data structure supplied\n\t */\n\tfunction mintFor(address to, uint256 amount, bytes memory mintingBlob) external;\n}\n\n/**\n * @dev IMX Mintable interface, enables Layer 2 minting in IMX,\n *      see https://docs.x.immutable.com/docs/minting-assets-1\n *\n * @dev See @imtbl/imx-contracts/contracts/IMintable.sol\n */\ninterface ImmutableMintableERC721 {\n\t/**\n\t * @dev Mints an NFT\n\t *\n\t * @param to address to mint NFT to\n\t * @param id ID of the NFT to mint\n\t * @param mintingBlob [optional] data structure stored alongside with NFT\n\t */\n\tfunction mintFor(address to, uint256 id, bytes memory mintingBlob) external;\n}\n"
    },
    "contracts/mocks/ERC165DenierMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title ERC165 Denier Mock\n *\n * @notice ERC165 Denier Mock a contract that always denies ERC165 support, used for testing purposes;\n *\n * @author Komninos Chatzipapas\n */\ncontract ERC165DenierMock {\n  /**\n   * @dev always returns false\n   */\n  function supportsInterface(bytes4) public pure returns (bool) {\n    return false;\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}